var JSHINTRC = {
    "predef": [
        "console",
        "Ember",
        "DS",
        "Handlebars",
        "Metamorph",
        "ember_assert",
        "ember_warn",
        "ember_deprecate",
        "ember_deprecateFunc",
        "require",
        "equal",
        "asyncTest",
        "test",
        "raises",
        "deepEqual",
        "start",
        "stop",
        "ok",
        "strictEqual",
        "module",
        "expect",
        "minispade",
        "async",
        "invokeAsync"
    ],

    "node" : false,
    "es5" : true,
    "browser" : true,

    "boss" : true,
    "curly": false,
    "debug": false,
    "devel": false,
    "eqeqeq": true,
    "evil": true,
    "forin": false,
    "immed": false,
    "laxbreak": false,
    "newcap": true,
    "noarg": true,
    "noempty": false,
    "nonew": false,
    "nomen": false,
    "onevar": false,
    "plusplus": false,
    "regexp": false,
    "undef": true,
    "sub": true,
    "strict": false,
    "white": false
}
;

minispade.register('ember-data/~tests/helpers', "(function() {DS.MockObject = Ember.Object.extend({\n  init: function() {\n    this.spyMeta = {};\n  },\n\n  spyOn: function(methodName) {\n    var func = this[methodName],\n        meta = this.spyMeta;\n\n    if (func && func.isSpy) { return; }\n\n    if (!func) {\n      func = function() { };\n    }\n\n    this[methodName] = function() {\n      var callCount = meta[methodName] || 0;\n\n      meta[methodName] = ++callCount;\n\n      return func.apply(this, arguments);\n    };\n\n    this[methodName].isSpy = true;\n  },\n\n  shouldHaveBeenCalled: function(methodName, times) {\n    times = times === undefined ? 1 : times;\n\n    equal(this.spyMeta[methodName], times, methodName+\" was called \"+times+ \" times\");\n  }\n});\n\nDS.MockModel = DS.MockObject.extend({\n  init: function() {\n    this.resetEvents();\n\n    return this._super();\n  },\n\n  send: function(event) {\n    this.receivedEvents.push(event);\n  },\n\n  resetEvents: function() {\n    this.receivedEvents = [];\n  },\n\n  didReceiveEvent: function(event) {\n    return -1 !== this.receivedEvents.indexOf(event);\n  },\n\n  shouldHaveReceived: function() {\n    var events = Array.prototype.slice.call(arguments);\n\n    Ember.ArrayPolyfills.forEach.call(events, function(event) {\n      ok(this.didReceiveEvent(event), \"record received event \"+event);\n    }, this);\n  },\n\n  shouldNotHaveReceived: function() {\n    var events = Array.prototype.slice.call(arguments);\n\n    Ember.ArrayPolyfills.forEach.call(events, function(event) {\n      ok(!this.didReceiveEvent(event), \"record did not received event \"+event);\n    }, this);\n  },\n\n  becomeDirty: function(type) {\n    this.get('transaction').recordBecameDirty(type, this);\n  },\n\n  eachAttribute: Ember.K,\n  eachRelationshipChange: Ember.K,\n  setupData: Ember.K\n});\n\nDS.MockModel.reopenClass({\n  _create: function() {\n    return this.create.apply(this, arguments);\n  }\n});\n\n\n})();\n//@ sourceURL=ember-data/~tests/helpers");minispade.register('ember-data/~tests/integration/adapters/basic_adapter/commit_test', "(function() {var get = Ember.get;\n\nvar store, adapter, Person, PhoneNumber;\nmodule(\"Basic Adapter - Saving\", {\n  setup: function() {\n    adapter = DS.BasicAdapter.create();\n    store = DS.Store.create({\n      adapter: adapter\n    });\n\n    var attr = DS.attr, hasMany = DS.hasMany, belongsTo = DS.belongsTo;\n    Person = DS.Model.extend({\n      firstName: attr('string'),\n      lastName: attr('string'),\n      createdAt: attr('date')\n    });\n\n    PhoneNumber = DS.Model.extend({\n      areaCode: attr('number'),\n      number: attr('number'),\n      person: belongsTo(Person)\n    });\n\n    Person.reopen({\n      phoneNumbers: hasMany(PhoneNumber)\n    });\n\n    DS.registerTransforms('test', {\n      date: {\n        serialize: function(value) {\n          return value.toString();\n        },\n\n        deserialize: function(string) {\n          return new Date(string);\n        }\n      }\n    });\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      DS.clearTransforms();\n      store.destroy();\n      adapter.destroy();\n    });\n  }\n});\n\ntest(\"After creating a record, calling `save` on it will save it using the BasicAdapter\", function() {\n  expect(2);\n\n  Person.sync = {\n    createRecord: function(passedRecord, process) {\n      equal(passedRecord, person, \"The person was passed through\");\n      process(passedRecord).save(function(json) {\n        deepEqual(json, { firstName: \"Igor\", lastName: \"Terzic\", createdAt: null }, \"The process method toJSON'ifies the record\");\n      });\n    }\n  };\n\n  var person = Person.createRecord({ firstName: \"Igor\", lastName: \"Terzic\" });\n  person.save();\n});\n\ntest(\"After updating a record, calling `save` on it will save it using the BasicAdapter\", function() {\n  expect(2);\n\n  Person.sync = {\n    updateRecord: function(passedRecord, process) {\n      equal(passedRecord, person, \"The person was passed through\");\n      process(passedRecord).save(function(json) {\n        deepEqual(json, { id: 1, firstName: \"Igor\", lastName: \"Terzicsta\", createdAt: null }, \"The process method toJSON'ifies the record\");\n      });\n    }\n  };\n\n  store.load(Person, { id: 1, firstName: \"Igor\", lastName: \"Terzic\" });\n  var person = Person.find(1);\n  person.set('lastName', \"Terzicsta\");\n\n  person.save();\n});\n\ntest(\"After deleting a record, calling `save` on it will save it using the BasicAdapter\", function() {\n  expect(2);\n\n  Person.sync = {\n    deleteRecord: function(passedRecord, process) {\n      equal(passedRecord, person, \"The person was passed through\");\n      process(passedRecord).save(function(json) {\n        deepEqual(json, { id: 1, firstName: \"Igor\", lastName: \"Terzic\", createdAt: null }, \"The process method toJSON'ifies the record\");\n      });\n    }\n  };\n\n  store.load(Person, { id: 1, firstName: \"Igor\", lastName: \"Terzic\" });\n  var person = Person.find(1);\n  person.deleteRecord();\n  person.save();\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/adapters/basic_adapter/commit_test");minispade.register('ember-data/~tests/integration/adapters/basic_adapter/find_test', "(function() {var get = Ember.get;\n\nvar store, adapter, Person, PhoneNumber;\nmodule(\"Basic Adapter - Finding\", {\n  setup: function() {\n    adapter = DS.BasicAdapter.create();\n    store = DS.Store.create({\n      adapter: adapter\n    });\n\n    var attr = DS.attr, hasMany = DS.hasMany, belongsTo = DS.belongsTo;\n    Person = DS.Model.extend({\n      firstName: attr('string'),\n      lastName: attr('string'),\n      createdAt: attr('date')\n    });\n\n    PhoneNumber = DS.Model.extend({\n      areaCode: attr('number'),\n      number: attr('number'),\n      person: belongsTo(Person)\n    });\n\n    Person.reopen({\n      phoneNumbers: hasMany(PhoneNumber)\n    });\n\n    DS.registerTransforms('test', {\n      date: {\n        serialize: function(value) {\n          return value.toString();\n        },\n\n        deserialize: function(string) {\n          return new Date(string);\n        }\n      }\n    });\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      DS.clearTransforms();\n      store.destroy();\n      adapter.destroy();\n    });\n  }\n});\n\ntest(\"The sync object is consulted to load data\", function() {\n  Person.sync = {\n    find: function(id, process) {\n      equal(id, \"1\", \"The correct ID is passed through\");\n      setTimeout(async(function() {\n        process({ id: 1, firstName: \"Tom\", lastName: \"Dale\" }).load();\n      }));\n    }\n  };\n\n  var person = Person.find(1);\n\n  equal(get(person, 'id'), \"1\", \"The id is the coerced ID passed to find\");\n\n  person.on('didLoad', async(function() {\n    equal(get(person, 'firstName'), \"Tom\");\n    equal(get(person, 'lastName'), \"Dale\");\n    equal(get(person, 'id'), \"1\", \"The id is still the same\");\n  }));\n});\n\ntest(\"A camelizeKeys() convenience will camelize all of the keys\", function() {\n  Person.sync = {\n    find: function(id, process) {\n      setTimeout(async(function() {\n        process({ id: 1, first_name: \"Tom\", last_name: \"Dale\" })\n          .camelizeKeys()\n          .load();\n      }));\n    }\n  };\n\n  var person = Person.find(1);\n\n  equal(get(person, 'id'), \"1\", \"The id is the coerced ID passed to find\");\n\n  person.on('didLoad', async(function() {\n    equal(get(person, 'firstName'), \"Tom\");\n    equal(get(person, 'lastName'), \"Dale\");\n    equal(get(person, 'id'), \"1\", \"The id is still the same\");\n  }));\n});\n\ntest(\"An applyTransforms method will apply registered transforms\", function() {\n  Person.sync = {\n    find: function(id, process) {\n      setTimeout(async(function() {\n        process({ id: 1, firstName: \"Tom\", lastName: \"Dale\", createdAt: \"1986-06-09\" })\n          .applyTransforms('test')\n          .load();\n      }));\n    }\n  };\n\n  var person = Person.find(1);\n\n  equal(get(person, 'id'), \"1\", \"The id is the coerced ID passed to find\");\n\n  person.on('didLoad', async(function() {\n    equal(get(person, 'firstName'), \"Tom\");\n    equal(get(person, 'lastName'), \"Dale\");\n    equal(get(person, 'createdAt').valueOf(), new Date(\"1986-06-09\").valueOf(), \"The date was properly transformed\");\n    equal(get(person, 'id'), \"1\", \"The id is still the same\");\n  }));\n});\n\ntest(\"An adapter can use `munge` for arbitrary transformations\", function() {\n  Person.sync = {\n    find: function(id, process) {\n      setTimeout(async(function() {\n        process({ id: 1, FIRST_NAME: \"Tom\", LAST_NAME: \"Dale\", didCreateAtTime: \"1986-06-09\" })\n          .munge(function(json) {\n            json.firstName = json.FIRST_NAME;\n            json.lastName = json.LAST_NAME;\n            json.createdAt = json.didCreateAtTime;\n          })\n          .applyTransforms('test')\n          .load();\n      }));\n    }\n  };\n\n  var person = Person.find(1);\n\n  equal(get(person, 'id'), \"1\", \"The id is the coerced ID passed to find\");\n\n  person.on('didLoad', async(function() {\n    equal(get(person, 'firstName'), \"Tom\");\n    equal(get(person, 'lastName'), \"Dale\");\n    equal(get(person, 'createdAt').valueOf(), new Date(\"1986-06-09\").valueOf(), \"The date was properly transformed\");\n    equal(get(person, 'id'), \"1\", \"The id is still the same\");\n  }));\n});\n\ntest(\"A query will invoke the findQuery hook on the sync object\", function() {\n  Person.sync = {\n    query: function(query, process) {\n      deepEqual(query, { all: true }, \"The query was passed through\");\n\n      setTimeout(async(function() {\n        process([\n          { id: 1, first_name: \"Yehuda\", last_name: \"Katz\" },\n          { id: 2, first_name: \"Tom\", last_name: \"Dale\" }\n        ]).camelizeKeys().load();\n      }));\n    }\n  };\n\n  var people = Person.query({ all: true });\n\n  people.then(function() {\n    equal(get(people, 'length'), 2, \"The people are loaded in\");\n    deepEqual(people.objectAt(0).getProperties('id', 'firstName', 'lastName'), {\n      id: \"1\",\n      firstName: \"Yehuda\",\n      lastName: \"Katz\"\n    });\n\n    deepEqual(people.objectAt(1).getProperties('id', 'firstName', 'lastName'), {\n      id: \"2\",\n      firstName: \"Tom\",\n      lastName: \"Dale\"\n    });\n  });\n});\n\ntest(\"A query's processor supports munge across all elements in its Array\", function() {\n  Person.sync = {\n    query: function(query, process) {\n      deepEqual(query, { all: true }, \"The query was passed through\");\n\n      setTimeout(async(function() {\n        process([\n          { id: 1, \"name,first\": \"Yehuda\", \"name,last\": \"Katz\" },\n          { id: 2, \"name,first\": \"Tom\", \"name,last\": \"Dale\" }\n        ])\n        .munge(function(json) {\n          json.firstName = json[\"name,first\"];\n          json.lastName = json[\"name,last\"];\n        })\n        .load();\n      }));\n    }\n  };\n\n  var people = Person.query({ all: true });\n\n  people.then(function() {\n    equal(get(people, 'length'), 2, \"The people are loaded in\");\n    deepEqual(people.objectAt(0).getProperties('id', 'firstName', 'lastName'), {\n      id: \"1\",\n      firstName: \"Yehuda\",\n      lastName: \"Katz\"\n    });\n\n    deepEqual(people.objectAt(1).getProperties('id', 'firstName', 'lastName'), {\n      id: \"2\",\n      firstName: \"Tom\",\n      lastName: \"Dale\"\n    });\n  });\n});\n\ntest(\"A basic adapter receives a call to find<Relationship> for relationships\", function() {\n  expect(3);\n\n  Person.sync = {\n    find: function(id, process) {\n      setTimeout(async(function() {\n        process({ id: 1, firstName: \"Tom\", lastName: \"Dale\" }).load();\n      }));\n    },\n\n    findPhoneNumbers: function(person, options, process) {\n      setTimeout(async(function() {\n        process([ { id: 1, areaCode: 703, number: 1234567 }, { id: 2, areaCode: 904, number: 9543256 } ]).load();\n      }));\n    }\n  };\n\n  Person.find(1).then(function(person) {\n    return person.get('phoneNumbers');\n  }).then(async(function(phoneNumbers) {\n    equal(phoneNumbers.get('length'), 2, \"There are now two phone numbers\");\n    equal(phoneNumbers.objectAt(0).get('number'), 1234567, \"The first phone number was loaded in\");\n    equal(phoneNumbers.objectAt(1).get('number'), 9543256, \"The second phone number was loaded in\");\n  }));\n});\n\ntest(\"A basic adapter receives a call to find<Relationship> for relationships\", function() {\n  expect(4);\n\n  Person.sync = {\n    find: function(id, process) {\n      setTimeout(async(function() {\n        process({ id: 1, firstName: \"Tom\", lastName: \"Dale\" }).load();\n      }));\n    },\n\n    findHasMany: function(person, options, process) {\n      equal(options.relationship, 'phoneNumbers');\n      setTimeout(async(function() {\n        process([ { id: 1, areaCode: 703, number: 1234567 }, { id: 2, areaCode: 904, number: 9543256 } ]).load();\n      }));\n    }\n  };\n\n  Person.find(1).then(function(person) {\n    return person.get('phoneNumbers');\n  }).then(async(function(phoneNumbers) {\n    equal(phoneNumbers.get('length'), 2, \"There are now two phone numbers\");\n    equal(phoneNumbers.objectAt(0).get('number'), 1234567, \"The first phone number was loaded in\");\n    equal(phoneNumbers.objectAt(1).get('number'), 9543256, \"The second phone number was loaded in\");\n  }));\n});\n\ntest(\"Metadata passed for a relationship will get passed to find<Relationship>\", function() {\n  expect(4);\n\n  Person.sync = {\n    find: function(id, process) {\n      setTimeout(async(function() {\n        process({ id: 1, firstName: \"Tom\", lastName: \"Dale\", phoneNumbers: 'http://example.com/people/1/phone_numbers' }).load();\n      }));\n    },\n\n    findPhoneNumbers: function(person, options, process) {\n      equal(options.data, 'http://example.com/people/1/phone_numbers', \"The metadata was passed\");\n      setTimeout(async(function() {\n        process([ { id: 1, areaCode: 703, number: 1234567 }, { id: 2, areaCode: 904, number: 9543256 } ]).load();\n      }));\n    }\n  };\n\n  Person.find(1).then(function(person) {\n    return person.get('phoneNumbers');\n  }).then(async(function(phoneNumbers) {\n    equal(phoneNumbers.get('length'), 2, \"There are now two phone numbers\");\n    equal(phoneNumbers.objectAt(0).get('number'), 1234567, \"The first phone number was loaded in\");\n    equal(phoneNumbers.objectAt(1).get('number'), 9543256, \"The second phone number was loaded in\");\n  }));\n});\n\ntest(\"Metadata passed for a relationship will get passed to findHasMany\", function() {\n  expect(5);\n\n  Person.sync = {\n    find: function(id, process) {\n      setTimeout(async(function() {\n        process({ id: 1, firstName: \"Tom\", lastName: \"Dale\", phoneNumbers: 'http://example.com/people/1/phone_numbers' }).load();\n      }));\n    },\n\n    findHasMany: function(person, options, process) {\n      equal(options.data, 'http://example.com/people/1/phone_numbers', \"The metadata was passed\");\n      equal(options.relationship, 'phoneNumbers', \"The relationship name was passed\");\n      setTimeout(async(function() {\n        process([ { id: 1, areaCode: 703, number: 1234567 }, { id: 2, areaCode: 904, number: 9543256 } ]).load();\n      }));\n    }\n  };\n\n  Person.find(1).then(function(person) {\n    return person.get('phoneNumbers');\n  }).then(async(function(phoneNumbers) {\n    equal(phoneNumbers.get('length'), 2, \"There are now two phone numbers\");\n    equal(phoneNumbers.objectAt(0).get('number'), 1234567, \"The first phone number was loaded in\");\n    equal(phoneNumbers.objectAt(1).get('number'), 9543256, \"The second phone number was loaded in\");\n  }));\n});\n\n\n})();\n//@ sourceURL=ember-data/~tests/integration/adapters/basic_adapter/find_test");minispade.register('ember-data/~tests/integration/application_test', "(function() {var app, container;\n\n/**\n  These tests ensure that Ember Data works with Ember.js' application\n  initialization and dependency injection APIs.\n*/\n\nif (Ember.Application.initializer) {\n\n  module(\"Ember.Application Extensions\", {\n    setup: function() {\n      Ember.run(function() {\n        app = Ember.Application.create({\n          router: false,\n          Store: DS.Store,\n          FooController: Ember.Controller.extend(),\n          ApplicationView: Ember.View.extend(),\n          BazController: {},\n          ApplicationController: Ember.View.extend()\n        });\n      });\n\n      container = app.__container__;\n    },\n\n    teardown: function() {\n      app.destroy();\n      Ember.BOOTED = false;\n    }\n  });\n\n  test(\"If a Store property exists on an Ember.Application, it should be instantiated.\", function() {\n    ok(container.lookup('store:main') instanceof DS.Store, \"the store was instantiated\");\n  });\n\n  test(\"If a store is instantiated, it should be made available to each controller.\", function() {\n    var fooController = container.lookup('controller:foo');\n    ok(fooController.get('store') instanceof DS.Store, \"the store was injected\");\n  });\n}\n\nif (Ember.Application.registerInjection) {\n  /**\n    These tests ensure that Ember Data works with Ember.js' application\n    initialization and dependency injection APIs.\n  */\n\n  module(\"Ember.Application Extensions\", {\n    setup: function() {\n      var Router = Ember.Router.extend({\n        root: Ember.Route.extend()\n      });\n\n      Ember.run(function() {\n        app = Ember.Application.create({\n          Router: Router,\n          Store: DS.Store,\n          FooController: Ember.Controller.extend(),\n          ApplicationView: Ember.View.extend(),\n          BazController: {},\n          ApplicationController: Ember.View.extend()\n        });\n      });\n    },\n\n    teardown: function() {\n      app.destroy();\n    }\n  });\n\n  test(\"If a Store property exists on an Ember.Application, it should be instantiated.\", function() {\n    Ember.run(function() { app.initialize(); });\n\n    ok(app.get('router.store') instanceof DS.Store, \"the store was injected\");\n  });\n\n  test(\"If a store is instantiated, it should be made available to each controller.\", function() {\n    Ember.run(function() { app.initialize(); });\n\n    ok(app.get('router.fooController.store') instanceof DS.Store, \"the store was injected\");\n  });\n\n  test(\"It doesn't try to inject the store into non-controllers\", function() {\n    Ember.run(function() { app.initialize(); });\n\n    equal(app.get('router.bazController.store'), undefined, \"the function was not injected\");\n  });\n}\n\nif (!Ember.Application.registerInjection && !Ember.Application.initializer) {\n  test(\"Should support either the old or new initialization API\", function() {\n    ok(false, \"Should not get here\");\n  });\n}\n\n})();\n//@ sourceURL=ember-data/~tests/integration/application_test");minispade.register('ember-data/~tests/integration/client_id_generation_test', "(function() {var get = Ember.get, set = Ember.set;\nvar serializer, adapter, store;\nvar Post, Comment;\n\nmodule(\"Client-side ID Generation\", {\n  setup: function() {\n    serializer = DS.Serializer.create();\n    adapter = DS.Adapter.create({\n      serializer: serializer\n    });\n    store = DS.Store.create({\n      adapter: adapter\n    });\n\n    Comment = DS.Model.extend();\n\n    Post = DS.Model.extend({\n      comments: DS.hasMany(Comment)\n    });\n\n    Comment.reopen({\n      post: DS.belongsTo(Post)\n    });\n  },\n\n  teardown: function() {\n    serializer.destroy();\n    adapter.destroy();\n    store.destroy();\n  }\n});\n\ntest(\"If an adapter implements the `generateIdForRecord` method, the store should be able to assign IDs without saving to the persistence layer.\", function() {\n  expect(6);\n\n  var idCount = 1;\n\n  adapter.generateIdForRecord = function(passedStore, record) {\n    equal(store, passedStore, \"store is the first parameter\");\n\n    return \"id-\" + idCount++;\n  };\n\n  adapter.createRecord = function(store, type, record) {\n    if (type === Comment) {\n      equal(get(record, 'id'), 'id-1', \"Comment passed to `createRecord` has 'id-1' assigned\");\n    } else {\n      equal(get(record, 'id'), 'id-2', \"Post passed to `createRecord` has 'id-2' assigned\");\n    }\n  };\n\n  var comment = store.createRecord(Comment);\n  var post = store.createRecord(Post);\n\n  equal(get(comment, 'id'), 'id-1', \"comment is assigned id 'id-1'\");\n  equal(get(post, 'id'), 'id-2', \"post is assigned id 'id-2'\");\n\n  // Despite client-generated IDs, calling commit() on the store should still\n  // invoke the adapter's `createRecord` method.\n  store.commit();\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/client_id_generation_test");minispade.register('ember-data/~tests/integration/dirtiness_test', "(function() {var store, adapter;\nvar Person;\n\nmodule(\"Attribute Changes and Dirtiness\", {\n  setup: function() {\n    adapter = DS.Adapter.create();\n\n    store = DS.Store.create({\n      adapter: adapter\n    });\n\n    Person = DS.Model.extend({\n      firstName: DS.attr('string')\n    });\n  }\n});\n\ntest(\"By default, if a record's attribute is changed, it becomes dirty\", function() {\n  store.load(Person, { id: 1, firstName: \"Yehuda\" });\n  var wycats = store.find(Person, 1);\n\n  wycats.set('firstName', \"Brohuda\");\n\n  ok(wycats.get('isDirty'), \"record has become dirty\");\n});\n\ntest(\"By default, a newly created record is dirty\", function() {\n  var wycats = store.createRecord(Person);\n\n  ok(wycats.get('isDirty'), \"record is dirty\");\n});\n\ntest(\"By default, changing the relationship between two records does not cause them to become dirty\", function() {\n  adapter.dirtyRecordsForHasManyChange = Ember.K;\n  adapter.dirtyRecordsForBelongsToChange = Ember.K;\n\n  var Post = DS.Model.extend();\n\n  var Comment = DS.Model.extend({\n    post: DS.belongsTo(Post)\n  });\n\n  Post.reopen({\n    comments: DS.hasMany(Comment)\n  });\n\n  store.load(Post, { id: 1, comments: [1] });\n  store.load(Comment, { id: 1, post: 1 });\n\n  var post = store.find(Post, 1);\n  var comment = store.find(Comment, 1);\n\n  comment.set('post', null);\n\n  ok(!post.get('isDirty'), \"post should not be dirty\");\n  ok(!comment.get('isDirty'), \"comment should not be dirty\");\n});\n\ntest(\"If dirtyRecordsForAttributeChange does not add the record to the dirtyRecords set, it does not become dirty\", function() {\n  store.load(Person, { id: 1, firstName: \"Yehuda\" });\n  var wycats = store.find(Person, 1);\n\n  adapter.dirtyRecordsForAttributeChange = function(dirtyRecords, changedRecord, attributeName) {\n    equal(changedRecord, wycats, \"changed record is passed to hook\");\n    equal(attributeName, \"firstName\", \"attribute name is passed to hook\");\n  };\n\n  wycats.set('firstName', \"Brohuda\");\n\n  ok(!wycats.get('isDirty'), \"the record is not dirty despite attribute change\");\n});\n\ntest(\"If dirtyRecordsForAttributeChange adds the record to the dirtyRecords set, it becomes dirty\", function() {\n  store.load(Person, { id: 1, firstName: \"Yehuda\" });\n  var wycats = store.find(Person, 1);\n\n  adapter.dirtyRecordsForAttributeChange = function(dirtyRecords, changedRecord, attributeName) {\n    equal(changedRecord, wycats, \"changed record is passed to hook\");\n    equal(attributeName, \"firstName\", \"attribute name is passed to hook\");\n    dirtyRecords.add(changedRecord);\n  };\n\n  wycats.set('firstName', \"Brohuda\");\n\n  ok(wycats.get('isDirty'), \"the record is dirty after attribute change\");\n});\n\ntest(\"If dirtyRecordsForAttributeChange adds a different record than the changed record to the dirtyRecords set, the different record becomes dirty\", function() {\n  store.load(Person, { id: 1, firstName: \"Yehuda\" });\n  store.load(Person, { id: 2, firstName: \"Tom\" });\n  var wycats = store.find(Person, 1);\n  var tomdale = store.find(Person, 2);\n\n  adapter.dirtyRecordsForAttributeChange = function(dirtyRecords, changedRecord, attributeName) {\n    equal(changedRecord, wycats, \"changed record is passed to hook\");\n    equal(attributeName, \"firstName\", \"attribute name is passed to hook\");\n    dirtyRecords.add(tomdale);\n  };\n\n  wycats.set('firstName', \"Brohuda\");\n\n  ok(tomdale.get('isDirty'), \"the record is dirty after attribute change\");\n  ok(!wycats.get('isDirty'), \"the record is not dirty after attribute change\");\n});\n\ntest(\"If dirtyRecordsForAttributeChange adds two records to the dirtyRecords set, both become dirty\", function() {\n  store.load(Person, { id: 1, firstName: \"Yehuda\" });\n  store.load(Person, { id: 2, firstName: \"Tom\" });\n  var wycats = store.find(Person, 1);\n  var tomdale = store.find(Person, 2);\n\n  adapter.dirtyRecordsForAttributeChange = function(dirtyRecords, changedRecord, attributeName) {\n    equal(changedRecord, wycats, \"changed record is passed to hook\");\n    equal(attributeName, \"firstName\", \"attribute name is passed to hook\");\n    dirtyRecords.add(tomdale);\n    dirtyRecords.add(wycats);\n  };\n\n  wycats.set('firstName', \"Brohuda\");\n\n  ok(tomdale.get('isDirty'), \"the record is dirty after attribute change\");\n  ok(wycats.get('isDirty'), \"the record is dirty after attribute change\");\n});\n\ntest(\"When adding a newly created record to a hasMany relationship, the parent should become clean after committing\", function() {\n  var App = Ember.Namespace.create();\n  App.toString = function() { return \"App\"; };\n\n  App.Post = DS.Model.extend({\n    title: DS.attr('string')\n  });\n\n  App.Comment = DS.Model.extend({\n    body: DS.attr('string'),\n    post: DS.belongsTo(App.Post)\n  });\n\n  App.Post.reopen({\n    comments: DS.hasMany(App.Comment)\n  });\n\n  expect(3);\n\n  adapter.dirtyRecordsForHasManyChange = Ember.K;\n\n  function didSaveRecord(store, record, hash) {\n    record.eachRelationship(function(name, relationship) {\n      if (relationship.kind === 'belongsTo') {\n        store.didUpdateRelationship(record, name);\n      }\n    });\n\n    store.didSaveRecord(record, hash);\n  }\n\n  adapter.createRecord = function(store, type, record) {\n    didSaveRecord(store, record, this.serialize(record));\n  };\n\n  store.load(App.Post, { id: 1});\n  var post = store.find(App.Post, 1);\n\n  post.get('comments').createRecord();\n\n  equal(post.get('isDirty'), false, \"precond - the record should be dirty\");\n\n  store.commit();\n\n  equal(post.get('isDirty'), false, \"The record should no longer be dirty\");\n  equal(post.get('isSaving'), false, \"The record should no longer be saving\");\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/dirtiness_test");minispade.register('ember-data/~tests/integration/embedded/embedded_dirtying_test', "(function() {var attr = DS.attr;\nvar Post, Comment, User, Vote, Blog;\nvar Adapter, App;\nvar adapter, store, post;\nvar forEach = Ember.EnumerableUtils.forEach;\n\n\n// The models here are related like this:\n//\n//             Post\n//  belongsTo /  |\n// (non-embedded)|\n//        Blog   | hasMany\n//           Comments\n// belongsTo /    \\\n//          /      \\ hasMany\n//       User     Votes\n\nmodule(\"Dirtying of Embedded Records\", {\n  setup: function() {\n    App = Ember.Namespace.create({ name: \"App\" });\n\n    User = App.User = DS.Model.extend({\n      name: attr('string')\n    });\n\n    Vote = App.Vote = DS.Model.extend({\n      voter: attr('string')\n    });\n\n    Comment = App.Comment = DS.Model.extend({\n      title: attr('string'),\n      user: DS.belongsTo(User),\n      votes: DS.hasMany(Vote)\n    });\n\n    Blog = App.Blog = DS.Model.extend({\n      title: attr('string')\n    });\n\n    Post = App.Post = DS.Model.extend({\n      title: attr('string'),\n      comments: DS.hasMany(Comment),\n      blog: DS.belongsTo(Blog)\n    });\n\n    Comment.reopen({\n      post: DS.belongsTo(Post)\n    });\n\n    Adapter = DS.RESTAdapter.extend();\n\n    Adapter.map(Comment, {\n      user: { embedded: 'always' },\n      votes: { embedded: 'always' }\n    });\n\n    Adapter.map(Post, {\n      comments: { embedded: 'always' },\n      blog: { embedded: 'load' }\n    });\n\n    adapter = Adapter.create();\n\n    store = DS.Store.create({\n      adapter: adapter\n    });\n\n    adapter.load(store, Post, {\n      id: 1,\n      title: \"A New MVC Framework in Under 100 Lines of Code\",\n\n      blog: {\n        id: 2,\n        title: \"Hacker News\"\n      },\n\n      comments: [{\n        title: \"Why not use a more lightweight solution?\",\n        user: {\n          name: \"mongodb_user\"\n        },\n        votes: [ { voter: \"tomdale\" }, { voter: \"wycats\" } ]\n      },\n      {\n        title: \"This does not seem to reflect the Unix philosophy haha\",\n        user: {\n          name: \"microuser\",\n        },\n        votes: [ { voter: \"ebryn\" } ]\n      }]\n    });\n\n    post = store.find(Post, 1);\n  },\n\n  teardown: function() {\n    store.destroy();\n    App.destroy();\n  }\n});\n\nfunction assertEmbeddedLoadNotDirtied() {\n  var blog = post.get('blog');\n  equal(blog.get('isDirty'), false, \"embedded load records should not become dirty\");\n}\n\nfunction assertTreeIs(state) {\n  post.get('comments').forEach(function(comment) {\n    assertRecordIs(comment, state);\n    if (comment.get('user')) {\n      assertRecordIs(comment.get('user'), state);\n    }\n    comment.get('votes').forEach(function(vote) {\n      assertRecordIs(vote, state);\n    });\n  });\n}\n\nfunction assertRecordIs(record, state) {\n  var isDirty = state === 'dirty';\n  equal(record.get('isDirty'), isDirty, record.toString() + \" should be \" + state);\n}\n\ntest(\"Modifying a record that contains embedded records should dirty the entire tree\", function() {\n  var post = store.find(Post, 1);\n  post.set('title', \"[dead]\");\n  assertTreeIs('dirty');\n  assertEmbeddedLoadNotDirtied();\n});\n\ntest(\"Modifying a record embedded via a belongsTo relationship should dirty the entire tree\", function() {\n  var user = post.get('comments.firstObject.user');\n  user.set('name', \"[dead]\");\n  assertTreeIs('dirty');\n  assertEmbeddedLoadNotDirtied();\n});\n\ntest(\"Modifying a record embedded via a hasMany relationship should dirty the entire tree\", function() {\n  var vote = post.get('comments.firstObject.votes.firstObject');\n  vote.set('voter', \"[dead]\");\n  assertTreeIs('dirty');\n});\n\ntest(\"Creating a record embedded via a hasMany relationship should dirty the entire tree\", function() {\n  var comment = store.createRecord(Comment, {\n    post: post,\n    title: 'A new comment'\n  });\n  equal(comment.get('isDirty'), true, \"New comment should be dirty\");\n  assertTreeIs('dirty');\n});\n\ntest(\"Creating a record embedded via a hasMany relationship should dirty the entire tree\", function() {\n  var comment = post.get('comments').createRecord({ title: 'A new comment' });\n  equal(comment.get('isDirty'), true, \"New comment should be dirty\");\n  assertTreeIs('dirty');\n});\n\ntest(\"Modifyng a record embedded via embedded loading should not dirty the tree\", function() {\n  var blog = post.get('blog');\n  blog.set('title', \"[dead]\");\n\n  assertTreeIs('clean');\n  ok(blog.get('isDirty'), true, \"embedded load record is dirty\");\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/embedded/embedded_dirtying_test");minispade.register('ember-data/~tests/integration/embedded/embedded_loading_test', "(function() {var originalLookup = Ember.lookup, lookup;\n\nvar Adapter, store, serializer, adapter;\n\nvar App = Ember.Namespace.create({\n  name: \"App\"\n});\n\nvar Person = App.Person = DS.Model.extend();\n\nvar Comment = App.Comment = DS.Model.extend({\n  user: DS.belongsTo(Person)\n});\n\nvar Group = App.Group = DS.Model.extend({\n  name: DS.attr('string'),\n  people: DS.hasMany(Person)\n});\n\nPerson.reopen({\n  name: DS.attr('string'),\n  group: DS.belongsTo(Group),\n  comments: DS.hasMany(Comment)\n});\n\nmodule(\"Embedded Loading\", {\n  setup: function() {\n    lookup = Ember.lookup = {};\n\n    lookup.Person = Person;\n    lookup.Comment = Comment;\n\n    Adapter = DS.RESTAdapter.extend();\n\n    store = DS.Store.create();\n  },\n\n  teardown: function() {\n    Ember.lookup = originalLookup;\n  }\n});\n\nEmber.ArrayPolyfills.forEach.call([[Comment, \"as a type\"], [\"Comment\", \"as a string\"]], function(testInfo) {\n  var mapping = testInfo[0], testString = testInfo[1];\n  test(\"A belongsTo relationship can be marked as embedded via the `map` API (\" + testString + \")\", function() {\n    Adapter.map(mapping, {\n      user: { embedded: 'load' }\n    });\n\n    adapter = Adapter.create();\n    store.set('adapter', adapter);\n\n    adapter.load(store, Comment, {\n      id: 1,\n      user: {\n        id: 2,\n        name: \"Yehuda Katz\"\n      }\n    });\n\n    adapter.load(store, Comment, {\n      id: 2,\n      user: {\n        id: 2,\n        name: \"Yehuda Katz\"\n      }\n    });\n\n    var comment1 = store.find(Comment, 1);\n    var comment2 = store.find(Comment, 2);\n    var user = store.find(Person, 2);\n\n    strictEqual(user.get('name'), \"Yehuda Katz\", \"user is addressable by its ID despite being loaded via embedding\");\n\n    strictEqual(comment1.get('user'), user, \"relationship references the globally addressable record\");\n    strictEqual(comment2.get('user'), user, \"relationships are identical\");\n  });\n});\n\nEmber.ArrayPolyfills.forEach.call([Person, \"Person\"], function(mapping) {\n  test(\"A hasMany relationship can be marked as embedded via the `map` API\", function() {\n    Adapter.map(mapping, {\n      comments: { embedded: 'load' }\n    });\n\n    adapter = Adapter.create();\n    store.set('adapter', adapter);\n\n    adapter.load(store, Person, {\n      id: 1,\n      name: \"Erik Brynroflsson\",\n      comments: [{ id: 1 }, { id: 2 }]\n    });\n\n    adapter.load(store, Person, {\n      id: 2,\n      name: \"Patrick Gibson\",\n      comments: [{ id: 1 }, { id: 2 }]\n    });\n\n    var person1 = store.find(Person, 1);\n    var person2 = store.find(Person, 2);\n    var comment1 = store.find(Comment, 1);\n    var comment2 = store.find(Comment, 2);\n\n    strictEqual(person1.get('comments').objectAt(0), comment1);\n    strictEqual(person2.get('comments').objectAt(0), comment1);\n  });\n\n  asyncTest(\"An embedded hasMany relationship can be extracted if the JSON is returned in response to a find\", function() {\n    Adapter.map(mapping, {\n      comments: { embedded: 'load' }\n    });\n\n    adapter = Adapter.create();\n    store.set('adapter', adapter);\n\n    adapter.find = function(store, type, id) {\n      var self = this;\n\n      setTimeout(function() {\n        Ember.run(function() {\n          self.didFindRecord(store, type, {\n            person: {\n              id: 1,\n              name: \"Erik Brynroflsson\",\n              comments: [{ id: 1 }, { id: 2 }]\n            }\n          }, id);\n        });\n\n        done();\n      });\n    };\n\n    store.find(Person, 1);\n\n    function done() {\n      start();\n\n      var person1 = store.find(Person, 1);\n      var comment1 = store.find(Comment, 1);\n      var comment2 = store.find(Comment, 2);\n\n      strictEqual(person1.get('comments').objectAt(0), comment1);\n    }\n  });\n\n  asyncTest(\"An embedded hasMany relationship can be extracted if the JSON is returned in response to a findAll\", function() {\n    Adapter.map(mapping, {\n      comments: { embedded: 'load' }\n    });\n\n    adapter = Adapter.create();\n    store.set('adapter', adapter);\n\n    adapter.findAll = function(store, type) {\n      var self = this;\n\n      setTimeout(function() {\n        Ember.run(function() {\n          self.didFindAll(store, type, {\n            persons: [{\n              id: 1,\n              name: \"Erik Brynroflsson\",\n              comments: [{ id: 1 }, { id: 2 }]\n            }, {\n              id: 2,\n              name: \"Patrick Gibson\",\n              comments: [{ id: 1 }, { id: 2 }]\n            }]\n          });\n        });\n\n        done();\n      });\n    };\n\n    store.find(Person);\n\n    function done() {\n      start();\n\n      var person1 = store.find(Person, 1);\n      var person2 = store.find(Person, 2);\n      var comment1 = store.find(Comment, 1);\n      var comment2 = store.find(Comment, 2);\n\n      strictEqual(person1.get('comments').objectAt(0), comment1);\n      strictEqual(person2.get('comments').objectAt(0), comment1);\n    }\n  });\n\n  test(\"Loading the same record with embedded hasMany multiple times works correctly\", function() {\n    Adapter.map(mapping, {\n      comments: { embedded: 'load' }\n    });\n\n    adapter = Adapter.create();\n    store.set('adapter', adapter);\n\n    Ember.run(function() {\n      adapter.load(store, Person, {\n        id: 1,\n        name: \"Erik Brynroflsson\",\n        comments: [{ id: 1 }, { id: 2 }]\n      });\n    });\n\n    var person = store.find(Person, 1);\n    person.get('comments');\n\n    // Load the same data twice\n    Ember.run(function() {\n      adapter.load(store, Person, {\n        id: 1,\n        name: \"Erik Brynroflsson\",\n        comments: [{ id: 1 }, { id: 2 }]\n      });\n    });\n\n    var comment1 = person.get('comments').objectAt(0);\n\n    equal(comment1.get('id'), 1, \"comment with ID 1 was loaded\");\n  });\n});\n\ntest(\"A nested belongsTo relationship can be marked as embedded via the `map` API\", function() {\n    Adapter.map(Comment, {\n      user: { embedded: 'load' }\n    });\n\n    Adapter.map(Person, {\n      group: { embedded: 'load' }\n    });\n\n    adapter = Adapter.create();\n    store.set('adapter', adapter);\n\n    adapter.load(store, Comment, {\n      id: 1,\n      user: {\n        id: 2,\n        name: \"Yehuda Katz\",\n        group: {\n          id: 3,\n          name: \"Developers\"\n        }\n      }\n    });\n\n    var comment = store.find(Comment, 1);\n    var group = store.find(Group, 3);\n\n    strictEqual(group.get('name'), \"Developers\", \"Group is addressable by its ID despite being loaded via embedding\");\n    strictEqual(comment.get('user.group'), group, \"relationship references the globally addressable record\");\n});\n\ntest(\"updating a embedded record with a belongsTo relationship is serialize correctly.\", function() {\n    Adapter.map(Comment, {\n      user: { embedded: 'load' }\n    });\n\n    Adapter.map(Person, {\n      group: { embedded: 'load' }\n    });\n\n    adapter = Adapter.create();\n    serializer = adapter.get('serializer');\n    store.set('adapter', adapter);\n\n    adapter.load(store, Comment, {\n      id: 1,\n      user: {\n        id: 2,\n        name: \"Yehuda Katz\",\n        group: {\n          id: 3,\n          name: \"Developers\"\n        }\n      }\n    });\n    adapter.load(store, Person, {\n      id: 4,\n      name: \"Peter Pan\"\n    });\n\n    var comment = store.find(Comment, 1);\n    var yehuda = store.find(Person, 2);\n    var peter = store.find(Person, 4);\n\n    comment.set('user', peter);\n    strictEqual(comment.get('user'), peter, \"updated relationship references the globally addressable record\");\n\n    var commentJSON = serializer.serialize(comment, { includeId: true });\n    deepEqual(commentJSON, { id: 1, user: { id: 4, name: \"Peter Pan\", group: null }});\n});\n\n\n})();\n//@ sourceURL=ember-data/~tests/integration/embedded/embedded_loading_test");minispade.register('ember-data/~tests/integration/embedded/embedded_saving_test', "(function() {var store, Adapter, adapter;\nvar Post, Comment, User, App;\nvar attr = DS.attr;\n\nmodule(\"Embedded Saving\", {\n  setup: function() {\n    App = Ember.Namespace.create({ name: \"App\" });\n\n    Comment = App.Comment = DS.Model.extend({\n      title: attr('string'),\n      post: DS.belongsTo('Post')\n    });\n\n    Post = App.Post = DS.Model.extend({\n      title: attr('string'),\n      comments: DS.hasMany(Comment)\n    });\n\n    Adapter = DS.RESTAdapter.extend();\n\n    Adapter.map(Post, {\n      comments: { embedded: 'always' }\n    });\n\n    adapter = Adapter.create();\n\n    store = DS.Store.create({\n      adapter: adapter\n    });\n  },\n\n  teardown: function() {\n    store.destroy();\n    App.destroy();\n  }\n});\n\nasyncTest(\"Adding a new embedded record to an unsaved record: Both records use the same POST request.\", function() {\n  adapter.ajax = function(url, type, hash) {\n    equal(url, '/posts');\n    equal(type, 'POST');\n    equal(hash.data.post.comments.length, 1);\n\n    setTimeout(function() {\n      hash.success.call(hash.context);\n      start();\n    });\n  };\n\n  var transaction = store.transaction();\n  var post = transaction.createRecord(Post, {\n    title: 'This post is unsaved'\n  });\n\n  post.get('comments').createRecord({ title: 'This embedded record is also unsaved' });\n\n  transaction.commit();\n});\n\n\n})();\n//@ sourceURL=ember-data/~tests/integration/embedded/embedded_saving_test");minispade.register('ember-data/~tests/integration/embedded/embedded_without_ids_test', "(function() {var store, Adapter, adapter;\nvar Post, Comment, User, Pingback, Like;\nvar attr = DS.attr;\n\nmodule(\"Embedded Relationships Without IDs\", {\n  setup: function() {\n    var App = Ember.Namespace.create({ name: \"App\" });\n\n    User = App.User = DS.Model.extend({\n      name: attr('string')\n    });\n\n    Comment = App.Comment = DS.Model.extend({\n      title: attr('string'),\n      user: DS.belongsTo(User)\n    });\n\n    Pingback = App.Pingback = DS.Model.extend();\n\n    Like = App.Like = DS.Model.extend();\n\n    Post = App.Post = DS.Model.extend({\n      title: attr('string'),\n      comments: DS.hasMany(Comment),\n      pingbacks: DS.hasMany(Pingback),\n      likes: DS.hasMany(Like)\n    });\n\n    Adapter = DS.RESTAdapter.extend();\n\n    Adapter.map(Comment, {\n      user: { embedded: 'always' }\n    });\n\n    Adapter.map(Post, {\n      comments: { embedded: 'always' },\n      pingbacks: { embedded: 'always' },\n      likes: { embedded: 'load' }\n    });\n\n    adapter = Adapter.create();\n\n    store = DS.Store.create({\n      adapter: adapter\n    });\n  }\n});\n\ntest(\"An embedded record can be accessed via a belongsTo relationship but does not have an ID\", function() {\n  adapter.load(store, Comment, {\n    id: 1,\n    title: \"Why not use a more lightweight solution?\",\n\n    user: {\n      name: \"mongodb_expert\"\n    }\n  });\n\n  adapter.load(store, Comment, {\n    id: 2,\n    title: \"I am noticing a common quality in Katz' recent foray into JavaScript, that being his desire that it be like Ruby\",\n\n    user: {\n      name: \"oinksoft\"\n    }\n  });\n\n  var comment1 = store.find(Comment, 1);\n  var comment2 = store.find(Comment, 2);\n\n  var user1 = comment1.get('user');\n  var user2 = comment2.get('user');\n\n  equal(user1.get('name'), \"mongodb_expert\", \"the embedded record is found and its attributes are materialized\");\n  equal(user1.get('id'), null, \"the embedded record does not have an id\");\n\n  equal(user2.get('name'), \"oinksoft\", \"the embedded record is found and its attributed are materialized\");\n  equal(user2.get('id'), null, \"the embedded record does not have an id\");\n});\n\nasyncTest(\"Embedded belongsTo relationships can be saved when embedded: always is true\", function() {\n  adapter.load(store, Comment, {\n    id: 1,\n    title: \"Why not use a more lightweight solution?\",\n\n    user: {\n      name: \"mongodb_user\"\n    }\n  });\n\n  adapter.ajax = function(url, type, hash) {\n    deepEqual(hash.data, {\n      comment: {\n        title: \"Why not use a more lightweight solution?\",\n        user: {\n          name: \"mongodb_expert\"\n        }\n      }\n    });\n\n    setTimeout(function() {\n      hash.success.call(hash.context);\n      done();\n    });\n  };\n\n  var transaction = store.transaction();\n\n  var comment = store.find(Comment, 1);\n  var user = comment.get('user');\n\n  transaction.add(user);\n  transaction.add(comment);\n\n  user.set('name', \"mongodb_expert\");\n  equal(user.get('isDirty'), true, \"user becomes dirty after changing a property\");\n  equal(comment.get('isDirty'), true, \"comment becomes dirty when its embedded user becomes dirty\");\n\n  transaction.commit();\n\n  function done() {\n    equal(user.get('isDirty'), false, \"user becomes clean after commit\");\n    equal(comment.get('isDirty'), false, \"comment becomes clean after commit\");\n    start();\n  }\n});\n\ntest(\"Embedded records can be accessed via a hasMany relationship without having IDs\", function() {\n  adapter.load(store, Post, {\n    id: 1,\n    title: \"A New MVC Framework in Under 100 Lines of Code\",\n\n    comments: [{\n      title: \"Why not use a more lightweight solution?\",\n      user: null\n    }, {\n      title: \"This does not seem to reflect the Unix philosophy haha\",\n      user: null\n    }]\n  });\n\n  var post = store.find(Post, 1);\n\n  var comments = post.get('comments');\n\n  var comment1 = comments.objectAt(0);\n  var comment2 = comments.objectAt(1);\n\n  equal(comment1.get('title'), \"Why not use a more lightweight solution?\");\n  equal(comment2.get('title'), \"This does not seem to reflect the Unix philosophy haha\");\n});\n\nasyncTest(\"Embedded hasMany relationships can be saved when embedded: always is true\", function() {\n  adapter.load(store, Post, {\n    id: 1,\n    title: \"A New MVC Framework in Under 100 Lines of Code\",\n\n    comments: [{\n      title: \"Why not use a more lightweight solution?\"\n    },\n    {\n      title: \"This does not seem to reflect the Unix philosophy haha\"\n    }],\n\n    likes: [{ id: 1 }, { id: 2 }]\n  });\n\n  adapter.ajax = function(url, type, hash) {\n    deepEqual(hash.data, {\n      post: {\n        title: \"A New MVC Framework in Under 100 Lines of Code\",\n\n        comments: [{\n          title: \"Wouldn't a more lightweight solution be better? This feels very monolithic.\",\n          user: null\n        },\n        {\n          title: \"This does not seem to reflect the Unix philosophy haha\",\n          user: null\n        }],\n\n        pingbacks: []\n      }\n    });\n\n    setTimeout(function() {\n      hash.success.call(hash.context);\n      done();\n    });\n  };\n\n  var transaction = store.transaction();\n\n  var post = store.find(Post, 1);\n  var comment1 = post.get('comments').objectAt(0);\n  var comment2 = post.get('comments').objectAt(1);\n\n  transaction.add(post);\n  transaction.add(comment1);\n  transaction.add(comment2);\n\n  comment1.set('title', \"Wouldn't a more lightweight solution be better? This feels very monolithic.\");\n  equal(post.get('isDirty'), true, \"post becomes dirty after changing a property\");\n  equal(comment1.get('isDirty'), true, \"comment becomes dirty when its embedded post becomes dirty\");\n  equal(comment2.get('isDirty'), true, \"comment becomes dirty when its embedded post becomes dirty\");\n\n  transaction.commit();\n\n  function done() {\n    equal(post.get('isDirty'), false, \"post becomes clean after commit\");\n    equal(comment1.get('isDirty'), false, \"comment becomes clean after commit\");\n    equal(comment2.get('isDirty'), false, \"comment becomes clean after commit\");\n    start();\n  }\n});\n\ntest(\"Embedded records can themselves contain embedded records\", function() {\n  adapter.load(store, Post, {\n    id: 1,\n    title: \"A New MVC Framework in Under 100 Lines of Code\",\n\n    comments: [{\n      title: \"Why not use a more lightweight solution?\",\n      user: {\n        name: \"mongodb_user\"\n      }\n    },\n    {\n      title: \"This does not seem to reflect the Unix philosophy haha\",\n      user: {\n        name: \"microuser\"\n      }\n    }]\n  });\n\n  var post = store.find(Post, 1);\n  var comment1 = post.get('comments.firstObject');\n  var user1 = comment1.get('user');\n\n  equal(user1.get('name'), \"mongodb_user\", \"user record was materialized correctly\");\n  equal(comment1.get('title'), \"Why not use a more lightweight solution?\", \"comment record was materialized correctly\");\n  equal(post.get('title'), \"A New MVC Framework in Under 100 Lines of Code\", \"post record was materialized correctly\");\n});\n\nasyncTest(\"Embedded records that contain embedded records can be saved\", function() {\n  adapter.load(store, Post, {\n    id: 1,\n    title: \"A New MVC Framework in Under 100 Lines of Code\",\n\n    comments: [{\n      title: \"Why not use a more lightweight solution?\",\n      user: {\n        name: \"mongodb_user\"\n      }\n    },\n    {\n      title: \"This does not seem to reflect the Unix philosophy haha\",\n      user: {\n        name: \"microuser\"\n      }\n    }]\n  });\n\n  adapter.ajax = function(url, type, hash) {\n    deepEqual(hash.data, {\n      post: {\n        title: \"A New MVC Framework in Under 100 Lines of Code\",\n\n        comments: [{\n          title: \"Wouldn't a more lightweight solution be better? This feels very monolithic.\",\n          user: {\n            name: \"mongodb_user\"\n          }\n        },\n        {\n          title: \"This does not seem to reflect the Unix philosophy haha\",\n          user: {\n            name: \"microuser\"\n          }\n        }],\n\n        pingbacks: []\n      }\n    });\n\n    setTimeout(function() {\n      hash.success.call(hash.context);\n      done();\n    });\n  };\n\n  var transaction = store.transaction();\n\n  var post = store.find(Post, 1);\n  var comment1 = post.get('comments').objectAt(0);\n  var comment2 = post.get('comments').objectAt(1);\n  var user1 = comment1.get('user');\n  var user2 = comment2.get('user');\n\n  transaction.add(post);\n  transaction.add(comment1);\n  transaction.add(comment2);\n  transaction.add(user1);\n  transaction.add(user2);\n\n  comment1.set('title', \"Wouldn't a more lightweight solution be better? This feels very monolithic.\");\n  equal(post.get('isDirty'), true, \"post becomes dirty after changing a property\");\n  equal(comment1.get('isDirty'), true, \"comment becomes dirty when its parent post becomes dirty\");\n  equal(comment2.get('isDirty'), true, \"comment becomes dirty when its parent post becomes dirty\");\n  equal(user1.get('isDirty'), true, \"user becomes dirty when its parent post becomes dirty\");\n  equal(user2.get('isDirty'), true, \"user becomes dirty when its parent post becomes dirty\");\n\n  transaction.commit();\n\n  function done() {\n    equal(post.get('isDirty'), false, \"post becomes clean after commit\");\n    equal(comment1.get('isDirty'), false, \"comment becomes clean after commit\");\n    equal(comment2.get('isDirty'), false, \"comment becomes clean after commit\");\n    equal(user1.get('isDirty'), false, \"user becomes clean after commit\");\n    equal(user2.get('isDirty'), false, \"user becomes clean after commit\");\n    start();\n  }\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/embedded/embedded_without_ids_test");minispade.register('ember-data/~tests/integration/find_all_test', "(function() {var get = Ember.get, set = Ember.set;\n\nvar Person, adapter, store, allRecords;\n\nmodule(\"Finding All Records of a Type\", {\n  setup: function() {\n    Person = DS.Model.extend({\n      updatedAt: DS.attr('string'),\n      name: DS.attr('string'),\n      firstName: DS.attr('string'),\n      lastName: DS.attr('string')\n    });\n\n    adapter = DS.Adapter.create();\n    store = DS.Store.create({ adapter: adapter });\n    allRecords = null;\n  },\n\n  teardown: function() {\n    if (allRecords) { allRecords.destroy(); }\n    adapter.destroy();\n    store.destroy();\n  }\n});\n\ntest(\"When all records for a type are requested, the store should call the adapter's `findAll` method.\", function() {\n  expect(5);\n\n  adapter.findAll = function(store, type, since) {\n    ok(true, \"the adapter's findAll method should be invoked\");\n\n    // Simulate latency to ensure correct behavior in asynchronous conditions.\n    invokeAsync(function() {\n      store.loadMany(type, [{ id: 1, name: \"Braaaahm Dale\" }]);\n\n      // Only one record array per type should ever be created (identity map)\n      strictEqual(allRecords, store.all(Person), \"the same record array is returned every time all records of a type are requested\");\n    });\n  };\n\n  allRecords = store.find(Person);\n\n  equal(get(allRecords, 'length'), 0, \"the record array's length is zero before any records are loaded\");\n\n  Ember.addObserver(allRecords, 'length', function() {\n    equal(get(allRecords, 'length'), 1, \"the record array's length is 1 after a record is loaded into it\");\n    equal(allRecords.objectAt(0).get('name'), \"Braaaahm Dale\", \"the first item in the record array is Braaaahm Dale\");\n  });\n});\n\ntest(\"When all records for a type are requested, records that are already loaded should be returned immediately.\", function() {\n  expect(3);\n\n  // Load a record from the server\n  store.load(Person, { id: 1, name: \"Jeremy Ashkenas\" });\n\n  // Create a new, unsaved record in the store\n  store.createRecord(Person, { name: \"Alex MacCaw\" });\n\n  allRecords = store.all(Person);\n\n  equal(get(allRecords, 'length'), 2, \"the record array's length is 2\");\n  equal(allRecords.objectAt(0).get('name'), \"Jeremy Ashkenas\", \"the first item in the record array is Jeremy Ashkenas\");\n  equal(allRecords.objectAt(1).get('name'), \"Alex MacCaw\", \"the first item in the record array is Jeremy Ashkenas\");\n});\n\ntest(\"When all records for a type are requested, records that are created on the client should be added to the record array.\", function() {\n  expect(3);\n\n  allRecords = store.all(Person);\n\n  equal(get(allRecords, 'length'), 0, \"precond - the record array's length is zero before any records are loaded\");\n\n  store.createRecord(Person, { name: \"Carsten Nielsen\" });\n\n  equal(get(allRecords, 'length'), 1, \"the record array's length is 1\");\n  equal(allRecords.objectAt(0).get('name'), \"Carsten Nielsen\", \"the first item in the record array is Carsten Nielsen\");\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/find_all_test");minispade.register('ember-data/~tests/integration/find_test', "(function() {var get = Ember.get, set = Ember.set;\nvar Person, store, adapter;\n\nmodule(\"Finding Records\", {\n  setup: function() {\n    Person = DS.Model.extend({\n      updatedAt: DS.attr('string'),\n      name: DS.attr('string'),\n      firstName: DS.attr('string'),\n      lastName: DS.attr('string')\n    });\n\n    adapter = DS.Adapter.create();\n    store = DS.Store.create({ adapter: adapter });\n  },\n\n  teardown: function() {\n    adapter.destroy();\n    store.destroy();\n  }\n});\n\ntest(\"When a single record is requested, the adapter's find method should be called unless it's loaded.\", function() {\n  expect(2);\n\n  var count = 0;\n\n  adapter.find = function(store, type, id) {\n    equal(type, Person, \"the find method is called with the correct type\");\n    equal(count, 0, \"the find method is only called once\");\n\n    store.load(type, id, { id: 1, name: \"Braaaahm Dale\" });\n\n    count++;\n  };\n\n  store.find(Person, 1);\n  store.find(Person, 1);\n});\n\ntest(\"When a record is requested but has not yet been loaded, its `id` property should be the ID used to request the record.\", function() {\n  adapter.find = Ember.K;\n\n  var record = store.find(Person, 1);\n  equal(get(record, 'id'), 1, \"should report its id while loading\");\n});\n\ntest(\"When multiple records are requested, the adapter's `findMany` method should be called.\", function() {\n  expect(1);\n\n  adapter.findMany = function(store, type, ids) {\n    deepEqual(ids, ['1','2','3'], \"ids are passed\");\n  };\n\n  store.findMany(Person, [1,2,3]);\n  store.findMany(Person, [1,2,3]);\n});\n\ntest(\"When multiple records are requested, the default adapter should call the `find` method once per record if findMany is not implemented\", function() {\n  expect(3);\n\n  var count = 0;\n  adapter.find = function(store, type, id) {\n    count++;\n\n    equal(id, count);\n  };\n\n  store.findMany(Person, [1,2,3]);\n  store.findMany(Person, [1,2,3]);\n});\n\ntest(\"When multiple records are requested, the store should not call findMany on the adapter if all the requested records are already loaded.\", function() {\n  expect(0);\n\n  adapter.find = function(store, type, id) {\n    ok(false, \"This should not be called\");\n  };\n\n  store.load(Person, { id: 1 });\n  store.findMany(Person, [ 1 ]);\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/find_test");minispade.register('ember-data/~tests/integration/fixture_adapter_test', "(function() {var get = Ember.get, set = Ember.set;\nvar App, ComplexObject, Person, store, adapter;\n\nComplexObject = Ember.Object.extend({\n\n});\n\nmodule(\"DS.FixtureAdapter & DS.FixtureSerializer\", {\n  setup: function() {\n    App = Ember.Namespace.create();\n\n    App.Person = DS.Model.extend({\n      name: DS.attr('string'),\n      profile: DS.attr('object'),\n    });\n\n    App.Person.FIXTURES = [];\n\n    adapter = DS.FixtureAdapter.create({\n      simulateRemoteResponse: false\n    });\n\n    store = DS.Store.create({ adapter: adapter });\n  },\n\n  teardown: function() {\n    adapter.destroy();\n    store.destroy();\n  }\n});\n\ntest(\"records are persisted as is\", function() {\n  var attributes = {\n    name: \"Adam Hawkins\",\n    profile: ComplexObject.create({\n      skills: ['ruby', 'javascript'],\n      music: 'Trance'\n    })\n  };\n\n  var record = store.createRecord(App.Person, attributes);\n  store.commit();\n\n  var adam = store.find(App.Person, record.get('id'));\n\n  equal(adam.get('name'), attributes.name, 'Attribute materialized');\n  equal(adam.get('profile'), attributes.profile, 'Complex object materialized');\n\n  var fixtures = adapter.fixturesForType(App.Person);\n  equal(fixtures.length, 1, \"fixtures updated\");\n\n  var inMemoryProfile = fixtures[0].profile;\n  ok(inMemoryProfile instanceof Ember.Object, 'Complex objects persisted in memory');\n  equal(inMemoryProfile.skills, adam.get('profile.skills'));\n  equal(inMemoryProfile.music, adam.get('profile.music'));\n});\n\ntest(\"records are updated as is\", function() {\n  var attributes = {\n    name: \"Adam Hawkins\",\n    profile: ComplexObject.create({\n      skills: ['ruby', 'javascript'],\n      music: 'Trance'\n    })\n  };\n\n  var record = store.createRecord(App.Person, attributes);\n  store.commit();\n\n  var adam = store.find(App.Person, record.get('id'));\n\n  adam.set('name', 'Adam Andrew Hawkins');\n  store.commit();\n\n  equal(adam.get('name'), 'Adam Andrew Hawkins', 'Attribute materialized');\n\n  var fixtures = adapter.fixturesForType(App.Person);\n  equal(fixtures.length, 1, \"fixtures updated\");\n\n  var inMemoryObject = fixtures[0];\n\n  equal(inMemoryObject.name, adam.get('name'), 'Changes saved to in memory records');\n});\n\ntest(\"records are deleted\", function() {\n  var attributes = {\n    name: \"Adam Hawkins\",\n    profile: ComplexObject.create({\n      skills: ['ruby', 'javascript'],\n      music: 'Trance'\n    })\n  };\n\n  var record = store.createRecord(App.Person, attributes);\n  store.commit();\n\n  var adam = store.find(App.Person, record.get('id'));\n  adam.deleteRecord();\n  store.commit();\n\n  var fixtures = adapter.fixturesForType(App.Person);\n  equal(fixtures.length, 0, \"fixtures updated\");\n});\n\ntest(\"find queries loaded records\", function() {\n  var attributes = {\n    id: '1',\n    name: \"Adam Hawkins\",\n    profile: ComplexObject.create({\n      skills: ['ruby', 'javascript'],\n      music: 'Trance'\n    })\n  };\n\n  adapter.updateFixtures(App.Person, attributes);\n\n  var adam = store.find(App.Person, 1);\n\n  equal(adam.get('name'), attributes.name, 'Attribute materialized');\n  equal(adam.get('profile'), attributes.profile, 'Complex object materialized');\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/fixture_adapter_test");minispade.register('ember-data/~tests/integration/has_many_test', "(function() {var get = Ember.get, set = Ember.set;\nvar adapter, serializer, store, App;\n\nmodule(\"Has-Many Relationships\", {\n  setup: function() {\n    adapter = DS.Adapter.create();\n    store = DS.Store.create({\n      adapter: adapter\n    });\n\n    serializer = get(adapter, 'serializer');\n\n    App = Ember.Namespace.create({\n      name: 'App'\n    });\n\n    App.Post = DS.Model.extend({\n      title: DS.attr('string')\n    });\n\n    App.Comment = DS.Model.extend({\n      body: DS.attr('string'),\n      post: DS.belongsTo(App.Post)\n    });\n\n    App.Post.reopen({\n      comments: DS.hasMany(App.Comment)\n    });\n  },\n\n  teardown: function() {\n    adapter.destroy();\n    store.destroy();\n  }\n});\n\ntest(\"A hasMany relationship has an isLoaded flag that indicates whether the ManyArray has finished loaded\", function() {\n  expect(10);\n\n  var array, hasLoaded;\n\n  adapter.find = function(store, type, id) {\n    setTimeout(async(function() {\n      equal(array.get('isLoaded'), false, \"Before loading, the array isn't isLoaded\");\n      store.load(type, { id: id });\n\n      // The isLoaded flag change is deferred, so this should be `false`\n      // even after all of the records have been loaded.\n      // This becoming `true` is tested below in the on('didLoad') event listener.\n      equal(array.get('isLoaded'), false, \"After loading some records, the array isn't isLoaded\");\n    }), 1);\n  };\n\n  array = store.findMany(App.Comment, [ 1, 2, 3 ]);\n\n  array.on('didLoad', function() {\n    equal(array.get('isLoaded'), true, \"After loading all records, the array isLoaded\");\n    ok(true, \"didLoad was triggered\");\n  });\n\n  array.then(function(resolvedValue) {\n    equal(resolvedValue, array, \"the promise was resolved with itself\");\n  });\n\n  equal(get(array, 'isLoaded'), false, \"isLoaded should not be true when first created\");\n});\n\ntest(\"When a hasMany relationship is accessed, the adapter's findMany method should not be called if all the records in the relationship are already loaded\", function() {\n  expect(0);\n\n  adapter.findMany = function() {\n    ok(false, \"The adapter's find method should not be called\");\n  };\n\n  store.load(App.Post, { id: 1, comments: [ 1 ] });\n  store.load(App.Comment, { id: 1 });\n\n  var post = store.find(App.Post, 1);\n\n  post.get('comments');\n\n  store.load(App.Post, { id: 1, comments: [ 1 ] });\n});\n\n// This tests the case where a serializer materializes a has-many\n// relationship as a reference that it can fetch lazily. The most\n// common use case of this is to provide a URL to a collection that\n// is loaded later.\nasyncTest(\"An serializer can materialize a hasMany as an opaque token that can be lazily fetched via the adapter's findHasMany hook\", function() {\n  expect(8);\n\n  // When a payload comes in from the server, replace the string\n  // with an object. This can technically be anything; we just need\n  // something that the adapter will understand when its findHasMany\n  // hook is invoked.\n  serializer.extractHasMany = function(record, hash, relationship) {\n    return { url: hash.comments };\n  };\n\n  // When the store asks the adapter for the record with ID 1,\n  // provide some fake data.\n  adapter.find = function(store, type, id) {\n    equal(type, App.Post);\n    equal(id, 1);\n\n    setTimeout(function() {\n      store.load(App.Post, { id: 1, comments: \"/posts/1/comments\" });\n      next();\n    }, 1);\n  };\n\n  adapter.findMany = function() {\n    start();\n    throw new Error(\"Adapter's findMany should not be called\");\n  };\n\n  adapter.findHasMany = function(store, record, relationship, details) {\n    equal(relationship.type, App.Comment);\n    equal(relationship.key, 'comments');\n    equal(details.url, \"/posts/1/comments\");\n\n    setTimeout(function() {\n      // Load in some fake comments\n      store.loadMany(App.Comment, [\n        { id: 1, body: \"First\" },\n        { id: 2, body: \"Second\" }\n      ]);\n\n      // Now load those comments into the ManyArray that was provided.\n      store.loadHasMany(record, relationship.key, [ 1, 2 ]);\n\n      setTimeout(function() {\n        done();\n      }, 1);\n    }, 1);\n  };\n\n  var post = store.find(App.Post, 1), comments;\n\n  function next() {\n    // Kick off the materialization of the comments\n    // hasMany by getting it from the Post object.\n    // The isLoaded property should not be true\n    // because no data has yet been provided.\n    comments = post.get('comments');\n    equal(comments.get('isLoaded'), false);\n  }\n\n  function done() {\n    start();\n    equal(comments.get('isLoaded'), true);\n    equal(comments.get('length'), 2);\n  }\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/has_many_test");minispade.register('ember-data/~tests/integration/inverse_relationships_test', "(function() {var Post, Comment, store;\n\nmodule('Inverse Relationships', {\n  setup: function() {\n    store = DS.Store.create();\n  },\n\n  teardown: function() {\n    store.destroy();\n  }\n});\n\ntest(\"When a record is added to a has-many relationship, the inverse belongsTo is determined automatically\", function() {\n  Post = DS.Model.extend();\n\n  Comment = DS.Model.extend({\n    post: DS.belongsTo(Post)\n  });\n\n  Post.reopen({\n    comments: DS.hasMany(Comment)\n  });\n\n  var comment = store.createRecord(Comment);\n  var post = store.createRecord(Post);\n\n  equal(comment.get('post'), null, \"no post has been set on the comment\");\n\n  post.get('comments').pushObject(comment);\n  equal(comment.get('post'), post, \"post was set on the comment\");\n});\n\ntest(\"When a record is added to a has-many relationship, the inverse belongsTo can be set explicitly\", function() {\n  Post = DS.Model.extend();\n\n  Comment = DS.Model.extend({\n    onePost: DS.belongsTo(Post),\n    twoPost: DS.belongsTo(Post),\n    redPost: DS.belongsTo(Post),\n    bluePost: DS.belongsTo(Post)\n  });\n\n  Post.reopen({\n    comments: DS.hasMany(Comment, {\n      inverse: 'redPost'\n    })\n  });\n\n  var comment = store.createRecord(Comment);\n  var post = store.createRecord(Post);\n\n  equal(comment.get('onePost'), null, \"onePost has not been set on the comment\");\n  equal(comment.get('twoPost'), null, \"twoPost has not been set on the comment\");\n  equal(comment.get('redPost'), null, \"redPost has not been set on the comment\");\n  equal(comment.get('bluePost'), null, \"bluePost has not been set on the comment\");\n\n  post.get('comments').pushObject(comment);\n\n  equal(comment.get('onePost'), null, \"onePost has not been set on the comment\");\n  equal(comment.get('twoPost'), null, \"twoPost has not been set on the comment\");\n  equal(comment.get('redPost'), post, \"redPost has been set on the comment\");\n  equal(comment.get('bluePost'), null, \"bluePost has not been set on the comment\");\n});\n\ntest(\"When a record's belongsTo relationship is set, it can specify the inverse hasMany to which the new child should be added\", function() {\n  Post = DS.Model.extend();\n\n  Comment = DS.Model.extend({\n    post: DS.belongsTo(Post, {\n      inverse: 'youComments'\n    }),\n  });\n\n  Post.reopen({\n    meComments: DS.hasMany(Comment),\n    youComments: DS.hasMany(Comment),\n    everyoneWeKnowComments: DS.hasMany(Comment)\n  });\n\n  var comment = store.createRecord(Comment);\n  var post = store.createRecord(Post);\n\n  equal(post.get('meComments.length'), 0, \"meComments has no posts\");\n  equal(post.get('youComments.length'), 0, \"youComments has no posts\");\n  equal(post.get('everyoneWeKnowComments.length'), 0, \"everyoneWeKnowComments has no posts\");\n\n  comment.set('post', post);\n\n  equal(post.get('meComments.length'), 0, \"meComments has no posts\");\n  equal(post.get('youComments.length'), 1, \"youComments had the post added\");\n  equal(post.get('everyoneWeKnowComments.length'), 0, \"everyoneWeKnowComments has no posts\");\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/inverse_relationships_test");minispade.register('ember-data/~tests/integration/json_serialization_test', "(function() {var store, serializer, Post, post;\n\nmodule(\"Adapter serialization with attributes only\", {\n  setup: function() {\n    store = DS.Store.create();\n\n    Post = DS.Model.extend({\n      title: DS.attr('string')\n    });\n\n    serializer = DS.JSONSerializer.create();\n  },\n  teardown: function() {\n    post.destroy();\n    serializer.destroy();\n    store.destroy();\n  }\n});\n\ntest(\"calling serialize with a record invokes addAttributes\", function() {\n  post = store.createRecord(Post, { title: \"Ohai\" });\n\n  serializer.addAttributes = function(hash, record) {\n    record.eachAttribute(function(attribute) {\n      hash[attribute] = record.get(attribute);\n    });\n  };\n\n  var json = serializer.serialize(post);\n\n  deepEqual(json, { title: \"Ohai\" });\n});\n\ntest(\"by default, addAttributes calls keyForAttributeName\", function() {\n  expect(2);\n\n  post = store.createRecord(Post, { title: \"Ohai\" });\n\n  serializer.keyForAttributeName = function(type, name) {\n    equal(type, Post, \"keyForAttributeName should receive type as first parameter\");\n    equal(name, \"title\", \"keyForAttributeName should receive name as second parameter\");\n\n    return \"__\" + name + \"__\";\n  };\n\n  serializer.serialize(post);\n});\n\ntest(\"the default addAttributes uses a specified defaultValue\", function() {\n  Post.reopen({\n    body: DS.attr('string', { defaultValue: 'FIRST' })\n  });\n\n  post = store.createRecord(Post, { title: \"Ohai\" });\n\n  var json = serializer.serialize(post);\n\n  deepEqual(json, { title: \"Ohai\", body: \"FIRST\" });\n});\n\ntest(\"the default addAttributes calls transform\", function() {\n  serializer.serializeValue = function(value, attributeType) {\n    return value.toUpperCase();\n  };\n\n  post = store.createRecord(Post, { title: \"Ohai\" });\n\n  var json = serializer.serialize(post);\n\n  deepEqual(json, { title: \"OHAI\" });\n});\n\nmodule(\"Adapter serialization with an ID\", {\n  setup: function() {\n    store = DS.Store.create();\n\n    Post = DS.Model.extend();\n\n    serializer = DS.JSONSerializer.create();\n  },\n  teardown: function() {\n    serializer.destroy();\n    store.destroy();\n  }\n});\n\ntest(\"calling serialize with a record and includeId: true invokes addId\", function() {\n  serializer.addId = function(hash, type, id) {\n    hash.__id__ = id;\n  };\n\n  var post = store.createRecord(Post, { id: \"EWOT\" });\n  var json = serializer.serialize(post, { includeId: true });\n\n  deepEqual(json, { __id__: \"EWOT\" });\n});\n\ntest(\"by default, addId calls primaryKey\", function() {\n  expect(2);\n\n  serializer.primaryKey = function(type) {\n    equal(type, Post);\n    return \"__key__\";\n  };\n\n  var post = store.createRecord(Post, { id: \"EWOT\" });\n  var json = serializer.serialize(post, { includeId: true });\n\n  deepEqual(json, { __key__: \"EWOT\" });\n});\n\nvar Comment, comment;\n\nmodule(\"Adapter serialization with relationships\", {\n  setup: function() {\n    store = DS.Store.create();\n\n    Post = DS.Model.extend();\n\n    Comment = DS.Model.extend({\n      post: DS.belongsTo(Post)\n    });\n\n    Post.reopen({\n      comments: DS.hasMany(Comment)\n    });\n\n    serializer = DS.JSONSerializer.create();\n\n    post = store.createRecord(Post);\n    comment = store.createRecord(Comment);\n\n    post.get('comments').pushObject(comment);\n  },\n\n  teardown: function() {\n    post.destroy();\n    comment.destroy();\n    serializer.destroy();\n    store.destroy();\n  }\n});\n\ntest(\"calling serialize with a record with relationships invokes addRelationships\", function() {\n  expect(1);\n\n  serializer.addRelationships = function(hash, record) {\n    equal(record, post);\n  };\n\n  serializer.serialize(post);\n});\n\ntest(\"the default addRelationships calls addBelongsTo\", function() {\n  serializer.addBelongsTo = function(hash, record, key, relationship) {\n    equal(relationship.kind, \"belongsTo\");\n    equal(key, 'post');\n    equal(record, comment);\n  };\n\n  serializer.serialize(comment);\n});\n\ntest(\"the default addRelationships calls addHasMany\", function() {\n  serializer.addHasMany = function(hash, record, key, relationship) {\n    equal(relationship.kind, \"hasMany\");\n    equal(key, 'comments');\n    equal(record, post);\n  };\n\n  serializer.serialize(post);\n});\n\ntest(\"loadValue should be called once per sideloaded type\", function() {\n  var payload, loader, K = Ember.K, loadedTypes = [], App = Ember.Namespace.create({\n    toString: function() { return \"App\"; }\n  });\n\n  App.Fan = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  App.Player = DS.Model.extend({\n    name: DS.attr('string'),\n    fans: DS.hasMany(App.Fan)\n  });\n\n  App.Coach = DS.Model.extend({\n    name: DS.attr('string'),\n    fans: DS.hasMany(App.Fan),\n    players: DS.hasMany(App.Player)\n  });\n\n  serializer.configure(App.Coach, {\n    sideloadAs: 'coaches'\n  });\n\n  App.Team = DS.Model.extend({\n    name: DS.attr('string'),\n    mascots: DS.hasMany(App.Coach),\n    fans: DS.hasMany(App.Fan),\n    players: DS.hasMany(App.Player)\n  });\n\n  payload = {\n    coaches: [{\n      id: 1, name: \"Peter Wagenet\", fan_ids: [ 1 ], player_ids: [ 1 ]\n    }],\n    fans: [{\n      id: 1, name: \"Yehuda Katz\"\n    }],\n    players: [{\n      id: 1, name: \"Tom Dale\", fan_ids: [ 1 ]\n    }],\n    team: {\n      id: 1, name: \"49ers\", fan_ids: [ 1 ], player_ids: [ 1 ], coach_ids: [ 1 ]\n    }\n  };\n\n  loader = { load: K, loadMany: K, prematerialize: K, sinceForType: K };\n\n  serializer.loadValue = function(store, type, value) {\n    loadedTypes.push(type);\n  };\n\n  serializer.extract(loader, payload, App.Team);\n\n  equal(loadedTypes.length, 3, \"Loaded: \" + loadedTypes.join(\", \"));\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/json_serialization_test");minispade.register('ember-data/~tests/integration/mapping_test', "(function() {var ParentAdapter, ChildAdapter, Person, store;\n\nmodule(\"Mapping Attributes\", {\n  setup: function() {\n    Person = window.Person = DS.Model.extend({\n      firstName: DS.attr('string'),\n      lastName: DS.attr('string')\n    });\n\n    ParentAdapter = DS.Adapter.extend();\n    ChildAdapter = ParentAdapter.extend();\n  },\n\n  teardown: function() {\n    window.Person = null;\n    if (store) { store.destroy(); }\n  }\n});\n\ntest(\"Attributes mapped on an adapter class should be used when materializing a record.\", function() {\n  ParentAdapter.map('Person', {\n    lastName: { key: 'LAST_NAME' }\n  });\n\n  ChildAdapter.map('Person', {\n    firstName: { key: 'FIRST_NAME' }\n  });\n\n  store = DS.Store.create({\n    adapter: ChildAdapter\n  });\n\n  store.load(Person, {\n    id: 1,\n    FIRST_NAME: \"Chuck\",\n    LAST_NAME: \"Testa\"\n  });\n\n  var chuck = store.find(Person, 1);\n  chuck.get('data');\n\n  equal(chuck.get('firstName'), \"Chuck\", \"first name is Chuck\");\n  equal(chuck.get('lastName'), \"Testa\", \"last name is Testa\");\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/mapping_test");minispade.register('ember-data/~tests/integration/materialization_tests', "(function() {var Person;\nvar store;\nvar adapter;\nvar serializer;\n\nmodule(\"Record Materialization\", {\n  setup: function() {\n    Person = DS.Model.extend({\n      updatedAt: DS.attr('string'),\n      name: DS.attr('string'),\n      firstName: DS.attr('string'),\n      lastName: DS.attr('string')\n    });\n\n    serializer = DS.JSONSerializer.create();\n    adapter = DS.Adapter.create({\n      serializer: serializer\n    });\n    store = DS.Store.create({ adapter: adapter });\n  },\n\n  teardown: function() {\n    adapter.destroy();\n    store.destroy();\n  }\n});\n\ntest(\"the adapter's materialize method should provide attributes to a record\", function() {\n  store.load(Person, { id: 1, FIRST_NAME: \"Yehuda\", lAsTnAmE: \"Katz\" });\n\n  adapter.materialize = function(record, hash) {\n    record.materializeAttributes({\n      firstName: hash.FIRST_NAME,\n      lastName: hash.lAsTnAmE\n    });\n  };\n\n  var person = store.find(Person, 1);\n\n  equal(person.get('firstName'), \"Yehuda\");\n  equal(person.get('lastName'), \"Katz\");\n});\n\ntest(\"when materializing a record, the serializer's materializeAttributes method should be invoked\", function() {\n  expect(1);\n\n  store.load(Person, { id: 1, FIRST_NAME: \"Yehuda\", lAsTnAmE: \"Katz\" });\n\n  serializer.materializeAttributes = function(record, hash) {\n    deepEqual(hash, {\n      id: 1,\n      FIRST_NAME: \"Yehuda\",\n      lAsTnAmE: \"Katz\"\n    });\n  };\n\n  var person = store.find(Person, 1);\n});\n\ntest(\"when materializing a record, the serializer's materializeAttribute method should be invoked for each attribute\", function() {\n  expect(8);\n\n  store.load(Person, { id: 1, FIRST_NAME: \"Yehuda\", lAsTnAmE: \"Katz\" });\n\n  var attributes = {\n    firstName: 'string',\n    lastName: 'string',\n    updatedAt: 'string',\n    name: 'string'\n  };\n\n  serializer.materializeAttribute = function(record, hash, attributeName, attributeType) {\n    deepEqual(hash, {\n      id: 1,\n      FIRST_NAME: \"Yehuda\",\n      lAsTnAmE: \"Katz\"\n    });\n\n    var expectedType = attributes[attributeName];\n    equal(expectedType, attributeType, \"The attribute type should be correct\");\n    delete attributes[attributeName];\n  };\n\n  var person = store.find(Person, 1);\n});\n\ntest(\"extractId is called when loading a record but not when materializing it afterwards\", function() {\n  expect(2);\n\n  serializer.extractId = function(type, hash) {\n    equal(type, Person, \"extractId is passed the correct type\");\n    deepEqual(hash, { id: 1, name: \"Yehuda Katz\" }, \"the opaque hash should be passed\");\n\n    return 1;\n  };\n\n  store.load(Person, { id: 1, name: \"Yehuda Katz\" });\n\n  // Find record to ensure it gets materialized\n  var person = store.find(Person, 1);\n});\n\ntest(\"when materializing a record, the serializer's extractAttribute is called for each attribute defined on the model\", function() {\n  expect(9);\n\n  var DrugDealer = DS.Model.extend({\n    firstName: DS.attr('string'),\n    lastName: DS.attr('string'),\n    yearsIncarcerated: DS.attr('number')\n  });\n\n  // Keep a hash of which attribute names extractAttribute\n  // has been called with, and `tick` them off as we go along.\n  var attributes = {\n    firstName: true,\n    lastName: true,\n    yearsIncarcerated: true\n  };\n\n  store.load(DrugDealer, { id: 1, firstName: \"Patrick\", lastName: \"Gibson\", yearsIncarcerated: 42 });\n\n  serializer.extractAttribute = function(type, hash, attributeName) {\n    deepEqual(hash, { id: 1, firstName: \"Patrick\", lastName: \"Gibson\", yearsIncarcerated: 42 }, \"opaque hash should be passed to extractAttribute\");\n    equal(type, DrugDealer, \"model type is passed to extractAttribute\");\n\n    ok(attributes.hasOwnProperty(attributeName), \"the attribute name is present\");\n    delete attributes[attributeName];\n  };\n\n  store.find(DrugDealer, 1);\n});\n\ntest(\"when materializing a record, the serializer's extractHasMany method should be invoked\", function() {\n  expect(3);\n\n  Person.reopen({\n    children: DS.hasMany(Person)\n  });\n\n  store.load(Person, { id: 1, children: [ 1, 2, 3 ] });\n\n  serializer.extractHasMany = function(type, hash, name) {\n    equal(type, Person);\n    deepEqual(hash, {\n      id: 1,\n      children: [ 1, 2, 3 ]\n    });\n    equal(name, 'children');\n  };\n\n  var person = store.find(Person, 1);\n});\n\ntest(\"when materializing a record, the serializer's extractBelongsTo method should be invoked\", function() {\n  expect(3);\n\n  Person.reopen({\n    father: DS.belongsTo(Person)\n  });\n\n  store.load(Person, { id: 1, father: 2 });\n\n  serializer.extractBelongsTo = function(type, hash, name) {\n    equal(type, Person);\n    deepEqual(hash, {\n      id: 1,\n      father: 2\n    });\n    equal(name, 'father');\n  };\n\n  var person = store.find(Person, 1);\n});\n\ntest(\"when materializing a record, deserializeValue is called to convert the value from data into a JavaScript value\", function() {\n  expect(2);\n\n  var Bowler = DS.Model.extend({\n    favoriteDrink: DS.attr('string'),\n    hasSpecialLadyFriend: DS.attr('boolean')\n  });\n\n  var typeToValueMap = {\n    \"string\": \"white russian\",\n    \"boolean\": \"FALSE\"\n  };\n\n  store.load(Bowler, { id: 'dude', favoriteDrink: \"white russian\", hasSpecialLadyFriend: \"FALSE\" });\n  serializer.deserializeValue = function(value, attributeType) {\n    strictEqual(typeToValueMap[attributeType], value, \"correct value and type pair should be passed\");\n    delete typeToValueMap[attributeType];\n\n    return value;\n  };\n\n  store.find(Bowler, 'dude');\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/materialization_tests");minispade.register('ember-data/~tests/integration/method_aliases_test', "(function() {/**\n  DS.Model classes contain aliases for common methods that act on the default\n  store. This file tests that those are operating correctly.\n*/\n\nvar get = Ember.get;\nvar store, Person, findCalled;\n\nmodule(\"DS.Model Class Method Aliases\", {\n  setup: function() {\n    store = DS.Store.create({\n      isDefaultStore: true\n    });\n\n    Person = DS.Model.extend({\n      name: DS.attr('string')\n    });\n  },\n\n  teardown: function() {\n    store.destroy();\n  }\n});\n\ntest(\"the find method should be aliased\", function() {\n  expect(2);\n\n  store.find = function(type, id) {\n    equal(type, Person, \"find called with correct type\");\n    equal(id, 1, \"find called with correct arguments\");\n  };\n\n  Person.find(1);\n});\n\ntest(\"the filter method should be aliased\", function() {\n  expect(2);\n\n  var filter = function() {};\n\n  store.filter = function(type, passedFilter) {\n    equal(type, Person, \"filter called with correct type\");\n    equal(passedFilter, filter, \"filter was called with correct arguments\");\n  };\n\n  Person.filter(filter);\n});\n\ntest(\"the all method should be aliased\", function() {\n  expect(1);\n\n  var all = function() {};\n\n  store.all = function(type) {\n    equal(type, Person, \"filter called with correct type\");\n  };\n\n  Person.all();\n});\n\ntest(\"the recordIsLoaded method should be aliased\", function() {\n  expect(2);\n\n  var id = 1;\n\n  store.recordIsLoaded = function(type, passedId) {\n    equal(type, Person, \"recordIsLoaded called with correct type\");\n    equal(passedId, id, \"recordIsLoaded was called with correct arguments\");\n  };\n\n  Person.isLoaded(id);\n});\n\ntest(\"the create method should raise an exception\", function() {\n  raises(function() {\n    Person.create();\n  }, Ember.Error);\n});\n\ntest(\"the createRecord method should be aliased\", function() {\n  expect(4);\n\n  var hash = {};\n\n  store = DS.Store.createWithMixins({\n    isDefaultStore: true,\n\n    createRecord: function(type, passedHash, transaction) {\n      equal(type, Person, \"createRecord called with correct type\");\n      equal(hash, passedHash);\n\n      return this._super(type, passedHash, transaction);\n    }\n  });\n\n  var person = Person.createRecord(hash);\n\n  equal(get(person, 'store'), store, \"the store was set\");\n  equal(Person.detectInstance(person), true, \"the person is an instance of Person\");\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/method_aliases_test");minispade.register('ember-data/~tests/integration/per_type_adapters', "(function() {var oldLookup, lookup;\n\nmodule(\"Per-Type Adapters\", {\n  setup: function() {\n    oldLookup = Ember.lookup;\n    lookup = Ember.lookup = {};\n  },\n\n  teardown: function() {\n    Ember.lookup = oldLookup;\n  }\n});\n\ntest(\"Adapters can be registered on a per-type basis\", function() {\n  expect(2);\n\n  var Store = DS.Store.extend(),\n      Post = DS.Model.extend(),\n      Comment = DS.Model.extend();\n\n  Store.registerAdapter(Post, DS.Adapter.extend({\n    find: function(store, type, id) {\n      strictEqual(type, Post, \"Post adapter was used to find Post record\");\n    }\n  }));\n\n  var store = Store.create({\n    adapter: DS.Adapter.extend({\n      find: function(store, type, id) {\n        strictEqual(type, Comment, \"default adapter is used to find Comment\");\n      }\n    })\n  });\n\n  store.find(Post, 1);\n  store.find(Comment, 1);\n});\n\ntest(\"Mapped adapters are inherited from their parents\", function() {\n  expect(2);\n\n  var ParentStore = DS.Store.extend(),\n      ChildStore = ParentStore.extend(),\n      Post = DS.Model.extend(),\n      Comment = DS.Model.extend();\n\n  ParentStore.registerAdapter(Post, DS.Adapter.extend({\n    find: function(store, type, id) {\n      strictEqual(type, Post, \"Post adapter was used to find Post record\");\n    }\n  }));\n\n  ChildStore.registerAdapter(Comment, DS.Adapter.extend({\n    find: function(store, type, id) {\n      strictEqual(type, Comment, \"Comment adapter is used to find Comment\");\n    }\n  }));\n\n  var store = ChildStore.create();\n\n  store.find(Post, 1);\n  store.find(Comment, 1);\n});\n\ntest(\"Types can be specified as strings\", function() {\n  expect(1);\n\n  var Store = DS.Store.extend(),\n      Post = DS.Model.extend();\n\n  lookup.Post = Post;\n\n  Store.registerAdapter('Post', DS.Adapter.extend({\n    find: function(store, type, id) {\n      strictEqual(type, Post, \"Post adapter was used to find Post record\");\n    }\n  }));\n\n  var store = Store.create();\n  store.find(Post, 1);\n});\n\ntest(\"Child classes can override the mappings of parent classes\", function() {\n  expect(1);\n\n  var ParentStore = DS.Store.extend(),\n      ChildStore = ParentStore.extend(),\n      Post = DS.Model.extend();\n\n  ParentStore.registerAdapter(Post, DS.Adapter.extend({\n    find: function(store, type, id) {\n      ok(false, \"parent adapter mapping should not have been reached\");\n    }\n  }));\n\n  ChildStore.registerAdapter(Post, DS.Adapter.extend({\n    find: function(store, type, id) {\n      strictEqual(type, Post, \"Child adapter is used to find Post\");\n    }\n  }));\n\n  var store = ChildStore.create();\n\n  store.find(Post, 1);\n});\n\ntest(\"Child classes can override the mappings of parent classes when types are provided as strings\", function() {\n  expect(1);\n\n  var ParentStore = DS.Store.extend(),\n      ChildStore = ParentStore.extend(),\n      Post = DS.Model.extend();\n\n  lookup.Post = Post;\n\n  ParentStore.registerAdapter('Post', DS.Adapter.extend({\n    find: function(store, type, id) {\n      ok(false, \"parent adapter mapping should not have been reached\");\n    }\n  }));\n\n  ChildStore.registerAdapter(Post, DS.Adapter.extend({\n    find: function(store, type, id) {\n      strictEqual(type, Post, \"Child adapter is used to find Post\");\n    }\n  }));\n\n  var store = ChildStore.create();\n\n  store.find(Post, 1);\n});\n\ntest(\"Child classes can override the mappings of parent classes when types are provided as strings\", function() {\n  expect(1);\n\n  var ParentStore = DS.Store.extend(),\n      ChildStore = ParentStore.extend(),\n      Post = DS.Model.extend();\n\n  lookup.Post = Post;\n\n  ParentStore.registerAdapter(Post, DS.Adapter.extend({\n    find: function(store, type, id) {\n      ok(false, \"parent adapter mapping should not have been reached\");\n    }\n  }));\n\n  ChildStore.registerAdapter('Post', DS.Adapter.extend({\n    find: function(store, type, id) {\n      strictEqual(type, Post, \"Child adapter is used to find Post\");\n    }\n  }));\n\n  var store = ChildStore.create();\n\n  store.find(Post, 1);\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/per_type_adapters");minispade.register('ember-data/~tests/integration/prematerialized_data_test', "(function() {var Person, adapter, serializer, store;\n\nmodule(\"Prematerialized Data\", {\n  setup: function() {\n    Person = DS.Model.extend({\n      firstName: DS.attr('string'),\n      lastName: DS.attr('string')\n    });\n\n    Person.reopen({\n      bestBud: DS.belongsTo(Person),\n      drugDealers: DS.hasMany(Person)\n    });\n\n    adapter = DS.Adapter.create(),\n    serializer = adapter.serializer,\n    store = DS.Store.create({ adapter: adapter });\n\n    serializer.extractAttribute = function(type, data, name) {\n      return data[name];\n    };\n\n    serializer.keyForAttributeName = function(type, name) {\n      return name;\n    };\n  },\n\n  teardown: function() {\n    store.destroy();\n  }\n});\n\ntest(\"after loading a record, a subsequent find materializes the record through the serializer\", function() {\n  expect(1);\n\n  serializer.extractId = function(type, data) {\n    ok(false, \"extraction is skipped since the id was already provided\");\n  };\n\n  store.load(Person, { id: 1, firstName: \"Yehuda\", lastName: \"Katz\" }, { id: 1 });\n\n  var person = store.find(Person, 1);\n  equal(person.get('firstName'), \"Yehuda\", \"getting an attribute returned the right value\");\n});\n\ntest(\"after loading a record with prematerialized attributes, a subsequent find materializes the record through the serializer\", function() {\n  expect(1);\n\n  serializer.extractId = function(type, data) {\n    ok(false, \"extraction is skipped since the id was already provided\");\n  };\n\n  store.load(Person, {}, { id: 1, firstName: \"Yehuda\", lastName: \"Katz\" });\n\n  var person = store.find(Person, 1);\n  equal(person.get('firstName'), \"Yehuda\", \"getting an attribute returned the right value\");\n});\n\ntest(\"after loading a record with a prematerialized belongsTo relationship, a subsequent find materializes the record through the serializer\", function() {\n  store.load(Person, {}, { id: 1, firstName: \"Tom\", lastName: \"Dale\", bestBud: 2 });\n  store.load(Person, {}, { id: 2, firstName: \"Yehuda\", lastName: \"Katz\", bestBud: 1 });\n\n  var tom = store.find(Person, 1);\n  equal(tom.get('firstName'), \"Tom\", \"attributes are materialized correctly\");\n  var wycats = tom.get('bestBud');\n\n  equal(wycats.get('firstName'), \"Yehuda\", \"related record was found successfully\");\n});\n\ntest(\"after loading a record with a prematerialized hasMany relationship, a subsequent find materializes the record through the serializer\", function() {\n  store.load(Person, {}, { id: 1, firstName: \"Peter\", lastName: \"Wagenet\" });\n  store.load(Person, {}, { id: 2, firstName: \"Tom\", lastName: \"Dale\" });\n  store.load(Person, {}, { id: 3, firstName: \"Yehuda\", lastName: \"Katz\", drugDealers: [1, 2]  });\n\n  var wycats = store.find(Person, 3);\n  equal(wycats.get('firstName'), \"Yehuda\", \"attributes are materialized correctly\");\n\n  var drugDealers = wycats.get('drugDealers');\n\n  equal(drugDealers.objectAt(0).get('firstName'), \"Peter\", \"first drug dealer is found\");\n  equal(drugDealers.objectAt(1).get('firstName'), \"Tom\", \"second drug dealer is found\");\n});\n\nasyncTest(\"if a record is found through store.find(), its prematerialized attributes are loaded once the adapter returns\", function() {\n  expect(1);\n\n  serializer.extractId = function(type, data) {\n    ok(false, \"extraction is skipped since the id was already provided\");\n  };\n\n  adapter.find = function(store, type, id) {\n    setTimeout(function() {\n      store.load(Person, {}, { id: 1, firstName: \"Yehuda\", lastName: \"Katz\" });\n      equal(person.get('firstName'), \"Yehuda\", \"getting an attribute returned the right value\");\n      start();\n    });\n  };\n  var person = store.find(Person, 1);\n});\n\nasyncTest(\"if a record is found through store.find(), its prematerialized belongsTo is loaded once the adapter returns\", function() {\n  adapter.find = function(store, type, id) {\n    setTimeout(function() {\n      store.load(Person, {}, { id: 1, firstName: \"Tom\", lastName: \"Dale\", bestBud: 2 });\n      store.load(Person, {}, { id: 2, firstName: \"Yehuda\", lastName: \"Katz\", bestBud: 1 });\n\n      var tom = store.find(Person, 1);\n      equal(tom.get('firstName'), \"Tom\", \"attributes are materialized correctly\");\n      var wycats = tom.get('bestBud');\n\n      equal(wycats.get('firstName'), \"Yehuda\", \"related record was found successfully\");\n      start();\n    });\n  };\n  var person = store.find(Person, 1);\n});\n\nasyncTest(\"if a record is found through store.find(), its prematerialized hasMany is loaded once the adapter returns\", function() {\n  adapter.find = function(store, type, id) {\n    setTimeout(function() {\n      store.load(Person, {}, { id: 1, firstName: \"Peter\", lastName: \"Wagenet\" });\n      store.load(Person, {}, { id: 2, firstName: \"Tom\", lastName: \"Dale\" });\n      store.load(Person, {}, { id: 3, firstName: \"Yehuda\", lastName: \"Katz\", drugDealers: [1, 2]  });\n\n      var wycats = store.find(Person, 3);\n      equal(wycats.get('firstName'), \"Yehuda\", \"attributes are materialized correctly\");\n\n      var drugDealers = wycats.get('drugDealers');\n\n      equal(drugDealers.objectAt(0).get('firstName'), \"Peter\", \"first drug dealer is found\");\n      equal(drugDealers.objectAt(1).get('firstName'), \"Tom\", \"second drug dealer is found\");\n\n      start();\n    });\n  };\n  var person = store.find(Person, 3);\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/prematerialized_data_test");minispade.register('ember-data/~tests/integration/queries_test', "(function() {var get = Ember.get, set = Ember.set;\nvar Person, store, adapter;\n\nmodule(\"Queries\", {\n  setup: function() {\n    var App = Ember.Namespace.create({ name: \"App\" });\n\n    Person = App.Person = DS.Model.extend({\n      updatedAt: DS.attr('string'),\n      name: DS.attr('string'),\n      firstName: DS.attr('string'),\n      lastName: DS.attr('string')\n    });\n\n    adapter = DS.Adapter.create();\n    store = DS.Store.create({ adapter: adapter });\n  },\n\n  teardown: function() {\n    adapter.destroy();\n    store.destroy();\n  }\n});\n\ntest(\"When a query is made, the adapter should receive a record array it can populate with the results of the query.\", function() {\n  expect(8);\n\n  adapter.findQuery = function(store, type, query, recordArray) {\n    equal(type, Person, \"the find method is called with the correct type\");\n\n    stop();\n\n    var self = this;\n\n    // Simulate latency to ensure correct behavior in asynchronous conditions.\n    // Once 100ms has passed, load the results of the query into the record array.\n    setTimeout(function() {\n      Ember.run(function() {\n        self.didFindQuery(store, type, { persons: [{ id: 1, name: \"Peter Wagenet\" }, { id: 2, name: \"Brohuda Katz\" }] }, recordArray);\n      });\n    }, 100);\n  };\n\n  var queryResults = store.find(Person, { page: 1 });\n  equal(get(queryResults, 'length'), 0, \"the record array has a length of zero before the results are loaded\");\n  equal(get(queryResults, 'isLoaded'), false, \"the record array's `isLoaded` property is false\");\n\n  queryResults.one('didLoad', function() {\n    equal(get(queryResults, 'length'), 2, \"the record array has a length of 2 after the results are loaded\");\n    equal(get(queryResults, 'isLoaded'), true, \"the record array's `isLoaded` property should be true\");\n\n    equal(queryResults.objectAt(0).get('name'), \"Peter Wagenet\", \"the first record is 'Peter Wagenet'\");\n    equal(queryResults.objectAt(1).get('name'), \"Brohuda Katz\", \"the second record is 'Brohuda Katz'\");\n  });\n\n  queryResults.then(function(resolvedValue) {\n    start();\n\n    equal(resolvedValue, queryResults, \"The promise was resolved with the query results\");\n  });\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/queries_test");minispade.register('ember-data/~tests/integration/record_persistence_test', "(function() {var get = Ember.get, set = Ember.set;\nvar Person, store, adapter;\n\nmodule(\"Persisting Records\", {\n  setup: function() {\n    Person = DS.Model.extend({\n      updatedAt: DS.attr('string'),\n      name: DS.attr('string'),\n      firstName: DS.attr('string'),\n      lastName: DS.attr('string')\n    });\n    Person[Ember.GUID_KEY+'_name'] = 'Person'; // To test error messages\n\n    adapter = DS.Adapter.create();\n    store = DS.Store.create({ adapter: adapter });\n  },\n\n  teardown: function() {\n    adapter.destroy();\n    store.destroy();\n  }\n});\n\ntest(\"When a store is committed, the adapter's `commit` method should be called with records that have been changed.\", function() {\n  expect(2);\n\n  adapter.commit = function(store, records) {\n    this.groupByType(records.updated).forEach(function(type, set) {\n      equal(type, Person, \"the type is correct\");\n      equal(get(set.toArray(), 'length'), 1, \"the array is the right length\");\n\n      store.didSaveRecords(set);\n    });\n  };\n\n  store.load(Person, { id: 1, name: \"Braaaahm Dale\" });\n\n  var tom = store.find(Person, 1);\n  set(tom, \"name\", \"Tom Dale\");\n\n  store.commit();\n\n  // Make sure that if we commit again, the previous records have been\n  // removed.\n  store.commit();\n});\n\ntest(\"When a store is committed, the adapter's `commit` method should be called with records that have been created.\", function() {\n  expect(3);\n\n  adapter.commit = function(store, records) {\n    equal(get(records.updated.toArray(), 'length'), 0, \"no records are marked as being updated\");\n\n    this.groupByType(records.created).forEach(function(type, set) {\n      equal(type, Person, \"the type is correct\");\n      equal(get(set.toArray(), 'length'), 1, \"the array is the right length\");\n\n      store.didSaveRecords(set, [{ id: 1, name: \"Tom Dale\" }]);\n    });\n  };\n\n  var tom = store.createRecord(Person, { name: \"Tom Dale\" });\n\n  store.commit();\n\n  // Make sure that if we commit again, the previous records have been\n  // removed.\n  store.commit();\n});\n\ntest(\"After a created record has been assigned an ID, finding a record by that ID returns the original record.\", function() {\n  expect(1);\n\n  adapter.commit = function(store, records) {\n    store.didSaveRecords(records.created, [{ id: 1, name: \"Tom Dale\" }]);\n  };\n\n  var tom = store.createRecord(Person, { name: \"Tom Dale\" });\n  store.commit();\n\n  strictEqual(tom, store.find(Person, 1), \"the retrieved record is the same as the created record\");\n\n  // Make sure that if we commit again, the previous records have been\n  // removed.\n  store.commit();\n});\n\ntest(\"when a store is committed, the adapter's `commit` method should be called with records that have been deleted.\", function() {\n  expect(5);\n\n  adapter.commit = function(store, records) {\n    equal(records.updated.isEmpty(), true, \"no records are marked as updated\");\n    equal(records.created.isEmpty(), true, \"no records are marked as created\");\n\n    this.groupByType(records.deleted).forEach(function(type, set) {\n      equal(type, Person, \"the type is correct\");\n      equal(get(set.toArray(), 'length'), 1, \"the array is the right length\");\n\n      store.didSaveRecords(set);\n    });\n  };\n\n  store.load(Person, { id: 1, name: \"Tom Dale\" });\n  var tom = store.find(Person, 1);\n\n  tom.deleteRecord();\n  store.commit();\n\n  equal(get(tom, 'isDeleted'), true, \"record is marked as deleted\");\n});\n\ntest(\"An adapter can notify the store that records were updated by calling `didSaveRecords`.\", function() {\n  expect(5);\n\n  var tom, yehuda;\n\n  adapter.commit = function(store, commitDetails, relationships) {\n    var updatedRecords = commitDetails.updated;\n\n    equal(get(updatedRecords.toArray(), 'length'), 2, \"two updated records are passed to `commit`\");\n\n    store.didSaveRecords([tom, yehuda]);\n\n    ok(!tom.get('isDirty'), \"tom is no longer dirty\");\n    ok(!yehuda.get('isDirty'), \"yehuda is no longer dirty\");\n  };\n\n  store.load(Person, { id: 1 });\n  store.load(Person, { id: 2 });\n\n  tom = store.find(Person, 1);\n  yehuda = store.find(Person, 2);\n\n  tom.set('name', \"Michael Phelps\");\n  yehuda.set('name', \"Usain Bolt\");\n\n  ok(tom.get('isDirty'), \"tom is dirty\");\n  ok(yehuda.get('isDirty'), \"yehuda is dirty\");\n\n  store.commit();\n\n  // there is nothing to commit, so there won't be any records\n  store.commit();\n});\n\ntest(\"An adapter can notify the store that records were updated and provide new data by calling `didSaveRecords`.\", function() {\n  expect(5);\n\n  var tom, yehuda, transaction;\n\n  adapter.commit = function(store, commitDetails, relationships) {\n    var updatedRecords = commitDetails.updated;\n\n    equal(get(updatedRecords.toArray(), 'length'), 2, \"precond - two updated records are passed to `commit`\");\n\n    store.didSaveRecords([tom, yehuda], [ { id: 1, name: \"Tom Dale\", updatedAt: \"now\" }, { id: 2, name: \"Yehuda Katz\", updatedAt: \"now!\" } ]);\n\n    equal(tom.get('name'), \"Tom Dale\", \"name attribute should reflect value of hash passed to didSaveRecords\");\n    equal(yehuda.get('name'), \"Yehuda Katz\", \"name attribute should reflect value of hash passed to didSaveRecords\");\n    equal(tom.get('updatedAt'), \"now\", \"updatedAt attribute should reflect value of hash passed to didSaveRecords\");\n    equal(yehuda.get('updatedAt'), \"now!\", \"updatedAt attribute should reflect value of hash passed to didSaveRecords\");\n  };\n\n  store.load(Person, { id: 1, name: \"Braaaahm Dale\" });\n  store.load(Person, { id: 2, name: \"Gentile Katz\" });\n\n  tom = store.find(Person, 1);\n  yehuda = store.find(Person, 2);\n\n  tom.set('name', \"Draaaaaahm Dale\");\n  yehuda.set('name', \"Goy Katz\");\n\n  store.commit();\n\n  // there is nothing to commit, so there won't be any records\n  store.commit();\n});\n\ntest(\"An adapter can notify the store that a record was updated by calling `didSaveRecord`.\", function() {\n  expect(5);\n\n  var tom, yehuda;\n\n  adapter.commit = function(store, commitDetails, relationships) {\n    var updatedRecords = commitDetails.updated;\n\n    equal(get(updatedRecords.toArray(), 'length'), 2, \"precond - two updated records are passed to `commit`\");\n\n    store.didSaveRecord(tom);\n    store.didSaveRecord(yehuda);\n\n    ok(!tom.get('isDirty'), \"tom is not dirty\");\n    ok(!yehuda.get('isDirty'), \"yehuda is not dirty\");\n  };\n\n  store.load(Person, { id: 1 });\n  store.load(Person, { id: 2 });\n\n  tom = store.find(Person, 1);\n  yehuda = store.find(Person, 2);\n\n  tom.set('name', \"Tom Dale\");\n  yehuda.set('name', \"Yehuda Katz\");\n\n  ok(tom.get('isDirty'), \"tom is dirty\");\n  ok(yehuda.get('isDirty'), \"yehuda is dirty\");\n\n  store.commit();\n\n  // there is nothing to commit, so there won't be any records\n  store.commit();\n});\n\ntest(\"An adapter can notify the store that a record was updated and provide new data by calling `didSaveRecord`.\", function() {\n  expect(5);\n\n  var tom, yehuda, transaction;\n\n  adapter.commit = function(store, commitDetails, relationships) {\n    var updatedRecords = commitDetails.updated;\n\n    equal(get(updatedRecords.toArray(), 'length'), 2, \"precond - two updated records are passed to `commit`\");\n\n    store.didSaveRecord(tom, { id: 1, name: \"Tom Dale\", updatedAt: \"now\" });\n    store.didSaveRecord(yehuda, { id: 2, name: \"Yehuda Katz\", updatedAt: \"now!\" });\n\n    equal(tom.get('name'), \"Tom Dale\", \"name attribute should reflect value of hash passed to didSaveRecords\");\n    equal(yehuda.get('name'), \"Yehuda Katz\", \"name attribute should reflect value of hash passed to didSaveRecords\");\n    equal(tom.get('updatedAt'), \"now\", \"updatedAt attribute should reflect value of hash passed to didSaveRecords\");\n    equal(yehuda.get('updatedAt'), \"now!\", \"updatedAt attribute should reflect value of hash passed to didSaveRecords\");\n  };\n\n  store.load(Person, { id: 1, name: \"Braaaahm Dale\" });\n  store.load(Person, { id: 2, name: \"Gentile Katz\" });\n\n  tom = store.find(Person, 1);\n  yehuda = store.find(Person, 2);\n\n  tom.set('name', \"Draaaaaahm Dale\");\n  yehuda.set('name', \"Goy Katz\");\n\n  store.commit();\n\n  // there is nothing to commit, so there won't be any records\n  store.commit();\n});\n\ntest(\"An adapter can notify the store that records were deleted by calling `didSaveRecords`.\", function() {\n  expect(3);\n\n  var tom, yehuda, transaction;\n\n  adapter.commit = function(store, commitDetails, relationships) {\n    var deletedRecords = commitDetails.deleted;\n\n    equal(get(deletedRecords.toArray(), 'length'), 2, \"precond - two updated records are passed to `commit`\");\n\n    store.didSaveRecords([tom, yehuda]);\n\n    ok(!get(tom, 'isDirty'), \"Tom is no longer dirty\");\n    ok(!get(yehuda, 'isDirty'), \"Yehuda is no longer dirty\");\n  };\n\n  store.load(Person, { id: 1, name: \"Braaaahm Dale\" });\n  store.load(Person, { id: 2, name: \"Gentile Katz\" });\n\n  tom = store.find(Person, 1);\n  yehuda = store.find(Person, 2);\n\n  tom.deleteRecord();\n  yehuda.deleteRecord();\n\n  store.commit();\n\n  // there is nothing to commit, so there won't be any records\n  store.commit();\n});\n\ntest(\"An adapter can notify the store that a record was deleted by calling `didSaveRecord`.\", function() {\n  expect(3);\n\n  var tom, yehuda, transaction;\n\n  adapter.commit = function(store, commitDetails, relationships) {\n    var deletedRecords = commitDetails.deleted;\n\n    equal(get(deletedRecords.toArray(), 'length'), 2, \"precond - two updated records are passed to `commit`\");\n\n    store.didSaveRecord(tom);\n    store.didSaveRecord(yehuda);\n\n    ok(!get(tom, 'isDirty'), \"Tom is no longer dirty\");\n    ok(!get(yehuda, 'isDirty'), \"Yehuda is no longer dirty\");\n  };\n\n  store.load(Person, { id: 1, name: \"Braaaahm Dale\" });\n  store.load(Person, { id: 2, name: \"Gentile Katz\" });\n\n  tom = store.find(Person, 1);\n  yehuda = store.find(Person, 2);\n\n  tom.deleteRecord();\n  yehuda.deleteRecord();\n\n  store.commit();\n\n  // there is nothing to commit, so there won't be any records\n  store.commit();\n});\n\ntest(\"An error is raised when attempting to set a property while a record is being saved\", function() {\n  expect(3);\n\n  var tom;\n\n  adapter.commit = function(store, commitDetails, relationships) {\n  };\n\n  var finishSaving = function() {\n    store.didSaveRecord(tom);\n  };\n\n  store.load(Person, { id: 1 });\n  tom = store.find(Person, 1);\n  tom.set('name', \"Tom Dale\");\n  store.commit();\n  ok(tom.get('isDirty'), \"tom is dirty\");\n  try {\n    tom.set('name', \"Tommy Bahama\");\n  } catch(e) {\n    var expectedMessage = \"Attempted to handle event `willSetProperty` on <Person:\" + Ember.guidFor(tom) + \":1> \";\n    expectedMessage +=    \"while in state rootState.loaded.updated.inFlight. Called with \";\n    expectedMessage +=    \"{reference: [object Object], store: <DS.Store:\" + Ember.guidFor(store) + \">, name: name}\";\n    equal(e.message, expectedMessage);\n  }\n  finishSaving();\n  ok(!tom.get('isDirty'), \"tom is not dirty\");\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/record_persistence_test");minispade.register('ember-data/~tests/integration/relationships/introspection_test', "(function() {var Blog, User, Post;\nvar lookup, oldLookup;\n\nmodule(\"Relationship Introspection\", {\n  setup: function() {\n    oldLookup = Ember.lookup;\n    Ember.lookup = {};\n\n    User = DS.Model.extend();\n    Post = DS.Model.extend();\n    Blog = DS.Model.extend({\n      admins: DS.hasMany(User),\n      owner: DS.belongsTo(User),\n\n      posts: DS.hasMany(Post)\n    });\n  },\n\n  teardown: function() {\n    Ember.lookup = oldLookup;\n  }\n});\n\ntest(\"DS.Model class computed property `relationships` returns a map keyed on types\", function() {\n  var relationships = Ember.get(Blog, 'relationships');\n\n  var expected = [{ name: 'admins', kind: 'hasMany'  }, { name: 'owner', kind: 'belongsTo' }];\n  deepEqual(relationships.get(User), expected, \"user relationships returns expected array\");\n\n  expected = [{ name: 'posts', kind: 'hasMany' }];\n  deepEqual(relationships.get(Post), expected, \"post relationships returns expected array\");\n});\n\ntest(\"DS.Model class computed property `relationships` returns a map keyed on types when types are specified as strings\", function() {\n  Blog = DS.Model.extend({\n    admins: DS.hasMany('User'),\n    owner: DS.belongsTo('User'),\n\n    posts: DS.hasMany('Post')\n  });\n\n  Ember.lookup = {\n    User: DS.Model.extend(),\n    Post: DS.Model.extend()\n  };\n\n  var relationships = Ember.get(Blog, 'relationships');\n\n  var expected = [{ name: 'admins', kind: 'hasMany'  }, { name: 'owner', kind: 'belongsTo' }];\n  deepEqual(relationships.get(Ember.lookup.User), expected, \"user relationships returns expected array\");\n\n  expected = [{ name: 'posts', kind: 'hasMany' }];\n  deepEqual(relationships.get(Ember.lookup.Post), expected, \"post relationships returns expected array\");\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/relationships/introspection_test");minispade.register('ember-data/~tests/integration/relationships/inverse_test', "(function() {var get = Ember.get, set = Ember.set;\n\nvar store, adapter, App, Post, Comment;\n\nmodule(\"Inverse test\", {\n  setup: function() {\n    adapter = DS.Adapter.create();\n\n    store = DS.Store.create({\n      isDefaultStore: true,\n      adapter: adapter\n    }); \n\n    App = Ember.Namespace.create({\n      toString: function() { return \"App\"; }\n    }); \n  },  \n\n  teardown: function() {\n    Ember.run(function() {\n      store.destroy();\n    }); \n  }\n});\n\ntest(\"One to one relationships should be identified correctly\", function() {\n\n  App.Post = DS.Model.extend({\n    title: DS.attr('string')\n  }); \n\n  App.Comment = DS.Model.extend({\n    body: DS.attr('string'),\n    post: DS.belongsTo(App.Post)\n  }); \n\n  App.Post.reopen({\n    comment: DS.belongsTo(App.Comment)\n  });\n\n  var type = DS.RelationshipChange.determineRelationshipType(App.Post, {key: \"comment\", kind: \"belongsTo\"});\n \n  equal(type, \"oneToOne\", \"Relationship type is oneToOne\");\n});\n\ntest(\"One to many relationships should be identified correctly\", function() {\n\n  App.Post = DS.Model.extend({\n    title: DS.attr('string')\n  }); \n\n  App.Comment = DS.Model.extend({\n    body: DS.attr('string'),\n    post: DS.hasMany(App.Post)\n  }); \n\n  App.Post.reopen({\n    comment: DS.belongsTo(App.Comment)\n  });\n\n  var type = DS.RelationshipChange.determineRelationshipType(App.Post, {key: \"comment\", kind: \"belongsTo\"});\n \n  equal(type, \"oneToMany\", \"Relationship type is oneToMany\");\n});\n\ntest(\"Many to one relationships should be identified correctly\", function() {\n\n  App.Post = DS.Model.extend({\n    title: DS.attr('string')\n  }); \n\n  App.Comment = DS.Model.extend({\n    body: DS.attr('string'),\n    post: DS.hasMany(App.Post)\n  }); \n\n  App.Post.reopen({\n    comment: DS.belongsTo(App.Comment)\n  });\n\n  var type = DS.RelationshipChange.determineRelationshipType(App.Comment, {key: \"post\", kind: \"hasMany\"});\n \n  equal(type, \"manyToOne\", \"Relationship type is manyToOne\");\n});\n\ntest(\"Many to many relationships should be identified correctly\", function() {\n\n  App.Post = DS.Model.extend({\n    title: DS.attr('string')\n  }); \n\n  App.Comment = DS.Model.extend({\n    body: DS.attr('string'),\n    post: DS.hasMany(App.Post)\n  }); \n\n  App.Post.reopen({\n    comment: DS.belongsTo(App.Comment)\n  });\n\n  var type = DS.RelationshipChange.determineRelationshipType(App.Post, {key: \"comment\", kind: \"hasMany\"});\n \n  equal(type, \"manyToMany\", \"Relationship type is manyTomany\");\n});\n\ntest(\"Many to none relationships should be identified correctly\", function() {\n\n  App.Post = DS.Model.extend({\n    title: DS.attr('string')\n  }); \n\n  App.Comment = DS.Model.extend({\n    body: DS.attr('string'),\n    post: DS.hasMany(App.Post)\n  }); \n\n  var type = DS.RelationshipChange.determineRelationshipType(App.Comment, {key: \"post\", kind: \"hasMany\"});\n \n  equal(type, \"manyToNone\", \"Relationship type is manyToNone\");\n});\n\ntest(\"One to none relationships should be identified correctly\", function() {\n\n  App.Post = DS.Model.extend({\n    title: DS.attr('string')\n  }); \n\n  App.Comment = DS.Model.extend({\n    body: DS.attr('string'),\n    post: DS.belongsTo(App.Post)\n  }); \n\n  var type = DS.RelationshipChange.determineRelationshipType(App.Comment, {key: \"post\", kind: \"belongsTo\"});\n \n  equal(type, \"oneToNone\", \"Relationship type is oneToNone\");\n});\n\n\n})();\n//@ sourceURL=ember-data/~tests/integration/relationships/inverse_test");minispade.register('ember-data/~tests/integration/relationships/many_to_many_relationships_test', "(function() {var get = Ember.get, set = Ember.set;\n\nvar store, adapter, App, Post, Comment;\n\nmodule(\"One-to-Many Relationships\", {\n  setup: function() {\n    adapter = DS.Adapter.create();\n\n    store = DS.Store.create({\n      isDefaultStore: true,\n      adapter: adapter\n    });\n\n    App = Ember.Namespace.create({\n      toString: function() { return \"App\"; }\n    });\n\n    App.Post = DS.Model.extend({\n      title: DS.attr('string')\n    });\n\n    App.Comment = DS.Model.extend({\n      body: DS.attr('string'),\n      posts: DS.hasMany(App.Post)\n    });\n\n    App.Post.reopen({\n      comments: DS.hasMany(App.Comment)\n    });\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      store.destroy();\n    });\n  }\n});\n\nfunction verifySynchronizedManyToMany(post, comment, expectedHasMany) {\n  expectedHasMany = expectedHasMany || [comment];\n  deepEqual(post.get('comments').toArray(), [comment]);\n  deepEqual(comment.get('posts').toArray(), [post]);\n}\n\ntest(\"When adding another record to a hasMany relationship, that record should be added to the inverse hasMany array\", function() {\n  store.load(App.Post, { id: 1, title: \"parent\" });\n  store.load(App.Comment, { id: 2, body: \"child\" });\n\n  var post = store.find(App.Post, 1),\n      comment = store.find(App.Comment, 2);\n\n  equal(post.get('comments.length'), 0, \"precond - the post has no child comments yet\");\n\n  comment.get('posts').addObject(post);\n  verifySynchronizedManyToMany(post, comment);\n});\n/*\ntest(\"When setting a record's belongsTo relationship to null, that record should be removed from the inverse hasMany array\", function() {\n  store.load(App.Post, { id: 1, title: \"parent\", comments: [2, 3] });\n  store.load(App.Comment, { id: 2, body: \"child\", post: 1 });\n  store.load(App.Comment, { id: 3, body: \"child\", post: 1 });\n\n  var post = store.find(App.Post, 1),\n      comment1 = store.find(App.Comment, 2),\n      comment2 = store.find(App.Comment, 3);\n\n  deepEqual(post.get('comments').toArray(), [comment1, comment2], \"precond - the post has has two child comments\");\n\n  comment1.set('post', null);\n  equal(comment1.get('post'), null, \"belongsTo relationship has been set to null\");\n  deepEqual(post.get('comments').toArray(), [ comment2 ], \"the post comments array should have the remaining comment\");\n});\n\ntest(\"When adding a record to a hasMany array, its belongsTo is set\", function() {\n  store.load(App.Post, { id: 1, title: \"parent\", comments: [2] });\n  store.load(App.Comment, { id: 2, body: \"child\", post: 1 });\n  store.load(App.Comment, { id: 3, body: \"child\" });\n\n  var post = store.find(App.Post, 1),\n      comment1 = store.find(App.Comment, 2),\n      comment2 = store.find(App.Comment, 3);\n\n  post.get('comments').addObject(comment2);\n  verifySynchronizedOneToMany(post, comment2, [comment1, comment2]);\n});\n\ntest(\"When removing a record from a hasMany array, its belongsTo is set to null\", function() {\n  store.load(App.Post, { id: 1, title: \"parent\", comments: [2, 3] });\n  store.load(App.Comment, { id: 2, body: \"child\", post: 1 });\n  store.load(App.Comment, { id: 3, body: \"child\", post: 1 });\n\n  var post = store.find(App.Post, 1),\n      comment1 = store.find(App.Comment, 2),\n      comment2 = store.find(App.Comment, 3);\n\n  post.get('comments').removeObject(comment1);\n  verifySynchronizedOneToMany(post, comment2);\n  equal(comment1.get('post'), null, \"belongsTo relationship has been set to null\");\n});\n\ntest(\"When adding a record to a hasMany array, it should be removed from its old hasMany array, if there was one\", function() {\n  store.load(App.Post, { id: 1, title: \"old parent\", comments: [3] });\n  store.load(App.Post, { id: 2, title: \"new parent\" });\n\n  store.load(App.Comment, { id: 3, body: \"child\", post: 1 });\n\n  var oldParent = store.find(App.Post, 1),\n      newParent = store.find(App.Post, 2),\n      child = store.find(App.Comment, 3);\n\n  verifySynchronizedOneToMany(oldParent, child);\n\n  newParent.get('comments').addObject(child);\n\n  deepEqual(oldParent.get('comments').toArray(), [], \"old parent has no child comments\");\n\n  verifySynchronizedOneToMany(newParent, child);\n});\n\ntest(\"When changing a record's belongsTo, it should be removed from its old inverse hasMany array, if there was one\", function() {\n  store.load(App.Post, { id: 1, title: \"old parent\", comments: [3] });\n  store.load(App.Post, { id: 2, title: \"new parent\" });\n\n  store.load(App.Comment, { id: 3, body: \"child\", post: 1 });\n\n  var oldParent = store.find(App.Post, 1),\n      newParent = store.find(App.Post, 2),\n      child = store.find(App.Comment, 3);\n\n  verifySynchronizedOneToMany(oldParent, child);\n\n  child.set('post', newParent);\n\n  deepEqual(oldParent.get('comments').toArray(), [], \"old parent has no child comments\");\n\n  verifySynchronizedOneToMany(newParent, child);\n});\n\ntest(\"Deleting a record removes it from any inverse hasMany arrays to which it belongs.\", function() {\n  var post, comment;\n\n  store.load(App.Post, { id: 1, title: \"parent\", comments: [1] });\n  store.load(App.Comment, { id: 1, title: \"parent\", post: 1 });\n\n  post = store.find(App.Post, 1);\n  comment = store.find(App.Comment, 1);\n\n  verifySynchronizedOneToMany(post, comment);\n\n  comment.deleteRecord();\n\n  equal(comment.get('post'), null, \"the comment should no longer belong to a post\");\n  deepEqual(post.get('comments').toArray(), [], \"the post should no longer have any comments\");\n});\n\ntest(\"Deleting a newly created record removes it from any inverse hasMany arrays to which it belongs.\", function() {\n  var post, comment;\n\n  store.load(App.Post, { id: 1, title: \"parent\" });\n\n  post = store.find(App.Post, 1);\n  comment = store.createRecord(App.Comment);\n\n  equal(comment.get('post'), null, \"precond - the child should not yet belong to anyone\");\n\n  post.get('comments').addObject(comment);\n\n  verifySynchronizedOneToMany(post, comment);\n\n  comment.deleteRecord();\n\n  equal(comment.get('post'), null, \"the comment should no longer belong to a post\");\n  deepEqual(post.get('comments').toArray(), [], \"the post should no longer have any comments\");\n});\n\n//test(\"When a record with a hasMany association is deleted, its associated record is materialized and its belongsTo is changed\", function() {\n  //store.load(App.Post, { id: 1, title: \"NEW! Ember Table\", comments: [ 2 ] });\n  //store.load(App.Comment, { id: 2, body: \"Needs more async\", post: 1 });\n\n  //// Only find the post, not the comment. This ensures\n  //// that the comment is not yet materialized.\n  //var post = store.find(App.Post, 1);\n  //var comment = store.find(App.Comment, 2);\n  //post.deleteRecord();\n\n  //// Now that we've deleted the post, we should materialize the\n  //// comment and ensure that its inverse relationship has been\n  //// modified appropriately (i.e., set to null)\n  //equal(comment.get('post'), null, \"the comment's post belongsTo relationship was set to null\");\n//});\n*/\n\n})();\n//@ sourceURL=ember-data/~tests/integration/relationships/many_to_many_relationships_test");minispade.register('ember-data/~tests/integration/relationships/many_to_none_relationships_test', "(function() {var get = Ember.get, set = Ember.set;\n\nvar store, adapter, App, Post, Comment;\n\nmodule(\"Many-to-None Relationships\", {\n  setup: function() {\n    adapter = DS.Adapter.create();\n\n    store = DS.Store.create({\n      isDefaultStore: true,\n      adapter: adapter\n    });\n\n    App = Ember.Namespace.create({\n      toString: function() { return \"App\"; }\n    });\n    \n    App.Comment = DS.Model.extend({\n      body: DS.attr('string'),\n    });\n\n    App.Post = DS.Model.extend({\n      title: DS.attr('string'),\n      comments: DS.hasMany(App.Comment)\n    });\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      store.destroy();\n    });\n  }\n});\n\ntest(\"Adding a record to a hasMany relationship should work\", function() {\n  store.load(App.Post, { id: 1, title: \"parent\" });\n  store.load(App.Comment, { id: 2, body: \"child\" });\n\n  var post = store.find(App.Post, 1),\n      comment = store.find(App.Comment, 2);\n\n  post.get('comments').pushObject(comment);\n  deepEqual(post.get('comments').toArray(), [comment], \"post should have the comment added to its comments\");\n});\n\ntest(\"Removing a record from a hasMany relationship should work\", function() {\n  store.load(App.Post, { id: 1, title: \"parent\", comments: [2, 3] });\n  store.load(App.Comment, { id: 2, body: \"child\" });\n  store.load(App.Comment, { id: 3, body: \"child\" });\n\n  var post = store.find(App.Post, 1),\n      comment1 = store.find(App.Comment, 2),\n      comment2 = store.find(App.Comment, 3);\n\n  post.get('comments').removeObject(comment1);\n  deepEqual(post.get('comments').toArray(), [comment2], \"post should have the comment added to its comments\");\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/relationships/many_to_none_relationships_test");minispade.register('ember-data/~tests/integration/relationships/one_to_many_relationships_test', "(function() {var get = Ember.get, set = Ember.set;\n\nvar store, adapter, App, Post, Comment;\n\nmodule(\"One-to-Many Relationships\", {\n  setup: function() {\n    adapter = DS.Adapter.create();\n\n    store = DS.Store.create({\n      isDefaultStore: true,\n      adapter: adapter\n    });\n\n    App = Ember.Namespace.create({\n      toString: function() { return \"App\"; }\n    });\n\n    App.Post = DS.Model.extend({\n      title: DS.attr('string')\n    });\n\n    App.Comment = DS.Model.extend({\n      body: DS.attr('string'),\n      post: DS.belongsTo(App.Post)\n    });\n\n    App.Post.reopen({\n      comments: DS.hasMany(App.Comment)\n    });\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      store.destroy();\n    });\n  }\n});\n\nfunction verifySynchronizedOneToMany(post, comment, expectedHasMany) {\n  expectedHasMany = expectedHasMany || [comment];\n  equal(comment.get('post'), post);\n  deepEqual(post.get('comments').toArray(), expectedHasMany);\n}\n\ntest(\"Referencing a null belongsTo relationship returns null\", function(){\n  store.load(App.Comment, { id: 1, post: null, body: \"child with intentionally null parent\" });\n  var comment = store.find(App.Comment, 1);\n  equal(comment.get('post'), null, \"null belongsTo relationship returns null\");\n});\n\ntest(\"When setting a record's belongsTo relationship to another record, that record should be added to the inverse hasMany array\", function() {\n  store.load(App.Post, { id: 1, title: \"parent\" });\n  store.load(App.Comment, { id: 2, body: \"child\" });\n\n  var post = store.find(App.Post, 1),\n      comment = store.find(App.Comment, 2);\n\n  equal(post.get('comments.length'), 0, \"precond - the post has no child comments yet\");\n\n  comment.set('post', post);\n  verifySynchronizedOneToMany(post, comment);\n});\n\ntest(\"When setting a record's belongsTo relationship to null, that record should be removed from the inverse hasMany array\", function() {\n  store.load(App.Post, { id: 1, title: \"parent\", comments: [2, 3] });\n  store.load(App.Comment, { id: 2, body: \"child\", post: 1 });\n  store.load(App.Comment, { id: 3, body: \"child\", post: 1 });\n\n  var post = store.find(App.Post, 1),\n      comment1 = store.find(App.Comment, 2),\n      comment2 = store.find(App.Comment, 3);\n\n  deepEqual(post.get('comments').toArray(), [comment1, comment2], \"precond - the post has has two child comments\");\n\n  comment1.set('post', null);\n  equal(comment1.get('post'), null, \"belongsTo relationship has been set to null\");\n  deepEqual(post.get('comments').toArray(), [ comment2 ], \"the post comments array should have the remaining comment\");\n});\n\ntest(\"When adding a record to a hasMany array, its belongsTo is set\", function() {\n  store.load(App.Post, { id: 1, title: \"parent\", comments: [2] });\n  store.load(App.Comment, { id: 2, body: \"child\", post: 1 });\n  store.load(App.Comment, { id: 3, body: \"child\" });\n\n  var post = store.find(App.Post, 1),\n      comment1 = store.find(App.Comment, 2),\n      comment2 = store.find(App.Comment, 3);\n\n  post.get('comments').addObject(comment2);\n  verifySynchronizedOneToMany(post, comment2, [comment1, comment2]);\n});\n\ntest(\"When removing a record from a hasMany array, its belongsTo is set to null\", function() {\n  store.load(App.Post, { id: 1, title: \"parent\", comments: [2, 3] });\n  store.load(App.Comment, { id: 2, body: \"child\", post: 1 });\n  store.load(App.Comment, { id: 3, body: \"child\", post: 1 });\n\n  var post = store.find(App.Post, 1),\n      comment1 = store.find(App.Comment, 2),\n      comment2 = store.find(App.Comment, 3);\n\n  post.get('comments').removeObject(comment1);\n  verifySynchronizedOneToMany(post, comment2);\n  equal(comment1.get('post'), null, \"belongsTo relationship has been set to null\");\n});\n\ntest(\"When adding a record to a hasMany array, it should be removed from its old hasMany array, if there was one\", function() {\n  store.load(App.Post, { id: 1, title: \"old parent\", comments: [3] });\n  store.load(App.Post, { id: 2, title: \"new parent\" });\n\n  store.load(App.Comment, { id: 3, body: \"child\", post: 1 });\n\n  var oldParent = store.find(App.Post, 1),\n      newParent = store.find(App.Post, 2),\n      child = store.find(App.Comment, 3);\n\n  verifySynchronizedOneToMany(oldParent, child);\n\n  newParent.get('comments').addObject(child);\n\n  deepEqual(oldParent.get('comments').toArray(), [], \"old parent has no child comments\");\n\n  verifySynchronizedOneToMany(newParent, child);\n});\n\ntest(\"When changing a record's belongsTo, it should be removed from its old inverse hasMany array, if there was one\", function() {\n  store.load(App.Post, { id: 1, title: \"old parent\", comments: [3] });\n  store.load(App.Post, { id: 2, title: \"new parent\" });\n\n  store.load(App.Comment, { id: 3, body: \"child\", post: 1 });\n\n  var oldParent = store.find(App.Post, 1),\n      newParent = store.find(App.Post, 2),\n      child = store.find(App.Comment, 3);\n\n  verifySynchronizedOneToMany(oldParent, child);\n\n  child.set('post', newParent);\n\n  deepEqual(oldParent.get('comments').toArray(), [], \"old parent has no child comments\");\n\n  verifySynchronizedOneToMany(newParent, child);\n});\n\ntest(\"Deleting a record removes it from any inverse hasMany arrays to which it belongs.\", function() {\n  var post, comment;\n\n  store.load(App.Post, { id: 1, title: \"parent\", comments: [1] });\n  store.load(App.Comment, { id: 1, title: \"parent\", post: 1 });\n\n  post = store.find(App.Post, 1);\n  comment = store.find(App.Comment, 1);\n\n  verifySynchronizedOneToMany(post, comment);\n\n  comment.deleteRecord();\n\n  equal(comment.get('post'), null, \"the comment should no longer belong to a post\");\n  deepEqual(post.get('comments').toArray(), [], \"the post should no longer have any comments\");\n});\n\ntest(\"Deleting a newly created record removes it from any inverse hasMany arrays to which it belongs.\", function() {\n  var post, comment;\n\n  store.load(App.Post, { id: 1, title: \"parent\" });\n\n  post = store.find(App.Post, 1);\n  comment = store.createRecord(App.Comment);\n\n  equal(comment.get('post'), null, \"precond - the child should not yet belong to anyone\");\n\n  post.get('comments').addObject(comment);\n\n  verifySynchronizedOneToMany(post, comment);\n\n  comment.deleteRecord();\n\n  equal(comment.get('post'), null, \"the comment should no longer belong to a post\");\n  deepEqual(post.get('comments').toArray(), [], \"the post should no longer have any comments\");\n});\n\n//test(\"When a record with a hasMany relationship is deleted, its associated record is materialized and its belongsTo is changed\", function() {\n  //store.load(App.Post, { id: 1, title: \"NEW! Ember Table\", comments: [ 2 ] });\n  //store.load(App.Comment, { id: 2, body: \"Needs more async\", post: 1 });\n\n  //// Only find the post, not the comment. This ensures\n  //// that the comment is not yet materialized.\n  //var post = store.find(App.Post, 1);\n  //var comment = store.find(App.Comment, 2);\n  //post.deleteRecord();\n\n  //// Now that we've deleted the post, we should materialize the\n  //// comment and ensure that its inverse relationship has been\n  //// modified appropriately (i.e., set to null)\n  //equal(comment.get('post'), null, \"the comment's post belongsTo relationship was set to null\");\n//});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/relationships/one_to_many_relationships_test");minispade.register('ember-data/~tests/integration/relationships/one_to_none_relationships_test', "(function() {var get = Ember.get, set = Ember.set;\n\nvar store, adapter, App, Post, Comment;\n\nmodule(\"One-to-None Relationships\", {\n  setup: function() {\n    adapter = DS.Adapter.create();\n\n    store = DS.Store.create({\n      isDefaultStore: true,\n      adapter: adapter\n    });\n\n    App = Ember.Namespace.create({\n      toString: function() { return \"App\"; }\n    });\n\n    App.Post = DS.Model.extend({\n      title: DS.attr('string')\n    });\n\n    App.Comment = DS.Model.extend({\n      body: DS.attr('string'),\n      post: DS.belongsTo(App.Post)\n    });\n\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      store.destroy();\n    });\n  }\n});\n\nfunction verifySynchronizedOneToMany(post, comment, expectedHasMany) {\n  expectedHasMany = expectedHasMany || [comment];\n  equal(comment.get('post'), post);\n  deepEqual(post.get('comments').toArray(), expectedHasMany);\n}\n\ntest(\"Setting a record's belongsTo relationship to another record, should work\", function() {\n  store.load(App.Post, { id: 1, title: \"parent\" });\n  store.load(App.Comment, { id: 2, body: \"child\" });\n\n  var post = store.find(App.Post, 1),\n      comment = store.find(App.Comment, 2);\n\n  comment.set('post', post);\n  deepEqual(comment.get('post'), post, \"comment should have the correct post set\");\n});\n\ntest(\"Setting a record's belongsTo relationship to null should work\", function() {\n  store.load(App.Post, { id: 1, title: \"parent\", comments: [2, 3] });\n  store.load(App.Comment, { id: 2, body: \"child\", post: 1 });\n  store.load(App.Comment, { id: 3, body: \"child\", post: 1 });\n\n  var post = store.find(App.Post, 1),\n      comment1 = store.find(App.Comment, 2),\n      comment2 = store.find(App.Comment, 3);\n\n  comment1.set('post', null);\n  equal(comment1.get('post'), null, \"belongsTo relationship has been set to null\");\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/relationships/one_to_none_relationships_test");minispade.register('ember-data/~tests/integration/relationships/one_to_one_relationships_test', "(function() {var get = Ember.get, set = Ember.set;\n\nvar store, adapter, App, Post, Comment;\n\nmodule(\"One-to-One Relationships\", {\n  setup: function() {\n    adapter = DS.Adapter.create();\n\n    store = DS.Store.create({\n      isDefaultStore: true,\n      adapter: adapter\n    });\n\n    App = Ember.Namespace.create({\n      toString: function() { return \"App\"; }\n    });\n\n    App.Post = DS.Model.extend({\n      title: DS.attr('string')\n    });\n\n    App.Comment = DS.Model.extend({\n      body: DS.attr('string'),\n      post: DS.belongsTo(App.Post)\n    });\n\n    App.Post.reopen({\n      comment: DS.belongsTo(App.Comment)\n    });\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      store.destroy();\n    });\n  }\n});\n\nfunction verifySynchronizedOneToOne(post, comment, expectedHasMany) {\n  equal(comment.get('post'), post);\n  equal(post.get('comment'), comment);\n}\n\ntest(\"When setting a record's belongsTo relationship to another record, that record should be added to the inverse belongsTo\", function() {\n  store.load(App.Post, { id: 1, title: \"parent\" });\n  store.load(App.Comment, { id: 2, body: \"child\" });\n\n  var post = store.find(App.Post, 1),\n      comment = store.find(App.Comment, 2);\n\n  comment.set('post', post);\n  verifySynchronizedOneToOne(post, comment);\n});\n/*\ntest(\"When setting a record's belongsTo relationship to null, that record should be removed from the inverse hasMany array\", function() {\n  store.load(App.Post, { id: 1, title: \"parent\", comments: [2, 3] });\n  store.load(App.Comment, { id: 2, body: \"child\", post: 1 });\n  store.load(App.Comment, { id: 3, body: \"child\", post: 1 });\n\n  var post = store.find(App.Post, 1),\n      comment1 = store.find(App.Comment, 2),\n      comment2 = store.find(App.Comment, 3);\n\n  deepEqual(post.get('comments').toArray(), [comment1, comment2], \"precond - the post has has two child comments\");\n\n  comment1.set('post', null);\n  equal(comment1.get('post'), null, \"belongsTo relationship has been set to null\");\n  deepEqual(post.get('comments').toArray(), [ comment2 ], \"the post comments array should have the remaining comment\");\n});\n\ntest(\"When adding a record to a hasMany array, its belongsTo is set\", function() {\n  store.load(App.Post, { id: 1, title: \"parent\", comments: [2] });\n  store.load(App.Comment, { id: 2, body: \"child\", post: 1 });\n  store.load(App.Comment, { id: 3, body: \"child\" });\n\n  var post = store.find(App.Post, 1),\n      comment1 = store.find(App.Comment, 2),\n      comment2 = store.find(App.Comment, 3);\n\n  post.get('comments').addObject(comment2);\n  verifySynchronizedOneToMany(post, comment2, [comment1, comment2]);\n});\n\ntest(\"When removing a record from a hasMany array, its belongsTo is set to null\", function() {\n  store.load(App.Post, { id: 1, title: \"parent\", comments: [2, 3] });\n  store.load(App.Comment, { id: 2, body: \"child\", post: 1 });\n  store.load(App.Comment, { id: 3, body: \"child\", post: 1 });\n\n  var post = store.find(App.Post, 1),\n      comment1 = store.find(App.Comment, 2),\n      comment2 = store.find(App.Comment, 3);\n\n  post.get('comments').removeObject(comment1);\n  verifySynchronizedOneToMany(post, comment2);\n  equal(comment1.get('post'), null, \"belongsTo relationship has been set to null\");\n});\n\ntest(\"When adding a record to a hasMany array, it should be removed from its old hasMany array, if there was one\", function() {\n  store.load(App.Post, { id: 1, title: \"old parent\", comments: [3] });\n  store.load(App.Post, { id: 2, title: \"new parent\" });\n\n  store.load(App.Comment, { id: 3, body: \"child\", post: 1 });\n\n  var oldParent = store.find(App.Post, 1),\n      newParent = store.find(App.Post, 2),\n      child = store.find(App.Comment, 3);\n\n  verifySynchronizedOneToMany(oldParent, child);\n\n  newParent.get('comments').addObject(child);\n\n  deepEqual(oldParent.get('comments').toArray(), [], \"old parent has no child comments\");\n\n  verifySynchronizedOneToMany(newParent, child);\n});\n\ntest(\"When changing a record's belongsTo, it should be removed from its old inverse hasMany array, if there was one\", function() {\n  store.load(App.Post, { id: 1, title: \"old parent\", comments: [3] });\n  store.load(App.Post, { id: 2, title: \"new parent\" });\n\n  store.load(App.Comment, { id: 3, body: \"child\", post: 1 });\n\n  var oldParent = store.find(App.Post, 1),\n      newParent = store.find(App.Post, 2),\n      child = store.find(App.Comment, 3);\n\n  verifySynchronizedOneToMany(oldParent, child);\n\n  child.set('post', newParent);\n\n  deepEqual(oldParent.get('comments').toArray(), [], \"old parent has no child comments\");\n\n  verifySynchronizedOneToMany(newParent, child);\n});\n\ntest(\"Deleting a record removes it from any inverse hasMany arrays to which it belongs.\", function() {\n  var post, comment;\n\n  store.load(App.Post, { id: 1, title: \"parent\", comments: [1] });\n  store.load(App.Comment, { id: 1, title: \"parent\", post: 1 });\n\n  post = store.find(App.Post, 1);\n  comment = store.find(App.Comment, 1);\n\n  verifySynchronizedOneToMany(post, comment);\n\n  comment.deleteRecord();\n\n  equal(comment.get('post'), null, \"the comment should no longer belong to a post\");\n  deepEqual(post.get('comments').toArray(), [], \"the post should no longer have any comments\");\n});\n\ntest(\"Deleting a newly created record removes it from any inverse hasMany arrays to which it belongs.\", function() {\n  var post, comment;\n\n  store.load(App.Post, { id: 1, title: \"parent\" });\n\n  post = store.find(App.Post, 1);\n  comment = store.createRecord(App.Comment);\n\n  equal(comment.get('post'), null, \"precond - the child should not yet belong to anyone\");\n\n  post.get('comments').addObject(comment);\n\n  verifySynchronizedOneToMany(post, comment);\n\n  comment.deleteRecord();\n\n  equal(comment.get('post'), null, \"the comment should no longer belong to a post\");\n  deepEqual(post.get('comments').toArray(), [], \"the post should no longer have any comments\");\n});\n\n//test(\"When a record with a hasMany association is deleted, its associated record is materialized and its belongsTo is changed\", function() {\n  //store.load(App.Post, { id: 1, title: \"NEW! Ember Table\", comments: [ 2 ] });\n  //store.load(App.Comment, { id: 2, body: \"Needs more async\", post: 1 });\n\n  //// Only find the post, not the comment. This ensures\n  //// that the comment is not yet materialized.\n  //var post = store.find(App.Post, 1);\n  //var comment = store.find(App.Comment, 2);\n  //post.deleteRecord();\n\n  //// Now that we've deleted the post, we should materialize the\n  //// comment and ensure that its inverse relationship has been\n  //// modified appropriately (i.e., set to null)\n  //equal(comment.get('post'), null, \"the comment's post belongsTo relationship was set to null\");\n//});\n*/\n\n})();\n//@ sourceURL=ember-data/~tests/integration/relationships/one_to_one_relationships_test");minispade.register('ember-data/~tests/integration/reload_test', "(function() {var get = Ember.get, set = Ember.set;\nvar Person, store, adapter;\n\nmodule(\"Reloading Records\", {\n  setup: function() {\n    Person = DS.Model.extend({\n      updatedAt: DS.attr('string'),\n      name: DS.attr('string'),\n      firstName: DS.attr('string'),\n      lastName: DS.attr('string')\n    });\n\n    Person.toString = function() { return \"Person\"; };\n\n    adapter = DS.Adapter.create();\n    store = DS.Store.create({ adapter: adapter });\n  },\n\n  teardown: function() {\n    adapter.destroy();\n    store.destroy();\n  }\n});\n\nasyncTest(\"When a single record is requested, the adapter's find method should be called unless it's loaded.\", function() {\n  expect(5);\n\n  var count = 0;\n\n  adapter.find = function(store, type, id) {\n    if (count === 0) {\n      setTimeout(function() {\n        adapter.didFindRecord(store, type, { person: { name: \"Tom Dale\" } }, id);\n        firstFound();\n      });\n      count++;\n    } else if (count === 1) {\n      setTimeout(function() {\n        adapter.didFindRecord(store, type, { person: { name: \"Braaaahm Dale\" } }, id);\n        secondFound();\n      });\n      count++;\n    } else {\n      ok(false, \"Should not get here\");\n    }\n  };\n\n  var person = store.find(Person, 1);\n\n  var waitingFor = 2;\n\n  function done() {\n    if (--waitingFor === 0) { start(); }\n  }\n\n  function firstFound() {\n    equal(get(person, 'name'), \"Tom Dale\", \"The person is loaded with the right name\");\n    equal(get(person, 'isLoaded'), true, \"The person is now loaded\");\n    person.one('didReload', done);\n    person.reload();\n    equal(get(person, 'isReloading'), true, \"The person is now reloading\");\n  }\n\n  function secondFound() {\n    done();\n    equal(get(person, 'isReloading'), false, \"The person is no longer reloading\");\n    equal(get(person, 'name'), \"Braaaahm Dale\", \"The person is now updated with the right name\");\n  }\n});\n\nasyncTest(\"If a record is modified, it cannot be reloaded\", function() {\n  var count = 0;\n\n  adapter.find = function(store, type, id) {\n    if (count === 0) {\n      setTimeout(function() {\n        adapter.didFindRecord(store, type, { person: { name: \"Tom Dale\" } }, id);\n        found();\n      });\n      count++;\n    } else {\n      ok(false, \"Should not get here\");\n    }\n  };\n\n  var person = store.find(Person, 1);\n\n  function found() {\n    start();\n    set(person, 'name', \"Braaaaahm Dale\");\n\n    raises(function() {\n      person.reload();\n    }, /uncommitted/);\n  }\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/reload_test");minispade.register('ember-data/~tests/integration/rest_adapter_test', "(function() {var store, adapter, Post, Comment;\n\nmodule(\"REST Adapter\") ;\n\n//test(\"changing A=>null=>A should clean up the record\", function() {\n  //var store = DS.Store.create({\n    //adapter: DS.RESTAdapter\n  //});\n  //var Kidney = DS.Model.extend();\n  //var Person = DS.Model.extend();\n\n  //Kidney.reopen({\n    //person: DS.belongsTo(Person)\n  //});\n  //Kidney.toString = function() { return \"Kidney\"; };\n\n  //Person.reopen({\n    //name: DS.attr('string'),\n    //kidneys: DS.hasMany(Kidney)\n  //});\n  //Person.toString = function() { return \"Person\"; };\n\n  //store.load(Person, { id: 1, kidneys: [1, 2] });\n  //store.load(Kidney, { id: 1, person: 1 });\n  //store.load(Kidney, { id: 2, person: 1 });\n\n  //var person = store.find(Person, 1);\n  //var kidney1 = store.find(Kidney, 1);\n  //var kidney2 = store.find(Kidney, 2);\n\n  //deepEqual(person.get('kidneys').toArray(), [kidney1, kidney2], \"precond - person should have both kidneys\");\n  //equal(kidney1.get('person'), person, \"precond - first kidney should be in the person\");\n\n  //person.get('kidneys').removeObject(kidney1);\n\n  //ok(person.get('isDirty'), \"precond - person should be dirty after operation\");\n  //ok(kidney1.get('isDirty'), \"precond - first kidney should be dirty after operation\");\n\n  //deepEqual(person.get('kidneys').toArray(), [kidney2], \"precond - person should have only the second kidney\");\n  //equal(kidney1.get('person'), null, \"precond - first kidney should be on the operating table\");\n\n  //person.get('kidneys').addObject(kidney1);\n\n  //ok(!person.get('isDirty'), \"person should be clean after restoration\");\n  //ok(!kidney1.get('isDirty'), \"first kidney should be clean after restoration\");\n\n  //deepEqual(person.get('kidneys').toArray(), [kidney2, kidney1], \"person should have both kidneys again\");\n  //equal(kidney1.get('person'), person, \"first kidney should be in the person again\");\n//});\n\n//test(\"changing A=>B=>A should clean up the record\", function() {\n  //var store = DS.Store.create({\n    //adapter: DS.RESTAdapter\n  //});\n  //var Kidney = DS.Model.extend();\n  //var Person = DS.Model.extend();\n\n  //Kidney.reopen({\n    //person: DS.belongsTo(Person)\n  //});\n  //Kidney.toString = function() { return \"Kidney\"; };\n\n  //Person.reopen({\n    //name: DS.attr('string'),\n    //kidneys: DS.hasMany(Kidney)\n  //});\n  //Person.toString = function() { return \"Person\"; };\n\n  //store.load(Person, { person: { id: 1, name: \"John Doe\", kidneys: [1, 2] }});\n  //store.load(Person, { person: { id: 2, name: \"Jane Doe\", kidneys: [3]} });\n  //store.load(Kidney, { kidney: { id: 1, person_id: 1 } });\n  //store.load(Kidney, { kidney: { id: 2, person_id: 1 } });\n  //store.load(Kidney, { kidney: { id: 3, person_id: 2 } });\n\n  //var john = store.find(Person, 1);\n  //var jane = store.find(Person, 2);\n  //var kidney1 = store.find(Kidney, 1);\n  //var kidney2 = store.find(Kidney, 2);\n  //var kidney3 = store.find(Kidney, 3);\n\n  //deepEqual(john.get('kidneys').toArray(), [kidney1, kidney2], \"precond - john should have the first two kidneys\");\n  //deepEqual(jane.get('kidneys').toArray(), [kidney3], \"precond - jane should have the third kidney\");\n  //equal(kidney2.get('person'), john, \"precond - second kidney should be in john\");\n\n  //kidney2.set('person', jane);\n\n  //ok(john.get('isDirty'), \"precond - john should be dirty after operation\");\n  //ok(jane.get('isDirty'), \"precond - jane should be dirty after operation\");\n  //ok(kidney2.get('isDirty'), \"precond - second kidney should be dirty after operation\");\n\n  //deepEqual(john.get('kidneys').toArray(), [kidney1], \"precond - john should have only the first kidney\");\n  //deepEqual(jane.get('kidneys').toArray(), [kidney3, kidney2], \"precond - jane should have the other two kidneys\");\n  //equal(kidney2.get('person'), jane, \"precond - second kidney should be in jane\");\n\n  //kidney2.set('person', john);\n\n  //ok(!john.get('isDirty'), \"john should be clean after restoration\");\n  //ok(!jane.get('isDirty'), \"jane should be clean after restoration\");\n  //ok(!kidney2.get('isDirty'), \"second kidney should be clean after restoration\");\n\n  //deepEqual(john.get('kidneys').toArray(), [kidney1, kidney2], \"john should have the first two kidneys again\");\n  //deepEqual(jane.get('kidneys').toArray(), [kidney3], \"jane should have the third kidney again\");\n  //equal(kidney2.get('person'), john, \"second kidney should be in john again\");\n//});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/rest_adapter_test");minispade.register('ember-data/~tests/integration/rollback_test', "(function() {var store, Comment, Post;\n\nmodule(\"Transaction Rollback\", {\n  setup: function() {\n    store = DS.Store.create({ adapter: 'DS.Adapter' });\n\n    Post = DS.Model.extend({\n      title: DS.attr('string')\n    });\n\n    Post.toString = function() { return \"Post\"; };\n\n    Comment = DS.Model.extend({\n      title: DS.attr('string'),\n      post: DS.belongsTo(Post)\n    });\n\n    Comment.toString = function() { return \"Comment\"; };\n\n    Post.reopen({\n      comments: DS.hasMany(Comment)\n    });\n  },\n\n  teardown: function() {\n    store.destroy();\n  }\n});\n\n// Loaded Records\n\nvar testSetAndRollback = function(record, property, newValue, callback) {\n  var oldValue = record.get(property);\n\n  var transaction = store.transaction();\n  transaction.add(record);\n\n  ok(!record.get('isDirty'), \"precond - record should not yet be dirty\");\n\n  record.set(property, newValue);\n\n  ok(record.get('isDirty'), \"precond - record should be dirty after change\");\n  equal(record.get(property), newValue, \"precond - property reflects changed value\");\n\n  transaction.rollback();\n\n  ok(!record.get('isDirty'), \"record is not dirty after rollback\");\n\n  equal(record.get(property), oldValue, \"property is rolled back to original value\");\n  if (callback) { callback(); }\n};\n\ntest(\"A loaded record in a transaction with changed attributes should revert to the old attributes when the transaction is rolled back.\", function() {\n  store.load(Post, { id: 1, title: \"My Darkest Node.js Fantasies\" });\n\n  var post = store.find(Post, 1);\n\n  testSetAndRollback(post, 'title', \"Developing Interplanetary-Scale Apps\");\n});\n\ntest(\"A loaded record that is deleted and then rolled back is not dirty.\", function() {\n  store.load(Post, { id: 1, title: \"MongoDB on Mars\" });\n\n  var post = store.find(Post, 1);\n  var transaction = store.transaction();\n\n  transaction.add(post);\n\n  post.deleteRecord();\n  ok(post.get('isDirty'), \"record is dirty\");\n  ok(post.get('isDeleted'), \"record is deleted\");\n\n  transaction.rollback();\n  ok(!post.get('isDirty'), \"record is not dirty\");\n  ok(!post.get('isDeleted'), \"record is not deleted\");\n});\n\n// UPDATED\n\ntest(\"A loaded record in a transaction with a changed belongsTo should revert to the old relationship when the transaction is rolled back. (A=>null)\", function() {\n  store.load(Post, { id: 1, title: \"My Darkest Node.js Fantasies\", comments: [ 1, 2 ] });\n  store.load(Comment, { id: 1, title: \"I don't see the appeal of Rails these days when Node.js and Django are both as mature and inherently more scalable than Rails\", post: 1 });\n  store.load(Comment, { id: 2, title: \"I was skeptical about http://App.net before I paid the $$, but now I am all excited about it.\", post: 1 });\n\n  var post = store.find(Post, 1);\n  var comment1 = store.find(Comment, 1);\n  var comment2 = store.find(Comment, 2);\n\n  var oldValue = comment1.get('post');\n\n  var transaction = store.transaction();\n  transaction.add(post);\n\n  ok(!post.get('isDirty'), \"precond - record should not yet be dirty\");\n  ok(!comment1.get('isDirty'), \"precond - record should not yet be dirty\");\n\n  comment1.set('post', null);\n\n  ok(post.get('isDirty'), \"precond - record should be dirty after change\");\n  ok(comment1.get('isDirty'), \"precond - record should be dirty after change\");\n\n  equal(comment1.get('post'), null, \"precond - property reflects changed value\");\n  deepEqual(post.get('comments').toArray(), [ comment2 ], \"precond - property reflects changed value\");\n\n  transaction.rollback();\n\n  ok(!post.get('isDirty'), \"record should not be dirty after rollback\");\n  ok(!comment1.get('isDirty'), \"record should not be dirty after rollback\");\n\n  equal(comment1.get('post'), post, \"property is rolled back to its original value\");\n  deepEqual(post.get('comments').toArray(), [ comment1, comment2 ], \"property is rolled back to its original value\");\n});\n\ntest(\"A loaded record in a transaction with a changed belongsTo should revert to the old relationship when the transaction is rolled back. (null=>A)\", function() {\n  store.load(Post, { id: 1, title: \"My Darkest Node.js Fantasies\" });\n  store.load(Comment, { id: 1, title: \"I don't see the appeal of Rails these days when Node.js and Django are both as mature and inherently more scalable than Rails\" });\n  store.load(Comment, { id: 2, title: \"I was skeptical about http://App.net before I paid the $$, but now I am all excited about it.\" });\n\n  var post = store.find(Post, 1);\n  var comment1 = store.find(Comment, 1);\n  var comment2 = store.find(Comment, 2);\n\n  var oldValue = comment1.get('post');\n\n  equal(oldValue, null, \"precond - the original value is null\");\n  deepEqual(post.get('comments').toArray(), [ ], \"precond - the original value is an empty array\");\n\n  var transaction = store.transaction();\n  transaction.add(post);\n\n  ok(!post.get('isDirty'), \"precond - record should not yet be dirty\");\n  ok(!comment1.get('isDirty'), \"precond - record should not yet be dirty\");\n\n  comment1.set('post', post);\n\n  ok(post.get('isDirty'), \"precond - record should be dirty after change\");\n  ok(comment1.get('isDirty'), \"precond - record should be dirty after change\");\n\n  equal(comment1.get('post'), post, \"precond - property reflects changed value\");\n  deepEqual(post.get('comments').toArray(), [ comment1 ], \"precond - property reflects changed value\");\n\n  transaction.rollback();\n\n  ok(!post.get('isDirty'), \"record should not be dirty after rollback\");\n  ok(!comment1.get('isDirty'), \"record should not be dirty after rollback\");\n\n  equal(comment1.get('post'), null, \"property is rolled back to its original value\");\n  deepEqual(post.get('comments').toArray(), [ ], \"property is rolled back to its original value\");\n});\n\ntest(\"A loaded record in a transaction with a changed belongsTo should revert to the old relationship when the transaction is rolled back. (A=>B)\", function() {\n  store.load(Post, { id: 1, title: \"My Darkest Node.js Fantasies\", comments: [ 1, 2 ] });\n  store.load(Post, { id: 2, title: \"VIM for iPad Best Practices\" });\n  store.load(Comment, { id: 1, title: \"I don't see the appeal of Rails these days when Node.js and Django are both as mature and inherently more scalable than Rails\", post: 1 });\n  store.load(Comment, { id: 2, title: \"I was skeptical about http://App.net before I paid the $$, but now I am all excited about it.\", post: 1 });\n\n  var post = store.find(Post, 1);\n  var post2 = store.find(Post, 2);\n  var comment1 = store.find(Comment, 1);\n  var comment2 = store.find(Comment, 2);\n\n  var oldValue = comment1.get('post');\n\n  equal(oldValue, post, \"precond - the original value is null\");\n  deepEqual(post.get('comments').toArray(), [ comment1, comment2 ], \"precond - the original value is a list of comments\");\n\n  var transaction = store.transaction();\n  transaction.add(post);\n\n  ok(!post.get('isDirty'), \"precond - record should not yet be dirty\");\n  ok(!comment1.get('isDirty'), \"precond - record should not yet be dirty\");\n\n  comment1.set('post', post2);\n\n  ok(post.get('isDirty'), \"precond - record should be dirty after change\");\n  ok(post2.get('isDirty'), \"precond - record should be dirty after change\");\n  ok(comment1.get('isDirty'), \"precond - record should be dirty after change\");\n\n  equal(comment1.get('post'), post2, \"precond - property reflects changed value\");\n  deepEqual(post.get('comments').toArray(), [ comment2 ], \"precond - property reflects changed value\");\n  deepEqual(post2.get('comments').toArray(), [ comment1 ], \"precond - property reflects changed value\");\n\n  transaction.rollback();\n\n  ok(!post.get('isDirty'), \"record should not be dirty after rollback\");\n  ok(!post2.get('isDirty'), \"record should not be dirty after rollback\");\n  ok(!comment1.get('isDirty'), \"record should not be dirty after rollback\");\n\n  equal(comment1.get('post'), post, \"property is rolled back to its original value\");\n  deepEqual(post.get('comments').toArray(), [ comment1, comment2 ], \"property is rolled back to its original value\");\n});\n\ntest(\"A loaded record in a transaction with a changed hasMany should revert to the old relationship when the transaction is rolled back. (A=>null)\", function() {\n  store.load(Post, { id: 1, title: \"My Darkest Node.js Fantasies\", comments: [ 1, 2 ] });\n  store.load(Comment, { id: 1, title: \"I don't see the appeal of Rails these days when Node.js and Django are both as mature and inherently more scalable than Rails\", post: 1 });\n  store.load(Comment, { id: 2, title: \"I was skeptical about http://App.net before I paid the $$, but now I am all excited about it.\", post: 1 });\n\n  var post = store.find(Post, 1);\n  var comment1 = store.find(Comment, 1);\n  var comment2 = store.find(Comment, 2);\n\n  var oldValue = comment1.get('post');\n\n  var transaction = store.transaction();\n  transaction.add(post);\n\n  ok(!post.get('isDirty'), \"precond - record should not yet be dirty\");\n  ok(!comment1.get('isDirty'), \"precond - record should not yet be dirty\");\n\n  post.get('comments').removeObject(comment1);\n\n  ok(post.get('isDirty'), \"precond - record should be dirty after change\");\n  ok(comment1.get('isDirty'), \"precond - record should be dirty after change\");\n\n  equal(comment1.get('post'), null, \"precond - property reflects changed value\");\n  deepEqual(post.get('comments').toArray(), [ comment2 ], \"precond - property reflects changed value\");\n\n  transaction.rollback();\n\n  ok(!post.get('isDirty'), \"record should not be dirty after rollback\");\n  ok(!comment1.get('isDirty'), \"record should not be dirty after rollback\");\n\n  equal(comment1.get('post'), post, \"property is rolled back to its original value\");\n  deepEqual(post.get('comments').toArray(), [ comment1, comment2 ], \"property is rolled back to its original value\");\n});\n\ntest(\"A loaded record in a transaction with a changed hasMany should revert to the old relationship when the transaction is rolled back. (null=>A)\", function() {\n  store.load(Post, { id: 1, title: \"My Darkest Node.js Fantasies\" });\n  store.load(Comment, { id: 1, title: \"I don't see the appeal of Rails these days when Node.js and Django are both as mature and inherently more scalable than Rails\" });\n  store.load(Comment, { id: 2, title: \"I was skeptical about http://App.net before I paid the $$, but now I am all excited about it.\" });\n\n  var post = store.find(Post, 1);\n  var comment1 = store.find(Comment, 1);\n  var comment2 = store.find(Comment, 2);\n\n  var oldValue = comment1.get('post');\n\n  equal(oldValue, null, \"precond - the original value is null\");\n  deepEqual(post.get('comments').toArray(), [ ], \"precond - the original value is an empty array\");\n\n  var transaction = store.transaction();\n  transaction.add(post);\n\n  ok(!post.get('isDirty'), \"precond - record should not yet be dirty\");\n  ok(!comment1.get('isDirty'), \"precond - record should not yet be dirty\");\n\n  post.get('comments').addObject(comment1);\n\n  ok(post.get('isDirty'), \"precond - record should be dirty after change\");\n  ok(comment1.get('isDirty'), \"precond - record should be dirty after change\");\n\n  equal(comment1.get('post'), post, \"precond - property reflects changed value\");\n  deepEqual(post.get('comments').toArray(), [ comment1 ], \"precond - property reflects changed value\");\n\n  transaction.rollback();\n\n  ok(!post.get('isDirty'), \"record should not be dirty after rollback\");\n  ok(!comment1.get('isDirty'), \"record should not be dirty after rollback\");\n\n  equal(comment1.get('post'), null, \"property is rolled back to its original value\");\n  deepEqual(post.get('comments').toArray(), [ ], \"property is rolled back to its original value\");\n});\n\ntest(\"A loaded record in a transaction with a changed hasMany should revert to the old relationship when the transaction is rolled back. (A=>B)\", function() {\n  store.load(Post, { id: 1, title: \"My Darkest Node.js Fantasies\", comments: [ 1, 2 ] });\n  store.load(Post, { id: 2, title: \"VIM for iPad Best Practices\" });\n  store.load(Comment, { id: 1, title: \"I don't see the appeal of Rails these days when Node.js and Django are both as mature and inherently more scalable than Rails\", post: 1 });\n  store.load(Comment, { id: 2, title: \"I was skeptical about http://App.net before I paid the $$, but now I am all excited about it.\", post: 1 });\n\n  var post = store.find(Post, 1);\n  var post2 = store.find(Post, 2);\n  var comment1 = store.find(Comment, 1);\n  var comment2 = store.find(Comment, 2);\n\n  var oldValue = comment1.get('post');\n\n  equal(oldValue, post, \"precond - the original value is null\");\n  deepEqual(post.get('comments').toArray(), [ comment1, comment2 ], \"precond - the original value is a list of comments\");\n\n  var transaction = store.transaction();\n  transaction.add(post);\n\n  ok(!post.get('isDirty'), \"precond - record should not yet be dirty\");\n  ok(!comment1.get('isDirty'), \"precond - record should not yet be dirty\");\n\n  post.get('comments').removeObject(comment1);\n  post2.get('comments').addObject(comment1);\n\n  ok(post.get('isDirty'), \"precond - record should be dirty after change\");\n  ok(post2.get('isDirty'), \"precond - record should be dirty after change\");\n  ok(comment1.get('isDirty'), \"precond - record should be dirty after change\");\n\n  equal(comment1.get('post'), post2, \"precond - property reflects changed value\");\n  deepEqual(post.get('comments').toArray(), [ comment2 ], \"precond - property reflects changed value\");\n  deepEqual(post2.get('comments').toArray(), [ comment1 ], \"precond - property reflects changed value\");\n\n  transaction.rollback();\n\n  ok(!post.get('isDirty'), \"record should not be dirty after rollback\");\n  ok(!post2.get('isDirty'), \"record should not be dirty after rollback\");\n  ok(!comment1.get('isDirty'), \"record should not be dirty after rollback\");\n\n  equal(comment1.get('post'), post, \"property is rolled back to its original value\");\n  deepEqual(post.get('comments').toArray(), [ comment1, comment2 ], \"property is rolled back to its original value\");\n});\n\ntest(\"A loaded record in a transaction with a changed hasMany (without first removing) should revert to the old relationship when the transaction is rolled back. (A=>B)\", function() {\n  store.load(Post, { id: 1, title: \"My Darkest Node.js Fantasies\", comments: [ 1, 2 ] });\n  store.load(Post, { id: 2, title: \"VIM for iPad Best Practices\" });\n  store.load(Comment, { id: 1, title: \"I don't see the appeal of Rails these days when Node.js and Django are both as mature and inherently more scalable than Rails\", post: 1 });\n  store.load(Comment, { id: 2, title: \"I was skeptical about http://App.net before I paid the $$, but now I am all excited about it.\", post: 1 });\n\n  var post = store.find(Post, 1);\n  var post2 = store.find(Post, 2);\n  var comment1 = store.find(Comment, 1);\n  var comment2 = store.find(Comment, 2);\n\n  var oldValue = comment1.get('post');\n\n  equal(oldValue, post, \"precond - the original value is null\");\n  deepEqual(post.get('comments').toArray(), [ comment1, comment2 ], \"precond - the original value is a list of comments\");\n\n  var transaction = store.transaction();\n  transaction.add(post);\n\n  ok(!post.get('isDirty'), \"precond - record should not yet be dirty\");\n  ok(!comment1.get('isDirty'), \"precond - record should not yet be dirty\");\n\n  post2.get('comments').addObject(comment1);\n\n  ok(post.get('isDirty'), \"precond - record should be dirty after change\");\n  ok(post2.get('isDirty'), \"precond - record should be dirty after change\");\n  ok(comment1.get('isDirty'), \"precond - record should be dirty after change\");\n\n  equal(comment1.get('post'), post2, \"precond - property reflects changed value\");\n  deepEqual(post.get('comments').toArray(), [ comment2 ], \"precond - property reflects changed value\");\n  deepEqual(post2.get('comments').toArray(), [ comment1 ], \"precond - property reflects changed value\");\n\n  transaction.rollback();\n\n  ok(!post.get('isDirty'), \"record should not be dirty after rollback\");\n  ok(!post2.get('isDirty'), \"record should not be dirty after rollback\");\n  ok(!comment1.get('isDirty'), \"record should not be dirty after rollback\");\n\n  equal(comment1.get('post'), post, \"property is rolled back to its original value\");\n  deepEqual(post.get('comments').toArray(), [ comment1, comment2 ], \"property is rolled back to its original value\");\n});\n\n// CREATED - Changing belongsTo\n\ntest(\"A created record in a transaction with a changed belongsTo (child is newly created, but parent is not) should revert to the old relationship when the transaction is rolled back. (null=>A)\", function() {\n  store.load(Post, { id: 1, title: \"My Darkest Node.js Fantasies\", comments: [ 2 ] });\n  store.load(Comment, { id: 2, title: \"I don't see the appeal of Rails these days when Node.js and Django are both as mature and inherently more scalable than Rails\", post: 1 });\n\n  var transaction = store.transaction();\n\n  var post = store.find(Post, 1);\n  var comment1 = transaction.createRecord(Comment, { title: \"I don't see the appeal of Rails these days when Node.js and Django are both as mature and inherently more scalable than Rails\" });\n  var comment2 = store.find(Comment, 2);\n\n  var oldValue = comment1.get('post');\n\n  equal(oldValue, null, \"precond - the original value is null\");\n  deepEqual(post.get('comments').toArray(), [ comment2 ], \"precond - the original value is a list of comments\");\n\n  transaction.add(post);\n\n  comment1.set('post', post);\n  equal(comment1.get('post'), post, \"precond - the new value is the post\");\n  deepEqual(post.get('comments').toArray(), [ comment2, comment1 ], \"precond - the new value is a list of comments\");\n\n  ok(post.get('isDirty'), \"precond - record should be dirty\");\n  ok(comment1.get('isDirty'), \"precond - record should be dirty\");\n\n  transaction.rollback();\n\n  ok(!post.get('isDirty'), \"record should not be dirty after rollback\");\n  ok(!comment1.get('isDirty'), \"record should not be dirty after rollback\");\n\n  equal(comment1.get('post'), null, \"property is rolled back to its original value\");\n  deepEqual(post.get('comments').toArray(), [ comment2 ], \"property is rolled back to its original value\");\n});\n\ntest(\"A loaded record in a transaction with a changed belongsTo (parent is newly created, but child is not) should revert to the old relationship when the transaction is rolled back. (null=>A)\", function() {\n  var transaction = store.transaction();\n\n  store.load(Comment, { id: 1, title: \"I don't see the appeal of Rails these days when Node.js and Django are both as mature and inherently more scalable than Rails\" });\n  store.load(Comment, { id: 2, title: \"I was skeptical about http://App.net before I paid the $$, but now I am all excited about it.\" });\n\n  var post = transaction.createRecord(Post, { title: \"My Darkest Node.js Fantasies\" });\n  var comment1 = store.find(Comment, 1);\n  var comment2 = store.find(Comment, 2);\n\n  var oldValue = comment1.get('post');\n\n  equal(oldValue, null, \"precond - the original value is null\");\n  deepEqual(post.get('comments').toArray(), [ ], \"precond - the original value is an empty array\");\n\n  ok(post.get('isDirty'), \"precond - record should be dirty\");\n  ok(!comment1.get('isDirty'), \"precond - record should not yet be dirty\");\n\n  comment1.set('post', post);\n\n  ok(post.get('isDirty'), \"precond - record should be dirty after change\");\n  ok(comment1.get('isDirty'), \"precond - record should be dirty after change\");\n\n  equal(comment1.get('post'), post, \"precond - property reflects changed value\");\n  deepEqual(post.get('comments').toArray(), [ comment1 ], \"precond - property reflects changed value\");\n\n  transaction.rollback();\n\n  ok(!post.get('isDirty'), \"record should not be dirty after rollback\");\n  ok(!comment1.get('isDirty'), \"record should not be dirty after rollback\");\n\n  equal(comment1.get('post'), null, \"property is rolled back to its original value\");\n  deepEqual(post.get('comments').toArray(), [ ], \"property is rolled back to its original value\");\n});\n\ntest(\"A loaded record in a transaction with a changed belongsTo (parent and child are both newly created) should revert to the old relationship when the transaction is rolled back. (A=>B)\", function() {\n  var transaction = store.transaction();\n\n  var post = transaction.createRecord(Post, { title: \"My Darkest Node.js Fantasies\" });\n  var comment1 = transaction.createRecord(Comment, { title: \"I don't see the appeal of Rails these days when Node.js and Django are both as mature and inherently more scalable than Rails\" });\n\n  var oldValue = comment1.get('post');\n\n  equal(oldValue, null, \"precond - the original value is null\");\n  deepEqual(post.get('comments').toArray(), [ ], \"precond - the original value is an empty list of comments\");\n\n  ok(post.get('isDirty'), \"precond - record should be dirty\");\n  ok(comment1.get('isDirty'), \"precond - record should be dirty\");\n\n  comment1.set('post', post);\n\n  ok(post.get('isDirty'), \"precond - record should be dirty after change\");\n  ok(comment1.get('isDirty'), \"precond - record should be dirty after change\");\n\n  equal(comment1.get('post'), post, \"precond - property reflects changed value\");\n  deepEqual(post.get('comments').toArray(), [ comment1 ], \"precond - property reflects changed value\");\n\n  transaction.rollback();\n\n  ok(!post.get('isDirty'), \"record should not be dirty after rollback\");\n  ok(!comment1.get('isDirty'), \"record should not be dirty after rollback\");\n\n  equal(comment1.get('post'), null, \"property is rolled back to its original value\");\n  deepEqual(post.get('comments').toArray(), [ ], \"property is rolled back to its original value\");\n});\n\n// CREATED - Changing hasMany\n\ntest(\"A created record in a transaction with a changed hasMany (child is newly created, but parent is not) should revert to the old relationship when the transaction is rolled back. (null=>A)\", function() {\n  store.load(Post, { id: 1, title: \"My Darkest Node.js Fantasies\", comments: [ 2 ] });\n  store.load(Comment, { id: 2, title: \"I don't see the appeal of Rails these days when Node.js and Django are both as mature and inherently more scalable than Rails\", post: 1 });\n\n  var transaction = store.transaction();\n\n  var post = store.find(Post, 1);\n  var comment1 = transaction.createRecord(Comment, { title: \"I don't see the appeal of Rails these days when Node.js and Django are both as mature and inherently more scalable than Rails\" });\n  var comment2 = store.find(Comment, 2);\n\n  var oldValue = comment1.get('post');\n\n  equal(oldValue, null, \"precond - the original value is null\");\n  deepEqual(post.get('comments').toArray(), [ comment2 ], \"precond - the original value is a list of comments\");\n\n  transaction.add(post);\n\n  post.get('comments').addObject(comment1);\n\n  equal(comment1.get('post'), post, \"precond - the new value is the post\");\n  deepEqual(post.get('comments').toArray(), [ comment2, comment1 ], \"precond - the new value is a list of comments\");\n\n  ok(post.get('isDirty'), \"precond - record should be dirty\");\n  ok(comment1.get('isDirty'), \"precond - record should be dirty\");\n\n  transaction.rollback();\n\n  ok(!post.get('isDirty'), \"record should not be dirty after rollback\");\n  ok(!comment1.get('isDirty'), \"record should not be dirty after rollback\");\n\n  equal(comment1.get('post'), null, \"property is rolled back to its original value\");\n  deepEqual(post.get('comments').toArray(), [ comment2 ], \"property is rolled back to its original value\");\n});\n\ntest(\"A created record in a transaction with a changed belongsTo (parent is newly created, but child is not) should revert to the old relationship when the transaction is rolled back. (null=>A)\", function() {\n  var transaction = store.transaction();\n\n  store.load(Comment, { id: 1, title: \"I don't see the appeal of Rails these days when Node.js and Django are both as mature and inherently more scalable than Rails\" });\n  store.load(Comment, { id: 2, title: \"I was skeptical about http://App.net before I paid the $$, but now I am all excited about it.\" });\n\n  var post = transaction.createRecord(Post, { title: \"My Darkest Node.js Fantasies\" });\n  var comment1 = store.find(Comment, 1);\n  var comment2 = store.find(Comment, 2);\n\n  var oldValue = comment1.get('post');\n\n  equal(oldValue, null, \"precond - the original value is null\");\n  deepEqual(post.get('comments').toArray(), [ ], \"precond - the original value is an empty array\");\n\n  ok(post.get('isDirty'), \"precond - record should be dirty\");\n  ok(!comment1.get('isDirty'), \"precond - record should not yet be dirty\");\n\n  post.get('comments').addObject(comment1);\n\n  ok(post.get('isDirty'), \"precond - record should be dirty after change\");\n  ok(comment1.get('isDirty'), \"precond - record should be dirty after change\");\n\n  equal(comment1.get('post'), post, \"precond - property reflects changed value\");\n  deepEqual(post.get('comments').toArray(), [ comment1 ], \"precond - property reflects changed value\");\n\n  transaction.rollback();\n\n  ok(!post.get('isDirty'), \"record should not be dirty after rollback\");\n  ok(!comment1.get('isDirty'), \"record should not be dirty after rollback\");\n\n  equal(comment1.get('post'), null, \"property is rolled back to its original value\");\n  deepEqual(post.get('comments').toArray(), [ ], \"property is rolled back to its original value\");\n});\n\ntest(\"A created record in a transaction with a changed belongsTo (parent and child are both newly created) should revert to the old relationship when the transaction is rolled back. (A=>B)\", function() {\n  var transaction = store.transaction();\n\n  var post = transaction.createRecord(Post, { title: \"My Darkest Node.js Fantasies\" });\n  var comment1 = transaction.createRecord(Comment, { title: \"I don't see the appeal of Rails these days when Node.js and Django are both as mature and inherently more scalable than Rails\" });\n\n  var oldValue = comment1.get('post');\n\n  equal(oldValue, null, \"precond - the original value is null\");\n  deepEqual(post.get('comments').toArray(), [ ], \"precond - the original value is an empty list of comments\");\n\n  ok(post.get('isDirty'), \"precond - record should be dirty\");\n  ok(comment1.get('isDirty'), \"precond - record should be dirty\");\n\n  post.get('comments').addObject(comment1);\n\n  ok(post.get('isDirty'), \"precond - record should be dirty after change\");\n  ok(comment1.get('isDirty'), \"precond - record should be dirty after change\");\n\n  equal(comment1.get('post'), post, \"precond - property reflects changed value\");\n  deepEqual(post.get('comments').toArray(), [ comment1 ], \"precond - property reflects changed value\");\n\n  transaction.rollback();\n\n  ok(!post.get('isDirty'), \"record should not be dirty after rollback\");\n  ok(!comment1.get('isDirty'), \"record should not be dirty after rollback\");\n\n  equal(comment1.get('post'), null, \"property is rolled back to its original value\");\n  deepEqual(post.get('comments').toArray(), [ ], \"property is rolled back to its original value\");\n});\n\n// DELETED\n\ntest(\"A deleted record should be restored to a hasMany relationship if the transaction is rolled back\", function() {\n  store.load(Post, { id: 1, title: \"My Darkest Node.js Fantasies\", comments: [ 1, 2 ] });\n  store.load(Comment, { id: 1, title: \"I don't see the appeal of Rails these days when Node.js and Django are both as mature and inherently more scalable than Rails\", post: 1 });\n  store.load(Comment, { id: 2, title: \"I was skeptical about http://App.net before I paid the $$, but now I am all excited about it.\", post: 1 });\n\n  var post = store.find(Post, 1);\n  var comment1 = store.find(Comment, 1);\n  var comment2 = store.find(Comment, 2);\n\n  var oldValue = comment1.get('post');\n\n  var transaction = store.transaction();\n  transaction.add(post);\n  transaction.add(comment1);\n\n  ok(!post.get('isDirty'), \"precond - record should not yet be dirty\");\n  ok(!comment1.get('isDirty'), \"precond - record should not yet be dirty\");\n\n  comment1.deleteRecord();\n\n  ok(post.get('isDirty'), \"precond - record should be dirty after change\");\n  ok(comment1.get('isDirty'), \"precond - record should be dirty after change\");\n\n  equal(comment1.get('post'), null, \"precond - property reflects changed value\");\n  deepEqual(post.get('comments').toArray(), [ comment2 ], \"precond - deleted record is removed from parent's hasMany\");\n\n  transaction.rollback();\n\n  ok(!post.get('isDirty'), \"record should not be dirty after rollback\");\n  ok(!comment1.get('isDirty'), \"record should not be dirty after rollback\");\n\n  equal(comment1.get('post'), post, \"property is rolled back to its original value\");\n  deepEqual(post.get('comments').toArray(), [ comment1, comment2 ], \"property is rolled back to its original value\");\n});\n\ntest(\"A deleted record should be restored to a belongsTo relationship if the transaction is rolled back\", function() {\n  store.load(Post, { id: 1, title: \"My Darkest Node.js Fantasies\", comments: [ 1 ] });\n  store.load(Comment, { id: 1, title: \"I don't see the appeal of Rails these days when Node.js and Django are both as mature and inherently more scalable than Rails\", post: 1 });\n\n  var post = store.find(Post, 1);\n  var comment1 = store.find(Comment, 1);\n\n  var oldValue = comment1.get('post');\n\n  var transaction = store.transaction();\n  transaction.add(post);\n\n  ok(!post.get('isDirty'), \"precond - record should not yet be dirty\");\n  ok(!comment1.get('isDirty'), \"precond - record should not yet be dirty\");\n\n  post.deleteRecord();\n\n  ok(post.get('isDirty'), \"precond - record should be dirty after change\");\n  ok(comment1.get('isDirty'), \"precond - record should be dirty after change\");\n\n  equal(comment1.get('post'), null, \"precond - property reflects changed value\");\n  deepEqual(post.get('comments').toArray(), [ ], \"precond - deleted record is removed from parent's hasMany\");\n\n  transaction.rollback();\n\n  ok(!post.get('isDirty'), \"record should not be dirty after rollback\");\n  ok(!comment1.get('isDirty'), \"record should not be dirty after rollback\");\n\n  equal(comment1.get('post'), post, \"property is rolled back to its original value\");\n  deepEqual(post.get('comments').toArray(), [ comment1 ], \"property is rolled back to its original value\");\n});\n\ntest(\"A deleted record should be restored to a belongsTo relationship if the transaction is rolled back\", function() {\n  store.load(Post, { id: 1, title: \"My Darkest Node.js Fantasies\", comments: [ 1 ] });\n  store.load(Comment, { id: 1, title: \"I don't see the appeal of Rails these days when Node.js and Django are both as mature and inherently more scalable than Rails\", post: 1 });\n\n  var post = store.find(Post, 1);\n  var comment1 = store.find(Comment, 1);\n\n  var oldValue = comment1.get('post');\n\n  var transaction = store.transaction();\n  transaction.add(post);\n  transaction.add(comment1);\n\n  ok(!post.get('isDirty'), \"precond - record should not yet be dirty\");\n  ok(!comment1.get('isDirty'), \"precond - record should not yet be dirty\");\n\n  post.deleteRecord();\n  comment1.deleteRecord();\n\n  ok(post.get('isDirty'), \"precond - record should be dirty after change\");\n  ok(comment1.get('isDirty'), \"precond - record should be dirty after change\");\n\n  equal(comment1.get('post'), null, \"precond - property reflects changed value\");\n  deepEqual(post.get('comments').toArray(), [ ], \"precond - deleted record is removed from parent's hasMany\");\n\n  transaction.rollback();\n\n  ok(!post.get('isDirty'), \"record should not be dirty after rollback\");\n  ok(!comment1.get('isDirty'), \"record should not be dirty after rollback\");\n\n  equal(comment1.get('post'), post, \"property is rolled back to its original value\");\n  deepEqual(post.get('comments').toArray(), [ comment1 ], \"property is rolled back to its original value\");\n});\n\n//test(\"A deleted record in a transaction with changed attributes should revert to the old attributes when the transaction is rolled back.\");\n//test(\"A deleted record in a transaction with a changed belongsTo should revert to the old relationship when the transaction is rolled back.\");\n//test(\"A deleted record in a transaction with a changed hasMany should revert to the old relationship when the transaction is rolled back.\");\n\n})();\n//@ sourceURL=ember-data/~tests/integration/rollback_test");minispade.register('ember-data/~tests/integration/store_adapter_test', "(function() {/**\n This is an integration test that tests the communication between a store\n and its adapter.\n\n Typically, when a method is invoked on the store, it calls a related\n method on its adapter. The adapter notifies the store that it has\n completed the assigned task, either synchronously or asynchronously,\n by calling a method on the store.\n\n These tests ensure that the proper methods get called, and, if applicable,\n the given record orrecord arrayay changes state appropriately.\n*/\n\nvar get = Ember.get, set = Ember.set;\nvar Person, store, adapter;\n\nmodule(\"DS.Store and DS.Adapter integration test\", {\n  setup: function() {\n    var App = Ember.Namespace.create({ name: \"App\" });\n\n    App.Person = Person = DS.Model.extend({\n      updatedAt: DS.attr('string'),\n      name: DS.attr('string'),\n      firstName: DS.attr('string'),\n      lastName: DS.attr('string')\n    });\n\n    adapter = DS.Adapter.create();\n    store = DS.Store.create({ adapter: adapter });\n  },\n\n  teardown: function() {\n    adapter.destroy();\n    store.destroy();\n  }\n});\n\n\nasyncTest(\"Records loaded multiple times and retrieved in recordArray are ready to send state events\", function() {\n\n  adapter.findQuery = function(store, type, query, recordArray) {\n    var self = this;\n\n    setTimeout(function() {\n      Ember.run(function() {\n        \n        // use different recordArray based on the call\n        var recordArray = (!!people2) ? people2 : people;\n\n        self.didFindQuery(store, type, {\n          persons: [{\n            id: 1,\n            name: \"Mickael Ramírez\"\n          }, {\n            id: 2,\n            name: \"Johny Fontana\"\n          }]\n        }, recordArray);\n\n      });\n\n    });\n  };\n\n  var people, people2;\n  people = store.findQuery(Person, {q: 'bla'});\n  people.one('didLoad', function() {\n\n    people2 = store.findQuery(Person, {q: 'bla2'});\n    people2.one('didLoad', function() {\n\n      start();\n      expect(3);\n\n      equal( people2.get('length'), 2, 'return the elements' );\n      ok( people2.get('isLoaded'), 'array is loaded' );\n\n      var person = people.objectAt(0);\n      ok( person.get('isLoaded'), 'record is loaded' );\n      // delete record will not throw exception\n      person.deleteRecord();\n\n\n    });\n  });\n\n});\n\ntest(\"by default, createRecords calls createRecord once per record\", function() {\n  expect(8);\n  var count = 1;\n\n  adapter.createRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n\n    if (count === 1) {\n      equal(get(record, 'name'), \"Tom Dale\");\n    } else if (count === 2) {\n      equal(get(record, 'name'), \"Yehuda Katz\");\n    } else {\n      ok(false, \"should not have invoked more than 2 times\");\n    }\n\n    var hash = get(record, 'data');\n    hash.id = count;\n    hash.updatedAt = \"now\";\n\n    store.didSaveRecord(record, hash);\n    equal(get(record, 'updatedAt'), \"now\", \"the record should receive the new information\");\n\n    count++;\n  };\n\n  var tom = store.createRecord(Person, { name: \"Tom Dale\" });\n  var yehuda = store.createRecord(Person, { name: \"Yehuda Katz\" });\n\n  store.commit();\n  equal(tom, store.find(Person, 1), \"Once an ID is in, find returns the same object\");\n  equal(yehuda, store.find(Person, 2), \"Once an ID is in, find returns the same object\");\n  store.commit();\n});\n\ntest(\"by default, updateRecords calls updateRecord once per record\", function() {\n  expect(10);\n\n  var count = 0;\n\n  adapter.updateRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n\n    if (count === 0) {\n      equal(get(record, 'name'), \"Tom Dale\");\n    } else if (count === 1) {\n      equal(get(record, 'name'), \"Yehuda Katz\");\n    } else {\n      ok(false, \"should not get here\");\n    }\n\n    count++;\n\n    equal(record.get('isSaving'), true, \"record is saving\");\n\n    store.didSaveRecord(record);\n\n    equal(record.get('isSaving'), false, \"record is no longer saving\");\n    equal(record.get('isLoaded'), true, \"record is saving\");\n  };\n\n  store.load(Person, { id: 1, name: \"Braaaahm Dale\" });\n  store.load(Person, { id: 2, name: \"Brohuda Katz\" });\n\n  var tom = store.find(Person, 1);\n  var yehuda = store.find(Person, 2);\n\n  set(tom, \"name\", \"Tom Dale\");\n  set(yehuda, \"name\", \"Yehuda Katz\");\n\n  store.commit();\n\n  // there is nothing to commit, so there won't be any records\n  store.commit();\n});\n\ntest(\"calling store.didSaveRecord can provide an optional hash\", function() {\n  expect(8);\n\n  var count = 0;\n\n  adapter.updateRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n\n    if (count === 0) {\n      equal(get(record, 'name'), \"Tom Dale\");\n      store.didSaveRecord(record, { id: 1, name: \"Tom Dale\", updatedAt: \"now\" });\n      equal(get(record, 'isDirty'), false, \"the record should not be dirty\");\n      equal(get(record, 'updatedAt'), \"now\", \"the hash was updated\");\n    } else if (count === 1) {\n      equal(get(record, 'name'), \"Yehuda Katz\");\n      store.didSaveRecord(record, { id: 2, name: \"Yehuda Katz\", updatedAt: \"now!\" });\n      equal(record.get('isDirty'), false, \"the record should not be dirty\");\n      equal(get(record, 'updatedAt'), \"now!\", \"the hash was updated\");\n    } else {\n      ok(false, \"should not get here\");\n    }\n\n    count++;\n  };\n\n  store.load(Person, { id: 1, name: \"Braaaahm Dale\" });\n  store.load(Person, { id: 2, name: \"Brohuda Katz\" });\n\n  var tom = store.find(Person, 1);\n  var yehuda = store.find(Person, 2);\n\n  set(tom, \"name\", \"Tom Dale\");\n  set(yehuda, \"name\", \"Yehuda Katz\");\n\n  store.commit();\n\n  // there is nothing to commit, so there won't be any records\n  store.commit();\n});\n\ntest(\"by default, deleteRecords calls deleteRecord once per record\", function() {\n  expect(4);\n\n  var count = 0;\n\n  adapter.deleteRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n\n    if (count === 0) {\n      equal(get(record, 'name'), \"Tom Dale\");\n    } else if (count === 1) {\n      equal(get(record, 'name'), \"Yehuda Katz\");\n    } else {\n      ok(false, \"should not get here\");\n    }\n\n    count++;\n\n    store.didSaveRecord(record);\n  };\n\n  store.load(Person, { id: 1, name: \"Tom Dale\" });\n  store.load(Person, { id: 2, name: \"Yehuda Katz\" });\n\n  var tom = store.find(Person, 1);\n  var yehuda = store.find(Person, 2);\n\n  tom.deleteRecord();\n  yehuda.deleteRecord();\n  store.commit();\n\n  // there is nothing to commit, so there won't be any records\n  store.commit();\n});\n\ntest(\"if an existing model is edited then deleted, deleteRecord is called on the adapter\", function() {\n  expect(5);\n\n  var count = 0;\n\n  adapter.deleteRecord = function(store, type, record) {\n    count++;\n    equal(get(record, 'id'), 'deleted-record', \"should pass correct record to deleteRecord\");\n    equal(count, 1, \"should only call deleteRecord method of adapter once\");\n\n    store.didSaveRecord(record);\n  };\n\n  adapter.updateRecord = function() {\n    ok(false, \"should not have called updateRecord method of adapter\");\n  };\n\n  // Load data for a record into the store.\n  store.load(Person, { id: 'deleted-record', name: \"Tom Dale\" });\n\n  // Retrieve that loaded record and edit it so it becomes dirty\n  var tom = store.find(Person, 'deleted-record');\n  tom.set('name', \"Tom Mothereffin' Dale\");\n\n  equal(get(tom, 'isDirty'), true, \"precond - record should be dirty after editing\");\n\n  tom.deleteRecord();\n  store.commit();\n\n  equal(get(tom, 'isDirty'), false, \"record should not be dirty\");\n  equal(get(tom, 'isDeleted'), true, \"record should be considered deleted\");\n\n  // should be a no-op since all records should be clean\n  store.commit();\n});\n\ntest(\"if a created record is marked as invalid by the server, it enters an error state\", function() {\n  adapter.createRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n\n    if (get(record, 'name').indexOf('Bro') === -1) {\n      store.recordWasInvalid(record, { name: ['common... name requires a \"bro\"'] });\n    } else {\n      store.didSaveRecord(record);\n    }\n  };\n\n  var yehuda = store.createRecord(Person, { id: 1, name: \"Yehuda Katz\" });\n\n  var hasNameError,\n      observer = function() { hasNameError = yehuda.get('errors.name'); };\n\n  Ember.addObserver(yehuda, 'errors.name', observer);\n\n  store.commit();\n\n  equal(get(yehuda, 'isValid'), false, \"the record is invalid\");\n  ok(hasNameError, \"should trigger errors.name observer on invalidation\");\n\n  set(yehuda, 'updatedAt', true);\n  equal(get(yehuda, 'isValid'), false, \"the record is still invalid\");\n\n  // This tests that we handle undefined values without blowing up\n  var errors = get(yehuda, 'errors');\n  set(errors, 'other_bound_property', undefined);\n  set(yehuda, 'errors', errors);\n  set(yehuda, 'name', \"Brohuda Brokatz\");\n\n  equal(get(yehuda, 'isValid'), true, \"the record is no longer invalid after changing\");\n  equal(get(yehuda, 'isDirty'), true, \"the record has outstanding changes\");\n  ok(!hasNameError, \"should trigger errors.name observer on validation\");\n\n  equal(get(yehuda, 'isNew'), true, \"precond - record is still new\");\n\n  store.commit();\n  equal(get(yehuda, 'isValid'), true, \"record remains valid after committing\");\n  equal(get(yehuda, 'isNew'), false, \"record is no longer new\");\n\n  Ember.removeObserver(yehuda, 'errors.name', observer);\n});\n\ntest(\"if a created record is marked as erred by the server, it enters an error state\", function() {\n  adapter.createRecord = function(store, type, record) {\n    store.recordWasError(record);\n  };\n\n  var person = store.createRecord(Person, { id: 1, name: \"John Doe\" });\n\n  store.commit();\n\n  ok(get(person, 'isError'), \"the record is in the error state\");\n});\n\ntest(\"if an updated record is marked as invalid by the server, it enters an error state\", function() {\n  adapter.updateRecord = function(store, type, record) {\n    equal(type, Person, \"the type is correct\");\n\n    if (get(record, 'name').indexOf('Bro') === -1) {\n      store.recordWasInvalid(record, { name: ['common... name requires a \"bro\"'] });\n    } else {\n      store.didSaveRecord(record);\n    }\n  };\n\n  store.load(Person, { id: 1, name: \"Brohuda Brokatz\" });\n  var yehuda = store.find(Person, 1);\n\n  equal(get(yehuda, 'isValid'), true, \"precond - the record is valid\");\n  set(yehuda, 'name', \"Yehuda Katz\");\n  equal(get(yehuda, 'isValid'), true, \"precond - the record is still valid as far as we know\");\n\n  equal(get(yehuda, 'isDirty'), true, \"the record is dirty\");\n  store.commit();\n  equal(get(yehuda, 'isDirty'), true, \"the record is still dirty\");\n  equal(get(yehuda, 'isValid'), false, \"the record is invalid\");\n\n  set(yehuda, 'updatedAt', true);\n  equal(get(yehuda, 'isValid'), false, \"the record is still invalid\");\n\n  set(yehuda, 'name', \"Brohuda Brokatz\");\n  equal(get(yehuda, 'isValid'), true, \"the record is no longer invalid after changing\");\n  equal(get(yehuda, 'isDirty'), true, \"the record has outstanding changes\");\n\n  store.commit();\n  equal(get(yehuda, 'isValid'), true, \"record remains valid after committing\");\n  equal(get(yehuda, 'isDirty'), false, \"record is no longer new\");\n\n  // Test key mapping\n});\n\ntest(\"if a created record is marked as erred by the server, it enters an error state\", function() {\n  adapter.updateRecord = function(store, type, record) {\n    store.recordWasError(record);\n  };\n\n  store.load(Person, { id: 1, name: \"John Doe\" });\n  var person = store.find(Person, 1);\n  person.set('name', \"Jonathan Doe\");\n\n  store.commit();\n\n  ok(get(person, 'isError'), \"the record is in the error state\");\n});\n\ntest(\"can be created after the DS.Store\", function() {\n  expect(1);\n  store.set('adapter', 'App.adapter');\n  adapter.find = function(store, type) {\n    equal(type, Person, \"the type is correct\");\n  };\n  // Expose the adapter to global namespace\n  window.App = {adapter: adapter};\n\n  store.find(Person, 1);\n});\n\ntest(\"the filter method can optionally take a server query as well\", function() {\n  adapter.findQuery = function(store, type, query, array) {\n    this.didFindQuery(store, type, { persons: [\n      { id: 1, name: \"Yehuda Katz\" },\n      { id: 2, name: \"Tom Dale\" }\n    ]}, array);\n  };\n\n  var filter = store.filter(Person, { page: 1 }, function(data) {\n    return data.get('name') === \"Tom Dale\";\n  });\n\n  var tom = store.find(Person, 2);\n\n  equal(get(filter, 'length'), 1, \"The filter has an item in it\");\n  deepEqual(filter.toArray(), [ tom ], \"The filter has a single entry in it\");\n});\n\ntest(\"can rollback after sucessives updates\", function() {\n  store.load(Person, 1, {name: \"Paul Chavard\"});\n  store.set('adapter', 'App.adapter');\n  adapter.updateRecord = function(store, type, record) {\n    store.didSaveRecord(record);\n  };\n  // Expose the adapter to global namespace\n  window.App = {adapter: adapter};\n\n  var person = store.find(Person, 1);\n\n  equal(person.get('name'), \"Paul Chavard\", \"person has a name defined\");\n\n  person.set('name', 'Paul Bro');\n\n  equal(person.get('name'), \"Paul Bro\", \"person changed the name\");\n\n  person.get('transaction').rollback();\n\n  equal(person.get('name'), \"Paul Chavard\", \"person name is back to Paul Chavard\");\n\n  person.set('name', 'Paul Bro');\n  equal(person.get('name'), \"Paul Bro\", \"person changed the name\");\n  equal(person.get('isDirty'), true, \"person is dirty\");\n\n  person.get('transaction').commit();\n\n  equal(person.get('isDirty'), false, \"person is not dirty\");\n  equal(person.get('name'), \"Paul Bro\", \"person changed the name\");\n\n  person.set('name', 'Paul BroBro');\n  equal(person.get('name'), \"Paul BroBro\", \"person changed the name again\");\n  equal(person.get('isDirty'), true, \"person is dirty\");\n\n  person.get('transaction').rollback();\n\n  equal(person.get('isDirty'), false, \"person is not dirty\");\n  equal(person.get('name'), \"Paul Bro\", \"person changed the name back to Paul Bro\");\n});\n\ntest(\"mappings registered on an adapter class are applied to the serializer of adapter instances\", function() {\n  var MyAdapter = DS.Adapter.extend();\n\n  MyAdapter.configure(Person, {\n    primaryKey: 'id!'\n  });\n\n  MyAdapter.map(Person, {\n    name: { key: 'name!' }\n  });\n\n  var adapter = MyAdapter.create();\n  store.set('adapter', adapter);\n\n  store.load(Person, {\n    'id!': 1,\n    'name!': \"Tom Dale\"\n  });\n\n  var person = store.find(Person, 1);\n\n  equal(person.get('id'), 1);\n  equal(person.get('name'), \"Tom Dale\");\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/store_adapter_test");minispade.register('ember-data/~tests/integration/store_model_filter_test', "(function() {var get = Ember.get, set = Ember.set;\n\nvar Person, store, array, recordArray;\n\nvar shouldContain = function(array, item) {\n  ok(array.indexOf(item) !== -1, \"array should contain \"+item.get('name'));\n};\n\nvar shouldNotContain = function(array, item) {\n  ok(array.indexOf(item) === -1, \"array should not contain \"+item.get('name'));\n};\n\nmodule(\"DS.Model updating\", {\n  setup: function() {\n    store = DS.Store.create();\n    array = [{ id: 1, name: \"Scumbag Dale\" }, { id: 2, name: \"Scumbag Katz\" }, { id: 3, name: \"Scumbag Bryn\" }];\n    Person = DS.Model.extend({ name: DS.attr('string') });\n  },\n  teardown: function() {\n    store.destroy();\n    Person = null;\n    array = null;\n  }\n});\n\ntest(\"when a DS.Model updates its attributes, its changes affect its filtered Array membership\", function() {\n  store.loadMany(Person, array);\n\n  var people = store.filter(Person, function(hash) {\n    if (hash.get('name').match(/Katz$/)) { return true; }\n  });\n\n  equal(get(people, 'length'), 1, \"precond - one item is in the RecordArray\");\n\n  var person = people.objectAt(0);\n\n  equal(get(person, 'name'), \"Scumbag Katz\", \"precond - the item is correct\");\n\n  set(person, 'name', \"Yehuda Katz\");\n\n  equal(get(people, 'length'), 1, \"there is still one item\");\n  equal(get(person, 'name'), \"Yehuda Katz\", \"it has the updated item\");\n\n  set(person, 'name', \"Yehuda Katz-Foo\");\n\n  equal(get(people, 'length'), 0, \"there are now no items\");\n});\n\ntest(\"a record array can have a filter on it\", function() {\n  store.loadMany(Person, array);\n\n  var recordArray = store.filter(Person, function(hash) {\n    if (hash.get('name').match(/Scumbag [KD]/)) { return true; }\n  });\n\n  equal(get(recordArray, 'length'), 2, \"The Record Array should have the filtered objects on it\");\n\n  store.load(Person, { id: 4, name: \"Scumbag Koz\" });\n\n  equal(get(recordArray, 'length'), 3, \"The Record Array should be updated as new items are added to the store\");\n\n  store.load(Person, { id: 1, name: \"Scumbag Tom\" });\n\n  equal(get(recordArray, 'length'), 2, \"The Record Array should be updated as existing members are updated\");\n});\n\ntest(\"a filtered record array includes created elements\", function() {\n  store.loadMany(Person, array);\n\n  var recordArray = store.filter(Person, function(hash) {\n    if (hash.get('name').match(/Scumbag [KD]/)) { return true; }\n  });\n\n  equal(get(recordArray, 'length'), 2, \"precond - The Record Array should have the filtered objects on it\");\n\n  store.createRecord(Person, { name: \"Scumbag Koz\" });\n\n  equal(get(recordArray, 'length'), 3, \"The record array has the new object on it\");\n});\n\ntest(\"a Record Array can update its filter\", function() {\n  set(store, 'adapter', DS.Adapter.create({\n    deleteRecord: function(store, type, record) {\n      store.didSaveRecord(record);\n    }\n  }));\n\n  store.loadMany(Person, array);\n\n  var dickens = store.createRecord(Person, { id: 4, name: \"Scumbag Dickens\" });\n  dickens.deleteRecord();\n  store.commit();\n\n  var dale = store.find(Person, 1);\n  var katz = store.find(Person, 2);\n  var bryn = store.find(Person, 3);\n\n  var recordArray = store.filter(Person, function(hash) {\n    if (hash.get('name').match(/Scumbag [KD]/)) { return true; }\n  });\n\n  shouldContain(recordArray, dale);\n  shouldContain(recordArray, katz);\n  shouldNotContain(recordArray, bryn);\n  shouldNotContain(recordArray, dickens);\n\n  recordArray.set('filterFunction', function(hash) {\n    if (hash.get('name').match(/Katz/)) { return true; }\n  });\n\n  equal(get(recordArray, 'length'), 1, \"The Record Array should have one object on it\");\n\n  store.load(Person, 5, { name: \"Other Katz\" });\n\n  equal(get(recordArray, 'length'), 2, \"The Record Array now has the new object matching the filter\");\n\n  store.load(Person, 6, { name: \"Scumbag Demon\" });\n\n  equal(get(recordArray, 'length'), 2, \"The Record Array doesn't have objects matching the old filter\");\n});\n\ntest(\"a Record Array can update its filter and notify array observers\", function() {\n  set(store, 'adapter', DS.Adapter.create({\n    deleteRecord: function(store, type, record) {\n      store.didSaveRecord(record);\n    }\n  }));\n\n  store.loadMany(Person, array);\n\n  var dickens = store.createRecord(Person, { id: 4, name: \"Scumbag Dickens\" });\n  dickens.deleteRecord();\n  store.commit();\n\n  var dale = store.find(Person, 1);\n  var katz = store.find(Person, 2);\n  var bryn = store.find(Person, 3);\n\n  var recordArray = store.filter(Person, function(hash) {\n    if (hash.get('name').match(/Scumbag [KD]/)) { return true; }\n  });\n\n  var didChangeIdx, didChangeRemoved = 0, didChangeAdded = 0;\n\n  var arrayObserver = {\n    arrayWillChange: Ember.K,\n\n    arrayDidChange: function(array, idx, removed, added) {\n      didChangeIdx = idx;\n      didChangeRemoved += removed;\n      didChangeAdded += added;\n    }\n  };\n\n  recordArray.addArrayObserver(arrayObserver);\n\n  recordArray.set('filterFunction', function(hash) {\n    if (hash.get('name').match(/Katz/)) { return true; }\n  });\n\n  equal(didChangeRemoved, 1, \"removed one item from array\");\n  didChangeRemoved = 0;\n\n  store.load(Person, 5, { name: \"Other Katz\" });\n\n  equal(didChangeAdded, 1, \"one item was added\");\n  didChangeAdded = 0;\n\n  equal(recordArray.objectAt(didChangeIdx).get('name'), \"Other Katz\");\n\n  store.load(Person, 6, { name: \"Scumbag Demon\" });\n\n  equal(didChangeAdded, 0, \"did not get called when an object that doesn't match is added\");\n\n  recordArray.set('filterFunction', function(hash) {\n    if (hash.get('name').match(/Scumbag [KD]/)) { return true; }\n  });\n\n  equal(didChangeAdded, 2, \"one item is added when going back\");\n  equal(recordArray.objectAt(didChangeIdx).get('name'), \"Scumbag Demon\");\n  equal(recordArray.objectAt(didChangeIdx-1).get('name'), \"Scumbag Dale\");\n});\n\ntest(\"it is possible to filter by computed properties\", function() {\n  Person = DS.Model.extend({\n    name: DS.attr('string'),\n    upperName: Ember.computed(function() {\n      return this.get('name').toUpperCase();\n    }).property('name')\n  });\n\n  var filter = store.filter(Person, function(person) {\n    return person.get('upperName') === \"TOM DALE\";\n  });\n\n  equal(filter.get('length'), 0, \"precond - the filter starts empty\");\n\n  store.load(Person, { id: 1, name: \"Tom Dale\" });\n\n  equal(filter.get('length'), 1, \"the filter now has a record in it\");\n\n  var person = store.find(Person, 1);\n  person.set('name', \"Yehuda Katz\");\n\n  equal(filter.get('length'), 0, \"the filter is empty again\");\n});\n\ntest(\"a filter created after a record is already loaded works\", function() {\n  Person = DS.Model.extend({\n    name: DS.attr('string'),\n    upperName: Ember.computed(function() {\n      return this.get('name').toUpperCase();\n    }).property('name')\n  });\n\n  store.load(Person, { id: 1, name: \"Tom Dale\" });\n\n  var filter = store.filter(Person, function(person) {\n    return person.get('upperName') === \"TOM DALE\";\n  });\n\n  equal(filter.get('length'), 1, \"the filter now has a record in it\");\n  equal(filter.objectAt(0), store.find(Person, 1));\n});\n\ntest(\"it is possible to filter by state flags\", function() {\n  set(store, 'adapter', DS.Adapter.create({\n    find: Ember.K\n  }));\n\n  var filter = store.filter(Person, function(person) {\n    return person.get('isLoaded');\n  });\n\n  equal(filter.get('length'), 0, \"precond - there are no records yet\");\n\n  store.find(Person, 1);\n\n  equal(filter.get('length'), 0, \"the unloaded record isn't in the filter\");\n\n  store.load(Person, { id: 1, name: \"Tom Dale\" });\n\n  equal(filter.get('length'), 1, \"the now-loaded record is in the filter\");\n  equal(filter.objectAt(0), store.find(Person, 1));\n});\n\ntest(\"it is possible to filter loaded records by dirtiness\", function() {\n  set(store, 'adapter', DS.Adapter.create({\n    updateRecord: Ember.K\n  }));\n\n  var filter = store.filter(Person, function(person) {\n    return !person.get('isDirty');\n  });\n\n  store.load(Person, { id: 1, name: \"Tom Dale\" });\n  var person = store.find(Person, 1);\n\n  equal(filter.get('length'), 1, \"the clean record is in the filter\");\n\n  person.set('name', \"Yehuda Katz\");\n\n  equal(filter.get('length'), 0, \"the now-dirty record is not in the filter\");\n\n  store.commit();\n  store.didSaveRecord(person);\n\n  equal(filter.get('length'), 1, \"the clean record is back in the filter\");\n});\n\ntest(\"it is possible to filter created records by dirtiness\", function() {\n  set(store, 'adapter', DS.Adapter.create({\n    createRecord: Ember.K\n  }));\n\n  var filter = store.filter(Person, function(person) {\n    return !person.get('isDirty');\n  });\n\n  var person = store.createRecord(Person, {\n    id: 1,\n    name: \"Tom Dale\"\n  });\n\n  equal(filter.get('length'), 0, \"the dirty record is not in the filter\");\n\n  store.commit();\n  store.didSaveRecord(person);\n\n  equal(filter.get('length'), 1, \"the clean record is in the filter\");\n});\n\n\n// SERVER SIDE TESTS\nvar clientEdits = function(ids) {\n  // wrap in an Ember.run to guarantee coalescence of the\n  // iterated `set` calls.\n  Ember.run( function() {\n    ids.forEach( function(id) {\n      var person = store.find(Person, id);\n      person.set('name', 'Client-side ' + id );\n    });\n  });\n};\n\nvar clientCreates = function(names) {\n  // wrap in an Ember.run to guarantee coalescence of the\n  // iterated `set` calls.\n  Ember.run( function() {\n    names.forEach( function( name ) {\n      store.createRecord(Person, { name: 'Client-side ' + name });\n    });\n  });\n};\n\nvar serverResponds = function(){\n  store.commit();\n};\n\nvar setup = function(serverCallbacks) {\n  set(store, 'adapter', DS.Adapter.create(serverCallbacks));\n\n  store.loadMany(Person, array);\n\n  recordArray = store.filter(Person, function(hash) {\n    if (hash.get('name').match(/Scumbag/)) { return true; }\n  });\n\n  equal(get(recordArray, 'length'), 3, \"The filter function should work\");\n};\n\ntest(\"a Record Array can update its filter after server-side updates one record\", function() {\n  setup({\n    updateRecord: function(store, type, record) {\n      store.didSaveRecord(record, {id: 1, name: \"Scumbag Server-side Dale\"});\n    }\n  });\n\n  clientEdits([1]);\n  equal(get(recordArray, 'length'), 2, \"The record array updates when the client changes records\");\n\n  serverResponds();\n  equal(get(recordArray, 'length'), 3, \"The record array updates when the server changes one record\");\n});\n\ntest(\"a Record Array can update its filter after server-side updates multiple records\", function() {\n  setup({\n    updateRecords: function(store, type, records) {\n      store.didSaveRecords(records, [\n        {id: 1, name: \"Scumbag Server-side Dale\"},\n        {id: 2, name: \"Scumbag Server-side Katz\"}\n      ]);\n    }\n  });\n\n  clientEdits([1,2]);\n  equal(get(recordArray, 'length'), 1, \"The record array updates when the client changes records\");\n\n  serverResponds();\n  equal(get(recordArray, 'length'), 3, \"The record array updates when the server changes multiple records\");\n});\n\ntest(\"a Record Array can update its filter after server-side creates one record\", function() {\n  setup({\n    createRecord: function(store, type, record) {\n      store.didSaveRecord(record, {id: 4, name: \"Scumbag Server-side Tim\"});\n    }\n  });\n\n  clientCreates([\"Tim\"]);\n  equal(get(recordArray, 'length'), 3, \"The record array does not include non-matching records\");\n\n  serverResponds();\n  equal(get(recordArray, 'length'), 4, \"The record array updates when the server creates a record\");\n});\n\ntest(\"a Record Array can update its filter after server-side creates multiple records\", function() {\n  setup({\n    createRecords: function(store, type, records) {\n      store.didSaveRecords(records, [\n        {id: 4, name: \"Scumbag Server-side Mike\"},\n        {id: 5, name: \"Scumbag Server-side David\"}\n      ]);\n    }\n  });\n\n  clientCreates([\"Mike\", \"David\"]);\n  equal(get(recordArray, 'length'), 3, \"The record array does not include non-matching records\");\n\n  serverResponds();\n  equal(get(recordArray, 'length'), 5, \"The record array updates when the server creates multiple records\");\n});\n\n\n})();\n//@ sourceURL=ember-data/~tests/integration/store_model_filter_test");minispade.register('ember-data/~tests/integration/transaction_adapter_test', "(function() {var transaction, adapter, store, Post, Comment;\n\nmodule(\"DS.Transaction and DS.Adapter Integration\", {\n  setup: function() {\n    adapter = DS.Adapter.create();\n    store = DS.Store.create({\n      adapter: adapter\n    });\n\n    transaction = store.transaction();\n\n    Post = DS.Model.extend();\n    Comment = DS.Model.extend({\n      body: DS.attr('string'),\n      post: DS.belongsTo(Post)\n    });\n\n    Post.reopen({\n      comments: DS.hasMany(Comment)\n    });\n  },\n\n  teardown: function() {\n    adapter.destroy();\n    store.destroy();\n    transaction.destroy();\n    Post = null;\n    Comment = null;\n  }\n});\n\n//test(\"adding a clean record to a relationship causes it to be passed as an updated record\", function() {\n  //var post, comment;\n\n  //adapter.commit = async(function(store, records, relationships) {\n    //var relationship = {\n      //child: comment,\n      //oldParent: post1,\n      //newParent: post2\n    //};\n\n    //ok(records.updated.indexOf(comment) >= 0, \"The comment is in the updated list\");\n    //ok(records.updated.indexOf(post1) >= 0, \"The old post is in the updated list\");\n    //ok(records.updated.indexOf(post2) >= 0, \"The new post is in the updated list\");\n\n    //deepEqual(relationships.byChild.get(comment), [ relationship ]);\n    //deepEqual(relationships.byOldParent.get(post1), [ relationship ]);\n    //deepEqual(relationships.byNewParent.get(post2), [ relationship ]);\n\n    //raises(function() {\n      //comment.set('body', \"NOPE! CHUCK TESTA!\");\n    //});\n\n    //setTimeout(async(function() {\n      //store.didUpdateRecord(comment);\n      //store.didUpdateRecord(post1);\n      //store.didUpdateRecord(post2);\n\n      //var defaultTransaction = store.get('defaultTransaction');\n\n      //equal(comment.get('transaction'), defaultTransaction);\n      //equal(post1.get('transaction'), defaultTransaction);\n      //equal(post2.get('transaction'), defaultTransaction);\n    //}), 1);\n  //});\n\n  //store.load(Comment, { id: 1 });\n  //store.load(Post, { id: 1, comments: [ 1 ] });\n  //store.load(Post, { id: 2 });\n\n  //comment = store.find(Comment, 1);\n  //var post1 = store.find(Post, 1);\n  //var post2 = store.find(Post, 2);\n\n  //transaction.add(comment);\n  //transaction.add(post1);\n  //transaction.add(post2);\n\n  //post1.get('comments').removeObject(comment);\n  //post2.get('comments').addObject(comment);\n\n  //transaction.commit();\n\n  //equal(comment.get('transaction'), transaction);\n//});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/transaction_adapter_test");minispade.register('ember-data/~tests/integration/transactions/basic_test', "(function() {/*global QUnit*/\n\nvar get = Ember.get, set = Ember.set;\n\nvar Person = DS.Model.extend({\n  name: DS.attr('string'),\n  foo: DS.attr('string')\n});\n\nvar transaction, store;\n\nmodule(\"Transactions\", {\n  setup: function() {\n    store = DS.Store.create();\n  },\n\n  teardown: function() {\n    if (transaction) { transaction.destroy(); }\n    store.destroy();\n  }\n});\n\ntest(\"Stores can create a new transaction\", function() {\n  transaction = store.transaction();\n\n  ok(transaction, \"transaction is created\");\n  ok(DS.Transaction.detectInstance(transaction), \"transaction is an instance of DS.Transaction\");\n});\n\ntest(\"If a record is created from a transaction, it is not committed when store.commit() is called but is committed when transaction.commit() is called\", function() {\n  var commitCalls = 0;\n\n  store.adapter = DS.Adapter.create({\n    createRecords: function() {\n      commitCalls++;\n    }\n  });\n\n  transaction = store.transaction();\n  transaction.createRecord(Person, {});\n\n  store.commit();\n  equal(commitCalls, 0, \"commit was not called when committing the store\");\n\n  transaction.commit();\n  equal(commitCalls, 1, \"commit was called when committing the transaction\");\n});\n\ntest(\"If a record is added to a transaction then updated, it is not committed when store.commit() is called but is committed when transaction.commit() is called\", function() {\n  var commitCalls = 0;\n\n  store.adapter = DS.Adapter.create({\n    updateRecords: function() {\n      commitCalls++;\n    }\n  });\n\n  store.load(Person, { id: 1, name: \"Yehuda Katz\" });\n\n  transaction = store.transaction();\n  var record = store.find(Person, 1);\n  transaction.add(record);\n\n  record.set('name', 'Brohuda Brokatz');\n\n  store.commit();\n  equal(commitCalls, 0, \"commit was not called when committing the store\");\n\n  transaction.commit();\n  equal(commitCalls, 1, \"commit was called when committing the transaction\");\n});\n\ntest(\"a record is removed from a transaction after the records become clean\", function() {\n  var createCalls = 0, updateCalls = 0;\n\n  var store = DS.Store.create({\n    adapter: DS.Adapter.create({\n      createRecord: function(store, type, record) {\n        createCalls++;\n\n        store.didSaveRecord(record, { id: 1 });\n      },\n\n      updateRecords: function() {\n        updateCalls++;\n      }\n    })\n  });\n\n  transaction = store.transaction();\n  var record = transaction.createRecord(Person, {});\n\n  transaction.commit();\n  equal(createCalls, 1, \"create should be called when committing the store\");\n\n  record.set('foo', 'bar');\n\n  transaction.commit();\n  equal(updateCalls, 0, \"commit was not called when committing the transaction\");\n\n  store.commit();\n  equal(updateCalls, 1, \"commit was called when committing the store\");\n});\n\ntest(\"after a record is added to a transaction then deleted, it is not committed when store.commit() is called but is committed when transaction.commit() is called\", function() {\n  var commitCalls = 0;\n\n  var store = DS.Store.create({\n    adapter: DS.Adapter.create({\n      deleteRecords: function() {\n        commitCalls++;\n      }\n    })\n  });\n\n  store.load(Person, { id: 1, name: \"Yehuda Katz\" });\n\n  transaction = store.transaction();\n  var record = store.find(Person, 1);\n  transaction.add(record);\n\n  record.deleteRecord();\n\n  store.commit();\n  equal(commitCalls, 0, \"commit was not called when committing the store\");\n\n  transaction.commit();\n  equal(commitCalls, 1, \"commit was called when committing the transaction\");\n});\n\ntest(\"a record that is clean can be removed from a transaction\", function() {\n  var updateCalled = 0;\n\n  var store = DS.Store.create({\n    adapter: DS.Adapter.create({\n      updateRecord: function() {\n        updateCalled++;\n      }\n    })\n  });\n\n  store.load(Person, { id: 1, name: \"Yehuda Katz\" });\n\n  transaction = store.transaction();\n  var record = store.find(Person, 1);\n\n  transaction.add(record);\n  transaction.remove(record);\n\n  set(record, 'name', \"shuck it trebek\");\n\n  transaction.commit();\n\n  equal(updateCalled, 0, \"after removing from transaction it does not commit\");\n\n  store.commit();\n\n  equal(updateCalled, 1, \"after removing from transaction it commits on the store\");\n});\n\ntest(\"a record that is in the created state cannot be moved into a new transaction\", function() {\n  var store = DS.Store.create();\n\n  var person = store.createRecord(Person);\n  transaction = store.transaction();\n\n  raises(function() {\n    transaction.add(person);\n  }, Error);\n});\n\ntest(\"a record that is in the updated state cannot be moved into a new transaction\", function() {\n  var store = DS.Store.create();\n\n  store.load(Person, { id: 1 });\n  var person = store.find(Person, 1);\n\n  person.set('name', \"Scumdale\");\n  transaction = store.transaction();\n\n  raises(function() {\n    transaction.add(person);\n  }, Error);\n});\n\ntest(\"a record that is in the deleted state cannot be moved into a new transaction\", function() {\n  var store = DS.Store.create();\n\n  store.load(Person, { id: 1 });\n  var person = store.find(Person, 1);\n\n  person.deleteRecord();\n  transaction = store.transaction();\n\n  raises(function() {\n    transaction.add(person);\n  }, Error);\n});\n\ntest(\"a record that is in the clean state is moved back to the default transaction after its transaction is committed\", function() {\n  var store = DS.Store.create();\n\n  store.load(Person, { id: 1 });\n\n  var person = store.find(Person, 1);\n\n  transaction = store.transaction();\n  transaction.add(person);\n  transaction.commit();\n\n  equal(get(person, 'transaction'), get(store, 'defaultTransaction'), \"record should have been moved back to the default transaction\");\n});\n\ntest(\"modified records are reset when their transaction is rolled back\", function() {\n\n  var store = DS.Store.create({\n    adapter: DS.Adapter.create({\n      commit: function() {\n        ok(false, \"should never call adapter methods\");\n      }\n    })\n  });\n\n  store.load(Person, { id: 1, name: \"Scumbag Tom\" });\n  store.load(Person, { id: 2, name: \"Scumbag Carl\" });\n  store.load(Person, { id: 3, name: \"Scumbag André\" });\n  store.load(Person, { id: 4, name: \"Scumbag Paul\" });\n\n  var updatedPerson = store.find(Person, 1);\n  var deletedPerson = store.find(Person, 2);\n  var anotherUpdatedPerson = store.find(Person, 3);\n  var invalidPerson = store.find(Person, 4);\n\n  transaction = store.transaction();\n  transaction.add(updatedPerson);\n  transaction.add(deletedPerson);\n  transaction.add(anotherUpdatedPerson);\n  transaction.add(invalidPerson);\n\n  var newPerson = transaction.createRecord(Person, {\n    name: \"Scumbag Yehuda\"\n  });\n  var anotherInvalidPerson = transaction.createRecord(Person, {});\n\n  updatedPerson.set('name', \"Scumbag Patrick\");\n  anotherUpdatedPerson.set('name', \"Scumbag Leah\");\n  deletedPerson.deleteRecord();\n  invalidPerson.set('name', null);\n  invalidPerson.send('willCommit');\n  store.recordWasInvalid(invalidPerson, {name: 'no name!'});\n  anotherInvalidPerson.send('willCommit');\n  store.recordWasInvalid(anotherInvalidPerson, {name: 'no name!'});\n\n  equal(updatedPerson.get('isDirty'), true, \"precond - Record is marked as dirty when changed\");\n  equal(updatedPerson.get('name'), \"Scumbag Patrick\", \"precond - Record has been changed to the value we set\");\n  equal(anotherUpdatedPerson.get('isDirty'), true, \"precond - Record is marked as dirty when changed\");\n  equal(anotherUpdatedPerson.get('name'), \"Scumbag Leah\", \"precond - Record has been changed to the value we set\");\n  equal(newPerson.get('isDirty'), true, \"precond - new record is marked as dirty\");\n  equal(newPerson.get('isNew'), true, \"precond - new record is marked as new\");\n  equal(deletedPerson.get('isDirty'), true, \"precond - deleted record is marked as dirty when deleted\");\n  equal(deletedPerson.get('isDeleted'), true, \"precond - deleted record is marked as deleted\");\n  equal(invalidPerson.get('isDirty'), true, \"precond - invalid record is marked as dirty\");\n  equal(invalidPerson.get('isValid'), false, \"precond - invalid record is marked as invalid\");\n  equal(anotherInvalidPerson.get('isDirty'), true, \"precond - invalid record is marked as dirty\");\n  equal(anotherInvalidPerson.get('isNew'), true, \"precond - invalid record is marked as dirty\");\n  equal(anotherInvalidPerson.get('isValid'), false, \"precond - invalid record is marked as invalid\");\n\n  transaction.rollback();\n\n  equal(updatedPerson.get('isDirty'), false, \"Record is not dirty after rollback\");\n  equal(updatedPerson.get('name'), \"Scumbag Tom\", \"Record has previously loaded name\");\n  equal(anotherUpdatedPerson.get('isDirty'), false, \"Record is not dirty after rollback\");\n  equal(anotherUpdatedPerson.get('name'), \"Scumbag André\", \"Record has previously loaded name\");\n  equal(newPerson.get('isDirty'), false, \"created record is no longer considered dirty\");\n  equal(newPerson.get('isDeleted'), true, \"created records are deleted when their transaction is rolled back\");\n  equal(deletedPerson.get('isDirty'), false, \"deleted record is no longer considered dirty\");\n  equal(deletedPerson.get('isDeleted'), false, \"deleted record is no longer considered deleted\");\n  equal(invalidPerson.get('isDirty'), false, \"invalid record is no longer considered dirty\");\n  equal(invalidPerson.get('name'), \"Scumbag Paul\", \"Record has previously loaded name\");\n  equal(invalidPerson.get('isValid'), true, \"invalid record is marked as valid\");\n  equal(anotherInvalidPerson.get('isValid'), true, \"invalid record is marked as valid\");\n  equal(anotherInvalidPerson.get('isDeleted'), true, \"created records are deleted when their transaction is rolled back\");\n\n  equal(get(newPerson, 'transaction'), get(store, 'defaultTransaction'), \"record should have been moved back to the default transaction\");\n  equal(get(updatedPerson, 'transaction'), get(store, 'defaultTransaction'), \"record should have been moved back to the default transaction\");\n  equal(get(anotherUpdatedPerson, 'transaction'), get(store, 'defaultTransaction'), \"record should have been moved back to the default transaction\");\n  equal(get(deletedPerson, 'transaction'), get(store, 'defaultTransaction'), \"record should have been moved back to the default transaction\");\n  equal(get(invalidPerson, 'transaction'), get(store, 'defaultTransaction'), \"record should have been moved back to the default transaction\");\n});\n\ntest(\"modified records are reset when their transaction is rolled back\", function() {\n  var store = DS.Store.create();\n\n  store.load(Person, { id: 1, name: \"Scumbag Tom\" });\n\n  var person = store.find(Person, 1);\n\n  transaction = store.transaction();\n  transaction.add(person);\n\n  person.set('name', 'toto');\n\n  store.recordWasInvalid(person, {name: 'error'});\n\n  equal(person.get('isValid'), false, \"precond - invalid record is marked as invalid\");\n\n  transaction.rollback();\n\n  equal(person.get('isValid'), true, \"invalid record is now marked as valid\");\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/transactions/basic_test");minispade.register('ember-data/~tests/integration/transactions/relationships_test', "(function() {/*global QUnit*/\n\nvar Post = DS.Model.extend({\n  title: DS.attr('string'),\n  body: DS.attr('string')\n});\n\nvar Comment = DS.Model.extend({\n  body: DS.attr('string'),\n  post: DS.belongsTo(Post)\n});\n\nPost.reopen({\n  comments: DS.hasMany(Comment)\n});\n\nvar store, adapter, transaction;\n\nmodule(\"Transactions and Relationships\", {\n  setup: function() {\n    adapter = DS.Adapter.create();\n    store = DS.Store.create({\n      adapter: adapter\n    });\n  },\n\n  teardown: function() {\n    if (transaction) { transaction.destroy(); }\n    adapter.destroy();\n    store.destroy();\n  }\n});\n\nfunction expectRelationships(description) {\n  var relationships = transaction.get('relationships').toArray(),\n      relationship = relationships[0],\n      count = description.count === undefined ? description.length : description.count;\n\n  if(description.count === undefined && (!description[0] || !description[1])){\n    count = 1;\n  }\n  QUnit.push(relationships.length === count, relationships.length, count, \"There should be \" + count + \" dirty relationships\");\n\n  if (count) {\n    if(description[0]){\n      QUnit.push(relationships[0].getSecondRecord() === description[0].parent, relationships[0].getSecondRecord(), description[0].parent, \"oldParent is incorrect\");\n      QUnit.push(relationships[0].getFirstRecord() === description[0].child, relationships[0].child, description[0].child, \"child in relationship 0 is incorrect\");\n    }\n    if(description[1]){\n      var relPosition = count === 2 ? 1 : 0;\n      QUnit.push(relationships[relPosition].getFirstRecord() === description[1].child, relationships[relPosition].child, description[1].child, \"child in relationship 1 is incorrect\");\n      QUnit.push(relationships[relPosition].getSecondRecord() === description[1].parent, relationships[relPosition].parent, description[1].parent, \"newParent is incorrect\");\n    }\n  }\n}\n\ntest(\"If both the parent and child are clean and in the same transaction, a dirty relationship is added to the transaction null->A\", function() {\n  store.load(Post, { id: 1, title: \"Ohai\", body: \"FIRST POST ZOMG\" });\n  store.load(Comment, { id: 1, body: \"Kthx\" });\n\n  var post = store.find(Post, 1);\n  var comment = store.find(Comment, 1);\n\n  transaction = store.transaction();\n\n  transaction.add(post);\n  transaction.add(comment);\n\n  post.get('comments').pushObject(comment);\n\n  expectRelationships(\n    [null,{parent: post, child: comment}]\n  );\n});\n\ntest(\"If a child is removed from a parent, a dirty relationship is added to the transaction A->null\", function() {\n  store.load(Comment, { id: 1, body: \"Kthx\" });\n  store.load(Post, { id: 1, title: \"Ohai\", body: \"FIRST POST ZOMG\", comments: [ 1 ] });\n\n  var post = store.find(Post, 1);\n  var comment = store.find(Comment, 1);\n\n  transaction = store.transaction();\n\n  transaction.add(post);\n  transaction.add(comment);\n\n  post.get('comments').removeObject(comment);\n\n  expectRelationships(\n    [{parent: post,\n      child: comment}]\n  );\n});\n\ntest(\"If a child is removed from a parent it was recently added to, the dirty relationship is removed. null->A, A->null\", function() {\n  store.load(Comment, { id: 1, body: \"Kthx\" });\n  store.load(Post, { id: 1, title: \"Ohai\", body: \"FIRST POST ZOMG\", comments: [ 1 ] });\n\n  var post = store.find(Post, 1);\n  var comment = store.find(Comment, 1);\n\n  transaction = store.transaction();\n\n  transaction.add(post);\n  transaction.add(comment);\n\n  post.get('comments').removeObject(comment);\n  post.get('comments').pushObject(comment);\n\n  expectRelationships({ count: 0 });\n});\n\ntest(\"If a child was added to one parent, and then another, the changes coalesce. A->B, B->C\", function() {\n  store.load(Comment, { id: 1, body: \"Kthx\" });\n  store.load(Post, { id: 1, title: \"Ohai\", body: \"FIRST POST ZOMG\", comments: [ 1 ] });\n  store.load(Post, { id: 2, title: \"ZOMG\", body: \"SECOND POST WAT\" });\n  store.load(Post, { id: 3, title: \"ORLY?\", body: \"Why am I still here?\" });\n\n  var post = store.find(Post, 1);\n  var post2 = store.find(Post, 2);\n  var post3 = store.find(Post, 3);\n  var comment = store.find(Comment, 1);\n\n  transaction = store.transaction();\n\n  transaction.add(post);\n  transaction.add(comment);\n\n  post.get('comments').removeObject(comment);\n  post2.get('comments').pushObject(comment);\n  post2.get('comments').removeObject(comment);\n  post3.get('comments').pushObject(comment);\n\n  expectRelationships([{parent:post, child:comment},{parent:post3, child:comment}]);\n});\n\ntest(\"the store should have a new defaultTransaction after commit from store\", function() {\n  store.load(Post, { id: 1, title: \"Ohai\" });\n\n  var record = store.find(Post, 1);\n  var transaction = record.get('transaction');\n  var defaultTransaction = store.get('defaultTransaction');\n\n  equal(transaction, defaultTransaction, 'record is in the defaultTransaction');\n\n  store.commit();\n\n  var newDefaultTransaction = store.get('defaultTransaction');\n  transaction = record.get('transaction');\n\n  ok(defaultTransaction !== newDefaultTransaction, \"store should have a new defaultTransaction\");\n  equal(transaction, newDefaultTransaction, 'record is in the new defaultTransaction');\n});\n\ntest(\"the store should have a new defaultTransaction after commit from defaultTransaction\", function() {\n  store.load(Post, { id: 1, title: \"Ohai\" });\n\n  var record = store.find(Post, 1);\n  var transaction = record.get('transaction');\n  var defaultTransaction = store.get('defaultTransaction');\n\n  equal(transaction, defaultTransaction, 'record is in the defaultTransaction');\n\n  defaultTransaction.commit();\n\n  var newDefaultTransaction = store.get('defaultTransaction');\n  transaction = record.get('transaction');\n\n  ok(defaultTransaction !== newDefaultTransaction, \"store should have a new defaultTransaction\");\n  equal(transaction, newDefaultTransaction, 'record is in the new defaultTransaction');\n});\n\ntest(\"the store should have a new defaultTransaction after commit from record's transaction\", function() {\n  store.load(Post, { id: 1, title: \"Ohai\" });\n\n  var record = store.find(Post, 1);\n  var transaction = record.get('transaction');\n  var defaultTransaction = store.get('defaultTransaction');\n\n  equal(transaction, defaultTransaction, 'record is in the defaultTransaction');\n\n  transaction.commit();\n\n  var newDefaultTransaction = store.get('defaultTransaction');\n  transaction = record.get('transaction');\n\n  ok(defaultTransaction !== newDefaultTransaction, \"store should have a new defaultTransaction\");\n  equal(transaction, newDefaultTransaction, 'record is in the new defaultTransaction');\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/transactions/relationships_test");minispade.register('ember-data/~tests/integration/transform_test', "(function() {var Adapter, adapter, store, serializer, Person;\n\nmodule(\"Record Attribute Transforms\", {\n  setup: function() {\n    Adapter = DS.Adapter.extend();\n\n    Adapter.registerTransform('unobtainium', {\n      serialize: function(value) {\n        return 'serialize';\n      },\n\n      deserialize: function(value) {\n        return 'fromData';\n      }\n    });\n\n    adapter = Adapter.create();\n    store = DS.Store.create({\n      adapter: adapter\n    });\n    serializer = adapter.get('serializer');\n  },\n\n  teardown: function() {\n    serializer.destroy();\n    adapter.destroy();\n    store.destroy();\n  }\n});\n\ntest(\"transformed values should be materialized on the record\", function() {\n  var Person = DS.Model.extend({\n    name: DS.attr('unobtainium')\n  });\n\n  store.load(Person, { id: 1, name: \"James Cameron\" });\n\n  var person = store.find(Person, 1);\n  equal(person.get('name'), 'fromData', \"value of attribute on the record should be transformed\");\n\n  var json = adapter.serialize(person);\n  equal(json.name, \"serialize\", \"value of attribute in the JSON hash should be transformed\");\n});\n\nmodule(\"Default DS.Transforms\", {\n  setup: function() {\n    store = DS.Store.create();\n\n    Person = DS.Model.extend({\n      name: DS.attr('string'),\n      born: DS.attr('date'),\n      age: DS.attr('number'),\n      isGood: DS.attr('boolean')\n    });\n  },\n\n  teardown: function() {\n    store.destroy();\n  }\n});\n\ntest(\"the default numeric transform\", function() {\n  store.load(Person, {id: 1, age: \"51\"});\n  var person = store.find(Person, 1);\n\n  var result = (typeof person.get('age') === \"number\"); \n  equal(result, true, \"string is transformed into a number\");\n  equal(person.get('age'),51, \"string value and transformed numeric value match\");\n});\n\ntest(\"the default boolean transform\", function() {\n  store.load(Person, {id: 1, isGood: \"false\"});\n  store.load(Person, {id: 2, isGood: \"f\"});\n  store.load(Person, {id: 3, isGood: 0});\n  store.load(Person, {id: 4, isGood: false});\n\n  var personOne = store.find(Person, 1);\n  var personTwo = store.find(Person, 2);\n  var personThree = store.find(Person, 3);\n  var personFour = store.find(Person, 4);\n\n  var result = (typeof personOne.get('isGood') === \"boolean\"); \n  equal(result, true, \"string is transformed into a boolean\");\n\n  equal(personOne.get('isGood'), false, \"string value and transformed boolean value match\");\n  equal(personTwo.get('isGood'), false, \"short string value and transformed boolean value match\");\n  equal(personThree.get('isGood'), false, \"numeric value and transformed boolean value match\");\n  equal(personFour.get('isGood'), false, \"boolean value and transformed boolean value match\");\n});\n\ntest(\"the default string transform\", function() {\n  store.load(Person, {id: 1, name: 8675309});\n  var person = store.find(Person, 1);\n\n  var result = (typeof person.get('name') === \"string\"); \n  equal(result, true, \"number is transformed into a string\");\n  equal(person.get('name'), \"8675309\", \"numeric value and transformed string value match\");\n});\n\ntest(\"the default date transform\", function() {\n  var date = new Date();\n  store.load(Person, {id: 1, born: date.toString()});\n  var person = store.find(Person, 1);\n\n  var result = (person.get('born') instanceof Date); \n  equal(result, true, \"string is transformed into a date\");\n  equal(person.get('born').toString(), date.toString(), \"date.toString and transformed date.toString values match\");\n\n  var timestamp = 293810400, // 1979-04-24 @ 08:00:00\n      date2 = new Date(timestamp);\n\n  store.load(Person, {id: 2, born: timestamp});\n  var person2 = store.find(Person, 2);\n\n  var result2 = (person.get('born') instanceof Date);\n  equal(result2, true, \"timestamp is transformed into a date\");\n  equal(person2.get('born').toString(), date2.toString(), \"date.toString and transformed date.toString values match\");\n});\n\n\nmodule(\"Enum Transforms\", {\n  setup: function() {\n    adapter = DS.Adapter.create();\n    adapter.registerEnumTransform('materials', ['unobtainium', 'kindaobtainium', 'veryobtainium']);\n  \n    store = DS.Store.create({\n      adapter: adapter\n    });\n  \n    serializer = adapter.get('serializer');\n  \n    Person = DS.Model.extend({\n      material: DS.attr('materials')\n    });\n  },\n  teardown: function() {\n    serializer.destroy();\n    adapter.destroy();\n    store.destroy();\n  }\n});\n\ntest(\"correct transforms are applied\", function() {\n  var json, person;\n  store.load(Person, {\n    id: 1,\n    material: 2\n  });\n  \n  person = store.find(Person, 1);\n  equal(person.get('material'), 'veryobtainium', 'value of the attribute on the record should be transformed');\n  \n  json = adapter.serialize(person);\n  equal(json.material, 2, 'value of the attribute in the JSON hash should be transformed');\n});\n\n})();\n//@ sourceURL=ember-data/~tests/integration/transform_test");minispade.register('ember-data/~tests/unit/adapter_test', "(function() {var get = Ember.get, set = Ember.set;\nvar adapter, storeStub, Person;\n\nmodule(\"DS.Adapter\", {\n  setup: function() {\n    adapter = DS.Adapter.create();\n    Person = Ember.Object.extend();\n    storeStub = Ember.Object.create();\n  },\n\n  teardown: function() {\n    adapter.destroy();\n  }\n});\n\ntest(\"The `commit` method should call `createRecords` once per type.\", function() {\n  expect(2);\n\n  adapter.createRecords = function(store, type, set) {\n    equal(type, Person, \"the passed type is Person\");\n    equal(get(set.toArray(), 'length'), 2, 'the array is has two items');\n  };\n\n  var tom = Person.create({ name: \"Tom Dale\", updatedAt: null });\n  var yehuda = Person.create({ name: \"Yehuda Katz\" });\n\n  adapter.commit(storeStub, {\n    updated: [],\n    deleted: [],\n    created: [tom, yehuda]\n  });\n});\n\ntest(\"The `commit` method should call `updateRecords` once per type.\", function() {\n  expect(2);\n\n  adapter.updateRecords = function(store, type, set) {\n    equal(type, Person, \"the type is Person\");\n    equal(get(set.toArray(), 'length'), 2, \"the array has two items\");\n  };\n\n  var tom = Person.create({ name: \"Tom Dale\", updatedAt: null });\n  var yehuda = Person.create({ name: \"Yehuda Katz\" });\n\n  adapter.commit(storeStub, {\n    updated: [tom, yehuda],\n    deleted: [],\n    created: []\n  });\n});\n\ntest(\"The `commit` method should call `deleteRecords` once per type.\", function() {\n  expect(2);\n\n  adapter.deleteRecords = function(store, type, set) {\n    equal(type, Person, \"the type is Person\");\n    equal(get(set.toArray(), 'length'), 2, \"the array has two items\");\n  };\n\n  var tom = Person.create({ name: \"Tom Dale\", updatedAt: null });\n  var yehuda = Person.create({ name: \"Yehuda Katz\" });\n\n  adapter.commit(storeStub, {\n    updated: [],\n    deleted: [tom, yehuda],\n    created: []\n  });\n});\n\nvar serializerMock, transformsPassed;\n\nmodule(\"DS.Adapter - Transformations\", {\n  setup: function() {\n    transformsPassed = {};\n\n    serializerMock = Ember.Object.create({\n      registerTransform: function(type, transforms) {\n        transformsPassed[type] = transforms;\n      }\n    });\n  },\n\n  teardown: function() {\n    serializerMock.destroy();\n  }\n});\n\nvar contains = function(array, item, message) {\n  ok(Ember.ArrayPolyfills.indexOf.call(array, item) > -1, message);\n};\n\ntest(\"Transformations registered on an adapter class should be set on the adapter's serializer at initialization time.\", function() {\n  // Make sure that transformations on parent adapter classes are included\n  // if subclasses are created.\n\n  var Adapter = DS.Adapter.extend();\n\n  var parentUnobtainium = {\n    serialize: function(value) {\n      return 'serialize';\n    },\n\n    fromData: function(value) {\n      return 'fromData';\n    }\n  };\n\n  Adapter.registerTransform('unobtainium', parentUnobtainium);\n\n  var ChildAdapter = Adapter.extend();\n\n  var childAdamantium = {\n    serialize: function(value) {\n      return 'adamantium serialize';\n    },\n\n    fromData: function(value) {\n      return 'adamantium fromData';\n    }\n  };\n\n  ChildAdapter.registerTransform('adamantium', childAdamantium);\n\n  var parentOtherType = {\n    serialize: function(value) {\n      return 'otherType serialize';\n    },\n\n    fromData: function(value) {\n      return 'otherType fromData';\n    }\n  };\n\n  Adapter.registerTransform('otherType', parentOtherType);\n\n  ChildAdapter.create({\n    serializer: serializerMock\n  });\n\n  deepEqual(transformsPassed, {\n    unobtainium: parentUnobtainium,\n    adamantium: childAdamantium,\n    otherType: parentOtherType\n  });\n});\n\ntest(\"Transforms registered subclasses take precedence over super classes.\", function() {\n  var ParentAdapter = DS.Adapter.extend();\n  var ChildAdapter = ParentAdapter.extend();\n\n  var childUnobtainium = {\n    serialize: Ember.K,\n    fromData: Ember.K\n  };\n\n  var parentUnobtainium = {\n    serialize: Ember.K,\n    fromData: Ember.K\n  };\n\n  ChildAdapter.registerTransform('unobtainium', childUnobtainium);\n  ParentAdapter.registerTransform('unobtainium', parentUnobtainium);\n\n  ChildAdapter.create({\n    serializer: serializerMock\n  });\n\n  deepEqual(transformsPassed, {\n    unobtainium: childUnobtainium\n  });\n});\n\nvar mappingsPassed;\n\nmodule(\"DS.Adapter - Mapping\", {\n  setup: function() {\n    mappingsPassed = {};\n\n    serializerMock = Ember.Object.create({\n      map: function(type, mappings) {\n        var mappingsForType = mappingsPassed[type] = mappingsPassed[type] || {};\n\n        for (var prop in mappings) {\n          if (!mappings.hasOwnProperty(prop)) { continue; }\n\n          mappingsForType[prop] = mappings[prop];\n        }\n      }\n    });\n  },\n\n  teardown: function() {\n    serializerMock.destroy();\n  }\n});\n\ntest(\"Mappings registered on an adapter class should be set on the adapter's serializer at initialization time.\", function() {\n  var Adapter = DS.Adapter.extend();\n  var oldLookup = Ember.lookup;\n  Ember.lookup = {\n    App: {}\n  };\n\n  Ember.lookup.App.Person = Ember.Object.extend();\n\n  Adapter.map('App.Person', {\n    firstName: { key: 'FIRST_NAME' }\n  });\n\n  var ChildAdapter = Adapter.extend();\n\n  ChildAdapter.map('App.Person', {\n    lastName: { key: 'LAST_NAME' }\n  });\n\n  Adapter.map('App.Person', {\n    middleName: { key: 'MIDDLE_NAME' },\n    lastName: { key: 'SHOULD_NOT_WORK' }\n  });\n\n  ChildAdapter.create({\n    serializer: serializerMock\n  });\n\n  deepEqual(mappingsPassed, {\n    'App.Person': {\n      firstName: { key: 'FIRST_NAME' },\n      lastName: { key: 'LAST_NAME' },\n      middleName: { key: 'MIDDLE_NAME' }\n    }\n  });\n\n  Ember.lookup = oldLookup;\n});\n\n})();\n//@ sourceURL=ember-data/~tests/unit/adapter_test");minispade.register('ember-data/~tests/unit/fixture_adapter_test', "(function() {var get = Ember.get, set = Ember.set;\nvar store, Person, Phone, App;\n\nmodule(\"DS.FixtureAdapter\", {\n  setup: function() {\n    store = DS.Store.create({\n      adapter: 'DS.FixtureAdapter'\n    });\n\n    Person = DS.Model.extend({\n      firstName: DS.attr('string'),\n      lastName: DS.attr('string'),\n\n      height: DS.attr('number'),\n\n      phones: DS.hasMany('App.Phone')\n    });\n\n    Phone = DS.Model.extend({\n      person: DS.belongsTo('App.Person')\n    });\n\n    App = Ember.Namespace.create();\n    App.Person = Person;\n    App.Phone = Phone;\n    Ember.lookup.App = App;\n\n    // Enable setTimeout.\n    Ember.testing = false;\n\n    Person.FIXTURES = [];\n    Phone.FIXTURES = [];\n  },\n  teardown: function() {\n    Ember.testing = true;\n\n    Ember.run(function() {\n      store.destroy();\n      App.destroy();\n    });\n    store = null;\n    Person = null;\n    Phone = null;\n  }\n});\n\ntest(\"should load data for a type asynchronously when it is requested\", function() {\n  Person.FIXTURES = [{\n    id: 'wycats',\n    firstName: \"Yehuda\",\n    lastName: \"Katz\",\n\n    height: 65\n  },\n\n  {\n    id: 'ebryn',\n    firstName: \"Erik\",\n    lastName: \"Brynjolffsosysdfon\",\n\n    height: 70,\n    phones: [1, 2]\n  }];\n\n  Phone.FIXTURES = [{\n    id: 1,\n    person: 'ebryn'\n  }, {\n    id: 2,\n    person: 'ebryn'\n  }];\n\n  stop();\n\n  var ebryn = store.find(Person, 'ebryn');\n\n  equal(get(ebryn, 'isLoaded'), false, \"record from fixtures is returned in the loading state\");\n\n  ebryn.then(function() {\n    clearTimeout(timer);\n    start();\n\n    ok(get(ebryn, 'isLoaded'), \"data loads asynchronously\");\n    equal(get(ebryn, 'height'), 70, \"data from fixtures is loaded correctly\");\n    equal(get(ebryn, 'phones.length'), 2, \"relationships from fixtures is loaded correctly\");\n\n    stop();\n\n    var wycats = store.find(Person, 'wycats');\n    wycats.then(function() {\n      clearTimeout(timer);\n      start();\n\n      equal(get(wycats, 'isLoaded'), true, \"subsequent requests for records are returned asynchronously\");\n      equal(get(wycats, 'height'), 65, \"subsequent requested records contain correct information\");\n    });\n\n    timer = setTimeout(function() {\n      start();\n      ok(false, \"timeout exceeded waiting for fixture data\");\n    }, 1000);\n  });\n\n  var timer = setTimeout(function() {\n    start();\n    ok(false, \"timeout exceeded waiting for fixture data\");\n  }, 1000);\n});\n\ntest(\"should load data asynchronously at the end of the runloop when simulateRemoteResponse is false\", function() {\n  Person.FIXTURES = [{\n    id: 'wycats',\n    firstName: \"Yehuda\"\n  }];\n\n  store = DS.Store.create({\n    adapter: DS.FixtureAdapter.create({\n      simulateRemoteResponse: false\n    })\n  });\n\n  var wycats;\n\n  Ember.run(function() {\n    wycats = store.find(Person, 'wycats');\n    ok(!get(wycats, 'isLoaded'), 'isLoaded is false initially');\n    ok(!get(wycats, 'firstName'), 'record properties are undefined initially');\n  });\n\n  ok(get(wycats, 'isLoaded'), 'isLoaded is true after runloop finishes');\n  equal(get(wycats, 'firstName'), 'Yehuda', 'record properties are defined after runloop finishes');\n});\n\ntest(\"should create record asynchronously when it is committed\", function() {\n  stop();\n\n  equal(Person.FIXTURES.length, 0, \"Fixtures is empty\");\n\n  var paul = store.createRecord(Person, {firstName: 'Paul', lastName: 'Chavard', height: 70});\n\n  paul.on('didCreate', function() {\n    clearTimeout(timer);\n    start();\n\n    equal(get(paul, 'isNew'), false, \"data loads asynchronously\");\n    equal(get(paul, 'isDirty'), false, \"data loads asynchronously\");\n    equal(get(paul, 'height'), 70, \"data from fixtures is saved correctly\");\n\n    equal(Person.FIXTURES.length, 1, \"Record added to FIXTURES\");\n\n    var fixture = Person.FIXTURES[0];\n\n    equal(fixture.id, Ember.guidFor(paul));\n    equal(fixture.firstName, 'Paul');\n    equal(fixture.lastName, 'Chavard');\n    equal(fixture.height, 70);\n  });\n\n  store.commit();\n\n  var timer = setTimeout(function() {\n    start();\n    ok(false, \"timeout exceeded waiting for fixture data\");\n  }, 1000);\n});\n\ntest(\"should update record asynchronously when it is committed\", function() {\n  stop();\n\n  equal(Person.FIXTURES.length, 0, \"Fixtures is empty\");\n\n  var paul = store.findByClientId(Person, store.load(Person, 1, {firstName: 'Paul', lastName: 'Chavard', height: 70}).clientId);\n\n  paul.set('height', 80);\n\n  paul.on('didUpdate', function() {\n    clearTimeout(timer);\n    start();\n\n    equal(get(paul, 'isDirty'), false, \"data loads asynchronously\");\n    equal(get(paul, 'height'), 80, \"data from fixtures is saved correctly\");\n\n    equal(Person.FIXTURES.length, 1, \"Record FIXTURES updated\");\n\n    var fixture = Person.FIXTURES[0];\n\n    equal(fixture.firstName, 'Paul');\n    equal(fixture.lastName, 'Chavard');\n    equal(fixture.height, 80);\n  });\n\n  store.commit();\n\n  var timer = setTimeout(function() {\n    start();\n    ok(false, \"timeout exceeded waiting for fixture data\");\n  }, 1000);\n});\n\ntest(\"should delete record asynchronously when it is committed\", function() {\n  stop();\n\n  equal(Person.FIXTURES.length, 0, \"Fixtures empty\");\n\n  var paul = store.findByClientId(Person, store.load(Person, 1, {firstName: 'Paul', lastName: 'Chavard', height: 70}).clientId);\n\n  paul.deleteRecord();\n\n  paul.on('didDelete', function() {\n    clearTimeout(timer);\n    start();\n\n    equal(get(paul, 'isDeleted'), true, \"data deleted asynchronously\");\n    equal(get(paul, 'isDirty'), false, \"data deleted asynchronously\");\n\n    equal(Person.FIXTURES.length, 0, \"Record removed from FIXTURES\");\n  });\n\n  store.commit();\n\n  var timer = setTimeout(function() {\n    start();\n    ok(false, \"timeout exceeded waiting for fixture data\");\n  }, 1000);\n});\n\ntest(\"should follow isUpdating semantics\", function() {\n  stop();\n\n  Person.FIXTURES = [{\n    id: \"twinturbo\",\n    firstName: \"Adam\",\n    lastName: \"Hawkins\",\n    height: 65\n  }];\n\n  var result = store.findAll(Person);\n\n  result.addObserver('isUpdating', function() {\n    clearTimeout(timer);\n    start();\n    clearTimeout(timer);\n    equal(get(result, 'isUpdating'), false, \"isUpdating is set when it shouldn't be\");\n  });\n\n  var timer = setTimeout(function() {\n    start();\n    ok(false, \"timeout exceeded waiting for fixture data\");\n  }, 1000);\n});\n\ntest(\"should coerce integer ids into string\", function() {\n  stop();\n\n  Person.FIXTURES = [{\n    id: 1,\n    firstName: \"Adam\",\n    lastName: \"Hawkins\",\n    height: 65\n  }];\n\n  var result = Person.find(\"1\");\n\n  result.then(function() {\n    clearTimeout(timer);\n    start();\n    clearTimeout(timer);\n    equal(get(result, 'id'), \"1\", \"should load integer model id\");\n  });\n\n  var timer = setTimeout(function() {\n    start();\n    ok(false, \"timeout exceeded waiting for fixture data\");\n  }, 1000);\n});\n\ntest(\"should throw if ids are not defined in the FIXTURES\", function() {\n  Person.FIXTURES = [{\n    firstName: \"Adam\",\n    lastName: \"Hawkins\",\n    height: 65\n  }];\n\n  raises(function(){\n    Person.find(\"1\");\n  }, /the id property must be defined for fixture/);\n});\n\n})();\n//@ sourceURL=ember-data/~tests/unit/fixture_adapter_test");minispade.register('ember-data/~tests/unit/json_serializer_test', "(function() {var MockModel = Ember.Object.extend({\n  init: function() {\n    this.materializedAttributes = {};\n    this.hasMany = {};\n    this.belongsTo = {};\n  },\n\n  eachAttribute: function(callback, binding) {\n    var attributes = this.constructor.attributes || {};\n\n    for (var prop in attributes) {\n      if (!attributes.hasOwnProperty(prop)) { continue; }\n      callback.call(binding, prop, { type: attributes[prop] });\n    }\n  },\n\n  eachRelationship: function(callback, binding) {\n    var relationships = this.constructor.relationships;\n\n    for (var prop in relationships) {\n      if (!relationships.hasOwnProperty(prop)) { continue; }\n      callback.call(binding, prop, { key: prop, kind: relationships[prop] });\n    }\n  },\n\n  materializeId: function(id) {\n    this.materializedId = id;\n  },\n\n  materializeAttribute: function(name, value) {\n    this.materializedAttributes[name] = value;\n  },\n\n  materializeHasMany: function(name, ids) {\n    this.hasMany[name] = ids;\n  },\n\n  materializeBelongsTo: function(name, id) {\n    this.belongsTo[name] = id;\n  }\n});\n\nvar serializer, Person;\n\nmodule(\"DS.JSONSerializer - Mapping API\", {\n  setup: function() {\n    serializer = DS.JSONSerializer.create();\n    Person = MockModel.extend();\n    window.Address = MockModel.extend();\n  },\n\n  teardown: function() {\n    serializer.destroy();\n    window.Address = null;\n  }\n});\n\ntest(\"Mapped attributes should be used when serializing a record to JSON.\", function() {\n  Person.attributes = { firstName: 'string' };\n  window.Address.attributes = { firstName: 'string' };\n\n  serializer.map(Person, {\n    firstName: { key: 'FIRST_NAME' }\n  });\n\n  serializer.map('Address', {\n    firstName: { key: 'first_name' }\n  });\n\n  var person = Person.create({\n    firstName: \"Tom\"\n  });\n\n  var address = window.Address.create({\n    firstName: \"Spruce\"\n  });\n\n  deepEqual(serializer.serialize(person), {\n    FIRST_NAME: \"Tom\"\n  });\n\n  deepEqual(serializer.serialize(address), {\n    first_name: \"Spruce\"\n  });\n});\n\ntest(\"Mapped attributes should be used when materializing a record from JSON.\", function() {\n  Person.attributes = { firstName: 'string' };\n  window.Address.attributes = { firstName: 'string' };\n\n  serializer.map(Person, {\n    firstName: { key: 'FIRST_NAME' }\n  });\n\n  serializer.map('Address', {\n    firstName: { key: 'first_name' }\n  });\n\n  var person = Person.create();\n  var address = window.Address.create();\n\n  serializer.materialize(person, { FIRST_NAME: \"Tom\" });\n  serializer.materialize(address, { first_name: \"Spruce\" });\n\n  deepEqual(person.get('materializedAttributes'), { firstName: \"Tom\" });\n  deepEqual(address.get('materializedAttributes'), { firstName: \"Spruce\" });\n});\n\ntest(\"Mapped relationships should be used when serializing a record to JSON.\", function() {\n  expect(8);\n\n  Person.relationships = { addresses: 'hasMany' };\n  window.Address.relationships = { person: 'belongsTo' };\n\n  serializer.map(Person, {\n    addresses: { key: 'ADDRESSES!' }\n  });\n\n  serializer.map('Address', {\n    person: { key: 'MY_PEEP' }\n  });\n\n  var person = Person.create();\n  var address = window.Address.create();\n\n  serializer.addHasMany = function(hash, record, key, relationship) {\n    ok(typeof hash === 'object', \"a hash to build is passed\");\n    equal(record, person, \"the record to serialize should be passed\");\n    equal(key, 'ADDRESSES!', \"the key to add to the hash respects the mapping\");\n\n    // The mocked record uses a simplified relationship description\n    deepEqual(relationship, {\n      kind: 'hasMany',\n      key: 'addresses'\n    });\n  };\n\n  serializer.addBelongsTo = function(hash, record, key, relationship) {\n    ok(typeof hash === 'object', \"a hash to build is passed\");\n    equal(record, address, \"the record to serialize should be passed\");\n    equal(key, 'MY_PEEP', \"the key to add to the hash respects the mapping\");\n\n    // The mocked record uses a simplified relationship description\n    deepEqual(relationship, {\n      kind: 'belongsTo',\n      key: 'person'\n    });\n  };\n\n  serializer.serialize(person);\n  serializer.serialize(address);\n});\n\ntest(\"mapped relationships are respected when materializing a record from JSON\", function() {\n  Person.relationships = { addresses: 'hasMany' };\n  window.Address.relationships = { person: 'belongsTo' };\n\n  serializer.map(Person, {\n    addresses: { key: 'ADDRESSES!' }\n  });\n\n  serializer.map('Address', {\n    person: { key: 'MY_PEEP' }\n  });\n\n  var person = Person.create();\n  var address = window.Address.create();\n\n  serializer.materialize(person, {\n    'ADDRESSES!': [ 1, 2, 3 ]\n  });\n\n  serializer.materialize(address, {\n    'MY_PEEP': 1\n  });\n\n  deepEqual(person.hasMany, {\n    addresses: [ 1, 2, 3 ]\n  });\n\n  deepEqual(address.belongsTo, {\n    person: 1\n  });\n});\n\ntest(\"mapped primary keys are respected when serializing a record to JSON\", function() {\n  serializer.configure(Person, {\n    primaryKey: '__id__'\n  });\n\n  serializer.configure('Address', {\n    primaryKey: 'ID'\n  });\n\n  var person = Person.create({ id: 1 });\n  var address = window.Address.create({ id: 2 });\n\n  var personJSON = serializer.serialize(person, { includeId: true });\n  var addressJSON = serializer.serialize(address, { includeId: true });\n\n  deepEqual(personJSON, { __id__: 1 });\n  deepEqual(addressJSON, { ID: 2 });\n});\n\ntest(\"mapped primary keys are respected when materializing a record from JSON\", function() {\n  serializer.configure(Person, {\n    primaryKey: '__id__'\n  });\n\n  serializer.configure('Address', {\n    primaryKey: 'ID'\n  });\n\n  var person = Person.create();\n  var address = window.Address.create();\n\n  serializer.materialize(person, { __id__: 1 });\n  serializer.materialize(address, { ID: 2 });\n\n  equal(person.materializedId, 1);\n  equal(address.materializedId, 2);\n});\n\nmodule(\"DS.JSONSerializer - Transform API\", {\n  setup: function() {\n    serializer = DS.JSONSerializer.create();\n\n    serializer.registerTransform('unobtainium', {\n      serialize: function(value) {\n        return 'serialize';\n      },\n\n      deserialize: function(value) {\n        return 'deserialize';\n      }\n    });\n  },\n\n  teardown: function() {\n    serializer.destroy();\n  }\n});\n\ntest(\"registered transformations should be called when serializing and materializing records\", function() {\n  var value;\n\n  value = serializer.deserializeValue('unknown', 'unobtainium');\n  equal(value, 'deserialize', \"the deserialize transform was called\");\n\n  value = serializer.serializeValue('unknown', 'unobtainium');\n  equal(value, 'serialize', \"the serialize transform was called\");\n\n  raises(function() {\n    serializer.deserializeValue('unknown', 'obtainium');\n  });\n\n  raises(function() {\n    serializer.serializeValue('unknown', 'obtainium');\n  });\n});\n\n})();\n//@ sourceURL=ember-data/~tests/unit/json_serializer_test");minispade.register('ember-data/~tests/unit/model_test', "(function() {var get = Ember.get, set = Ember.set;\n\nvar Person, store, array;\n\nvar testSerializer = DS.JSONSerializer.create({\n  primaryKey: function() {\n    return 'id';\n  }\n});\n\nvar TestAdapter = DS.Adapter.extend({\n  serializer: testSerializer\n});\n\nmodule(\"DS.Model\", {\n  setup: function() {\n    store = DS.Store.create({\n      adapter: TestAdapter.create()\n    });\n\n    Person = DS.Model.extend({\n      name: DS.attr('string'),\n      isDrugAddict: DS.attr('boolean')\n    });\n  },\n\n  teardown: function() {\n    Person = null;\n    store = null;\n  }\n});\n\ntest(\"can have a property set on it\", function() {\n  var record = store.createRecord(Person);\n  set(record, 'name', 'bar');\n\n  equal(get(record, 'name'), 'bar', \"property was set on the record\");\n});\n\ntest(\"setting a property on a record that has not changed does not cause it to become dirty\", function() {\n  store.load(Person, { id: 1, name: \"Peter\", isDrugAddict: true });\n  var person = store.find(Person, 1);\n\n  equal(person.get('isDirty'), false, \"precond - person record should not be dirty\");\n  person.set('name', \"Peter\");\n  person.set('isDrugAddict', true);\n  equal(person.get('isDirty'), false, \"record does not become dirty after setting property to old value\");\n});\n\ntest(\"a record reports its unique id via the `id` property\", function() {\n  store.load(Person, { id: 1 });\n\n  var record = store.find(Person, 1);\n  equal(get(record, 'id'), 1, \"reports id as id by default\");\n});\n\ntest(\"a record's id is included in its toString represenation\", function() {\n  store.load(Person, { id: 1 });\n\n  var record = store.find(Person, 1);\n  equal(record.toString(), '<(subclass of DS.Model):'+Ember.guidFor(record)+':1>', \"reports id in toString\");\n});\n\ntest(\"trying to set an `id` attribute should raise\", function() {\n  Person = DS.Model.extend({\n    id: DS.attr('number'),\n    name: \"Scumdale\"\n  });\n\n  raises(function() {\n    store.load(Person, { id: 1, name: \"Scumdale\" });\n    var person = store.find(Person, 1);\n    person.get('name');\n  }, /You may not set `id`/);\n});\n\ntest(\"it should cache attributes\", function() {\n  var store = DS.Store.create();\n\n  var Post = DS.Model.extend({\n    updatedAt: DS.attr('string')\n  });\n\n  var dateString = \"Sat, 31 Dec 2011 00:08:16 GMT\";\n  var date = new Date(dateString);\n\n  store.load(Post, { id: 1 });\n\n  var record = store.find(Post, 1);\n\n  record.set('updatedAt', date);\n  deepEqual(date, get(record, 'updatedAt'), \"setting a date returns the same date\");\n  strictEqual(get(record, 'updatedAt'), get(record, 'updatedAt'), \"second get still returns the same object\");\n});\n\nmodule(\"DS.Model updating\", {\n  setup: function() {\n    array = [{ id: 1, name: \"Scumbag Dale\" }, { id: 2, name: \"Scumbag Katz\" }, { id: 3, name: \"Scumbag Bryn\" }];\n    Person = DS.Model.extend({ name: DS.attr('string') });\n    store = DS.Store.create();\n    store.loadMany(Person, array);\n  },\n  teardown: function() {\n    Person = null;\n    store = null;\n    array = null;\n  }\n});\n\ntest(\"a DS.Model can update its attributes\", function() {\n  var person = store.find(Person, 2);\n\n  set(person, 'name', \"Brohuda Katz\");\n  equal(get(person, 'name'), \"Brohuda Katz\", \"setting took hold\");\n});\n\ntest(\"a DS.Model can have a defaultValue\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string', { defaultValue: \"unknown\" })\n  });\n\n  var tag = Tag.createRecord();\n\n  equal(get(tag, 'name'), \"unknown\", \"the default value is found\");\n\n  set(tag, 'name', null);\n\n  equal(get(tag, 'name'), null, \"null doesn't shadow defaultValue\");\n});\n\ntest(\"when a DS.Model updates its attributes, its changes affect its filtered Array membership\", function() {\n  var people = store.filter(Person, function(hash) {\n    if (hash.get('name').match(/Katz$/)) { return true; }\n  });\n\n  equal(get(people, 'length'), 1, \"precond - one item is in the RecordArray\");\n\n  var person = people.objectAt(0);\n\n  equal(get(person, 'name'), \"Scumbag Katz\", \"precond - the item is correct\");\n\n  set(person, 'name', \"Yehuda Katz\");\n\n  equal(get(people, 'length'), 1, \"there is still one item\");\n  equal(get(person, 'name'), \"Yehuda Katz\", \"it has the updated item\");\n\n  set(person, 'name', \"Yehuda Katz-Foo\");\n\n  equal(get(people, 'length'), 0, \"there are now no items\");\n});\n\nmodule(\"with a simple Person model\", {\n  setup: function() {\n    array = [{ id: 1, name: \"Scumbag Dale\" }, { id: 2, name: \"Scumbag Katz\" }, { id: 3, name: \"Scumbag Bryn\" }];\n    Person = DS.Model.extend({\n      name: DS.attr('string')\n    });\n    store = DS.Store.create();\n    store.loadMany(Person, array);\n  },\n  teardown: function() {\n    Person = null;\n    store = null;\n    array = null;\n  }\n});\n\ntest(\"when a DS.Model updates its attributes, its changes affect its filtered Array membership\", function() {\n  var people = store.filter(Person, function(hash) {\n    if (hash.get('name').match(/Katz$/)) { return true; }\n  });\n\n  equal(get(people, 'length'), 1, \"precond - one item is in the RecordArray\");\n\n  var person = people.objectAt(0);\n\n  equal(get(person, 'name'), \"Scumbag Katz\", \"precond - the item is correct\");\n\n  set(person, 'name', \"Yehuda Katz\");\n\n  equal(get(people, 'length'), 1, \"there is still one item\");\n  equal(get(person, 'name'), \"Yehuda Katz\", \"it has the updated item\");\n\n  set(person, 'name', \"Yehuda Katz-Foo\");\n\n  equal(get(people, 'length'), 0, \"there are now no items\");\n});\n\ntest(\"can ask if record with a given id is loaded\", function() {\n  equal(store.recordIsLoaded(Person, 1), true, 'should have person with id 1');\n  equal(store.recordIsLoaded(Person, 4), false, 'should not have person with id 2');\n});\n\ntest(\"a listener can be added to a record\", function() {\n  var count = 0;\n  var F = function() { count++; };\n  var record = store.createRecord(Person);\n\n  record.on('event!', F);\n  record.trigger('event!');\n\n  equal(count, 1, \"the event was triggered\");\n\n  record.trigger('event!');\n\n  equal(count, 2, \"the event was triggered\");\n});\n\ntest(\"when an event is triggered on a record the method with the same name is invoked with arguments\", function(){\n  var count = 0;\n  var F = function() { count++; };\n  var record = store.createRecord(Person);\n\n  record.eventNamedMethod = F;\n\n  record.trigger('eventNamedMethod');\n\n  equal(count, 1, \"the corresponding method was called\");\n});\n\ntest(\"when a method is invoked from an event with the same name the arguments are passed through\", function(){\n  var eventMethodArgs = null;\n  var F = function() { eventMethodArgs = arguments; };\n  var record = store.createRecord(Person);\n\n  record.eventThatTriggersMethod = F;\n\n  record.trigger('eventThatTriggersMethod', 1, 2);\n\n  equal( eventMethodArgs[0], 1);\n  equal( eventMethodArgs[1], 2);\n});\n\nvar converts = function(type, provided, expected) {\n  var testStore = DS.Store.create();\n\n  var Model = DS.Model.extend({\n    name: DS.attr(type)\n  });\n\n  testStore.load(Model, { id: 1, name: provided });\n  testStore.load(Model, { id: 2 });\n\n  var record = testStore.find(Model, 1);\n  deepEqual(get(record, 'name'), expected, type + \" coerces \" + provided + \" to \" + expected);\n\n  // See: Github issue #421\n  // record = testStore.find(Model, 2);\n  // set(record, 'name', provided);\n  // deepEqual(get(record, 'name'), expected, type + \" coerces \" + provided + \" to \" + expected);\n};\n\nvar convertsFromServer = function(type, provided, expected) {\n  var testStore = DS.Store.create();\n\n  var Model = DS.Model.extend({\n    name: DS.attr(type)\n  });\n\n  testStore.load(Model, { id: 1, name: provided });\n  var record = testStore.find(Model, 1);\n\n  deepEqual(get(record, 'name'), expected, type + \" coerces \" + provided + \" to \" + expected);\n};\n\nvar convertsWhenSet = function(type, provided, expected) {\n  var testStore = DS.Store.create();\n\n  var Model = DS.Model.extend({\n    name: DS.attr(type)\n  });\n\n  testStore.load(Model, { id: 2 });\n  var record = testStore.find(Model, 2);\n\n  set(record, 'name', provided);\n  deepEqual(record.serialize().name, expected, type + \" saves \" + provided + \" as \" + expected);\n};\n\ntest(\"a DS.Model can describe String attributes\", function() {\n  converts('string', \"Scumbag Tom\", \"Scumbag Tom\");\n  converts('string', 1, \"1\");\n  converts('string', null, null);\n  converts('string', undefined, null);\n  convertsFromServer('string', undefined, null);\n});\n\ntest(\"a DS.Model can describe Number attributes\", function() {\n  converts('number', \"1\", 1);\n  converts('number', \"0\", 0);\n  converts('number', 1, 1);\n  converts('number', 0, 0);\n  converts('number', null, null);\n  converts('number', undefined, null);\n  converts('number', true, 1);\n  converts('number', false, 0);\n});\n\ntest(\"a DS.Model can describe Boolean attributes\", function() {\n  converts('boolean', \"1\", true);\n  converts('boolean', \"\", false);\n  converts('boolean', 1, true);\n  converts('boolean', 0, false);\n  converts('boolean', null, false);\n  converts('boolean', true, true);\n  converts('boolean', false, false);\n});\n\ntest(\"a DS.Model can describe Date attributes\", function() {\n  converts('date', null, null);\n  converts('date', undefined, undefined);\n\n  var dateString = \"Sat, 31 Dec 2011 00:08:16 GMT\";\n  var date = new Date(dateString);\n\n  var store = DS.Store.create();\n\n  var Person = DS.Model.extend({\n    updatedAt: DS.attr('date')\n  });\n\n  store.load(Person, { id: 1 });\n  var record = store.find(Person, 1);\n\n  record.set('updatedAt', date);\n  deepEqual(date, get(record, 'updatedAt'), \"setting a date returns the same date\");\n  convertsFromServer('date', dateString, date);\n  convertsWhenSet('date', date, dateString);\n});\n\ntest(\"don't allow setting\", function(){\n  var store = DS.Store.create();\n\n  var Person = DS.Model.extend();\n  var record = store.createRecord(Person);\n\n  raises(function(){\n    record.set('isLoaded', true);\n  }, \"raised error when trying to set an unsettable record\");\n});\n\n})();\n//@ sourceURL=ember-data/~tests/unit/model_test");minispade.register('ember-data/~tests/unit/record_array_test', "(function() {var get = Ember.get, set = Ember.set;\nvar Person;\n\nmodule(\"DS.RecordArray\");\n\nvar array;\n\nmodule(\"DS.Store\", {\n  setup: function() {\n    array = [{ id: '1', name: \"Scumbag Dale\" }, { id: '2', name: \"Scumbag Katz\" }, { id: '3', name: \"Scumbag Bryn\" }];\n    var App = Ember.Namespace.create({ name: \"App\" });\n\n    App.Person = Person = DS.Model.extend({\n      name: DS.attr('string')\n    });\n  },\n\n  teardown: function() {\n    Person = null;\n    set(DS, 'defaultStore', null);\n  }\n});\n\ntest(\"a record array is backed by records\", function() {\n  var store = DS.Store.create();\n  store.loadMany(Person, [1,2,3], array);\n\n  var recordArray = store.findMany(Person, [1,2,3]);\n\n  for (var i=0, l=get(array, 'length'); i<l; i++) {\n    deepEqual(recordArray.objectAt(i).getProperties('id', 'name'), array[i], \"a record array materializes objects on demand\");\n  }\n});\n\ntest(\"a loaded record is removed from a record array when it is deleted\", function() {\n  var store = DS.Store.create();\n\n  var Tag = DS.Model.extend({\n    people: DS.hasMany(Person)\n  });\n\n  Person.reopen({\n    tag: DS.belongsTo(Tag)\n  });\n\n  store.loadMany(Person, [1,2,3], array);\n  store.load(Tag, { id: 1 });\n\n  var scumbag = store.find(Person, 1);\n  var tag = store.find(Tag, 1);\n\n  tag.get('people').addObject(scumbag);\n  equal(get(scumbag, 'tag'), tag, \"precond - the scumbag's tag has been set\");\n\n  var recordArray = tag.get('people');\n\n  equal(get(recordArray, 'length'), 1, \"precond - record array has one item\");\n  equal(get(recordArray.objectAt(0), 'name'), \"Scumbag Dale\", \"item at index 0 is record with id 1\");\n\n  scumbag.deleteRecord();\n\n  equal(get(recordArray, 'length'), 0, \"record is removed from the record array\");\n});\n\n// GitHub Issue #168\ntest(\"a newly created record is removed from a record array when it is deleted\", function() {\n  var store = DS.Store.create(),\n      recordArray;\n\n  recordArray = store.all(Person);\n\n  var scumbag = store.createRecord(Person, {\n    name: \"Scumbag Dale\"\n  });\n\n  equal(get(recordArray, 'length'), 1, \"precond - record array already has the first created item\");\n\n  // guarantee coalescence\n  Ember.run(function() {\n    store.createRecord(Person, { name: 'p1'});\n    store.createRecord(Person, { name: 'p2'});\n    store.createRecord(Person, { name: 'p3'});\n  });\n\n  equal(get(recordArray, 'length'), 4, \"precond - record array has the created item\");\n  equal(get(recordArray.objectAt(0), 'name'), \"Scumbag Dale\", \"item at index 0 is record with id 1\");\n\n  scumbag.deleteRecord();\n\n  equal(get(recordArray, 'length'), 3, \"record is removed from the record array\");\n});\n\ntest(\"a record array returns undefined when asking for a member outside of its content Array's range\", function() {\n  var store = DS.Store.create();\n\n  store.loadMany(Person, array);\n\n  var recordArray = store.all(Person);\n\n  strictEqual(recordArray.objectAt(20), undefined, \"objects outside of the range just return undefined\");\n});\n\n// This tests for a bug in the recordCache, where the records were being cached in the incorrect order.\ntest(\"a record array should be able to be enumerated in any order\", function() {\n  var store = DS.Store.create();\n  store.loadMany(Person, [1,2,3], array);\n\n  var recordArray = store.all(Person);\n\n  equal(get(recordArray.objectAt(2), 'id'), 3, \"should retrieve correct record at index 2\");\n  equal(get(recordArray.objectAt(1), 'id'), 2, \"should retrieve correct record at index 1\");\n  equal(get(recordArray.objectAt(0), 'id'), 1, \"should retrieve correct record at index 0\");\n});\n\nvar shouldContain = function(array, item) {\n  ok(array.indexOf(item) !== -1, \"array should contain \"+item.get('name'));\n};\n\nvar shouldNotContain = function(array, item) {\n  ok(array.indexOf(item) === -1, \"array should not contain \"+item.get('name'));\n};\n\ntest(\"an AdapterPopulatedRecordArray knows if it's loaded or not\", function() {\n  expect(2);\n\n  var store = DS.Store.create({\n    adapter: DS.Adapter.extend({\n      findQuery: function(store, type, query, recordArray) {\n        stop();\n\n        var self = this;\n\n        setTimeout(function() {\n          Ember.run(function() {\n            self.didFindQuery(store, type, { persons: array }, recordArray);\n            equal(get(people, 'isLoaded'), true, \"The array is now loaded\");\n            start();\n          });\n        }, 100);\n      }\n    })\n  });\n\n  var people = store.find(Person, { page: 1 });\n  equal(get(people, 'isLoaded'), false, \"The array is not yet loaded\");\n});\n\ntest(\"a record array that backs a collection view functions properly\", function() {\n\n  var store = DS.Store.create();\n\n  store.load(Person, 5, { name: \"Other Katz\" });\n\n  var container = Ember.CollectionView.create({\n    content: store.all(Person)\n  });\n\n  container.appendTo('#qunit-fixture');\n\n  function compareArrays() {\n    var recordArray = container.content;\n    var content = recordArray.get('content');\n    for(var i = 0; i < content.length; i++) {\n      var clientId = content.objectAt(i).clientId;\n      var record = store.findByClientId(get(recordArray, 'type'), clientId);\n      equal(record && record.clientId, clientId, \"The entries in the record cache should have matching client ids.\");\n    }\n  }\n\n  compareArrays();\n\n  store.load(Person, 6, { name: \"Scumbag Demon\" });\n\n  compareArrays();\n\n  store.load(Person, 7, { name: \"Lord British\" });\n\n  compareArrays();\n\n  container.destroy();\n\n});\n\n\n})();\n//@ sourceURL=ember-data/~tests/unit/record_array_test");minispade.register('ember-data/~tests/unit/relationships_test', "(function() {/*global Tag App*/\n\nvar get = Ember.get, set = Ember.set;\n\nmodule(\"DS.Model\");\n\ntest(\"exposes a hash of the relationships on a model\", function() {\n  var Occupation = DS.Model.extend();\n\n  var Person = DS.Model.extend({\n    occupations: DS.hasMany(Occupation)\n  });\n\n  Person.reopen({\n    people: DS.hasMany(Person),\n    parent: DS.belongsTo(Person)\n  });\n\n  var relationships = get(Person, 'relationships');\n  deepEqual(relationships.get(Person), [\n    { name: \"people\", kind: \"hasMany\" },\n    { name: \"parent\", kind: \"belongsTo\" }\n  ]);\n\n  deepEqual(relationships.get(Occupation), [\n    { name: \"occupations\", kind: \"hasMany\" }\n  ]);\n});\n\nmodule(\"DS.hasMany\");\n\ntest(\"hasMany lazily loads relationships as needed\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Pet = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany(Tag),\n    pets: DS.hasMany(Pet)\n  });\n\n  Tag.reopen({\n    person: DS.belongsTo(Person)\n  });\n\n  Pet.reopen({\n    person: DS.belongsTo(Person)\n  });\n\n  var store = DS.Store.create({\n    adapter: DS.Adapter.create({\n      find: function(store, type, id) {\n        if (type === Tag && id === '12') {\n          store.load(type, 12, {\n            id: 12,\n            name: \"oohlala\"\n          });\n        } else {\n          ok(false, \"find() should not be called with these values\");\n        }\n      }\n    })\n  });\n  store.loadMany(Tag, [5, 2], [{ id: 5, name: \"friendly\" }, { id: 2, name: \"smarmy\" }]);\n  store.loadMany(Pet, [4, 7, 12], [{ id: 4, name: \"fluffy\" }, { id: 7, name: \"snowy\" }, { id: 12, name: \"cerberus\" }]);\n  store.load(Person, 1, { id: 1, name: \"Tom Dale\", tags: [5] });\n  store.load(Person, 2, { id: 2, name: \"Yehuda Katz\", tags: [12] });\n\n  var person = store.find(Person, 1);\n  equal(get(person, 'name'), \"Tom Dale\", \"precond - retrieves person record from store\");\n\n  var tags = get(person, 'tags');\n  equal(get(tags, 'length'), 1, \"the list of tags should have the correct length\");\n  equal(get(tags.objectAt(0), 'name'), \"friendly\", \"the first tag should be a Tag\");\n\n  store.load(Person, 1, { id: 1, name: \"Tom Dale\", tags: [5, 2] });\n  equal(tags, get(person, 'tags'), \"a relationship returns the same object every time\");\n  equal(get(get(person, 'tags'), 'length'), 2, \"the length is updated after new data is loaded\");\n\n  strictEqual(get(person, 'tags').objectAt(0), get(person, 'tags').objectAt(0), \"the returned object is always the same\");\n  strictEqual(get(person, 'tags').objectAt(0), store.find(Tag, 5), \"relationship objects are the same as objects retrieved directly\");\n\n  var wycats = store.find(Person, 2);\n  equal(get(wycats, 'name'), \"Yehuda Katz\", \"precond - retrieves person record from store\");\n\n  equal(get(wycats, 'tags.length'), 1, \"the list of tags should have the correct length\");\n  equal(get(get(wycats, 'tags').objectAt(0), 'name'), \"oohlala\", \"the first tag should be a Tag\");\n\n  strictEqual(get(wycats, 'tags').objectAt(0), get(wycats, 'tags').objectAt(0), \"the returned object is always the same\");\n  strictEqual(get(wycats, 'tags').objectAt(0), store.find(Tag, 12), \"relationship objects are the same as objects retrieved directly\");\n\n  store.load(Person, 3, { id: 3, name: \"KSelden\" });\n  var kselden = store.find(Person, 3);\n\n  equal(get(get(kselden, 'tags'), 'length'), 0, \"a relationship that has not been supplied returns an empty array\");\n\n  store.load(Person, 4, { id: 4, name: \"Cyvid Hamluck\", pets: [4] });\n  var cyvid = store.find(Person, 4);\n  equal(get(cyvid, 'name'), \"Cyvid Hamluck\", \"precond - retrieves person record from store\");\n\n  var pets = get(cyvid, 'pets');\n  equal(get(pets, 'length'), 1, \"the list of pets should have the correct length\");\n  equal(get(pets.objectAt(0), 'name'), \"fluffy\", \"the first pet should be correct\");\n\n  store.load(Person, 4, { id: 4, name: \"Cyvid Hamluck\", pets: [4, 12] });\n  equal(pets, get(cyvid, 'pets'), \"a relationship returns the same object every time\");\n  equal(get(get(cyvid, 'pets'), 'length'), 2, \"the length is updated after new data is loaded\");\n\n  var newTag = store.createRecord(Tag);\n  get(wycats, 'tags').pushObject(newTag);\n});\n\ntest(\"should be able to retrieve the type for a hasMany relationship from its metadata\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany(Tag)\n  });\n\n  equal(Person.typeForRelationship('tags'), Tag, \"returns the relationship type\");\n});\n\ntest(\"should be able to retrieve the type for a hasMany relationship specified using a string from its metadata\", function() {\n  window.Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany('Tag')\n  });\n\n  equal(Person.typeForRelationship('tags'), Tag, \"returns the relationship type\");\n});\n\ntest(\"should be able to retrieve the type for a belongsTo relationship from its metadata\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.belongsTo(Tag)\n  });\n\n  equal(Person.typeForRelationship('tags'), Tag, \"returns the relationship type\");\n});\n\ntest(\"should be able to retrieve the type for a belongsTo relationship specified using a string from its metadata\", function() {\n  window.Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.belongsTo('Tag')\n  });\n\n  equal(Person.typeForRelationship('tags'), Tag, \"returns the relationship type\");\n});\n\ntest(\"relationships work when declared with a string path\", function() {\n  window.App = {};\n\n  App.Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany('App.Tag')\n  });\n\n  App.Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var store = DS.Store.create();\n  store.loadMany(App.Tag, [5, 2, 12], [{ id: 5, name: \"friendly\" }, { id: 2, name: \"smarmy\" }, { id: 12, name: \"oohlala\" }]);\n  store.load(App.Person, 1, { id: 1, name: \"Tom Dale\", tag_ids: [5, 2] });\n\n  var person = store.find(App.Person, 1);\n  equal(get(person, 'name'), \"Tom Dale\", \"precond - retrieves person record from store\");\n\n  equal(get(person, 'tags.length'), 2, \"the list of tags should have the correct length\");\n});\n\ntest(\"relationships work when the data hash has not been loaded\", function() {\n  expect(13);\n\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  Tag.toString = function() { return \"Tag\"; };\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany(Tag)\n  });\n\n  Person.toString = function() { return \"Person\"; };\n\n  Tag.reopen({\n    person: DS.belongsTo(Person)\n  });\n\n  var store = DS.Store.create({\n    adapter: DS.Adapter.create({\n      findMany: function(store, type, ids) {\n        equal(type, Tag, \"type should be Tag\");\n        deepEqual(ids, ['5', '2'], \"ids should be 5 and 2\");\n\n        stop();\n\n        setTimeout(function() {\n          start();\n          store.loadMany(type, ids, [{ id: 5, name: \"friendly\" }, { id: 2, name: \"smarmy\" }]);\n\n          equal(get(person, 'name'), \"Tom Dale\", \"precond - the person is still Tom Dale\");\n          equal(get(person, 'tags.length'), 2, \"the tags object still exists\");\n          equal(get(get(person, 'tags').objectAt(0), 'name'), \"friendly\", \"Tom Dale is now friendly\");\n          equal(get(get(person, 'tags').objectAt(0), 'isLoaded'), true, \"Tom Dale is now loaded\");\n        }, 1);\n      },\n\n      find: function(store, type, id) {\n        equal(type, Person, \"type should be Person\");\n        equal(id, 1, \"id should be 1\");\n\n        stop();\n\n        setTimeout(function() {\n          start();\n          store.load(type, id, { id: 1, name: \"Tom Dale\", tags: [5, 2] });\n\n          equal(get(person, 'name'), \"Tom Dale\", \"The person is now populated\");\n          equal(get(person, 'tags.length'), 2, \"the tags Array already exists\");\n          equal(get(get(person, 'tags').objectAt(0), 'isLoaded'), false, \"the tag objects exist, but are not yet loaded\");\n        }, 1);\n      }\n    })\n  });\n\n  var person = store.find(Person, 1);\n\n  equal(get(person, 'isLoaded'), false, \"isLoaded should be false\");\n  equal(get(person, 'tags.length'), 0, \"tags should be empty\");\n});\n\ntest(\"it is possible to add a new item to a relationship\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany(Tag)\n  });\n\n  Tag.reopen({\n    people: DS.belongsTo(Person)\n  });\n\n  var store = DS.Store.create();\n\n  store.load(Person, { id: 1, name: \"Tom Dale\", tag_ids: [ 1 ] });\n  store.load(Tag, { id: 1, name: \"ember\" });\n\n  var person = store.find(Person, 1);\n  var tag = get(person, 'tags').objectAt(0);\n\n  equal(get(tag, 'name'), \"ember\", \"precond - relationships work\");\n\n  tag = store.createRecord(Tag, { name: \"js\" });\n  get(person, 'tags').pushObject(tag);\n\n  equal(get(person, 'tags').objectAt(1), tag, \"newly added relationship works\");\n});\n\ntest(\"it is possible to remove an item from a relationship\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany(Tag)\n  });\n\n  Tag.reopen({\n    person: DS.belongsTo(Person)\n  });\n\n  var store = DS.Store.create();\n\n  store.load(Person, { id: 1, name: \"Tom Dale\", tag_ids: [ 1 ] });\n  store.load(Tag, { id: 1, name: \"ember\" });\n\n  var person = store.find(Person, 1);\n  var tag = get(person, 'tags').objectAt(0);\n\n  equal(get(tag, 'name'), \"ember\", \"precond - relationships work\");\n\n  get(person, 'tags').removeObject(tag);\n\n  equal(get(person, 'tags.length'), 0, \"object is removed from the relationship\");\n});\n\ntest(\"it is possible to add an item to a relationship, remove it, then add it again\", function() {\n  var Tag = DS.Model.extend();\n  var Person = DS.Model.extend();\n\n  Tag.reopen({\n    name: DS.attr('string'),\n    person: DS.belongsTo(Person)\n  });\n  Person.reopen({\n    name: DS.attr('string'),\n    tags: DS.hasMany(Tag)\n  });\n  Tag.toString = function() { return \"App.Tag\"; };\n  Person.toString = function() { return \"App.Person\"; };\n\n  var store = DS.Store.create();\n\n  var person = store.createRecord(Person);\n  var tag1 = store.createRecord(Tag);\n  var tag2 = store.createRecord(Tag);\n  var tag3 = store.createRecord(Tag);\n\n  var tags = get(person, 'tags');\n\n  tags.pushObjects([tag1, tag2, tag3]);\n  tags.removeObject(tag2);\n  equal(tags.objectAt(0), tag1);\n  equal(tags.objectAt(1), tag3);\n  equal(get(person, 'tags.length'), 2, \"object is removed from the relationship\");\n\n  tags.insertAt(0, tag2);\n  equal(get(person, 'tags.length'), 3, \"object is added back to the relationship\");\n  equal(tags.objectAt(0), tag2);\n  equal(tags.objectAt(1), tag1);\n  equal(tags.objectAt(2), tag3);\n});\n\nmodule(\"RecordArray\");\n\ntest(\"updating the content of a RecordArray updates its content\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var store = DS.Store.create();\n  var references = store.loadMany(Tag, [5, 2, 12], [{ id: 5, name: \"friendly\" }, { id: 2, name: \"smarmy\" }, { id: 12, name: \"oohlala\" }]);\n\n  var tags = DS.RecordArray.create({ content: Ember.A(references.slice(0, 2)), store: store, type: Tag });\n\n  var tag = tags.objectAt(0);\n  equal(get(tag, 'name'), \"friendly\", \"precond - we're working with the right tags\");\n\n  set(tags, 'content', Ember.A(references.slice(1, 3)));\n  tag = tags.objectAt(0);\n  equal(get(tag, 'name'), \"smarmy\", \"the lookup was updated\");\n});\n\ntest(\"can create child record from a hasMany relationship\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tags: DS.hasMany(Tag)\n  });\n\n  Tag.reopen({\n    person: DS.belongsTo(Person)\n  });\n\n  var store = DS.Store.create();\n  store.load(Person, 1, { id: 1, name: \"Tom Dale\"});\n\n  var person = store.find(Person, 1);\n  person.get(\"tags\").createRecord({name:\"cool\"});\n\n  equal(get(person, 'name'), \"Tom Dale\", \"precond - retrieves person record from store\");\n  equal(get(person, 'tags.length'), 1, \"tag is added to the parent record\");\n  equal(get(person, 'tags').objectAt(0).get(\"name\"), \"cool\", \"tag values are passed along\");\n});\n\nmodule(\"DS.belongsTo\");\n\ntest(\"belongsTo lazily loads relationships as needed\", function() {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n  Tag.toString = function() { return \"Tag\"; };\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tag: DS.belongsTo(Tag)\n  });\n  Person.toString = function() { return \"Person\"; };\n\n  Tag.reopen({\n    people: DS.hasMany(Person)\n  });\n\n  var store = DS.Store.create({ adapter: 'DS.Adapter' });\n  store.loadMany(Tag, [5, 2, 12], [{ id: 5, name: \"friendly\" }, { id: 2, name: \"smarmy\" }, { id: 12, name: \"oohlala\" }]);\n  store.load(Person, 1, { id: 1, name: \"Tom Dale\", tag: 5 });\n\n  var person = store.find(Person, 1);\n  equal(get(person, 'name'), \"Tom Dale\", \"precond - retrieves person record from store\");\n\n  equal(get(person, 'tag') instanceof Tag, true, \"the tag property should return a tag\");\n  equal(get(person, 'tag.name'), \"friendly\", \"the tag shuld have name\");\n\n  strictEqual(get(person, 'tag'), get(person, 'tag'), \"the returned object is always the same\");\n  strictEqual(get(person, 'tag'), store.find(Tag, 5), \"relationship object is the same as object retrieved directly\");\n});\n\ntest(\"relationships work when the data hash has not been loaded\", function() {\n  expect(12);\n\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tag: DS.belongsTo(Tag)\n  });\n\n  var store = DS.Store.create({\n    adapter: DS.Adapter.create({\n      find: function(store, type, id) {\n        if (type === Person) {\n          equal(type, Person, \"type should be Person\");\n          equal(id, 1, \"id should be 1\");\n\n          stop();\n\n          setTimeout(function() {\n            start();\n            store.load(type, id, { id: 1, name: \"Tom Dale\", tag: 2 });\n\n            equal(get(person, 'name'), \"Tom Dale\", \"The person is now populated\");\n            equal(get(person, 'tag') instanceof Tag, true, \"the tag Model already exists\");\n            equal(get(person, 'tag.isLoaded'), false, \"the tag objects exist, but are not yet loaded\");\n          }, 1);\n        } else if (type === Tag) {\n          equal(type, Tag, \"type should be Tag\");\n          equal(id, 2, \"id should be 2\");\n\n          stop();\n\n          setTimeout(function() {\n            start();\n            store.load(type, 2, { id: 2, name: \"friendly\" });\n\n            equal(get(person, 'name'), \"Tom Dale\", \"precond - the person is still Tom Dale\");\n            equal(get(person, 'tag.name'), \"friendly\", \"Tom Dale is now friendly\");\n            equal(get(person, 'tag.isLoaded'), true, \"Tom Dale is now loaded\");\n          }, 1);\n        }\n      }\n    })\n  });\n\n  var person = store.find(Person, 1);\n\n  equal(get(person, 'isLoaded'), false, \"isLoaded should be false\");\n  equal(get(person, 'tag'), null, \"tag should be null\");\n});\n\ntest(\"calling createRecord and passing in an undefined value for a relationship should be treated as if null\", function () {\n  var Tag = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    tag: DS.belongsTo(Tag),\n  });\n\n  Tag.reopen({\n    person: DS.belongsTo(Person)\n  });\n\n  var store = DS.Store.create();\n\n  store.createRecord(Person, {id: 1, tag: undefined});\n\n  var person = store.find(Person, 1);\n\n  strictEqual(person.get('tag'), null, \"undefined values should return null relationships\");\n});\n\ntest(\"findMany is passed the owner record for adapters when some of the object graph is already loaded\", function() {\n  var Occupation = DS.Model.extend({\n    description: DS.attr('string')\n  });\n\n  Occupation.toString = function() { return \"Occupation\"; };\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    occupations: DS.hasMany(Occupation)\n  });\n\n  Person.toString = function() { return \"Person\"; };\n\n  Occupation.reopen({\n    person: DS.belongsTo(Person)\n  });\n\n  var store = DS.Store.create({\n    adapter: DS.Adapter.create({\n      findMany: function(store, type, ids, owner) {\n        equal(type, Occupation, \"type should be Occupation\");\n        deepEqual(ids, ['5', '2'], \"ids should be 5 and 2\");\n        equal(get(owner, 'id'), 1, \"the owner record id should be 1\");\n\n        stop();\n\n        setTimeout(function() {\n          start();\n          store.loadMany(type, ids, [{ id: 5, description: \"fifth\" }, { id: 2, description: \"second\" }]);\n\n          equal(get(person, 'name'), \"Tom Dale\", \"the person is still Tom Dale\");\n          equal(get(person, 'occupations.length'), 2, \"the occupation objects still exist\");\n          equal(get(get(person, 'occupations').objectAt(0), 'description'), \"fifth\", \"the occupation is the fifth\");\n          equal(get(get(person, 'occupations').objectAt(0), 'isLoaded'), true, \"the occupation is now loaded\");\n        }, 1);\n      }\n    })\n  });\n\n  store.load(Person, 1, { id: 1, name: \"Tom Dale\", occupations: [5, 2] });\n\n  var person = store.find(Person, 1);\n\n  equal(get(person, 'isLoaded'), true, \"isLoaded should be true\");\n  equal(get(person, 'occupations.length'), 2, \"the list of occupations should have the correct length\");\n\n});\n\ntest(\"findMany is passed the owner record for adapters when none of the object graph is loaded\", function() {\n  var Occupation = DS.Model.extend({\n    description: DS.attr('string')\n  });\n\n  Occupation.toString = function() { return \"Occupation\"; };\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n    occupations: DS.hasMany(Occupation)\n  });\n\n  Person.toString = function() { return \"Person\"; };\n\n  Occupation.reopen({\n    person: DS.belongsTo(Person)\n  });\n\n  var store = DS.Store.create({\n    adapter: DS.Adapter.create({\n      findMany: function(store, type, ids, owner) {\n        equal(type, Occupation, \"type should be Occupation\");\n        deepEqual(ids, ['5', '2'], \"ids should be 5 and 2\");\n        equal(get(owner, 'id'), 1, \"the owner record id should be 1\");\n\n        stop();\n\n        setTimeout(function() {\n          start();\n          store.loadMany(type, ids, [{ id: 5, description: \"fifth\" }, { id: 2, description: \"second\" }]);\n\n          equal(get(person, 'name'), \"Tom Dale\", \"the person is still Tom Dale\");\n          equal(get(person, 'occupations.length'), 2, \"the occupation objects still exist\");\n          equal(get(get(person, 'occupations').objectAt(0), 'description'), \"fifth\", \"the occupation is the fifth\");\n          equal(get(get(person, 'occupations').objectAt(0), 'isLoaded'), true, \"the occupation is now loaded\");\n        }, 1);\n      },\n\n      find: function(store, type, id) {\n        equal(type, Person, \"type should be Person\");\n        equal(id, 1, \"id should be 1\");\n\n        stop();\n\n        setTimeout(function() {\n          start();\n          store.load(type, id, { id: 1, name: \"Tom Dale\", occupations: [5, 2] });\n\n          equal(get(person, 'name'), \"Tom Dale\", \"The person is now populated\");\n          equal(get(person, 'occupations.length'), 2, \"the occupations Array already exists\");\n          equal(get(get(person, 'occupations').objectAt(0), 'isLoaded'), false, \"the occupation objects exist, but are not yet loaded\");\n        }, 1);\n      }\n    })\n  });\n\n  var person = store.find(Person, 1);\n\n  equal(get(person, 'isLoaded'), false, \"isLoaded should be false\");\n  equal(get(person, 'occupations.length'), 0, \"occupations should be empty\");\n\n});\n\n\n})();\n//@ sourceURL=ember-data/~tests/unit/relationships_test");minispade.register('ember-data/~tests/unit/rest_adapter_test', "(function() {var get = Ember.get, set = Ember.set;\n\nvar adapter, store, serializer, ajaxUrl, ajaxType, ajaxHash;\nvar Person, person, people;\nvar Role, role, roles;\nvar Group, group;\n\nmodule(\"the REST adapter\", {\n  setup: function() {\n    ajaxUrl = undefined;\n    ajaxType = undefined;\n    ajaxHash = undefined;\n\n    var Adapter = DS.RESTAdapter.extend();\n    Adapter.configure('plurals', {\n      person: 'people'\n    });\n\n    adapter = Adapter.create({\n      ajax: function(url, type, hash) {\n        var success = hash.success, self = this;\n\n        ajaxUrl = url;\n        ajaxType = type;\n        ajaxHash = hash;\n\n        if (success) {\n          hash.success = function(json) {\n            success.call(self, json);\n          };\n        }\n      }\n    });\n\n    serializer = get(adapter, 'serializer');\n\n    store = DS.Store.create({\n      adapter: adapter\n    });\n\n    Person = DS.Model.extend({\n      name: DS.attr('string')\n    });\n\n    Person.toString = function() {\n      return \"App.Person\";\n    };\n\n    Group = DS.Model.extend({\n      name: DS.attr('string'),\n      people: DS.hasMany(Person)\n    });\n\n    Group.toString = function() {\n      return \"App.Group\";\n    };\n\n    Person.reopen({\n      group: DS.belongsTo(Group)\n    });\n\n    Role = DS.Model.extend({\n      name: DS.attr('string')\n    });\n\n    Role.toString = function() {\n      return \"App.Role\";\n    };\n  },\n\n  teardown: function() {\n    if (person) {\n      person.destroy();\n      person = null;\n    }\n\n    adapter.destroy();\n    store.destroy();\n  }\n});\n\nvar expectUrl = function(url, desc) {\n  equal(ajaxUrl, url, \"the URL is \" + desc);\n};\n\nvar expectType = function(type) {\n  equal(type, ajaxType, \"the HTTP method is \" + type);\n};\n\nvar expectData = function(hash) {\n  deepEqual(hash, ajaxHash.data, \"the hash was passed along\");\n};\n\nvar expectState = function(state, value, p) {\n  p = p || person;\n\n  if (value === undefined) { value = true; }\n\n  var flag = \"is\" + state.charAt(0).toUpperCase() + state.substr(1);\n  equal(get(p, flag), value, \"the person is \" + (value === false ? \"not \" : \"\") + state);\n};\n\nvar expectStates = function(state, value) {\n  people.forEach(function(person) {\n    expectState(state, value, person);\n  });\n};\n\ntest(\"creating a person makes a POST to /people, with the data hash\", function() {\n  person = store.createRecord(Person, { name: \"Tom Dale\" });\n\n  expectState('new');\n  store.commit();\n  expectState('saving');\n\n  expectUrl(\"/people\", \"the collection at the plural of the model name\");\n  expectType(\"POST\");\n  expectData({ person: { name: \"Tom Dale\" } });\n\n  ajaxHash.success({ person: { id: 1, name: \"Tom Dale\" } });\n  expectState('saving', false);\n\n  equal(person, store.find(Person, 1), \"it is now possible to retrieve the person by the ID supplied\");\n});\n\ntest(\"singular creations can sideload data\", function() {\n  person = store.createRecord(Person, { name: \"Tom Dale\" });\n\n  expectState('new');\n  store.commit();\n  expectState('saving');\n\n  expectUrl(\"/people\", \"the collection at the plural of the model name\");\n  expectType(\"POST\");\n  expectData({ person: { name: \"Tom Dale\" } });\n\n  ajaxHash.success({\n    person: { id: 1, name: \"Tom Dale\" },\n    groups: [{ id: 1, name: \"Group 1\" }]\n  });\n\n  expectState('saving', false);\n\n  equal(person, store.find(Person, 1), \"it is now possible to retrieve the person by the ID supplied\");\n\n  group = store.find(Group, 1);\n  equal(get(group, 'name'), \"Group 1\", \"the data sideloaded successfully\");\n});\n\ntest(\"updating a person makes a PUT to /people/:id with the data hash\", function() {\n  store.load(Person, { id: 1, name: \"Yehuda Katz\" });\n\n  person = store.find(Person, 1);\n\n  expectState('new', false);\n  expectState('loaded');\n  expectState('dirty', false);\n\n  set(person, 'name', \"Brohuda Brokatz\");\n\n  expectState('dirty');\n  store.commit();\n  expectState('saving');\n\n  expectUrl(\"/people/1\", \"the plural of the model name with its ID\");\n  expectType(\"PUT\");\n\n  ajaxHash.success({ person: { id: 1, name: \"Brohuda Brokatz\" } });\n  expectState('saving', false);\n\n  equal(person, store.find(Person, 1), \"the same person is retrieved by the same ID\");\n  equal(get(person, 'name'), \"Brohuda Brokatz\", \"the hash should be updated\");\n});\n\ntest(\"updates are not required to return data\", function() {\n  store.load(Person, { id: 1, name: \"Yehuda Katz\" });\n\n  person = store.find(Person, 1);\n\n  expectState('new', false);\n  expectState('loaded');\n  expectState('dirty', false);\n\n  set(person, 'name', \"Brohuda Brokatz\");\n\n  expectState('dirty');\n  store.commit();\n  expectState('saving');\n\n  expectUrl(\"/people/1\", \"the plural of the model name with its ID\");\n  expectType(\"PUT\");\n\n  ajaxHash.success();\n  expectState('saving', false);\n\n  equal(person, store.find(Person, 1), \"the same person is retrieved by the same ID\");\n  equal(get(person, 'name'), \"Brohuda Brokatz\", \"the data is preserved\");\n});\n\ntest(\"singular updates can sideload data\", function() {\n  serializer.configure(Group, { sideloadAs: 'groups' });\n\n  store.load(Person, { id: 1, name: \"Yehuda Katz\" });\n\n  person = store.find(Person, 1);\n\n  expectState('new', false);\n  expectState('loaded');\n  expectState('dirty', false);\n\n  set(person, 'name', \"Brohuda Brokatz\");\n\n  expectState('dirty');\n  store.commit();\n  expectState('saving');\n\n  expectUrl(\"/people/1\", \"the plural of the model name with its ID\");\n  expectType(\"PUT\");\n\n  ajaxHash.success({\n    person: { id: 1, name: \"Brohuda Brokatz\" },\n    groups: [{ id: 1, name: \"Group 1\" }]\n  });\n\n  expectState('saving', false);\n\n  equal(person, store.find(Person, 1), \"the same person is retrieved by the same ID\");\n\n  group = store.find(Group, 1);\n  equal(get(group, 'name'), \"Group 1\", \"the data sideloaded successfully\");\n});\n\ntest(\"deleting a person makes a DELETE to /people/:id\", function() {\n  store.load(Person, { id: 1, name: \"Tom Dale\" });\n\n  person = store.find(Person, 1);\n\n  expectState('new', false);\n  expectState('loaded');\n  expectState('dirty', false);\n\n  person.deleteRecord();\n\n  expectState('dirty');\n  expectState('deleted');\n  store.commit();\n  expectState('saving');\n\n  expectUrl(\"/people/1\", \"the plural of the model name with its ID\");\n  expectType(\"DELETE\");\n\n  ajaxHash.success();\n  expectState('deleted');\n});\n\ntest(\"singular deletes can sideload data\", function() {\n  serializer.configure(Group, { sideloadAs: 'groups' });\n\n  store.load(Person, { id: 1, name: \"Tom Dale\" });\n\n  person = store.find(Person, 1);\n\n  expectState('new', false);\n  expectState('loaded');\n  expectState('dirty', false);\n\n  person.deleteRecord();\n\n  expectState('dirty');\n  expectState('deleted');\n  store.commit();\n  expectState('saving');\n\n  expectUrl(\"/people/1\", \"the plural of the model name with its ID\");\n  expectType(\"DELETE\");\n\n  ajaxHash.success({\n    groups: [{ id: 1, name: \"Group 1\" }]\n  });\n\n  expectState('deleted');\n\n  group = store.find(Group, 1);\n  equal(get(group, 'name'), \"Group 1\", \"the data sideloaded successfully\");\n});\n\n/*\ntest(\"deleting a record with custom primaryKey\", function() {\n  store.load(Role, { _id: 1, name: \"Developer\" });\n\n  role = store.find(Role, 1);\n\n  role.deleteRecord();\n\n  store.commit();\n\n  expectUrl(\"/roles/1\", \"the plural of the model name with its ID\");\n  ajaxHash.success();\n});\n*/\n\ntest(\"finding all people makes a GET to /people\", function() {\n  people = store.find(Person);\n\n  expectUrl(\"/people\", \"the plural of the model name\");\n  expectType(\"GET\");\n\n  ajaxHash.success({ people: [{ id: 1, name: \"Yehuda Katz\" }] });\n\n  person = people.objectAt(0);\n\n  expectState('loaded');\n  expectState('dirty', false);\n\n  equal(person, store.find(Person, 1), \"the record is now in the store, and can be looked up by ID without another Ajax request\");\n});\n\ntest(\"finding all can sideload data\", function() {\n  var groups = store.find(Group);\n\n  expectUrl(\"/groups\", \"the plural of the model name\");\n  expectType(\"GET\");\n\n  ajaxHash.success({\n    groups: [{ id: 1, name: \"Group 1\", person_ids: [ 1 ] }],\n    people: [{ id: 1, name: \"Yehuda Katz\" }]\n  });\n\n  people = get(groups.objectAt(0), 'people');\n  person = people.objectAt(0);\n\n  expectState('loaded');\n  expectState('dirty', false);\n\n  equal(person, store.find(Person, 1), \"the record is now in the store, and can be looked up by ID without another Ajax request\");\n});\n\ntest(\"finding all people with since makes a GET to /people\", function() {\n  people = store.find(Person);\n\n  expectUrl(\"/people\", \"the plural of the model name\");\n  expectType(\"GET\");\n\n  ajaxHash.success({ meta: { since: '123'}, people: [{ id: 1, name: \"Yehuda Katz\" }] });\n\n  people = store.find(Person);\n\n  expectUrl(\"/people\", \"the plural of the model name\");\n  expectType(\"GET\");\n  expectData({since: '123'});\n\n  ajaxHash.success({ meta: { since: '1234'}, people: [{ id: 2, name: \"Paul Chavard\" }] });\n\n  person = people.objectAt(1);\n\n  expectState('loaded');\n  expectState('dirty', false);\n\n  equal(person, store.find(Person, 2), \"the record is now in the store, and can be looked up by ID without another Ajax request\");\n\n  people.update();\n\n  expectUrl(\"/people\", \"the plural of the model name\");\n  expectType(\"GET\");\n  expectData({since: '1234'});\n\n  ajaxHash.success({ meta: { since: '12345'}, people: [{ id: 3, name: \"Dan Gebhardt\" }] });\n\n  equal(people.get('length'), 3, 'should have 3 records now');\n});\n\ntest(\"meta and since are configurable\", function() {\n  serializer.configure({\n    meta: 'metaObject',\n    since: 'sinceToken'\n  });\n\n  set(adapter, 'since', 'lastToken');\n\n  people = store.find(Person);\n\n  expectUrl(\"/people\", \"the plural of the model name\");\n  expectType(\"GET\");\n\n  ajaxHash.success({ metaObject: {sinceToken: '123'}, people: [{ id: 1, name: \"Yehuda Katz\" }] });\n\n  people.update();\n\n  expectUrl(\"/people\", \"the plural of the model name\");\n  expectType(\"GET\");\n  expectData({lastToken: '123'});\n\n  ajaxHash.success({ metaObject: {sinceToken: '1234'}, people: [{ id: 2, name: \"Paul Chavard\" }] });\n\n  person = people.objectAt(1);\n\n  expectState('loaded');\n  expectState('dirty', false);\n\n  equal(person, store.find(Person, 2), \"the record is now in the store, and can be looked up by ID without another Ajax request\");\n});\n\ntest(\"finding a person by ID makes a GET to /people/:id\", function() {\n  person = store.find(Person, 1);\n\n  expectState('loaded', false);\n  expectUrl(\"/people/1\", \"the plural of the model name with the ID requested\");\n  expectType(\"GET\");\n\n  ajaxHash.success({ person: { id: 1, name: \"Yehuda Katz\" } });\n\n  expectState('loaded');\n  expectState('dirty', false);\n\n  equal(person, store.find(Person, 1), \"the record is now in the store, and can be looked up by ID without another Ajax request\");\n});\n\ntest(\"finding a person by an ID-alias populates the store\", function() {\n  person = store.find(Person, 'me');\n\n  expectState('loaded', false);\n  expectUrl(\"/people/me\", \"the plural of the model name with the ID requested\");\n  expectType(\"GET\");\n\n  ajaxHash.success({ person: { id: 1, name: \"Yehuda Katz\" } });\n\n  expectState('loaded');\n  expectState('dirty', false);\n\n  equal(person, store.find(Person, 'me'), \"the record is now in the store, and can be looked up by the alias without another Ajax request\");\n});\n\ntest(\"additional data can be sideloaded in a GET\", function() {\n  group = store.find(Group, 1);\n\n  ajaxHash.success({\n    group: {\n      id: 1, name: \"Group 1\", person_ids: [ 1 ]\n    },\n    people: [{\n      id: 1, name: \"Yehuda Katz\"\n    }]\n  });\n\n  equal(get(store.find(Person, 1), 'name'), \"Yehuda Katz\", \"the items are sideloaded\");\n  equal(get(get(store.find(Group, 1), 'people').objectAt(0), 'name'), \"Yehuda Katz\", \"the items are in the relationship\");\n});\n\ntest(\"finding many people by a list of IDs\", function() {\n  store.load(Group, { id: 1, person_ids: [ 1, 2, 3 ] });\n\n  var group = store.find(Group, 1);\n\n  equal(ajaxUrl, undefined, \"no Ajax calls have been made yet\");\n\n  var people = get(group, 'people');\n\n  equal(get(people, 'length'), 3, \"there are three people in the relationship already\");\n\n  people.forEach(function(person) {\n    equal(get(person, 'isLoaded'), false, \"the person is being loaded\");\n  });\n\n  expectUrl(\"/people\");\n  expectType(\"GET\");\n  expectData({ ids: [ 1, 2, 3 ] });\n\n  ajaxHash.success({\n    people: [\n      { id: 1, name: \"Rein Heinrichs\" },\n      { id: 2, name: \"Tom Dale\" },\n      { id: 3, name: \"Yehuda Katz\" }\n    ]\n  });\n\n  var rein = people.objectAt(0);\n  equal(get(rein, 'name'), \"Rein Heinrichs\");\n  equal(get(rein, 'id'), 1);\n\n  var tom = people.objectAt(1);\n  equal(get(tom, 'name'), \"Tom Dale\");\n  equal(get(tom, 'id'), 2);\n\n  var yehuda = people.objectAt(2);\n  equal(get(yehuda, 'name'), \"Yehuda Katz\");\n  equal(get(yehuda, 'id'), 3);\n\n  people.forEach(function(person) {\n    equal(get(person, 'isLoaded'), true, \"the person is being loaded\");\n  });\n});\n\ntest(\"finding many people by a list of IDs doesn't rely on the returned array order matching the passed list of ids\", function() {\n  store.load(Group, { id: 1, person_ids: [ 1, 2, 3 ] });\n\n  var group = store.find(Group, 1);\n\n  var people = get(group, 'people');\n\n  ajaxHash.success({\n    people: [\n      { id: 2, name: \"Tom Dale\" },\n      { id: 1, name: \"Rein Heinrichs\" },\n      { id: 3, name: \"Yehuda Katz\" }\n    ]\n  });\n\n  var rein = people.objectAt(0);\n  equal(get(rein, 'name'), \"Rein Heinrichs\");\n  equal(get(rein, 'id'), 1);\n\n  var tom = people.objectAt(1);\n  equal(get(tom, 'name'), \"Tom Dale\");\n  equal(get(tom, 'id'), 2);\n\n  var yehuda = people.objectAt(2);\n  equal(get(yehuda, 'name'), \"Yehuda Katz\");\n  equal(get(yehuda, 'id'), 3);\n\n});\n\ntest(\"additional data can be sideloaded in a GET with many IDs\", function() {\n  //store.load(Group, { id: 1, people: [ 1, 2, 3 ] });\n\n  equal(ajaxUrl, undefined, \"no Ajax calls have been made yet\");\n\n  // findMany is used here even though it is not normally public to test the\n  // functionality.\n  var groups = store.findMany(Group, [ 1 ]);\n  var group = groups.objectAt(0);\n\n  equal(get(group, 'isLoaded'), false, \"the group is being loaded\");\n\n  expectUrl(\"/groups\");\n  expectType(\"GET\");\n  expectData({ ids: [ 1 ] });\n\n  ajaxHash.success({\n    groups: [\n      { id: 1, person_ids: [ 1, 2, 3 ] }\n    ],\n    people: [\n      { id: 1, name: \"Rein Heinrichs\" },\n      { id: 2, name: \"Tom Dale\" },\n      { id: 3, name: \"Yehuda Katz\" }\n    ]\n  });\n\n  var people = get(group, 'people');\n  equal(get(people, 'length'), 3, \"the people have length\");\n\n  var rein = people.objectAt(0);\n  equal(get(rein, 'name'), \"Rein Heinrichs\");\n  equal(get(rein, 'id'), 1);\n\n  var tom = people.objectAt(1);\n  equal(get(tom, 'name'), \"Tom Dale\");\n  equal(get(tom, 'id'), 2);\n\n  var yehuda = people.objectAt(2);\n  equal(get(yehuda, 'name'), \"Yehuda Katz\");\n  equal(get(yehuda, 'id'), 3);\n\n  people.forEach(function(person) {\n    equal(get(person, 'isLoaded'), true, \"the person is being loaded\");\n  });\n});\n\ntest(\"finding people by a query\", function() {\n  var people = store.find(Person, { page: 1 });\n\n  equal(get(people, 'length'), 0, \"there are no people yet, as the query has not returned\");\n\n  expectUrl(\"/people\", \"the collection at the plural of the model name\");\n  expectType(\"GET\");\n  expectData({ page: 1 });\n\n  ajaxHash.success({\n    people: [\n      { id: 1, name: \"Rein Heinrichs\" },\n      { id: 2, name: \"Tom Dale\" },\n      { id: 3, name: \"Yehuda Katz\" }\n    ]\n  });\n\n  equal(get(people, 'length'), 3, \"the people are now loaded\");\n\n  var rein = people.objectAt(0);\n  equal(get(rein, 'name'), \"Rein Heinrichs\");\n  equal(get(rein, 'id'), 1);\n\n  var tom = people.objectAt(1);\n  equal(get(tom, 'name'), \"Tom Dale\");\n  equal(get(tom, 'id'), 2);\n\n  var yehuda = people.objectAt(2);\n  equal(get(yehuda, 'name'), \"Yehuda Katz\");\n  equal(get(yehuda, 'id'), 3);\n\n  people.forEach(function(person) {\n    equal(get(person, 'isLoaded'), true, \"the person is being loaded\");\n  });\n});\n\ntest(\"finding people by a query can sideload data\", function() {\n  var groups = store.find(Group, { page: 1 });\n\n  equal(get(groups, 'length'), 0, \"there are no groups yet, as the query has not returned\");\n\n  expectUrl(\"/groups\", \"the collection at the plural of the model name\");\n  expectType(\"GET\");\n  expectData({ page: 1 });\n\n  ajaxHash.success({\n    groups: [\n      { id: 1, name: \"Group 1\", person_ids: [ 1, 2, 3 ] }\n    ],\n    people: [\n      { id: 1, name: \"Rein Heinrichs\" },\n      { id: 2, name: \"Tom Dale\" },\n      { id: 3, name: \"Yehuda Katz\" }\n    ]\n  });\n\n  var group = groups.objectAt(0);\n  var people = get(group, 'people');\n\n  equal(get(people, 'length'), 3, \"the people are now loaded\");\n\n  var rein = people.objectAt(0);\n  equal(get(rein, 'name'), \"Rein Heinrichs\");\n  equal(get(rein, 'id'), 1);\n\n  var tom = people.objectAt(1);\n  equal(get(tom, 'name'), \"Tom Dale\");\n  equal(get(tom, 'id'), 2);\n\n  var yehuda = people.objectAt(2);\n  equal(get(yehuda, 'name'), \"Yehuda Katz\");\n  equal(get(yehuda, 'id'), 3);\n\n  people.forEach(function(person) {\n    equal(get(person, 'isLoaded'), true, \"the person is being loaded\");\n  });\n});\n\ntest(\"creating several people (with bulkCommit) makes a POST to /people, with a data hash Array\", function() {\n  set(adapter, 'bulkCommit', true);\n\n  var tom = store.createRecord(Person, { name: \"Tom Dale\" });\n  var yehuda = store.createRecord(Person, { name: \"Yehuda Katz\" });\n\n  people = [ tom, yehuda ];\n\n  expectStates('new');\n  store.commit();\n  expectStates('saving');\n\n  expectUrl(\"/people\", \"the collection at the plural of the model name\");\n  expectType(\"POST\");\n  expectData({ people: [ { name: \"Tom Dale\" }, { name: \"Yehuda Katz\" } ] });\n\n  ajaxHash.success({ people: [ { id: 1, name: \"Tom Dale\" }, { id: 2, name: \"Yehuda Katz\" } ] });\n  expectStates('saving', false);\n\n  equal(tom, store.find(Person, 1), \"it is now possible to retrieve the person by the ID supplied\");\n  equal(yehuda, store.find(Person, 2), \"it is now possible to retrieve the person by the ID supplied\");\n});\n\ntest(\"bulk commits can sideload data\", function() {\n  set(adapter, 'bulkCommit', true);\n\n  var tom = store.createRecord(Person, { name: \"Tom Dale\" });\n  var yehuda = store.createRecord(Person, { name: \"Yehuda Katz\" });\n\n  serializer.configure(Group, { sideloadAs: 'groups' });\n\n  people = [ tom, yehuda ];\n\n  expectStates('new');\n  store.commit();\n  expectStates('saving');\n\n  expectUrl(\"/people\", \"the collection at the plural of the model name\");\n  expectType(\"POST\");\n  expectData({ people: [ { name: \"Tom Dale\" }, { name: \"Yehuda Katz\" } ] });\n\n  ajaxHash.success({\n    people: [ { id: 1, name: \"Tom Dale\" }, { id: 2, name: \"Yehuda Katz\" } ],\n    groups: [ { id: 1, name: \"Group 1\" } ]\n  });\n\n  expectStates('saving', false);\n\n  equal(tom, store.find(Person, 1), \"it is now possible to retrieve the person by the ID supplied\");\n  equal(yehuda, store.find(Person, 2), \"it is now possible to retrieve the person by the ID supplied\");\n\n  group = store.find(Group, 1);\n  equal(get(group, 'name'), \"Group 1\", \"the data sideloaded successfully\");\n});\n\ntest(\"updating several people (with bulkCommit) makes a PUT to /people/bulk with the data hash Array\", function() {\n  set(adapter, 'bulkCommit', true);\n\n  store.loadMany(Person, [\n    { id: 1, name: \"Yehuda Katz\" },\n    { id: 2, name: \"Carl Lerche\" }\n  ]);\n\n  var yehuda = store.find(Person, 1);\n  var carl = store.find(Person, 2);\n\n  people = [ yehuda, carl ];\n\n  expectStates('new', false);\n  expectStates('loaded');\n  expectStates('dirty', false);\n\n  set(yehuda, 'name', \"Brohuda Brokatz\");\n  set(carl, 'name', \"Brocarl Brolerche\");\n\n  expectStates('dirty');\n  store.commit();\n  expectStates('saving');\n\n  expectUrl(\"/people/bulk\", \"the collection at the plural of the model name\");\n  expectType(\"PUT\");\n  expectData({ people: [{ id: 1, name: \"Brohuda Brokatz\" }, { id: 2, name: \"Brocarl Brolerche\" }] });\n\n  ajaxHash.success({ people: [\n    { id: 1, name: \"Brohuda Brokatz\" },\n    { id: 2, name: \"Brocarl Brolerche\" }\n  ]});\n\n  expectStates('saving', false);\n\n  equal(yehuda, store.find(Person, 1), \"the same person is retrieved by the same ID\");\n  equal(carl, store.find(Person, 2), \"the same person is retrieved by the same ID\");\n});\n\ntest(\"bulk updates can sideload data\", function() {\n  set(adapter, 'bulkCommit', true);\n\n  serializer.configure(Group, { sideloadAs: 'groups' });\n\n  store.loadMany(Person, [\n    { id: 1, name: \"Yehuda Katz\" },\n    { id: 2, name: \"Carl Lerche\" }\n  ]);\n\n  var yehuda = store.find(Person, 1);\n  var carl = store.find(Person, 2);\n\n  people = [ yehuda, carl ];\n\n  expectStates('new', false);\n  expectStates('loaded');\n  expectStates('dirty', false);\n\n  set(yehuda, 'name', \"Brohuda Brokatz\");\n  set(carl, 'name', \"Brocarl Brolerche\");\n\n  expectStates('dirty');\n  store.commit();\n  expectStates('saving');\n\n  expectUrl(\"/people/bulk\", \"the collection at the plural of the model name\");\n  expectType(\"PUT\");\n  expectData({ people: [{ id: 1, name: \"Brohuda Brokatz\" }, { id: 2, name: \"Brocarl Brolerche\" }] });\n\n  ajaxHash.success({\n    people: [\n      { id: 1, name: \"Brohuda Brokatz\" },\n      { id: 2, name: \"Brocarl Brolerche\" }\n    ],\n    groups: [{ id: 1, name: \"Group 1\" }]\n  });\n\n  expectStates('saving', false);\n\n  equal(yehuda, store.find(Person, 1), \"the same person is retrieved by the same ID\");\n  equal(carl, store.find(Person, 2), \"the same person is retrieved by the same ID\");\n\n  group = store.find(Group, 1);\n  equal(get(group, 'name'), \"Group 1\", \"the data sideloaded successfully\");\n});\n\ntest(\"deleting several people (with bulkCommit) makes a PUT to /people/bulk\", function() {\n  set(adapter, 'bulkCommit', true);\n\n  store.loadMany(Person, [\n    { id: 1, name: \"Yehuda Katz\" },\n    { id: 2, name: \"Carl Lerche\" }\n  ]);\n\n  var yehuda = store.find(Person, 1);\n  var carl = store.find(Person, 2);\n\n  people = [ yehuda, carl ];\n\n  expectStates('new', false);\n  expectStates('loaded');\n  expectStates('dirty', false);\n\n  yehuda.deleteRecord();\n  carl.deleteRecord();\n\n  expectStates('dirty');\n  expectStates('deleted');\n  store.commit();\n  expectStates('saving');\n\n  expectUrl(\"/people/bulk\", \"the collection at the plural of the model name with 'delete'\");\n  expectType(\"DELETE\");\n  expectData({ people: [1, 2] });\n\n  ajaxHash.success();\n\n  expectStates('saving', false);\n  expectStates('deleted');\n  expectStates('dirty', false);\n});\n\ntest(\"bulk deletes can sideload data\", function() {\n  set(adapter, 'bulkCommit', true);\n\n  serializer.configure(Group, { sideloadAs: 'groups' });\n\n  store.loadMany(Person, [\n    { id: 1, name: \"Yehuda Katz\" },\n    { id: 2, name: \"Carl Lerche\" }\n  ]);\n\n  var yehuda = store.find(Person, 1);\n  var carl = store.find(Person, 2);\n\n  people = [ yehuda, carl ];\n\n  expectStates('new', false);\n  expectStates('loaded');\n  expectStates('dirty', false);\n\n  yehuda.deleteRecord();\n  carl.deleteRecord();\n\n  expectStates('dirty');\n  expectStates('deleted');\n  store.commit();\n  expectStates('saving');\n\n  expectUrl(\"/people/bulk\", \"the collection at the plural of the model name with 'delete'\");\n  expectType(\"DELETE\");\n  expectData({ people: [1, 2] });\n\n  ajaxHash.success({\n    groups: [{ id: 1, name: \"Group 1\" }]\n  });\n\n  expectStates('saving', false);\n  expectStates('deleted');\n  expectStates('dirty', false);\n\n  group = store.find(Group, 1);\n  equal(get(group, 'name'), \"Group 1\", \"the data sideloaded successfully\");\n});\n\ntest(\"if you specify a namespace then it is prepended onto all URLs\", function() {\n  set(adapter, 'namespace', 'ember');\n  person = store.find(Person, 1);\n  expectUrl(\"/ember/people/1\", \"the namespace, followed by the plural of the model name and the id\");\n\n  store.load(Person, { id: 1 });\n});\n\ntest(\"if you specify a url then that custom url is used\", function() {\n  set(adapter, 'url', 'http://api.ember.dev');\n  person = store.find(Person, 1);\n  expectUrl(\"http://api.ember.dev/people/1\", \"the custom url, followed by the plural of the model name and the id\");\n\n  store.load(Person, { id: 1 });\n});\n\ntest(\"sideloaded data is loaded prior to primary data (to ensure relationship coherence)\", function() {\n  expect(1);\n\n  group = store.find(Group, 1);\n  group.then(function(group) {\n    equal(group.get('people.firstObject').get('name'), \"Tom Dale\", \"sideloaded data are already loaded\");\n  });\n\n  ajaxHash.success({\n    people: [\n      { id: 1, name: \"Tom Dale\" }\n    ],\n    group: { id: 1, name: \"Tilde team\", person_ids: [1] }\n  });\n});\n\ntest(\"additional data can be sideloaded with relationships in correct order\", function() {\n  var Comment = DS.Model.extend({\n    person: DS.belongsTo(Person)\n  });\n\n  serializer.configure(Comment, { sideloadAs: 'comments' });\n\n  var comments = store.filter(Comment, function(data) {\n    equal(store.find(Comment, data.get('id')).get('person.id'), 1);\n  });\n\n  group = store.find(Group, 1);\n\n  ajaxHash.success({\n    group: {\n      id: 1, name: \"Group 1\", person_ids: [ 1 ]\n    },\n    comments: [{\n      id: 1, person_id: 1, text: 'hello'\n    }],\n    people: [{\n      id: 1, name: \"Yehuda Katz\"\n    }]\n  });\n});\n\ntest(\"data loaded from the server is converted from underscores to camelcase\", function() {\n  Person.reopen({\n    lastName: DS.attr('string')\n  });\n\n  store.load(Person, { id: 1, name: \"Tom\", last_name: \"Dale\" });\n\n  var person = store.find(Person, 1);\n\n  equal(person.get('name'), \"Tom\", \"precond - data was materialized\");\n  equal(person.get('lastName'), \"Dale\", \"the attribute name was camelized\");\n});\n\ntest(\"When a record with a belongsTo is saved the foreign key should be sent.\", function () {\n  var PersonType = DS.Model.extend({\n    title: DS.attr(\"string\"),\n    people: DS.hasMany(Person)\n  });\n\n  PersonType.toString = function() {\n    return \"App.PersonType\";\n  };\n\n  Person.reopen({\n    personType: DS.belongsTo(PersonType)\n  });\n\n  store.load(PersonType, {id: 1, title: \"Developer\"});\n  var personType = store.find(PersonType, 1);\n\n  var person = store.createRecord(Person, {name: 'Sam Woodard', personType: personType});\n\n  store.commit();\n\n  expectUrl('/people');\n  expectType(\"POST\");\n  expectData({ person: { name: \"Sam Woodard\", person_type_id: \"1\" } });\n  ajaxHash.success({ person: { name: 'Sam Woodard', person_type_id: 1}});\n});\n\ntest(\"creating a record with a 422 error marks the records as invalid\", function(){\n  person = store.createRecord(Person, { name: \"\" });\n  store.commit();\n\n  var mockXHR = {\n    status:       422,\n    responseText: JSON.stringify({ errors: { name: [\"can't be blank\"]} })\n  };\n\n  ajaxHash.error.call(ajaxHash.context, mockXHR);\n\n  expectState('valid', false);\n  deepEqual(person.get('errors'), { name: [\"can't be blank\"]}, \"the person has the errors\");\n});\n\ntest(\"updating a record with a 422 error marks the records as invalid\", function(){\n  store.load(Person, { id: 1, name: \"John Doe\" });\n  person = store.find(Person, 1);\n  person.set('name', '');\n  store.commit();\n\n  var mockXHR = {\n    status:       422,\n    responseText: JSON.stringify({ errors: { name: [\"can't be blank\"]} })\n  };\n\n  ajaxHash.error.call(ajaxHash.context, mockXHR);\n\n  expectState('valid', false);\n  deepEqual(person.get('errors'), { name: [\"can't be blank\"]}, \"the person has the errors\");\n});\n\ntest(\"creating a record with a 500 error marks the record as error\", function() {\n  person = store.createRecord(Person, { name: \"\" });\n  store.commit();\n\n  var mockXHR = {\n    status:       500,\n    responseText: 'Internal Server Error'\n  };\n\n  ajaxHash.error.call(ajaxHash.context, mockXHR);\n\n  expectState('error');\n});\n\ntest(\"updating a record with a 500 error marks the record as error\", function() {\n  store.load(Person, { id: 1, name: \"John Doe\" });\n  person = store.find(Person, 1);\n  person.set('name', 'Jane Doe');\n  store.commit();\n\n  var mockXHR = {\n    status:       500,\n    responseText: 'Internal Server Error'\n  };\n\n  ajaxHash.error.call(ajaxHash.context, mockXHR);\n\n  expectState('error');\n});\n\n})();\n//@ sourceURL=ember-data/~tests/unit/rest_adapter_test");minispade.register('ember-data/~tests/unit/serializer_test', "(function() {var serializer;\n\nmodule(\"DS.Serializer\", {\n  setup: function() {\n    serializer = DS.Serializer.create();\n  },\n\n  teardown: function() {\n    serializer.destroy();\n  }\n});\n\n\n})();\n//@ sourceURL=ember-data/~tests/unit/serializer_test");minispade.register('ember-data/~tests/unit/serializers/rest_serializer_test', "(function() {var get = Ember.get, set = Ember.set;\n\nvar serializer;\n\nmodule(\"DS.RESTSerializer\", {\n  setup: function() {\n    serializer = DS.RESTSerializer.create();\n    serializer.configure('plurals', {\n      person: 'people'\n    });\n  },\n  teardown: function() {\n    serializer.destroy();\n  }\n});\n\ntest(\"keyForAttributeName returns decamelized property name\", function() {\n  equal(serializer.keyForAttributeName(DS.Model, 'myName'), 'my_name');\n  equal(serializer.keyForAttributeName(DS.Model, 'my_name'), 'my_name');\n});\n\ntest(\"keyForBelongsTo returns the key appended with '_id'\", function() {\n  equal(serializer.keyForBelongsTo(DS.Model, 'person'), 'person_id');\n  equal(serializer.keyForBelongsTo(DS.Model, 'town'), 'town_id');\n  equal(serializer.keyForBelongsTo(DS.Model, 'homeTown'), 'home_town_id');\n});\n\ntest(\"keyForHasMany returns the singularized key appended with '_ids'\", function() {\n  equal(serializer.keyForHasMany(DS.Model, 'people'), 'person_ids');\n  equal(serializer.keyForHasMany(DS.Model, 'towns'), 'town_ids');\n  equal(serializer.keyForHasMany(DS.Model, 'homeTowns'), 'home_town_ids');\n});\n\ntest(\"Calling extract on a JSON payload with multiple records will tear them apart and call loader\", function() {\n  var App = Ember.Namespace.create({\n    toString: function() { return \"App\"; }\n  });\n\n  App.Group = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  App.Post = DS.Model.extend({\n    title: DS.attr('string'),\n    groups: DS.hasMany(App.Group)\n  });\n\n  serializer.configure(App.Group, {\n    sideloadAs: 'groups'\n  });\n\n  var payload = {\n    post: {\n      id: 1,\n      title: \"Fifty Ways to Bereave Your Lover\",\n      groups: [1]\n    },\n\n    groups: [{ id: 1, name: \"Trolls\" }]\n  };\n\n  var loadCallCount = 0,\n      loadMainCallCount = 0;\n\n  var loader = {\n    sideload: function(type, data, prematerialized) {\n      loadCallCount++;\n    },\n\n    load: function(type, data, prematerialized) {\n      loadMainCallCount++;\n    },\n\n    prematerialize: Ember.K\n  };\n\n  serializer.extract(loader, payload, App.Post);\n\n  equal(loadMainCallCount, 1, \"one main record was loaded from a single payload\");\n  equal(loadCallCount, 1, \"one secondary record was loaded from a single payload\");\n\n  //this.extractRecord(type, structure, loader)\n\n  //function extractRecord(type, structure, loader) {\n    //loader.load(type, structure, {\n      //id: this.extractId(structure),\n      //hasMany: { comments: [ 1,2,3 ] }\n    //});\n  //}\n});\n\n\n})();\n//@ sourceURL=ember-data/~tests/unit/serializers/rest_serializer_test");minispade.register('ember-data/~tests/unit/store_test', "(function() {var get = Ember.get, set = Ember.set;\n\nvar testSerializer = DS.JSONSerializer.create({\n  primaryKey: function() { return 'id'; }\n});\n\nvar TestAdapter = DS.Adapter.extend({\n  serializer: testSerializer\n});\n\nmodule(\"DS.Store\", {\n  teardown: function() {\n    set(DS, 'defaultStore', null);\n  }\n});\n\ntest(\"a store can be created\", function() {\n  var store = DS.Store.create();\n  ok(store, 'a store exists');\n});\n\ntest(\"the first store becomes the default store\", function() {\n  var store = DS.Store.create();\n  equal(get(DS, 'defaultStore'), store, \"the first store is the default\");\n});\n\ntest(\"a specific store can be supplied as the default store\", function() {\n  DS.Store.create();\n  var store = DS.Store.create({ isDefaultStore: true });\n  DS.Store.create();\n\n  equal(get(DS, 'defaultStore'), store, \"isDefaultStore overrides the default behavior\");\n});\n\ntest(\"when a store is destroyed, it removes itself as the default store\", function() {\n  var store = DS.Store.create({ isDefaultStore: true });\n\n  equal(get(DS, 'defaultStore'), store, \"precond - store creates itself as default store\");\n  store.destroy();\n\n  equal(get(DS, 'defaultStore'), null, \"default store is set to null after previous default was destroyed\");\n});\n\nvar stateManager, stateName;\n\nmodule(\"DS.StateManager\", {\n  setup: function() {\n    stateManager = DS.StateManager.create();\n  }\n});\n\nvar isTrue = function(flag) {\n  var state = stateName.split('.').join('.states.');\n  equal(get(stateManager, 'states.rootState.states.'+ state + \".\" + flag), true, stateName + \".\" + flag + \" should be true\");\n};\n\nvar isFalse = function(flag) {\n  var state = stateName.split('.').join('.states.');\n  equal(get(stateManager, 'states.rootState.states.'+ state + \".\" + flag), false, stateName + \".\" + flag + \" should be false\");\n};\n\ntest(\"the empty state\", function() {\n  stateName = \"empty\";\n  isFalse(\"isLoaded\");\n  isFalse(\"isDirty\");\n  isFalse(\"isSaving\");\n  isFalse(\"isDeleted\");\n  isFalse(\"isError\");\n});\n\ntest(\"the loading state\", function() {\n  stateName = \"loading\";\n  isFalse(\"isLoaded\");\n  isFalse(\"isDirty\");\n  isFalse(\"isSaving\");\n  isFalse(\"isDeleted\");\n  isFalse(\"isError\");\n});\n\ntest(\"the loaded state\", function() {\n  stateName = \"loaded\";\n  isTrue(\"isLoaded\");\n  isFalse(\"isDirty\");\n  isFalse(\"isSaving\");\n  isFalse(\"isDeleted\");\n  isFalse(\"isError\");\n});\n\ntest(\"the updated state\", function() {\n  stateName = \"loaded.updated\";\n  isTrue(\"isLoaded\");\n  isTrue(\"isDirty\");\n  isFalse(\"isSaving\");\n  isFalse(\"isDeleted\");\n  isFalse(\"isError\");\n});\n\ntest(\"the saving state\", function() {\n  stateName = \"loaded.updated.inFlight\";\n  isTrue(\"isLoaded\");\n  isTrue(\"isDirty\");\n  isTrue(\"isSaving\");\n  isFalse(\"isDeleted\");\n  isFalse(\"isError\");\n});\n\ntest(\"the deleted state\", function() {\n  stateName = \"deleted\";\n  isTrue(\"isLoaded\");\n  isTrue(\"isDirty\");\n  isFalse(\"isSaving\");\n  isTrue(\"isDeleted\");\n  isFalse(\"isError\");\n});\n\ntest(\"the deleted.saving state\", function() {\n  stateName = \"deleted.inFlight\";\n  isTrue(\"isLoaded\");\n  isTrue(\"isDirty\");\n  isTrue(\"isSaving\");\n  isTrue(\"isDeleted\");\n  isFalse(\"isError\");\n});\n\ntest(\"the deleted.saved state\", function() {\n  stateName = \"deleted.saved\";\n  isTrue(\"isLoaded\");\n  isFalse(\"isDirty\");\n  isFalse(\"isSaving\");\n  isTrue(\"isDeleted\");\n  isFalse(\"isError\");\n});\n\n\ntest(\"the error state\", function() {\n  stateName = \"error\";\n  isFalse(\"isLoaded\");\n  isFalse(\"isDirty\");\n  isFalse(\"isSaving\");\n  isFalse(\"isDeleted\");\n  isTrue(\"isError\");\n});\n\nmodule(\"DS.Store working with a DS.Adapter\");\n\ntest(\"RESTAdapter is default adapter for DS.Store\", function () {\n  var currentStore = DS.Store.create();\n  ok(DS.RESTAdapter.detectInstance(currentStore.get('_adapter')), \"Store's adapter is instance of RESTAdapter\");\n});\n\ntest(\"Calling Store#find invokes its adapter#find\", function() {\n  expect(4);\n\n  var adapter = TestAdapter.create({\n    find: function(store, type, id) {\n      ok(true, \"Adapter#find was called\");\n      equal(store, currentStore, \"Adapter#find was called with the right store\");\n      equal(type,  currentType,  \"Adapter#find was called with the type passed into Store#find\");\n      equal(id,    1,            \"Adapter#find was called with the id passed into Store#find\");\n    }\n  });\n\n  var currentStore = DS.Store.create({ adapter: adapter });\n  var currentType = DS.Model.extend();\n\n  currentStore.find(currentType, 1);\n});\n\ntest(\"DS.Store has a load method to load in a new record\", function() {\n  var adapter = TestAdapter.create({\n    find: function(store, type, id) {\n      store.load(type, id, { id: 1, name: \"Scumbag Dale\" });\n    }\n  });\n\n  var currentStore = DS.Store.create({ adapter: adapter });\n  var currentType = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var object = currentStore.find(currentType, 1);\n\n  equal(adapter.serialize(object).name, \"Scumbag Dale\", \"the data hash was inserted\");\n});\n\ntest(\"IDs provided as numbers are coerced to strings\", function() {\n  var adapter = TestAdapter.create({\n    find: function(store, type, id) {\n      equal(typeof id, 'string', \"id has been normalized to a string\");\n      store.load(type, id, { id: 1, name: \"Scumbag Sylvain\" });\n    }\n  });\n\n  var currentStore = DS.Store.create({ adapter: adapter });\n  var currentType = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var object = currentStore.find(currentType, 1);\n  equal(typeof object.get('id'), 'string', \"id was coerced to a string\");\n\n  currentStore.load(currentType, { id: 2, name: \"Scumbag Sam Saffron\" });\n  object = currentStore.find(currentType, 2);\n  ok(object, \"object was found\");\n  equal(typeof object.get('id'), 'string', \"id is a string despite being supplied and searched for as a number\");\n});\n\n\nvar array = [{ id: 1, name: \"Scumbag Dale\" }, { id: 2, name: \"Scumbag Katz\" }, { id: 3, name: \"Scumbag Bryn\" }];\n\ntest(\"DS.Store has a load method to load in an Array of records\", function() {\n  var adapter = TestAdapter.create({\n\n    findMany: function(store, type, ids) {\n      store.loadMany(type, ids, array);\n    }\n  });\n\n  var currentStore = DS.Store.create({ adapter: adapter });\n  var currentType = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var objects = currentStore.findMany(currentType, [1,2,3]);\n\n  for (var i=0, l=get(objects, 'length'); i<l; i++) {\n    var object = objects.objectAt(i), hash = array[i];\n\n    deepEqual(adapter.serialize(object, { includeId: true }), hash);\n  }\n});\n\ntest(\"DS.Store loads individual records without explicit IDs\", function() {\n  var store = DS.Store.create();\n  var Person = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  store.load(Person, { id: 1, name: \"Tom Dale\" });\n\n  var tom = store.find(Person, 1);\n  equal(get(tom, 'name'), \"Tom Dale\", \"the person was successfully loaded for the given ID\");\n});\n\ntest(\"can load data for the same record if it is not dirty\", function() {\n  var store = DS.Store.create();\n  var Person = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  store.load(Person, { id: 1, name: \"Tom Dale\" });\n  var tom = store.find(Person, 1);\n\n  equal(get(tom, 'isDirty'), false, \"precond - record is not dirty\");\n  equal(get(tom, 'name'), \"Tom Dale\", \"returns the correct name\");\n\n  store.load(Person, { id: 1, name: \"Captain Underpants\" });\n  equal(get(tom, 'name'), \"Captain Underpants\", \"updated record with new date\");\n});\n\n/*\ntest(\"DS.Store loads individual records without explicit IDs with a custom primaryKey\", function() {\n  var store = DS.Store.create();\n  var Person = DS.Model.extend({ name: DS.attr('string'), primaryKey: 'key' });\n\n  store.load(Person, { key: 1, name: \"Tom Dale\" });\n\n  var tom = store.find(Person, 1);\n  equal(get(tom, 'name'), \"Tom Dale\", \"the person was successfully loaded for the given ID\");\n});\n*/\n\ntest(\"DS.Store passes only needed guids to findMany\", function() {\n  expect(13);\n\n  var adapter = TestAdapter.create({\n    findMany: function(store, type, ids) {\n      deepEqual(ids, ['4','5','6'], \"only needed ids are passed\");\n    }\n  });\n\n  var currentStore = DS.Store.create({ adapter: adapter });\n  var currentType = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  currentStore.loadMany(currentType, [1,2,3], array);\n\n  var objects = currentStore.findMany(currentType, [1,2,3,4,5,6]);\n\n  equal(get(objects, 'length'), 6, \"the RecordArray returned from findMany has all the objects\");\n  equal(get(objects, 'isLoaded'), false, \"the RecordArrays' isLoaded flag is false\");\n\n  objects.then(function(resolvedObjects) {\n    strictEqual(resolvedObjects, objects, \"The promise is resolved with the RecordArray\");\n    equal(get(objects, 'isLoaded'), true, \"The objects are loaded\");\n  });\n\n  var i, object, hash;\n  for (i=0; i<3; i++) {\n    object = objects.objectAt(i);\n    hash = array[i];\n\n    deepEqual(adapter.serialize(object, { includeId: true }), hash);\n  }\n\n  for (i=3; i<6; i++) {\n    object = objects.objectAt(i);\n    ok(currentType.detectInstance(object), \"objects are instances of the RecordArray's type\");\n  }\n\n  currentStore.loadMany(currentType, [4,5,6], [{ id: 4 }, { id: 5 }, { id: 6 }]);\n\n  equal(objects.everyProperty('isLoaded'), true, \"every objects' isLoaded is true\");\n  equal(get(objects, 'isLoaded'), true, \"after all objects are loaded, the RecordArrays' isLoaded flag is true\");\n});\n\ntest(\"a findManys' isLoaded is true when all objects are loaded\", function() {\n  expect(4);\n\n  var adapter = TestAdapter.create({\n    findMany: function(store, type, ids) {\n      ok(false, \"findMany should not have been called\");\n    }\n  });\n\n  var currentStore = DS.Store.create({ adapter: adapter });\n  var currentType = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  currentStore.loadMany(currentType, [1,2,3], array);\n\n  var objects = currentStore.findMany(currentType, [1,2,3]);\n\n  objects.then(function(resolvedObjects) {\n    strictEqual(resolvedObjects, objects, \"The resolved RecordArray is correct\");\n    equal(get(objects, 'isLoaded'), true, \"The RecordArray is loaded by the time the promise is resolved\");\n  });\n\n  equal(get(objects, 'length'), 3, \"the RecordArray returned from findMany has all the objects\");\n  equal(get(objects, 'isLoaded'), true, \"the RecordArrays' isLoaded flag is true\");\n});\n\ntest(\"loadMany extracts ids from an Array of hashes if no ids are specified\", function() {\n  var store = DS.Store.create();\n\n  var Person = DS.Model.extend({ name: DS.attr('string') });\n\n  store.loadMany(Person, array);\n  equal(get(store.find(Person, 1), 'name'), \"Scumbag Dale\", \"correctly extracted id for loaded data\");\n});\n\ntest(\"loadMany takes an optional Object and passes it on to the Adapter\", function() {\n  var passedQuery = { page: 1 };\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var adapter = TestAdapter.create({\n    findQuery: function(store, type, query) {\n      equal(type, Person, \"The type was Person\");\n      equal(query, passedQuery, \"The query was passed in\");\n    }\n  });\n\n  var store = DS.Store.create({\n    adapter: adapter\n  });\n\n  store.find(Person, passedQuery);\n});\n\ntest(\"all(type) returns a record array of all records of a specific type\", function() {\n  var store = DS.Store.create({ adapter: DS.Adapter.create() });\n  var Person = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  store.load(Person, 1, { id: 1, name: \"Tom Dale\" });\n\n  var results = store.all(Person);\n  equal(get(results, 'length'), 1, \"record array should have the original object\");\n  equal(get(results.objectAt(0), 'name'), \"Tom Dale\", \"record has the correct information\");\n\n  store.load(Person, 2, { id: 2, name: \"Yehuda Katz\" });\n  equal(get(results, 'length'), 2, \"record array should have the new object\");\n  equal(get(results.objectAt(1), 'name'), \"Yehuda Katz\", \"record has the correct information\");\n\n  strictEqual(results, store.all(Person), \"subsequent calls to all return the same recordArray)\");\n});\n\ntest(\"a new record of a particular type is created via store.createRecord(type)\", function() {\n  expect(6);\n  var store = DS.Store.create();\n  var Person = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var person = store.createRecord(Person);\n\n  person.then(function(resolvedPerson) {\n    strictEqual(resolvedPerson, person, \"The promise is resolved with the record\");\n    equal(get(person, 'isLoaded'), true, \"The record is loaded\");\n  });\n\n  equal(get(person, 'isLoaded'), true, \"A newly created record is loaded\");\n  equal(get(person, 'isNew'), true, \"A newly created record is new\");\n  equal(get(person, 'isDirty'), true, \"A newly created record is dirty\");\n\n  set(person, 'name', \"Braaahm Dale\");\n\n  equal(get(person, 'name'), \"Braaahm Dale\", \"Even if no hash is supplied, `set` still worked\");\n});\n\ntest(\"a new record with a specific id can't be created if this id is already used in the store\", function() {\n  var store = DS.Store.create();\n  var Person = DS.Model.extend({\n    name: DS.attr('string'),\n  });\n  Person.reopenClass({\n    toString: function() {\n      return 'Person';\n    }\n  });\n  store.createRecord(Person, {id: 5});\n\n  raises(\n    function() { store.createRecord(Person, {id: 5}); },\n    /The id 5 has already been used with another record of type Person/,\n    \"Creating a record with an if an id already in used in the store is disallowed\"\n  );\n});\n\ntest(\"an initial data hash can be provided via store.createRecord(type, hash)\", function() {\n  expect(6);\n  var store = DS.Store.create();\n  var Person = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var person = store.createRecord(Person, { name: \"Brohuda Katz\" });\n\n  person.then(function(resolvedPerson) {\n    strictEqual(resolvedPerson, person, \"The promise is resolved with the record\");\n    equal(get(person, 'isLoaded'), true, \"The record is loaded\");\n  });\n\n  equal(get(person, 'isLoaded'), true, \"A newly created record is loaded\");\n  equal(get(person, 'isNew'), true, \"A newly created record is new\");\n  equal(get(person, 'isDirty'), true, \"A newly created record is dirty\");\n\n  equal(get(person, 'name'), \"Brohuda Katz\", \"The initial data hash is provided\");\n});\n\ntest(\"if an id is supplied in the initial data hash, it can be looked up using `store.find`\", function() {\n  var store = DS.Store.create();\n  var Person = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  var person = store.createRecord(Person, { id: 1, name: \"Brohuda Katz\" });\n\n  var again = store.find(Person, 1);\n\n  strictEqual(person, again, \"the store returns the loaded object\");\n});\n\ntest(\"records inside a collection view should have their ids updated\", function() {\n  var Person = DS.Model.extend();\n\n  var idCounter = 1;\n  var adapter = TestAdapter.create({\n    createRecord: function(store, type, record) {\n      store.didSaveRecord(record, {name: record.get('name'), id: idCounter++});\n    }\n  });\n\n  var store = DS.Store.create({\n    adapter: adapter\n  });\n\n  var container = Ember.CollectionView.create({\n    content: store.all(Person)\n  });\n\n  container.appendTo('#qunit-fixture');\n\n  store.createRecord(Person, {name: 'Tom Dale'});\n  store.createRecord(Person, {name: 'Yehuda Katz'});\n\n  store.commit();\n\n  container.content.forEach(function(person, index) {\n    equal(person.get('id'), index + 1, \"The record's id should be correct.\");\n  });\n\n  Ember.run(function() {\n    container.destroy();\n  });\n});\n\nmodule(\"DS.State - Lifecycle Callbacks\");\n\nasyncTest(\"a record receives a didLoad callback when it has finished loading\", function() {\n  var Person = DS.Model.extend({\n    didLoad: function() {\n      ok(\"The didLoad callback was called\");\n    }\n  });\n\n  var adapter = TestAdapter.create({\n    find: function(store, type, id) {\n      store.load(Person, 1, { id: 1, name: \"Foo\" });\n    }\n  });\n\n  var store = DS.Store.create({\n    adapter: adapter\n  });\n  var person = store.find(Person, 1);\n\n  person.then(function(resolvedPerson) {\n    equal(resolvedPerson, person, \"The resolved value is correct\");\n    start();\n  });\n});\n\ntest(\"a record receives a didUpdate callback when it has finished updating\", function() {\n  var callCount = 0;\n\n  var Person = DS.Model.extend({\n    bar: DS.attr('string'),\n\n    didUpdate: function() {\n      callCount++;\n      equal(get(this, 'isSaving'), false, \"record should be saving\");\n      equal(get(this, 'isDirty'), false, \"record should not be dirty\");\n    }\n  });\n\n  var adapter = TestAdapter.create({\n    find: function(store, type, id) {\n      store.load(Person, 1, { id: 1, name: \"Foo\" });\n    },\n\n    updateRecord: function(store, type, record) {\n      equal(callCount, 0, \"didUpdate callback was not called until didSaveRecord is called\");\n\n      store.didSaveRecord(record);\n    }\n  });\n\n  var store = DS.Store.create({\n    adapter: adapter\n  });\n\n  var person = store.find(Person, 1);\n  equal(callCount, 0, \"precond - didUpdate callback was not called yet\");\n\n  person.set('bar', \"Bar\");\n  store.commit();\n\n  equal(callCount, 1, \"didUpdate called after update\");\n});\n\ntest(\"a record receives a didCreate callback when it has finished updating\", function() {\n  var callCount = 0;\n\n  var Person = DS.Model.extend({\n    didCreate: function() {\n      callCount++;\n      equal(get(this, 'isSaving'), false, \"record should not be saving\");\n      equal(get(this, 'isDirty'), false, \"record should not be dirty\");\n    }\n  });\n\n  var adapter = TestAdapter.create({\n    createRecord: function(store, type, record) {\n      equal(callCount, 0, \"didCreate callback was not called until didSaveRecord is called\");\n\n      store.didSaveRecord(record);\n    }\n  });\n\n  var store = DS.Store.create({\n    adapter: adapter\n  });\n\n  equal(callCount, 0, \"precond - didCreate callback was not called yet\");\n\n  store.createRecord(Person, { id: 69, name: \"Newt Gingrich\" });\n  store.commit();\n\n  equal(callCount, 1, \"didCreate called after commit\");\n});\n\ntest(\"a record receives a didDelete callback when it has finished deleting\", function() {\n  var callCount = 0;\n\n  var Person = DS.Model.extend({\n    bar: DS.attr('string'),\n\n    didDelete: function() {\n      callCount++;\n\n      equal(get(this, 'isSaving'), false, \"record should not be saving\");\n      equal(get(this, 'isDirty'), false, \"record should not be dirty\");\n    }\n  });\n\n  var adapter = TestAdapter.create({\n    find: function(store, type, id) {\n      store.load(Person, 1, { id: 1, name: \"Foo\" });\n    },\n\n    deleteRecord: function(store, type, record) {\n      equal(callCount, 0, \"didDelete callback was not called until didSaveRecord is called\");\n\n      store.didSaveRecord(record);\n    }\n  });\n\n  var store = DS.Store.create({\n    adapter: adapter\n  });\n\n  var person = store.find(Person, 1);\n  equal(callCount, 0, \"precond - didDelete callback was not called yet\");\n\n  person.deleteRecord();\n  store.commit();\n\n  equal(callCount, 1, \"didDelete called after delete\");\n});\n\ntest(\"a record receives a becameInvalid callback when it became invalid\", function() {\n  var callCount = 0;\n\n  var Person = DS.Model.extend({\n    bar: DS.attr('string'),\n\n    becameInvalid: function() {\n      callCount++;\n\n      equal(get(this, 'isSaving'), false, \"record should not be saving\");\n      equal(get(this, 'isDirty'), true, \"record should be dirty\");\n    }\n  });\n\n  var adapter = TestAdapter.create({\n    find: function(store, type, id) {\n      store.load(Person, 1, { id: 1, name: \"Foo\" });\n    },\n\n    updateRecord: function(store, type, record) {\n      equal(callCount, 0, \"becameInvalid callback was not called untill recordWasInvalid is called\");\n\n      store.recordWasInvalid(record, {bar: 'error'});\n    }\n  });\n\n  var store = DS.Store.create({\n    adapter: adapter\n  });\n\n  var person = store.find(Person, 1);\n  equal(callCount, 0, \"precond - becameInvalid callback was not called yet\");\n\n  person.set('bar', \"Bar\");\n  store.commit();\n\n  equal(callCount, 1, \"becameInvalid called after invalidating\");\n});\n\ntest(\"an ID of 0 is allowed\", function() {\n  var store = DS.Store.create();\n\n  var Person = DS.Model.extend({\n    name: DS.attr('string')\n  });\n\n  store.load(Person, { id: 0, name: \"Tom Dale\" });\n  equal(store.all(Person).objectAt(0).get('name'), \"Tom Dale\", \"found record with id 0\");\n});\n\nvar stubAdapter, store;\n\nmodule(\"DS.Store - Adapter Callbacks\", {\n  setup: function() {\n    stubAdapter = Ember.Object.create({\n      extractId: function(type, hash) {\n        return hash.id;\n      },\n\n      materialize: function(record, hash) {\n        record.materializedData = hash;\n      }\n    });\n\n    store = DS.Store.create({ adapter: stubAdapter });\n  },\n\n  teardown: function() {\n    stubAdapter.destroy();\n    store.destroy();\n  }\n});\n\nvar tryToFind, Record;\n\nmodule(\"DS.Store - unload record\", {\n  setup: function() {\n    store = DS.Store.create({\n      adapter: DS.Adapter.create({\n        find: function() {\n          tryToFind = true;\n        }\n      })\n    });\n\n    Record = DS.Model.extend({\n      title: DS.attr('string')\n    });\n  },\n  teardown: function() {\n    store.destroy();\n  }\n});\n\ntest(\"unload a dirty record\", function() {\n  store.load(Record, {id: 1, title: 'toto'});\n\n  var record = store.find(Record, 1);\n  record.set('title', 'toto2');\n\n  equal(get(record, 'isDirty'), true, \"record is dirty\");\n  raises(function() {\n    record.unloadRecord();\n  }, \"You can only unload a loaded non dirty record.\", \"can not unload dirty record\");\n});\n\ntest(\"unload a record\", function() {\n  store.load(Record, {id: 1, title: 'toto'});\n\n  var record = store.find(Record, 1);\n  equal(get(record, 'id'), 1, \"found record with id 1\");\n  equal(get(record, 'isDirty'), false, \"record is not dirty\");\n\n  store.unloadRecord(record);\n\n  equal(get(record, 'isDirty'), false, \"record is not dirty\");\n  equal(get(record, 'isDeleted'), true, \"record is deleted\");\n\n  tryToFind = false;\n  store.find(Record, 1);\n  equal(tryToFind, true, \"not found record with id 1\");\n});\n\n})();\n//@ sourceURL=ember-data/~tests/unit/store_test");