var JSHINTRC = {
    "predef": [
        "define",
        "console",
        "Ember",
        "DS",
        "Handlebars",
        "Metamorph",
        "RSVP",
        "require",
        "requireModule",
        "equal",
        "notEqual",
        "notStrictEqual",
        "test",
        "asyncTest",
        "testBoth",
        "testWithDefault",
        "raises",
        "throws",
        "deepEqual",
        "start",
        "stop",
        "ok",
        "strictEqual",
        "module",
        "expect",
        "minispade"
    ],

    "node" : false,
    "browser" : true,

    "boss" : true,
    "curly": false,
    "debug": false,
    "devel": false,
    "eqeqeq": true,
    "evil": true,
    "forin": false,
    "immed": false,
    "laxbreak": false,
    "newcap": true,
    "noarg": true,
    "noempty": false,
    "nonew": false,
    "nomen": false,
    "onevar": false,
    "plusplus": false,
    "regexp": false,
    "undef": true,
    "sub": true,
    "strict": false,
    "white": false,
    "eqnull": true
}
;

minispade.register('container/~tests/container_test', "(function() {var passedOptions;\nvar Container = requireModule('container');\n\nvar setProperties = function(object, properties) {\n  for (var key in properties) {\n    if (properties.hasOwnProperty(key)) {\n      object[key] = properties[key];\n    }\n  }\n};\n\nmodule(\"Container\");\n\nvar guids = 0;\n\nfunction factory() {\n  var Klass = function(options) {\n    setProperties(this, options);\n    this._guid = guids++;\n  };\n\n  Klass.prototype.destroy = function() {\n    this.isDestroyed = true;\n  };\n\n  Klass.prototype.toString = function() {\n    return \"<Factory:\" + this._guid + \">\";\n  };\n\n  Klass.create = function(options) {\n    passedOptions = options;\n    return new Klass(options);\n  };\n\n  return Klass;\n}\n\ntest(\"A registered factory returns the same instance each time\", function() {\n  var container = new Container();\n  var PostController = factory();\n\n  container.register('controller:post', PostController);\n\n  var postController = container.lookup('controller:post');\n\n  ok(postController instanceof PostController, \"The lookup is an instance of the factory\");\n\n  equal(postController, container.lookup('controller:post'));\n});\n\ntest(\"A registered factory returns a fresh instance if singleton: false is passed as an option\", function() {\n  var container = new Container();\n  var PostController = factory();\n\n  container.register('controller:post', PostController);\n\n  var postController1 = container.lookup('controller:post');\n  var postController2 = container.lookup('controller:post', { singleton: false });\n  var postController3 = container.lookup('controller:post', { singleton: false });\n  var postController4 = container.lookup('controller:post');\n\n  equal(postController1.toString(), postController4.toString(), \"Singleton factories looked up normally return the same value\");\n  notEqual(postController1.toString(), postController2.toString(), \"Singleton factories are not equal to factories looked up with singleton: false\");\n  notEqual(postController2.toString(), postController3.toString(), \"Two factories looked up with singleton: false are not equal\");\n  notEqual(postController3.toString(), postController4.toString(), \"A singleton factory looked up after a factory called with singleton: false is not equal\");\n\n  ok(postController1 instanceof PostController, \"All instances are instances of the registered factory\");\n  ok(postController2 instanceof PostController, \"All instances are instances of the registered factory\");\n  ok(postController3 instanceof PostController, \"All instances are instances of the registered factory\");\n  ok(postController4 instanceof PostController, \"All instances are instances of the registered factory\");\n});\n\ntest(\"A registered factory returns true for `has` if an item is registered\", function() {\n  var container = new Container();\n  var PostController = factory();\n\n  container.register('controller:post', PostController);\n\n  equal(container.has('controller:post'), true, \"The `has` method returned true for registered factories\");\n  equal(container.has('controller:posts'), false, \"The `has` method returned false for unregistered factories\");\n});\n\ntest(\"A container lookup has access to the container\", function() {\n  var container = new Container();\n  var PostController = factory();\n\n  container.register('controller:post', PostController);\n\n  var postController = container.lookup('controller:post');\n\n  equal(postController.container, container);\n});\n\ntest(\"A factory type with a registered injection receives the injection\", function() {\n  var container = new Container();\n  var PostController = factory();\n  var Store = factory();\n\n  container.register('controller:post', PostController);\n  container.register('store:main', Store);\n\n  container.typeInjection('controller', 'store', 'store:main');\n\n  var postController = container.lookup('controller:post');\n  var store = container.lookup('store:main');\n\n  equal(postController.store, store);\n});\n\ntest(\"An individual factory with a registered injection receives the injection\", function() {\n  var container = new Container();\n  var PostController = factory();\n  var Store = factory();\n\n  container.register('controller:post', PostController);\n  container.register('store:main', Store);\n\n  container.injection('controller:post', 'store', 'store:main');\n\n  var postController = container.lookup('controller:post');\n  var store = container.lookup('store:main');\n\n  deepEqual(passedOptions, {\n    store: store,\n    container: container,\n    _debugContainerKey: 'controller:post'\n  });\n});\n\ntest(\"A factory with both type and individual injections\", function() {\n  var container = new Container();\n  var PostController = factory();\n  var Store = factory();\n  var Router = factory();\n\n  container.register('controller:post', PostController);\n  container.register('store:main', Store);\n  container.register('router:main', Router);\n\n  container.injection('controller:post', 'store', 'store:main');\n  container.typeInjection('controller', 'router', 'router:main');\n\n  var postController = container.lookup('controller:post');\n  var store = container.lookup('store:main');\n  var router = container.lookup('router:main');\n\n  equal(postController.store, store);\n  equal(postController.router, router);\n});\n\ntest(\"A non-singleton factory is never cached\", function() {\n  var container = new Container();\n  var PostView = factory();\n\n  container.register('view:post', PostView, { singleton: false });\n\n  var postView1 = container.lookup('view:post');\n  var postView2 = container.lookup('view:post');\n\n  ok(postView1 !== postView2, \"Non-singletons are not cached\");\n});\n\ntest(\"A non-instantiated property is not instantiated\", function() {\n  var container = new Container();\n\n  var template = function() {};\n  container.register('template:foo', template, { instantiate: false });\n  equal(container.lookup('template:foo'), template);\n});\n\ntest(\"A failed lookup returns undefined\", function() {\n  var container = new Container();\n\n  equal(container.lookup(\"doesnot:exist\"), undefined);\n});\n\ntest(\"Destroying the container destroys any cached singletons\", function() {\n  var container = new Container();\n  var PostController = factory();\n  var PostView = factory();\n  var template = function() {};\n\n  container.register('controller:post', PostController);\n  container.register('view:post', PostView, { singleton: false });\n  container.register('template:post', template, { instantiate: false });\n\n  container.injection('controller:post', 'postView', 'view:post');\n\n  var postController = container.lookup('controller:post');\n  var postView = postController.postView;\n\n  ok(postView instanceof PostView, \"The non-singleton was injected\");\n\n  container.destroy();\n\n  ok(postController.isDestroyed, \"Singletons are destroyed\");\n  ok(!postView.isDestroyed, \"Non-singletons are not destroyed\");\n});\n\ntest(\"The container can take a hook to resolve factories lazily\", function() {\n  var container = new Container();\n  var PostController = factory();\n\n  container.resolve = function(fullName) {\n    if (fullName === 'controller:post') {\n      return PostController;\n    }\n  };\n\n  var postController = container.lookup('controller:post');\n\n  ok(postController instanceof PostController, \"The correct factory was provided\");\n});\n\ntest(\"The container respect the resolver hook for `has`\", function() {\n  var container = new Container();\n  var PostController = factory();\n\n  container.resolve = function(fullName) {\n    if (fullName === 'controller:post') {\n      return PostController;\n    }\n  };\n\n  ok(container.has('controller:post'), \"the `has` method uses the resolver hook\");\n});\n\ntest(\"The container normalizes names before resolving\", function() {\n  var container = new Container();\n  var PostController = factory();\n\n  container.normalize = function(fullName) {\n    return 'controller:post';\n  };\n\n  container.register('controller:post', PostController);\n  var postController = container.lookup('wycats');\n\n  ok(postController instanceof PostController, \"Normalizes the name before resolving\");\n});\n\ntest(\"The container can get options that should be applied to all factories for a given type\", function() {\n  var container = new Container();\n  var PostView = factory();\n\n  container.resolve = function(fullName) {\n    if (fullName === 'view:post') {\n      return PostView;\n    }\n  };\n\n  container.optionsForType('view', { singleton: false });\n\n  var postView1 = container.lookup('view:post');\n  var postView2 = container.lookup('view:post');\n\n  ok(postView1 instanceof PostView, \"The correct factory was provided\");\n  ok(postView2 instanceof PostView, \"The correct factory was provided\");\n\n  ok(postView1 !== postView2, \"The two lookups are different\");\n});\n\n})();\n//@ sourceURL=container/~tests/container_test");minispade.register('container/~tests/sub_container_test', "(function() {var passedOptions;\nvar Container = requireModule('container');\n\nvar setProperties = function(object, properties) {\n  for (var key in properties) {\n    if (properties.hasOwnProperty(key)) {\n      object[key] = properties[key];\n    }\n  }\n};\n\nvar container;\n\nmodule(\"Container (sub-containers)\", {\n  setup: function() {\n    container = new Container();\n    var PostController = factory();\n\n    container.register('controller:post', PostController);\n  },\n\n  teardown: function() {\n    if (!container.isDestroyed) {\n      container.destroy();\n    }\n  }\n});\n\nfunction factory() {\n  var Klass = function(options) {\n    setProperties(this, options);\n  };\n\n  Klass.prototype.destroy = function() {\n    this.isDestroyed = true;\n  };\n\n  Klass.create = function(options) {\n    passedOptions = options;\n    return new Klass(options);\n  };\n\n  return Klass;\n}\n\ntest(\"Singletons already found on the parent container will be found again on the sub-container\", function() {\n  var postController = container.lookup('controller:post');\n  var subContainer = container.child();\n\n  equal(postController, subContainer.lookup('controller:post'));\n});\n\ntest(\"Destroying a sub-container doesn't destroy any singletons on the parent\", function() {\n  var postController = container.lookup('controller:post');\n  var subContainer = container.child();\n  subContainer.destroy();\n\n  equal(postController.isDestroyed, undefined, \"The parent's singletons are not destroyed\");\n});\n\ntest(\"Looking up a singleton that wasn't yet looked up on a child container will cache it on the child\", function() {\n  var subContainer1 = container.child();\n  var subContainer2 = container.child();\n\n  var postController1 = subContainer1.lookup('controller:post');\n  var postController2 = subContainer2.lookup('controller:post');\n\n  notEqual(postController1, postController2);\n});\n\ntest(\"Destroying a parent container destroys the sub-containers\", function() {\n  var subContainer1 = container.child();\n  var subContainer2 = container.child();\n\n  var postController1 = subContainer1.lookup('controller:post');\n  var postController2 = subContainer2.lookup('controller:post');\n\n  container.destroy();\n\n  equal(postController1.isDestroyed, true, \"The child's singleton is destroyed\");\n  equal(postController2.isDestroyed, true, \"The child's singleton is destroyed\");\n});\n\ntest(\"Resolver is inherited from parent container\", function() {\n  var otherController = factory();\n  container.resolver = function(fullName) {\n    return otherController;\n  };\n  var subContainer = container.child();\n\n  equal(subContainer.resolve('controller:post'), otherController, 'should use parent resolver');\n  equal(container.resolve('controller:post'), otherController, 'should use resolver');\n});\n\ntest(\"Type injections should be inherited\", function() {\n  var container = new Container();\n  var PostController = factory();\n  var Store = factory();\n\n  container.register('controller:post', PostController);\n  container.register('store:main', Store);\n\n  container.typeInjection('controller', 'store', 'store:main');\n\n  var store = container.lookup('store:main');\n\n  var childContainer = container.child();\n  var postController = childContainer.lookup('controller:post');\n\n  equal(postController.store, store);\n});\n\n})();\n//@ sourceURL=container/~tests/sub_container_test");minispade.register('ember-application/~tests/system/application_test', "(function() {var view;\nvar application;\nvar set = Ember.set, get = Ember.get;\nvar trim = Ember.$.trim;\n\nmodule(\"Ember.Application\", {\n  setup: function() {\n    Ember.$(\"#qunit-fixture\").html(\"<div id='one'><div id='one-child'>HI</div></div><div id='two'>HI</div>\");\n    Ember.run(function() {\n      application = Ember.Application.create({ rootElement: '#one', router: null });\n    });\n  },\n\n  teardown: function() {\n    if (application) {\n      Ember.run(function(){ application.destroy(); });\n    }\n  }\n});\n\ntest(\"you can make a new application in a non-overlapping element\", function() {\n  var app;\n  Ember.run(function() {\n    app = Ember.Application.create({ rootElement: '#two', router: null });\n  });\n  Ember.run(function() {\n    app.destroy();\n  });\n  ok(true, \"should not raise\");\n});\n\ntest(\"you cannot make a new application that is a parent of an existing application\", function() {\n  raises(function() {\n    Ember.run(function() {\n      Ember.Application.create({ rootElement: '#qunit-fixture' });\n    });\n  }, Error);\n});\n\ntest(\"you cannot make a new application that is a descendent of an existing application\", function() {\n  raises(function() {\n    Ember.run(function() {\n      Ember.Application.create({ rootElement: '#one-child' });\n    });\n  }, Error);\n});\n\ntest(\"you cannot make a new application that is a duplicate of an existing application\", function() {\n  raises(function() {\n    Ember.run(function() {\n      Ember.Application.create({ rootElement: '#one' });\n    });\n  }, Error);\n});\n\ntest(\"you cannot make two default applications without a rootElement error\", function() {\n  // Teardown existing\n  Ember.run(function() {\n    application.destroy();\n  });\n\n  Ember.run(function() {\n    application = Ember.Application.create({ router: false });\n  });\n  raises(function() {\n    Ember.run(function() {\n      Ember.Application.create({ router: false });\n    });\n  }, Error);\n});\n\ntest(\"acts like a namespace\", function() {\n  var originalLookup = Ember.lookup;\n\n  try {\n    var lookup = Ember.lookup = {}, app;\n    Ember.run(function() {\n      app = lookup.TestApp = Ember.Application.create({ rootElement: '#two', router: false });\n    });\n    Ember.BOOTED = false;\n    app.Foo = Ember.Object.extend();\n    equal(app.Foo.toString(), \"TestApp.Foo\", \"Classes pick up their parent namespace\");\n    Ember.run(function() {\n      app.destroy();\n    });\n  } finally {\n    Ember.lookup = originalLookup;\n  }\n});\n\nvar app;\n\nmodule(\"Ember.Application initialization\", {\n  teardown: function() {\n    Ember.TEMPLATES = {};\n    Ember.run(function(){ app.destroy(); });\n  }\n});\n\ntest('initialized application go to initial route', function() {\n  Ember.$(\"#qunit-fixture\").empty();\n\n  Ember.run(function() {\n    app = Ember.Application.create({\n      rootElement: '#qunit-fixture'\n    });\n\n    app.Router.reopen({\n      location: 'none'\n    });\n\n    app.register('template:application',\n      Ember.Handlebars.compile(\"{{outlet}}\")\n    );\n\n    Ember.TEMPLATES.index = Ember.Handlebars.compile(\n      \"<h1>Hi from index</h1>\"\n    );\n  });\n\n  equal(Ember.$('#qunit-fixture h1').text(), \"Hi from index\");\n});\n\ntest(\"initialize application via initialize call\", function() {\n  Ember.$(\"#qunit-fixture\").empty();\n\n  Ember.run(function() {\n    app = Ember.Application.create({\n      rootElement: '#qunit-fixture'\n    });\n\n    app.Router.reopen({\n      location: 'none'\n    });\n\n    app.ApplicationView = Ember.View.extend({\n      template: function() { return \"<h1>Hello!</h1>\"; }\n    });\n  });\n\n  // This is not a public way to access the container; we just\n  // need to make some assertions about the created router\n  var router = app.__container__.lookup('router:main');\n  equal(router instanceof Ember.Router, true, \"Router was set from initialize call\");\n  equal(router.location instanceof Ember.NoneLocation, true, \"Location was set from location implementation name\");\n});\n\ntest(\"initialize application with stateManager via initialize call from Router class\", function() {\n  Ember.$(\"#qunit-fixture\").empty();\n\n  Ember.run(function() {\n    app = Ember.Application.create({\n      rootElement: '#qunit-fixture'\n    });\n\n    app.Router.reopen({\n      location: 'none'\n    });\n\n    app.register('template:application', function() {\n      return \"<h1>Hello!</h1>\";\n    });\n  });\n\n  var router = app.__container__.lookup('router:main');\n  equal(router instanceof Ember.Router, true, \"Router was set from initialize call\");\n  equal(Ember.$(\"#qunit-fixture h1\").text(), \"Hello!\");\n});\n\ntest(\"ApplicationView is inserted into the page\", function() {\n  Ember.$(\"#qunit-fixture\").empty();\n\n  Ember.run(function() {\n    app = Ember.Application.create({\n      rootElement: '#qunit-fixture'\n    });\n\n    app.ApplicationView = Ember.View.extend({\n      render: function(buffer) {\n        buffer.push(\"<h1>Hello!</h1>\");\n      }\n    });\n\n    app.ApplicationController = Ember.Controller.extend();\n\n    app.Router.reopen({\n      location: 'none'\n    });\n  });\n\n  equal(Ember.$(\"#qunit-fixture\").text(), \"Hello!\");\n});\n\ntest(\"Minimal Application initialized with just an application template\", function() {\n  Ember.$('#qunit-fixture').html('<script type=\"text/x-handlebars\">Hello World</script>');\n  Ember.run(function () {\n    app = Ember.Application.create({\n      rootElement: '#qunit-fixture'\n    });\n  });\n\n  equal(trim(Ember.$('#qunit-fixture').text()), 'Hello World');\n});\n\ntest('enable log  of libraries with an ENV var', function() {\n  var debug = Ember.debug;\n  Ember.LOG_VERSION = true;\n\n  Ember.debug = function(message) {\n    ok(true, 'libraries versions logged');\n  };\n\n  Ember.$(\"#qunit-fixture\").empty();\n\n  Ember.run(function() {\n    app = Ember.Application.create({\n      rootElement: '#qunit-fixture'\n    });\n\n    app.Router.reopen({\n      location: 'none'\n    });\n  });\n\n  Ember.LOG_VERSION = false;\n  Ember.debug = debug;\n});\n\ntest('disable log version of libraries with an ENV var', function() {\n  var debug = Ember.debug, logged = false;\n\n  Ember.LOG_VERSION = false;\n\n  Ember.debug = function(message) {\n    logged = true;\n  };\n\n  Ember.$(\"#qunit-fixture\").empty();\n\n  Ember.run(function() {\n    app = Ember.Application.create({\n      rootElement: '#qunit-fixture'\n    });\n\n    app.Router.reopen({\n      location: 'none'\n    });\n  });\n\n  ok(!logged, 'libraries versions logged');\n\n  Ember.debug = debug;\n});\n\nvar locator, originalLookup = Ember.lookup, lookup;\n\nmodule(\"Ember.Application Depedency Injection\", {\n  setup: function(){\n    Ember.$(\"#qunit-fixture\").html(\"<div id='one'><div id='one-child'>HI</div></div><div id='two'>HI</div>\");\n    Ember.run(function(){\n      application = Ember.Application.create({rootElement: '#one'});\n    });\n\n    application.Person              = Ember.Object.extend({});\n    application.Orange              = Ember.Object.extend({});\n    application.Email               = Ember.Object.extend({});\n    application.User                = Ember.Object.extend({});\n    application.PostIndexController = Ember.Object.extend({});\n\n    application.register('model:person', application.Person, {singleton: false });\n    application.register('model:user', application.User, {singleton: false });\n    application.register('fruit:favorite', application.Orange);\n    application.register('communication:main', application.Email, {singleton: false});\n    application.register('controller:postIndex', application.PostIndexController, {singleton: true});\n\n    locator = application.__container__;\n\n    lookup = Ember.lookup = {};\n  },\n  teardown: function() {\n    Ember.run(function(){\n      application.destroy();\n    });\n    application = locator = null;\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest('container lookup is normalized', function() {\n  var dotNotationController = locator.lookup('controller:post.index');\n  var camelCaseController = locator.lookup('controller:postIndex');\n\n  ok(dotNotationController instanceof application.PostIndexController);\n  ok(camelCaseController instanceof application.PostIndexController);\n\n  equal(dotNotationController, camelCaseController);\n});\n\ntest('registered entities can be looked up later', function(){\n  equal(locator.resolve('model:person'), application.Person);\n  equal(locator.resolve('model:user'), application.User);\n  equal(locator.resolve('fruit:favorite'), application.Orange);\n  equal(locator.resolve('communication:main'), application.Email);\n  equal(locator.resolve('controller:postIndex'), application.PostIndexController);\n\n  equal(locator.lookup('fruit:favorite'), locator.lookup('fruit:favorite'), 'singleton lookup worked');\n  ok(locator.lookup('model:user') !== locator.lookup('model:user'), 'non-singleton lookup worked');\n});\n\n\ntest('injections', function() {\n  application.inject('model', 'fruit', 'fruit:favorite');\n  application.inject('model:user', 'communication', 'communication:main');\n\n  var user = locator.lookup('model:user'),\n  person = locator.lookup('model:person'),\n  fruit = locator.lookup('fruit:favorite');\n\n  equal(user.get('fruit'), fruit);\n  equal(person.get('fruit'), fruit);\n\n  ok(application.Email.detectInstance(user.get('communication')));\n});\n\ntest('the default resolver can look things up in other namespaces', function() {\n  var UserInterface = lookup.UserInterface = Ember.Namespace.create();\n  UserInterface.NavigationController = Ember.Controller.extend();\n\n  var nav = locator.lookup('controller:userInterface/navigation');\n\n  ok(nav instanceof UserInterface.NavigationController, \"the result should be an instance of the specified class\");\n});\n\ntest('the default resolver looks up templates in Ember.TEMPLATES', function() {\n  var fooTemplate = function() {},\n      fooBarTemplate = function() {},\n      fooBarBazTemplate = function() {};\n  Ember.TEMPLATES['foo'] = fooTemplate;\n  Ember.TEMPLATES['fooBar'] = fooBarTemplate;\n  Ember.TEMPLATES['fooBar/baz'] = fooBarBazTemplate;\n  equal(locator.lookup('template:foo'), fooTemplate, \"resolves template:foo\");\n  equal(locator.lookup('template:fooBar'), fooBarTemplate, \"resolves template:foo_bar\");\n  equal(locator.lookup('template:fooBar.baz'), fooBarBazTemplate, \"resolves template:foo_bar.baz\");\n});\n\ntest('the default resolver looks up basic name as no prefix', function() {\n  equal(locator.lookup('controller:basic'), Ember.Controller);\n});\n\ntest('the default resolver looks up arbitrary types on the namespace', function() {\n  application.FooManager = Ember.Object.extend({});\n  equal(locator.resolve('manager:foo'), application.FooManager, \"looks up FooManager on application\");\n});\n\ntest(\"a resolver can be supplied to application\", function() {\n  Ember.$(\"#two\").empty();\n  var fallbackTemplate = function(){ return \"<h1>Fallback</h1>\"; };\n  Ember.run(function() {\n    app = Ember.Application.create({\n      rootElement: '#two',\n      resolver: Ember.DefaultResolver.extend({\n        resolveTemplate: function(parsedName) {\n          var resolvedTemplate = this._super(parsedName);\n          if (resolvedTemplate) { return resolvedTemplate; }\n          return fallbackTemplate;\n        }\n      })\n    });\n  });\n  equal(Ember.$(\"#two h1\").text(), \"Fallback\");\n  Ember.run(function(){\n    app.destroy();\n  });\n  app = null;\n});\n\n\ntest('normalization', function() {\n  equal(locator.normalize('foo:bar'), 'foo:bar');\n\n  equal(locator.normalize('controller:posts'), 'controller:posts');\n  equal(locator.normalize('controller:posts_index'), 'controller:postsIndex');\n  equal(locator.normalize('controller:posts.index'), 'controller:postsIndex');\n  equal(locator.normalize('controller:posts.post.index'), 'controller:postsPostIndex');\n  equal(locator.normalize('controller:posts_post.index'), 'controller:postsPostIndex');\n  equal(locator.normalize('controller:posts.post_index'), 'controller:postsPostIndex');\n  equal(locator.normalize('controller:postsIndex'), 'controller:postsIndex');\n  equal(locator.normalize('controller:blogPosts.index'), 'controller:blogPostsIndex');\n  equal(locator.normalize('controller:blog/posts.index'), 'controller:blog/postsIndex');\n  equal(locator.normalize('controller:blog/posts.post.index'), 'controller:blog/postsPostIndex');\n  equal(locator.normalize('controller:blog/posts_post.index'), 'controller:blog/postsPostIndex');\n\n  equal(locator.normalize('template:blog/posts_index'), 'template:blog/posts_index');\n});\n\ntest('normalization is indempotent', function() {\n  var examples = ['controller:posts', 'controller:posts.post.index', 'controller:blog/posts.post_index', 'template:foo_bar'];\n\n  examples.forEach(function (example) {\n    equal(locator.normalize(locator.normalize(example)), locator.normalize(example));\n  });\n});\n\n})();\n//@ sourceURL=ember-application/~tests/system/application_test");minispade.register('ember-application/~tests/system/controller_test', "(function() {module(\"Controller dependencies\");\n\ntest(\"If a controller specifies a dependency, it is accessible\", function() {\n  var container = new Ember.Container();\n\n  container.register('controller:post', Ember.Controller.extend({\n    needs: 'posts'\n  }));\n\n  container.register('controller:posts', Ember.Controller.extend());\n\n  var postController = container.lookup('controller:post'),\n      postsController = container.lookup('controller:posts');\n\n  equal(postsController, postController.get('controllers.posts'), \"controller.posts must be auto synthesized\");\n});\n\ntest(\"If a controller specifies an unavailable dependency, it raises\", function() {\n  var container = new Ember.Container();\n\n  container.register('controller:post', Ember.Controller.extend({\n    needs: 'posts'\n  }));\n\n  raises(function() {\n    container.lookup('controller:post');\n  }, /controller:posts/);\n});\n\n})();\n//@ sourceURL=ember-application/~tests/system/controller_test");minispade.register('ember-application/~tests/system/initializers_test', "(function() {var oldInitializers, app;\nvar indexOf = Ember.ArrayPolyfills.indexOf;\n\nmodule(\"Ember.Application initializers\", {\n  setup: function() {\n    oldInitializers = Ember.Application.initializers;\n    Ember.Application.initializers = Ember.A();\n  },\n\n  teardown: function() {\n    Ember.Application.initializers = oldInitializers;\n\n    if (app) {\n      Ember.run(function() { app.destroy(); });\n    }\n  }\n});\n\ntest(\"initializers can be registered in a specified order\", function() {\n  var order = [];\n  Ember.Application.initializer({\n    name: 'fourth',\n    after: 'third',\n    initialize: function(container) {\n      order.push('fourth');\n    }\n  });\n\n  Ember.Application.initializer({\n    name: 'second',\n    before: 'third',\n    initialize: function(container) {\n      order.push('second');\n    }\n  });\n\n  Ember.Application.initializer({\n    name: 'fifth',\n    after: 'fourth',\n    initialize: function(container) {\n      order.push('fifth');\n    }\n  });\n\n  Ember.Application.initializer({\n    name: 'first',\n    before: 'second',\n    initialize: function(container) {\n      order.push('first');\n    }\n  });\n\n  Ember.Application.initializer({\n    name: 'third',\n    initialize: function(container) {\n      order.push('third');\n    }\n  });\n\n  Ember.run(function() {\n    app = Ember.Application.create({\n      router: false,\n      rootElement: '#qunit-fixture'\n    });\n  });\n\n  deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth']);\n\n  Ember.run(function() {\n    app.destroy();\n  });\n});\n\ntest(\"initializers can have multiple dependencies\", function () {\n  var order = [],\n      a = {\n        name: \"a\",\n        before: \"b\",\n        initialize: function(container) {\n          order.push('a');\n        }\n      },\n      b = {\n        name: \"b\",\n        initialize: function(container) {\n          order.push('b');\n        }\n      },\n      c = {\n        name: \"c\",\n        after: \"b\",\n        initialize: function(container) {\n          order.push('c');\n        }\n      },\n      afterB = {\n        name: \"after b\",\n        after: \"b\",\n        initialize: function(container) {\n          order.push(\"after b\");\n        }\n      },\n      afterC = {\n        name: \"after c\",\n        after: \"c\",\n        initialize: function(container) {\n          order.push(\"after c\");\n        }\n      };\n  Ember.Application.initializer(b);\n  Ember.Application.initializer(a);\n  Ember.Application.initializer(afterC);\n  Ember.Application.initializer(afterB);\n  Ember.Application.initializer(c);\n\n  Ember.run(function() {\n    app = Ember.Application.create({\n      router: false,\n      rootElement: '#qunit-fixture'\n    });\n  });\n\n  ok(indexOf.call(order, a.name) < indexOf.call(order, b.name), 'a < b');\n  ok(indexOf.call(order, b.name) < indexOf.call(order, c.name), 'b < c');\n  ok(indexOf.call(order, b.name) < indexOf.call(order, afterB.name), 'b < afterB');\n  ok(indexOf.call(order, c.name) < indexOf.call(order, afterC.name), 'c < afterC');\n\n  Ember.run(function() {\n    app.destroy();\n  });\n});\n\n\n})();\n//@ sourceURL=ember-application/~tests/system/initializers_test");minispade.register('ember-application/~tests/system/readiness_test', "(function() {var jQuery, Application, application;\nvar readyWasCalled, domReady, readyCallbacks;\n\n// We are using a small mock of jQuery because jQuery is third-party code with\n// very well-defined semantics, and we want to confirm that a jQuery stub run\n// in a more minimal server environment that implements this behavior will be\n// sufficient for Ember's requirements.\n\nmodule(\"Application readiness\", {\n  setup: function() {\n    readyWasCalled = 0;\n    readyCallbacks = [];\n\n    var jQueryInstance = {\n      ready: function(callback) {\n        readyCallbacks.push(callback);\n        if (jQuery.isReady) {\n          domReady();\n        }\n      }\n    };\n\n    jQuery = function() {\n      return jQueryInstance;\n    };\n    jQuery.isReady = false;\n\n    var domReadyCalled = 0;\n    domReady = function() {\n      if (domReadyCalled !== 0) { return; }\n      domReadyCalled++;\n      var i;\n      for (i=0; i<readyCallbacks.length; i++) {\n        readyCallbacks[i]();\n      }\n    };\n\n    Application = Ember.Application.extend({\n      $: jQuery,\n\n      ready: function() {\n        readyWasCalled++;\n      }\n    });\n  },\n\n  teardown: function() {\n    if (application) {\n      Ember.run(function() { application.destroy(); });\n    }\n  }\n});\n\n// These tests are confirming that if the callbacks passed into jQuery's ready hook is called\n// synchronously during the application's initialization, we get the same behavior as if\n// it was triggered after initialization.\n\ntest(\"Ember.Application's ready event is called right away if jQuery is already ready\", function() {\n  var wasResolved = 0;\n  jQuery.isReady = true;\n\n  Ember.run(function() {\n    application = Application.create({ router: false });\n    application.then(function(){\n      wasResolved++;\n    });\n\n    equal(readyWasCalled, 0, \"ready is not called until later\");\n    equal(wasResolved, 0);\n  });\n\n  equal(wasResolved, 1);\n  equal(readyWasCalled, 1, \"ready was called\");\n\n  domReady();\n\n  equal(wasResolved, 1);\n  equal(readyWasCalled, 1, \"application's ready was not called again\");\n});\n\ntest(\"Ember.Application's ready event is called after the document becomes ready\", function() {\n  var wasResolved = 0;\n  Ember.run(function() {\n    application = Application.create({ router: false });\n    application.then(function(){\n      wasResolved++;\n    });\n    equal(wasResolved, 0);\n  });\n\n  equal(readyWasCalled, 0, \"ready wasn't called yet\");\n  equal(wasResolved, 0);\n\n  domReady();\n\n  equal(wasResolved, 1);\n  equal(readyWasCalled, 1, \"ready was called now that DOM is ready\");\n});\n\ntest(\"Ember.Application's ready event can be deferred by other components\", function() {\n  var wasResolved = 0;\n\n  Ember.run(function() {\n    application = Application.create({ router: false });\n    application.then(function(){\n      wasResolved++;\n    });\n    application.deferReadiness();\n    equal(wasResolved, 0);\n  });\n\n  equal(readyWasCalled, 0, \"ready wasn't called yet\");\n\n  domReady();\n\n  equal(readyWasCalled, 0, \"ready wasn't called yet\");\n  equal(wasResolved, 0);\n\n  Ember.run(function() {\n    application.advanceReadiness();\n    equal(readyWasCalled, 0);\n    equal(wasResolved, 0);\n  });\n\n  equal(wasResolved, 1);\n  equal(readyWasCalled, 1, \"ready was called now all readiness deferrals are advanced\");\n});\n\ntest(\"Ember.Application's ready event can be deferred by other components\", function() {\n  var wasResolved = 0;\n  jQuery.isReady = false;\n\n  Ember.run(function() {\n    application = Application.create({ router: false });\n    application.deferReadiness();\n    application.then(function(){\n      wasResolved++;\n    });\n    equal(wasResolved, 0);\n  });\n\n  domReady();\n\n  equal(readyWasCalled, 0, \"ready wasn't called yet\");\n\n  Ember.run(function() {\n    application.advanceReadiness();\n    equal(wasResolved, 0);\n  });\n\n  equal(wasResolved, 1);\n  equal(readyWasCalled, 1, \"ready was called now all readiness deferrals are advanced\");\n\n  raises(function() {\n    application.deferReadiness();\n  }, Error);\n});\n\n})();\n//@ sourceURL=ember-application/~tests/system/readiness_test");minispade.register('ember-application/~tests/system/reset_test', "(function() {var get = Ember.get, set = Ember.set;\n\nvar application;\nvar Application;\n\nApplication = Ember.Application.extend({\n  name: \"App\",\n  rootElement: \"#qunit-fixture\"\n});\n\nmodule(\"Ember.Application - resetting\", {\n  teardown: function() {\n    if (application) {\n      Ember.run(function() {\n        application.destroy();\n      });\n    }\n  }\n});\n\ntest(\"When an application is reset, new instances of controllers are generated\", function() {\n  Ember.run(function() {\n    application = Application.create();\n    application.AcademicController = Ember.Controller.extend();\n  });\n\n  var firstController = application.__container__.lookup('controller:academic');\n  var secondController = application.__container__.lookup('controller:academic');\n\n  Ember.run(function() {\n    application.reset();\n  });\n\n  var thirdController = application.__container__.lookup('controller:academic');\n\n  strictEqual(firstController, secondController, \"controllers looked up in succession should be the same instance\");\n\n  ok(firstController.isDestroying, 'controllers are destroyed when their application is reset');\n\n  notStrictEqual(firstController, thirdController, \"controllers looked up after the application is reset should not be the same instance\");\n});\n\ntest(\"When an application is reset, the ApplicationView is torn down\", function() {\n  Ember.run(function() {\n    application = Application.create();\n    application.ApplicationView = Ember.View.extend({\n      elementId: \"application-view\"\n    });\n  });\n\n  equal(Ember.$('#qunit-fixture #application-view').length, 1, \"precond - the application view is rendered\");\n\n  var originalView = Ember.View.views['application-view'];\n\n  Ember.run(function() {\n    application.reset();\n  });\n\n  var resettedView = Ember.View.views['application-view'];\n\n  equal(Ember.$('#qunit-fixture #application-view').length, 1, \"the application view is rendered\");\n\n  notStrictEqual(originalView, resettedView, \"The view object has changed\");\n});\n\ntest(\"When an application is reset, the router URL is reset to `/`\", function() {\n  var location, router;\n\n  Ember.run(function() {\n    application = Application.create();\n    application.Router = Ember.Router.extend({\n      location: 'none'\n    });\n\n    application.Router.map(function() {\n      this.route('one');\n      this.route('two');\n    });\n  });\n\n  router = application.__container__.lookup('router:main');\n\n  location = router.get('location');\n  location.handleURL('/one');\n\n  Ember.run(function() {\n    application.reset();\n  });\n\n  var applicationController = application.__container__.lookup('controller:application');\n  router = application.__container__.lookup('router:main');\n  location = router.get('location');\n\n  equal(location.getURL(), '');\n\n  equal(get(applicationController, 'currentPath'), \"index\");\n\n  location = application.__container__.lookup('router:main').get('location');\n  location.handleURL('/one');\n\n  equal(get(applicationController, 'currentPath'), \"one\");\n});\n\n})();\n//@ sourceURL=ember-application/~tests/system/reset_test");minispade.register('ember-handlebars/~tests/controls/button_test', "(function() {var button, dispatcher;\n\nvar get = Ember.get, set = Ember.set;\n\nvar originalLookup = Ember.lookup, lookup;\n\nmodule(\"Ember.Button\", {\n  setup: function() {\n    lookup = Ember.lookup = {};\n\n    Ember.TESTING_DEPRECATION = true;\n    dispatcher = Ember.EventDispatcher.create();\n    dispatcher.setup();\n    button = Ember.Button.create();\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      button.destroy();\n      dispatcher.destroy();\n    });\n    Ember.TESTING_DEPRECATION = false;\n    Ember.lookup = originalLookup;\n  }\n});\n\nfunction synthesizeEvent(type, view) {\n  view.$().trigger(type);\n}\n\nfunction synthesizeKeyEvent(type, keyCode, view) {\n  var event = Ember.$.Event(type);\n  event.keyCode = keyCode;\n  view.$().trigger(event);\n}\n\nfunction append() {\n  Ember.run(function() {\n    button.appendTo('#qunit-fixture');\n  });\n}\n\ntest(\"should begin disabled if the disabled attribute is true\", function() {\n  button.set('disabled', true);\n  append();\n\n  ok(button.$().is(\":disabled\"));\n});\n\ntest(\"should become disabled if the disabled attribute is changed\", function() {\n  append();\n  ok(button.$().is(\":not(:disabled)\"));\n\n  Ember.run(function() { button.set('disabled', true); });\n  ok(button.$().is(\":disabled\"));\n\n  Ember.run(function() { button.set('disabled', false); });\n  ok(button.$().is(\":not(:disabled)\"));\n});\n\ntest(\"should support the tabindex property\", function() {\n  Ember.run(function() { button.set('tabindex', 6); });\n  append();\n\n  equal(button.$().prop('tabindex'), '6', 'the initial button tabindex is set in the DOM');\n\n  Ember.run(function() { button.set('tabindex', 3); });\n  equal(button.$().prop('tabindex'), '3', 'the button tabindex changes when it is changed in the view');\n});\n\n\ntest(\"should trigger an action when clicked\", function() {\n  var wasClicked = false;\n\n  var actionObject = Ember.Object.create({\n    myAction: function() {\n      wasClicked = true;\n    }\n  });\n\n  button.set('target', actionObject);\n  button.set('action', 'myAction');\n\n  Ember.run(function() {\n    button.appendTo('#qunit-fixture');\n  });\n\n  synthesizeEvent('mousedown', button);\n  synthesizeEvent('mouseup', button);\n\n  ok(wasClicked);\n});\n\ntest(\"should trigger an action when touched\", function() {\n  var wasClicked = false;\n\n  var actionObject = Ember.Object.create({\n    myAction: function() {\n      wasClicked = true;\n    }\n  });\n\n  button.set('target', actionObject);\n  button.set('action', 'myAction');\n\n  Ember.run(function() {\n    button.appendTo('#qunit-fixture');\n  });\n\n  synthesizeEvent('touchstart', button);\n  synthesizeEvent('touchend', button);\n\n  ok(wasClicked);\n});\n\ntest(\"should trigger an action when space pressed\", function() {\n  var wasClicked = false;\n\n  var actionObject = Ember.Object.create({\n    myAction: function() {\n      wasClicked = true;\n    }\n  });\n\n  button.set('target', actionObject);\n  button.set('action', 'myAction');\n\n  Ember.run(function() {\n    button.appendTo('#qunit-fixture');\n  });\n\n  synthesizeKeyEvent('keydown', 13, button);\n  synthesizeKeyEvent('keyup', 13, button);\n\n  ok(wasClicked);\n});\n\ntest(\"should trigger an action when enter pressed\", function() {\n  var wasClicked = false;\n\n  var actionObject = Ember.Object.create({\n    myAction: function() {\n      wasClicked = true;\n    }\n  });\n\n  button.set('target', actionObject);\n  button.set('action', 'myAction');\n\n  Ember.run(function() {\n    button.appendTo('#qunit-fixture');\n  });\n\n  synthesizeKeyEvent('keydown', 32, button);\n  synthesizeKeyEvent('keyup', 32, button);\n\n  ok(wasClicked);\n});\n\ntest(\"should not trigger an action when another key is pressed\", function() {\n  var wasClicked = false;\n\n  var actionObject = Ember.Object.create({\n    myAction: function() {\n      wasClicked = true;\n    }\n  });\n\n  button.set('target', actionObject);\n  button.set('action', 'myAction');\n\n  Ember.run(function() {\n    button.appendTo('#qunit-fixture');\n  });\n\n  // 'a' key\n  synthesizeKeyEvent('keydown', 65, button);\n  synthesizeKeyEvent('keyup', 65, button);\n\n  ok(!wasClicked);\n});\n\ntest(\"should trigger an action on a String target when clicked\", function() {\n  var wasClicked = false;\n\n  lookup.MyApp = {\n    myActionObject: Ember.Object.create({\n      myAction: function() {\n        wasClicked = true;\n      }\n    })\n  };\n\n  var button = Ember.Button.create({\n    target: 'MyApp.myActionObject',\n    action: 'myAction'\n  });\n\n  Ember.run(function() {\n    button.appendTo('#qunit-fixture');\n  });\n\n  synthesizeEvent('mousedown', button);\n  synthesizeEvent('mouseup', button);\n\n  ok(wasClicked);\n\n  Ember.run(function() {\n    button.destroy();\n  });\n});\n\ntest(\"should not trigger action if mouse leaves area before mouseup\", function() {\n  var wasClicked = false;\n\n  var actionObject = Ember.Object.create({\n    myAction: function() {\n      wasClicked = true;\n    }\n  });\n\n  button.set('target', actionObject);\n  button.set('action', 'myAction');\n\n  Ember.run(function() {\n    button.appendTo('#qunit-fixture');\n  });\n\n  synthesizeEvent('mousedown', button);\n  ok(get(button, 'isActive'), \"becomes active when hovered\");\n  ok(button.$().hasClass('is-active'));\n  synthesizeEvent('mouseleave', button);\n  ok(!get(button, 'isActive'), \"loses active state if mouse exits\");\n  ok(!button.$().hasClass('is-active'));\n  synthesizeEvent('mouseup', button);\n\n  ok(!wasClicked);\n\n  wasClicked = false;\n\n  synthesizeEvent('mousedown', button);\n  synthesizeEvent('mouseleave', button);\n  synthesizeEvent('mouseenter', button);\n  synthesizeEvent('mouseup', button);\n\n  ok(wasClicked);\n});\n\ntest(\"should not trigger action if disabled and a non-standard input\", function() {\n  var wasClicked = false;\n\n  var actionObject = Ember.Object.create({\n    myAction: function() {\n      wasClicked = true;\n    }\n  });\n\n  button.set('tagName', 'span');\n  button.set('disabled', true);\n  button.set('target', actionObject);\n  button.set('action', 'myAction');\n\n  Ember.run(function() {\n    button.appendTo('#qunit-fixture');\n  });\n\n  synthesizeEvent('mousedown', button);\n  ok(!get(button, 'isActive'), \"button does not become active when pushed\");\n});\n\ntest(\"should not have a type if tagName is not 'input' or 'button'\", function() {\n  Ember.run(function() {\n    button.set('tagName', 'a');\n    button.appendTo('#qunit-fixture');\n  });\n\n  // IE 7 reports an empty string instead of null.\n  ok(!button.$().attr('type'));\n});\n\ntest(\"should by default be of type='button' if tagName is 'input'\", function() {\n  Ember.run(function() {\n    button.set('tagName', 'input');\n    button.appendTo('#qunit-fixture');\n  });\n\n  equal(button.$().attr('type'), 'button');\n});\n\ntest(\"should by default be of type='button' if tagName is 'button'\", function() {\n  Ember.run(function() {\n    button.set('tagName', 'button');\n    button.appendTo('#qunit-fixture');\n  });\n\n  equal(button.$().attr('type'), 'button');\n});\n\ntest(\"should allow setting of type when tagName is not 'input' or 'button'\", function() {\n  button.set('tagName', 'a');\n  button.set('type', 'submit');\n\n  equal(button.get('type'), 'submit');\n});\n\ntest(\"should allow setting of type when tagName is 'input'\", function() {\n  button.set('tagName', 'input');\n  button.set('type', 'submit');\n\n  equal(button.get('type'), 'submit');\n});\n\ntest(\"should allow setting of type when tagName is 'button'\", function() {\n  button.set('tagName', 'button');\n  button.set('type', 'submit');\n\n  equal(button.get('type'), 'submit');\n});\n\ntest(\"should have a configurable type\", function() {\n  button.set('type', 'submit');\n\n  Ember.run(function() {\n    button.appendTo('#qunit-fixture');\n  });\n\n  equal(button.$().attr('type'), 'submit');\n});\n\ntest(\"should set href='#' if tagName is 'a'\", function() {\n  button.set('tagName', 'a');\n\n  Ember.run(function() {\n    button.appendTo('#qunit-fixture');\n  });\n\n  // IE 7 throws the whole url in there. If it ends with '#' we're ok\n  ok(/#$/.test(button.$().attr('href')));\n});\n\ntest(\"should not set href if tagName is not 'a'\", function() {\n  Ember.run(function() {\n    button.appendTo('#qunit-fixture');\n  });\n\n  equal(button.$().attr('href'), null);\n});\n\ntest(\"should allow the target to be the parentView\", function() {\n  button.set('target', 'parentView');\n\n  equal(get(button, 'parentView'), button.get('targetObject'));\n});\n\n})();\n//@ sourceURL=ember-handlebars/~tests/controls/button_test");minispade.register('ember-handlebars/~tests/controls/checkbox_test', "(function() {var get = Ember.get, set = function(obj, key, value) {\n  Ember.run(function() { Ember.set(obj, key, value); });\n};\n\nvar isInternetExplorer = window.navigator.userAgent.match(/msie/i),\n    checkboxView, dispatcher, controller;\n\n\nvar compile = Ember.Handlebars.compile;\n\nfunction destroy(view) {\n  Ember.run(function() {\n    view.destroy();\n  });\n}\n\nmodule(\"{{input type='checkbox'}}\", {\n  setup: function() {\n    controller = {\n      tab: 6,\n      name: 'hello',\n      val: false\n    };\n\n    checkboxView = Ember.View.extend({\n      controller: controller,\n      template: compile('{{input type=\"checkbox\" disabled=disabled tabindex=tab name=name checked=val}}')\n    }).create();\n\n    append();\n  },\n\n  teardown: function() {\n    destroy(checkboxView);\n  }\n});\n\ntest(\"should append a checkbox\", function() {\n  equal(checkboxView.$('input[type=checkbox]').length, 1, \"A single checkbox is added\");\n});\n\ntest(\"should begin disabled if the disabled attribute is true\", function() {\n  equal(checkboxView.$('input[type=checkbox]:disabled').length, 0, \"The checkbox isn't disabled\");\n  set(controller, 'disabled', true);\n  equal(checkboxView.$('input[type=checkbox]:disabled').length, 1, \"The checkbox is now disabled\");\n});\n\ntest(\"should support the tabindex property\", function() {\n  equal(checkboxView.$('input').prop('tabindex'), '6', 'the initial checkbox tabindex is set in the DOM');\n  set(controller, 'tab', 3);\n  equal(checkboxView.$('input').prop('tabindex'), '3', 'the checkbox tabindex changes when it is changed in the view');\n});\n\ntest(\"checkbox name is updated\", function() {\n  equal(checkboxView.$('input').attr('name'), \"hello\", \"renders checkbox with the name\");\n  set(controller, 'name', 'bye');\n  equal(checkboxView.$('input').attr('name'), \"bye\", \"updates checkbox after name changes\");\n});\n\ntest(\"checkbox checked property is updated\", function() {\n  equal(checkboxView.$('input').prop('checked'), false, \"the checkbox isn't checked yet\");\n  set(controller, 'val', true);\n  equal(checkboxView.$('input').prop('checked'), true, \"the checkbox is checked now\");\n});\n\nmodule(\"{{input type='checkbox'}} - static values\", {\n  setup: function() {\n    controller = {\n      tab: 6,\n      name: 'hello',\n      val: false\n    };\n\n    checkboxView = Ember.View.extend({\n      controller: controller,\n      template: compile('{{input type=\"checkbox\" disabled=true tabindex=6 name=\"hello\" checked=false}}')\n    }).create();\n\n    append();\n  },\n\n  teardown: function() {\n    destroy(checkboxView);\n  }\n});\n\ntest(\"should begin disabled if the disabled attribute is true\", function() {\n  equal(checkboxView.$('input[type=checkbox]:disabled').length, 1, \"The checkbox isn't disabled\");\n});\n\ntest(\"should support the tabindex property\", function() {\n  equal(checkboxView.$('input').prop('tabindex'), '6', 'the initial checkbox tabindex is set in the DOM');\n});\n\ntest(\"checkbox name is updated\", function() {\n  equal(checkboxView.$('input').attr('name'), \"hello\", \"renders checkbox with the name\");\n});\n\ntest(\"checkbox checked property is updated\", function() {\n  equal(checkboxView.$('input').prop('checked'), false, \"the checkbox isn't checked yet\");\n});\n\nmodule(\"Ember.Checkbox\", {\n  setup: function() {\n    dispatcher = Ember.EventDispatcher.create();\n    dispatcher.setup();\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      dispatcher.destroy();\n      checkboxView.destroy();\n    });\n  }\n});\n\nfunction setAndFlush(view, key, value) {\n  Ember.run(function() {\n    Ember.set(view, key, value);\n  });\n}\n\nfunction append() {\n  Ember.run(function() {\n    checkboxView.appendTo('#qunit-fixture');\n  });\n}\n\ntest(\"should begin disabled if the disabled attribute is true\", function() {\n  checkboxView = Ember.Checkbox.create({});\n\n  checkboxView.set('disabled', true);\n  append();\n\n  ok(checkboxView.$().is(\":disabled\"));\n});\n\ntest(\"should become disabled if the disabled attribute is changed\", function() {\n  checkboxView = Ember.Checkbox.create({});\n\n  append();\n  ok(checkboxView.$().is(\":not(:disabled)\"));\n\n  Ember.run(function() { checkboxView.set('disabled', true); });\n  ok(checkboxView.$().is(\":disabled\"));\n\n  Ember.run(function() { checkboxView.set('disabled', false); });\n  ok(checkboxView.$().is(\":not(:disabled)\"));\n});\n\ntest(\"should support the tabindex property\", function() {\n  checkboxView = Ember.Checkbox.create({});\n\n  Ember.run(function() { checkboxView.set('tabindex', 6); });\n  append();\n\n  equal(checkboxView.$().prop('tabindex'), '6', 'the initial checkbox tabindex is set in the DOM');\n\n  Ember.run(function() { checkboxView.set('tabindex', 3); });\n  equal(checkboxView.$().prop('tabindex'), '3', 'the checkbox tabindex changes when it is changed in the view');\n});\n\ntest(\"checkbox name is updated when setting name property of view\", function() {\n  checkboxView = Ember.Checkbox.create({});\n\n  Ember.run(function() { checkboxView.set('name', 'foo'); });\n  append();\n\n  equal(checkboxView.$().attr('name'), \"foo\", \"renders checkbox with the name\");\n\n  Ember.run(function() { checkboxView.set('name', 'bar'); });\n\n  equal(checkboxView.$().attr('name'), \"bar\", \"updates checkbox after name changes\");\n});\n\ntest(\"checked property mirrors input value\", function() {\n  checkboxView = Ember.Checkbox.create({});\n  Ember.run(function() { checkboxView.append(); });\n\n  equal(get(checkboxView, 'checked'), false, \"initially starts with a false value\");\n  equal(!!checkboxView.$().prop('checked'), false, \"the initial checked property is false\");\n\n  setAndFlush(checkboxView, 'checked', true);\n\n  equal(checkboxView.$().prop('checked'), true, \"changing the value property changes the DOM\");\n\n  Ember.run(function() { checkboxView.remove(); });\n  Ember.run(function() { checkboxView.append(); });\n\n  equal(checkboxView.$().prop('checked'), true, \"changing the value property changes the DOM\");\n\n  Ember.run(function() { checkboxView.remove(); });\n  Ember.run(function() { set(checkboxView, 'checked', false); });\n  Ember.run(function() { checkboxView.append(); });\n\n  equal(checkboxView.$().prop('checked'), false, \"changing the value property changes the DOM\");\n});\n\ntest(\"checking the checkbox updates the value\", function() {\n  checkboxView = Ember.Checkbox.create({ checked: true });\n  Ember.run(function() { checkboxView.appendTo('#qunit-fixture'); });\n\n  equal(get(checkboxView, 'checked'), true, \"precond - initially starts with a true value\");\n  equal(!!checkboxView.$().prop('checked'), true, \"precond - the initial checked property is true\");\n\n  // Can't find a way to programatically trigger a checkbox in IE and have it generate the\n  // same events as if a user actually clicks.\n  if (!isInternetExplorer) {\n    checkboxView.$()[0].click();\n  } else {\n    checkboxView.$().trigger('click');\n    checkboxView.$().removeAttr('checked').trigger('change');\n  }\n\n  equal(!!checkboxView.$().prop('checked'), false, \"after clicking a checkbox, the checked property changed\");\n  equal(get(checkboxView, 'checked'), false, \"changing the checkbox causes the view's value to get updated\");\n});\n\n})();\n//@ sourceURL=ember-handlebars/~tests/controls/checkbox_test");minispade.register('ember-handlebars/~tests/controls/select_test', "(function() {var map = Ember.EnumerableUtils.map,\n    trim = Ember.$.trim;\n\nvar dispatcher, select, view;\n\nmodule(\"Ember.Select\", {\n  setup: function() {\n    dispatcher = Ember.EventDispatcher.create();\n    dispatcher.setup();\n    select = Ember.Select.create();\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      dispatcher.destroy();\n      select.destroy();\n    });\n  }\n});\n\nfunction setAndFlush(view, key, value) {\n  Ember.run(function() {\n    Ember.set(view, key, value);\n  });\n}\n\nfunction append() {\n  Ember.run(function() {\n    select.appendTo('#qunit-fixture');\n  });\n}\n\nfunction selectedOptions() {\n  return select.get('childViews').mapProperty('selected');\n}\n\ntest(\"has 'ember-view' and 'ember-select' CSS classes\", function() {\n  deepEqual(select.get('classNames'), ['ember-view', 'ember-select']);\n});\n\ntest(\"should render\", function() {\n  append();\n\n  ok(select.$().length, \"Select renders\");\n});\n\ntest(\"should begin disabled if the disabled attribute is true\", function() {\n  select.set('disabled', true);\n  append();\n\n  ok(select.$().is(\":disabled\"));\n});\n\ntest(\"should become disabled if the disabled attribute is changed\", function() {\n  append();\n  ok(select.$().is(\":not(:disabled)\"));\n\n  Ember.run(function() { select.set('disabled', true); });\n  ok(select.$().is(\":disabled\"));\n\n  Ember.run(function() { select.set('disabled', false); });\n  ok(select.$().is(\":not(:disabled)\"));\n});\n\ntest(\"can have options\", function() {\n  select.set('content', Ember.A([1, 2, 3]));\n\n  append();\n\n  equal(select.$('option').length, 3, \"Should have three options\");\n  // IE 8 adds whitespace\n  equal(select.$().text().replace(/\\s+/g,''), \"123\", \"Options should have content\");\n});\n\n\ntest(\"select tabindex is updated when setting tabindex property of view\", function() {\n  Ember.run(function() { select.set('tabindex', '4'); });\n  append();\n\n  equal(select.$().attr('tabindex'), \"4\", \"renders select with the tabindex\");\n\n  Ember.run(function() { select.set('tabindex', '1'); });\n\n  equal(select.$().attr('tabindex'), \"1\", \"updates select after tabindex changes\");\n});\n\ntest(\"select name is updated when setting name property of view\", function() {\n  Ember.run(function() { select.set('name', 'foo'); });\n  append();\n\n  equal(select.$().attr('name'), \"foo\", \"renders select with the name\");\n\n  Ember.run(function() { select.set('name', 'bar'); });\n\n  equal(select.$().attr('name'), \"bar\", \"updates select after name changes\");\n});\n\ntest(\"can specify the property path for an option's label and value\", function() {\n  select.set('content', Ember.A([\n    { id: 1, firstName: 'Yehuda' },\n    { id: 2, firstName: 'Tom' }\n  ]));\n\n  select.set('optionLabelPath', 'content.firstName');\n  select.set('optionValuePath', 'content.id');\n\n  append();\n\n  equal(select.$('option').length, 2, \"Should have two options\");\n  // IE 8 adds whitespace\n  equal(select.$().text().replace(/\\s+/g,''), \"YehudaTom\", \"Options should have content\");\n  deepEqual(map(select.$('option').toArray(), function(el) { return Ember.$(el).attr('value'); }), [\"1\", \"2\"], \"Options should have values\");\n});\n\ntest(\"can retrieve the current selected option when multiple=false\", function() {\n  var yehuda = { id: 1, firstName: 'Yehuda' },\n      tom = { id: 2, firstName: 'Tom' };\n  select.set('content', Ember.A([yehuda, tom]));\n\n  append();\n\n  equal(select.get('selection'), yehuda, \"By default, the first option is selected\");\n\n  select.$()[0].selectedIndex = 1; // select Tom\n  select.$().trigger('change');\n\n  equal(select.get('selection'), tom, \"On change, the new option should be selected\");\n});\n\ntest(\"can retrieve the current selected options when multiple=true\", function() {\n  var yehuda = { id: 1, firstName: 'Yehuda' },\n      tom = { id: 2, firstName: 'Tom' },\n      david = { id: 3, firstName: 'David' },\n      brennain = { id: 4, firstName: 'Brennain' };\n  select.set('content', Ember.A([yehuda, tom, david, brennain]));\n  select.set('multiple', true);\n  select.set('optionLabelPath', 'content.firstName');\n  select.set('optionValuePath', 'content.firstName');\n\n  append();\n\n  deepEqual(select.get('selection'), [], \"By default, nothing is selected\");\n\n  select.$('option').each(function() {\n    if (this.value === 'Tom' || this.value === 'David') {\n      this.selected = true;\n    }\n  });\n\n  select.$().trigger('change');\n\n  deepEqual(select.get('selection'), [tom, david], \"On change, the new options should be selected\");\n});\n\ntest(\"selection can be set when multiple=false\", function() {\n  var yehuda = { id: 1, firstName: 'Yehuda' },\n      tom = { id: 2, firstName: 'Tom' };\n\n  Ember.run(function() {\n    select.set('content', Ember.A([yehuda, tom]));\n    select.set('multiple', false);\n    select.set('selection', tom);\n  });\n\n  append();\n\n  equal(select.get('selection'), tom, \"Initial selection should be correct\");\n\n  Ember.run(function() { select.set('selection', yehuda); });\n\n  equal(select.$()[0].selectedIndex, 0, \"After changing it, selection should be correct\");\n});\n\ntest(\"selection can be set when multiple=true\", function() {\n  var yehuda = { id: 1, firstName: 'Yehuda' },\n      tom = { id: 2, firstName: 'Tom' },\n      david = { id: 3, firstName: 'David' },\n      brennain = { id: 4, firstName: 'Brennain' };\n\n  Ember.run(function() {\n    select.set('content', Ember.A([yehuda, tom, david, brennain]));\n    select.set('multiple', true);\n    select.set('selection', tom);\n  });\n\n  append();\n\n  deepEqual(select.get('selection'), [tom], \"Initial selection should be correct\");\n\n  Ember.run(function() { select.set('selection', yehuda); });\n\n  deepEqual(select.get('selection'), [yehuda], \"After changing it, selection should be correct\");\n});\n\ntest(\"selection can be set when multiple=true and prompt\", function() {\n  var yehuda = { id: 1, firstName: 'Yehuda' },\n      tom = { id: 2, firstName: 'Tom' },\n      david = { id: 3, firstName: 'David' },\n      brennain = { id: 4, firstName: 'Brennain' };\n\n  Ember.run(function() {\n    select.set('content', Ember.A([yehuda, tom, david, brennain]));\n    select.set('multiple', true);\n    select.set('prompt', 'Pick one!');\n    select.set('selection', tom);\n  });\n\n  append();\n\n  deepEqual(select.get('selection'), [tom], \"Initial selection should be correct\");\n\n  Ember.run(function() {\n    select.set('selection', yehuda);\n  });\n\n  deepEqual(select.get('selection'), [yehuda], \"After changing it, selection should be correct\");\n});\n\ntest(\"multiple selections can be set when multiple=true\", function() {\n  var yehuda = { id: 1, firstName: 'Yehuda' },\n      tom = { id: 2, firstName: 'Tom' },\n      david = { id: 3, firstName: 'David' },\n      brennain = { id: 4, firstName: 'Brennain' };\n\n  Ember.run(function() {\n    select.set('content', Ember.A([yehuda, tom, david, brennain]));\n    select.set('optionLabelPath', 'content.firstName');\n    select.set('multiple', true);\n\n    select.set('selection', Ember.A([yehuda, david]));\n  });\n\n  append();\n\n  deepEqual(select.get('selection'), [yehuda, david], \"Initial selection should be correct\");\n\n  Ember.run(function() { select.set('selection', Ember.A([tom, brennain])); });\n\n  deepEqual(\n    select.$(':selected').map(function(){ return trim(Ember.$(this).text());}).toArray(),\n    ['Tom', 'Brennain'],\n    \"After changing it, selection should be correct\");\n});\n\ntest(\"multiple selections can be set by changing in place the selection array when multiple=true\", function() {\n  var yehuda = { id: 1, firstName: 'Yehuda' },\n      tom = { id: 2, firstName: 'Tom' },\n      david = { id: 3, firstName: 'David' },\n      brennain = { id: 4, firstName: 'Brennain' },\n      selection = Ember.A([yehuda, tom]);\n\n  Ember.run(function() {\n    select.set('content', Ember.A([yehuda, tom, david, brennain]));\n    select.set('optionLabelPath', 'content.firstName');\n    select.set('multiple', true);\n    select.set('selection', selection);\n  });\n\n  append();\n\n  deepEqual(select.get('selection'), [yehuda, tom], \"Initial selection should be correct\");\n\n  Ember.run(function() {\n    selection.replace(0, selection.get('length'), Ember.A([david, brennain]));\n  });\n\n  deepEqual(\n    select.$(':selected').map(function(){ return trim(Ember.$(this).text());}).toArray(),\n    ['David', 'Brennain'],\n    \"After updating the selection array in-place, selection should be correct\");\n});\n\n\ntest(\"multiple selections can be set indirectly via bindings and in-place when multiple=true (issue #1058)\", function() {\n  var indirectContent = Ember.Object.create();\n\n  var yehuda = { id: 1, firstName: 'Yehuda' },\n      tom = { id: 2, firstName: 'Tom' },\n      david = { id: 3, firstName: 'David' },\n      brennain = { id: 4, firstName: 'Brennain' },\n      cyril = { id: 5, firstName: 'Cyril' };\n\n  Ember.run(function() {\n    select.destroy(); // Destroy the existing select\n\n    Ember.run(function() {\n      select = Ember.Select.extend({\n        indirectContent: indirectContent,\n        contentBinding: 'indirectContent.controller.content',\n        selectionBinding: 'indirectContent.controller.selection',\n        multiple: true,\n        optionLabelPath: 'content.firstName'\n      }).create();\n\n      indirectContent.set('controller', Ember.Object.create({\n        content: Ember.A([tom, david, brennain]),\n        selection: Ember.A([david])\n      }));\n    });\n\n    append();\n  });\n\n  deepEqual(select.get('content'), [tom, david, brennain], \"Initial content should be correct\");\n  deepEqual(select.get('selection'), [david], \"Initial selection should be correct\");\n\n  Ember.run(function() {\n    indirectContent.set('controller.content', Ember.A([david, cyril]));\n    indirectContent.set('controller.selection', Ember.A([cyril]));\n  });\n\n  deepEqual(select.get('content'), [david, cyril], \"After updating bound content, content should be correct\");\n  deepEqual(select.get('selection'), [cyril], \"After updating bound selection, selection should be correct\");\n});\n\ntest(\"selection uses the same array when multiple=true\", function() {\n  var yehuda = { id: 1, firstName: 'Yehuda' },\n      tom = { id: 2, firstName: 'Tom' },\n      david = { id: 3, firstName: 'David' },\n      brennain = { id: 4, firstName: 'Brennain' },\n      selection = Ember.A([yehuda, david]);\n\n  Ember.run(function() {\n    select.set('content', Ember.A([yehuda, tom, david, brennain]));\n    select.set('multiple', true);\n    select.set('optionLabelPath', 'content.firstName');\n    select.set('selection', selection);\n  });\n\n  append();\n\n  deepEqual(select.get('selection'), [yehuda, david], \"Initial selection should be correct\");\n\n  select.$('option').each(function() { this.selected = false; });\n  select.$(':contains(\"Tom\"), :contains(\"David\")').each(function() { this.selected = true; });\n\n  select.$().trigger('change');\n\n  deepEqual(select.get('selection'), [tom,david], \"On change the selection is updated\");\n  deepEqual(selection, [tom,david], \"On change the original selection array is updated\");\n});\n\ntest(\"Ember.SelectedOption knows when it is selected when multiple=false\", function() {\n  var yehuda = { id: 1, firstName: 'Yehuda' },\n      tom = { id: 2, firstName: 'Tom' },\n      david = { id: 3, firstName: 'David' },\n      brennain = { id: 4, firstName: 'Brennain' };\n\n  Ember.run(function() {\n    select.set('content', Ember.A([yehuda, tom, david, brennain]));\n    select.set('multiple', false);\n\n    select.set('selection', david);\n  });\n\n  append();\n\n  deepEqual(selectedOptions(), [false, false, true, false], \"Initial selection should be correct\");\n\n  Ember.run(function() { select.set('selection', brennain); });\n\n  deepEqual(selectedOptions(), [false, false, false, true], \"After changing it, selection should be correct\");\n});\n\ntest(\"Ember.SelectedOption knows when it is selected when multiple=true\", function() {\n  var yehuda = { id: 1, firstName: 'Yehuda' },\n      tom = { id: 2, firstName: 'Tom' },\n      david = { id: 3, firstName: 'David' },\n      brennain = { id: 4, firstName: 'Brennain' };\n\n  Ember.run(function() {\n    select.set('content', Ember.A([yehuda, tom, david, brennain]));\n    select.set('multiple', true);\n\n    select.set('selection', [yehuda, david]);\n  });\n\n  append();\n\n  deepEqual(selectedOptions(), [true, false, true, false], \"Initial selection should be correct\");\n\n  Ember.run(function() {\n    select.set('selection', [tom, david]);\n  });\n\n  deepEqual(selectedOptions(), [false, true, true, false], \"After changing it, selection should be correct\");\n});\n\ntest(\"Ember.SelectedOption knows when it is selected when multiple=true and options are primatives\", function() {\n  Ember.run(function() {\n    select.set('content', Ember.A([1, 2, 3, 4]));\n    select.set('multiple', true);\n    select.set('selection', [1, 3]);\n  });\n\n  append();\n\n  deepEqual(selectedOptions(), [true, false, true, false], \"Initial selection should be correct\");\n\n  Ember.run(function() { select.set('selection', [2, 3]); });\n\n  deepEqual(selectedOptions(), [false, true, true, false], \"After changing it, selection should be correct\");\n});\n\ntest(\"a prompt can be specified\", function() {\n  var yehuda = { id: 1, firstName: 'Yehuda' },\n      tom = { id: 2, firstName: 'Tom' };\n\n  Ember.run(function() {\n    select.set('content', Ember.A([yehuda, tom]));\n    select.set('prompt', 'Pick a person');\n    select.set('optionLabelPath', 'content.firstName');\n    select.set('optionValuePath', 'content.id');\n  });\n\n  append();\n\n  equal(select.$('option').length, 3, \"There should be three options\");\n  equal(select.$()[0].selectedIndex, 0, \"By default, the prompt is selected in the DOM\");\n  equal(trim(select.$('option:selected').text()), 'Pick a person', \"By default, the prompt is selected in the DOM\");\n  equal(select.$().val(), '', \"By default, the prompt has no value\");\n\n  equal(select.get('selection'), null, \"When the prompt is selected, the selection should be null\");\n\n  Ember.run(function() { select.set('selection', tom); });\n\n  equal(select.$()[0].selectedIndex, 2, \"The selectedIndex accounts for the prompt\");\n\n  select.$()[0].selectedIndex = 0;\n  select.$().trigger('change');\n\n  equal(select.get('selection'), null, \"When the prompt is selected again after another option, the selection should be null\");\n\n  select.$()[0].selectedIndex = 2;\n  select.$().trigger('change');\n  equal(select.get('selection'), tom, \"Properly accounts for the prompt when DOM change occurs\");\n});\n\ntest(\"handles null content\", function() {\n  append();\n\n  Ember.run(function() {\n    select.set('content', null);\n    select.set('selection', 'invalid');\n  });\n\n  equal(select.get('element').selectedIndex, -1, \"should have no selection\");\n\n  Ember.run(function() {\n    select.set('multiple', true);\n    select.set('selection', [{ content: 'invalid' }]);\n  });\n\n  equal(select.get('element').selectedIndex, -1, \"should have no selection\");\n});\n\n\ntest(\"should be able to select an option and then reselect the prompt\", function() {\n  Ember.run(function() {\n    select.set('content', Ember.A(['one', 'two', 'three']));\n    select.set('prompt', 'Select something');\n  });\n\n  append();\n\n  select.$()[0].selectedIndex = 2;\n  select.$().trigger('change');\n  equal(select.get('selection'), 'two');\n\n  select.$()[0].selectedIndex = 0;\n  select.$().trigger('change');\n  equal(select.get('selection'), null);\n  equal(select.$()[0].selectedIndex, 0);\n});\n\ntest(\"should be able to get the current selection's value\", function() {\n  Ember.run(function() {\n    select.set('content', Ember.A([\n      {label: 'Yehuda Katz', value: 'wycats'},\n      {label: 'Tom Dale', value: 'tomdale'},\n      {label: 'Peter Wagenet', value: 'wagenet'},\n      {label: 'Erik Bryn', value: 'ebryn'}\n    ]));\n    select.set('optionLabelPath', 'content.label');\n    select.set('optionValuePath', 'content.value');\n  });\n\n  append();\n\n  equal(select.get('value'), 'wycats');\n});\n\ntest(\"should be able to set the current selection by value\", function() {\n  var ebryn = {label: 'Erik Bryn', value: 'ebryn'};\n\n  Ember.run(function() {\n    select.set('content', Ember.A([\n      {label: 'Yehuda Katz', value: 'wycats'},\n      {label: 'Tom Dale', value: 'tomdale'},\n      {label: 'Peter Wagenet', value: 'wagenet'},\n      ebryn\n    ]));\n    select.set('optionLabelPath', 'content.label');\n    select.set('optionValuePath', 'content.value');\n    select.set('value', 'ebryn');\n  });\n\n  append();\n\n  equal(select.get('value'), 'ebryn');\n  equal(select.get('selection'), ebryn);\n});\n\nmodule(\"Ember.Select - usage inside templates\", {\n  setup: function() {\n    dispatcher = Ember.EventDispatcher.create();\n    dispatcher.setup();\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      dispatcher.destroy();\n      if (view) { view.destroy(); }\n    });\n  }\n});\n\ntest(\"works from a template with bindings\", function() {\n  var Person = Ember.Object.extend({\n    id: null,\n    firstName: null,\n    lastName: null,\n\n    fullName: Ember.computed(function() {\n      return this.get('firstName') + \" \" + this.get('lastName');\n    }).property('firstName', 'lastName')\n  });\n\n  var erik = Person.create({id: 4, firstName: 'Erik', lastName: 'Bryn'});\n\n  var application = Ember.Namespace.create();\n\n  application.peopleController = Ember.ArrayController.create({\n    content: Ember.A([\n      Person.create({id: 1, firstName: 'Yehuda', lastName: 'Katz'}),\n      Person.create({id: 2, firstName: 'Tom', lastName: 'Dale'}),\n      Person.create({id: 3, firstName: 'Peter', lastName: 'Wagenet'}),\n      erik\n    ])\n  });\n\n  application.selectedPersonController = Ember.Object.create({\n    person: null\n  });\n\n  view = Ember.View.create({\n    app: application,\n    template: Ember.Handlebars.compile(\n      '{{view Ember.Select viewName=\"select\"' +\n      '                    contentBinding=\"view.app.peopleController\"' +\n      '                    optionLabelPath=\"content.fullName\"' +\n      '                    optionValuePath=\"content.id\"' +\n      '                    prompt=\"Pick a person:\"' +\n      '                    selectionBinding=\"view.app.selectedPersonController.person\"}}'\n    )\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  var select = view.get('select');\n  ok(select.$().length, \"Select was rendered\");\n  equal(select.$('option').length, 5, \"Options were rendered\");\n  equal(select.$().text(), \"Pick a person:Yehuda KatzTom DalePeter WagenetErik Bryn\", \"Option values were rendered\");\n  equal(select.get('selection'), null, \"Nothing has been selected\");\n\n  Ember.run(function(){\n    application.selectedPersonController.set('person', erik);\n  });\n\n  equal(select.get('selection'), erik, \"Selection was updated through binding\");\n  Ember.run(function(){\n    application.peopleController.pushObject(Person.create({id: 5, firstName: \"James\", lastName: \"Rosen\"}));\n  });\n\n  equal(select.$('option').length, 6, \"New option was added\");\n  equal(select.get('selection'), erik, \"Selection was maintained after new option was added\");\n});\n\ntest(\"upon content change, the DOM should reflect the selection (#481)\", function() {\n  var userOne = {name: 'Mike', options: Ember.A(['a', 'b']), selectedOption: 'a'},\n      userTwo = {name: 'John', options: Ember.A(['c', 'd']), selectedOption: 'd'};\n\n  view = Ember.View.create({\n    user: userOne,\n    template: Ember.Handlebars.compile(\n      '{{view Ember.Select viewName=\"select\"' +\n      '    contentBinding=\"view.user.options\"' +\n      '    selectionBinding=\"view.user.selectedOption\"}}'\n    )\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  var select = view.get('select'),\n      selectEl = select.$()[0];\n\n  equal(select.get('selection'), 'a', \"Precond: Initial selection is correct\");\n  equal(selectEl.selectedIndex, 0, \"Precond: The DOM reflects the correct selection\");\n\n  Ember.run(function() {\n    view.set('user', userTwo);\n  });\n\n  equal(select.get('selection'), 'd', \"Selection was properly set after content change\");\n  equal(selectEl.selectedIndex, 1, \"The DOM reflects the correct selection\");\n});\n\ntest(\"upon content change with Array-like content, the DOM should reflect the selection\", function() {\n  var tom = {id: 4, name: 'Tom'},\n      sylvain = {id: 5, name: 'Sylvain'};\n\n  var proxy = Ember.ArrayProxy.create({\n    content: Ember.A([]),\n    selectedOption: sylvain\n  });\n\n  view = Ember.View.create({\n    proxy: proxy,\n    template: Ember.Handlebars.compile(\n      '{{view Ember.Select viewName=\"select\"' +\n      '    contentBinding=\"view.proxy\"' +\n      '    selectionBinding=\"view.proxy.selectedOption\"}}'\n    )\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  var select = view.get('select'),\n      selectEl = select.$()[0];\n\n  equal(selectEl.selectedIndex, -1, \"Precond: The DOM reflects the lack of selection\");\n\n  Ember.run(function() {\n    proxy.set('content', Ember.A([tom, sylvain]));\n  });\n\n  equal(select.get('selection'), sylvain, \"Selection was properly set after content change\");\n  equal(selectEl.selectedIndex, 1, \"The DOM reflects the correct selection\");\n});\n\ntest(\"select element should correctly initialize and update selectedIndex and bound properties when using valueBinding\", function() {\n  view = Ember.View.create({\n    collection: Ember.A([{name: 'Wes', value: 'w'}, {name: 'Gordon', value: 'g'}]),\n    val: 'g',\n    template: Ember.Handlebars.compile(\n      '{{view Ember.Select viewName=\"select\"' +\n      '    contentBinding=\"view.collection\"' +\n      '    optionLabelPath=\"content.name\"' +\n      '    optionValuePath=\"content.value\"' +\n      '    prompt=\"Please wait...\"' +\n      '    valueBinding=\"view.val\"}}'\n    )\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  var select = view.get('select'),\n      selectEl = select.$()[0];\n\n  equal(view.get('val'), 'g', \"Precond: Initial bound property is correct\");\n  equal(select.get('value'), 'g', \"Precond: Initial selection is correct\");\n  equal(selectEl.selectedIndex, 2, \"Precond: The DOM reflects the correct selection\");\n\n  select.$('option:eq(2)').removeAttr('selected');\n  select.$('option:eq(1)').prop('selected', true);\n  select.$().trigger('change');\n\n  equal(view.get('val'), 'w', \"Updated bound property is correct\");\n  equal(select.get('value'), 'w', \"Updated selection is correct\");\n  equal(selectEl.selectedIndex, 1, \"The DOM is updated to reflect the new selection\");\n});\n\n})();\n//@ sourceURL=ember-handlebars/~tests/controls/select_test");minispade.register('ember-handlebars/~tests/controls/text_area_test', "(function() {/*globals TestObject:true */\n\nvar textArea;\nvar get = Ember.get, set = Ember.set;\n\nmodule(\"Ember.TextArea\", {\n  setup: function() {\n    TestObject = Ember.Object.create({\n      value: null\n    });\n\n    textArea = Ember.TextArea.create();\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      textArea.destroy();\n    });\n    TestObject = textArea = null;\n  }\n});\n\nfunction append() {\n  Ember.run(function() {\n    textArea.appendTo('#qunit-fixture');\n  });\n}\n\ntest(\"should become disabled if the disabled attribute is true\", function() {\n  textArea.set('disabled', true);\n  append();\n\n  ok(textArea.$().is(\":disabled\"));\n});\n\ntest(\"should become disabled if the disabled attribute is true\", function() {\n  append();\n  ok(textArea.$().is(\":not(:disabled)\"));\n\n  Ember.run(function() { textArea.set('disabled', true); });\n  ok(textArea.$().is(\":disabled\"));\n\n  Ember.run(function() { textArea.set('disabled', false); });\n  ok(textArea.$().is(\":not(:disabled)\"));\n});\n\ntest(\"input value is updated when setting value property of view\", function() {\n  Ember.run(function() {\n    set(textArea, 'value', 'foo');\n    textArea.append();\n  });\n\n  equal(textArea.$().val(), \"foo\", \"renders text field with value\");\n\n  Ember.run(function() { set(textArea, 'value', 'bar'); });\n\n  equal(textArea.$().val(), \"bar\", \"updates text field after value changes\");\n});\n\ntest(\"input placeholder is updated when setting placeholder property of view\", function() {\n  Ember.run(function() {\n    set(textArea, 'placeholder', 'foo');\n    textArea.append();\n  });\n\n  equal(textArea.$().attr('placeholder'), \"foo\", \"renders text area with placeholder\");\n\n  Ember.run(function() { set(textArea, 'placeholder', 'bar'); });\n\n  equal(textArea.$().attr('placeholder'), \"bar\", \"updates text area after placeholder changes\");\n});\n\ntest(\"input name is updated when setting name property of view\", function() {\n  Ember.run(function() {\n    set(textArea, 'name', 'foo');\n    textArea.append();\n  });\n\n  equal(textArea.$().attr('name'), \"foo\", \"renders text area with name\");\n\n  Ember.run(function() { set(textArea, 'name', 'bar'); });\n\n  equal(textArea.$().attr('name'), \"bar\", \"updates text area after name changes\");\n});\n\ntest(\"input maxlength is updated when setting maxlength property of view\", function() {\n  Ember.run(function() {\n    set(textArea, 'maxlength', '300');\n    textArea.append();\n  });\n\n  equal(textArea.$().attr('maxlength'), \"300\", \"renders text area with maxlength\");\n\n  Ember.run(function() { set(textArea, 'maxlength', '400'); });\n\n  equal(textArea.$().attr('maxlength'), \"400\", \"updates text area after maxlength changes\");\n});\n\ntest(\"input rows is updated when setting rows property of view\", function() {\n  Ember.run(function() {\n    set(textArea, 'rows', '3');\n    textArea.append();\n  });\n\n  equal(textArea.$().attr('rows'), \"3\", \"renders text area with rows\");\n\n  Ember.run(function() { set(textArea, 'rows', '4'); });\n\n  equal(textArea.$().attr('rows'), \"4\", \"updates text area after rows changes\");\n});\n\ntest(\"input cols is updated when setting cols property of view\", function() {\n  Ember.run(function() {\n    set(textArea, 'cols', '30');\n    textArea.append();\n  });\n\n  equal(textArea.$().attr('cols'), \"30\", \"renders text area with cols\");\n\n  Ember.run(function() { set(textArea, 'cols', '40'); });\n\n  equal(textArea.$().attr('cols'), \"40\", \"updates text area after cols changes\");\n});\n\ntest(\"input tabindex is updated when setting tabindex property of view\", function() {\n  Ember.run(function() {\n    set(textArea, 'tabindex', '4');\n    textArea.append();\n  });\n\n  equal(textArea.$().attr('tabindex'), \"4\", \"renders text area with the tabindex\");\n\n  Ember.run(function() { set(textArea, 'tabindex', '1'); });\n\n  equal(textArea.$().attr('tabindex'), \"1\", \"updates text area after tabindex changes\");\n});\n\ntest(\"value binding works properly for inputs that haven't been created\", function() {\n\n  Ember.run(function() {\n    textArea.destroy(); // destroy existing textarea\n    textArea = Ember.TextArea.createWithMixins({\n      valueBinding: 'TestObject.value'\n    });\n  });\n\n  equal(get(textArea, 'value'), null, \"precond - default value is null\");\n  equal(textArea.$(), undefined, \"precond - view doesn't have its layer created yet, thus no input element\");\n\n  Ember.run(function() {\n    set(TestObject, 'value', 'ohai');\n  });\n\n  equal(get(textArea, 'value'), 'ohai', \"value property was properly updated\");\n\n  Ember.run(function() { textArea.append(); });\n\n  equal(get(textArea, 'value'), 'ohai', \"value property remains the same once the view has been appended\");\n  equal(textArea.$().val(), 'ohai', \"value is reflected in the input element once it is created\");\n});\n\n[ 'cut', 'paste', 'input' ].forEach(function(eventName) {\n  test(\"should update the value on \" + eventName + \" events\", function() {\n\n    Ember.run(function() {\n      textArea.append();\n    });\n\n    textArea.$().val('new value');\n    textArea.trigger(eventName, Ember.Object.create({\n      type: eventName\n    }));\n\n    equal(textArea.get('value'), 'new value', 'value property updates on ' + eventName + ' events');\n  });\n});\n\ntest(\"should call the insertNewline method when return key is pressed\", function() {\n  var wasCalled;\n  var event = Ember.Object.create({\n    keyCode: 13\n  });\n\n  Ember.run(function() { textArea.append(); });\n\n  textArea.insertNewline = function() {\n    wasCalled = true;\n  };\n\n  textArea.trigger('keyUp', event);\n  ok(wasCalled, \"invokes insertNewline method\");\n});\n\ntest(\"should call the cancel method when escape key is pressed\", function() {\n  var wasCalled;\n  var event = Ember.Object.create({\n    keyCode: 27\n  });\n\n  Ember.run(function() { textArea.append(); });\n\n  textArea.cancel = function() {\n    wasCalled = true;\n  };\n\n  textArea.trigger('keyUp', event);\n  ok(wasCalled, \"invokes cancel method\");\n});\n\n// test(\"listens for focus and blur events\", function() {\n//   var focusCalled = 0;\n//   var blurCalled = 0;\n\n//   textArea.focus = function() {\n//     focusCalled++;\n//   };\n//   textArea.blur = function() {\n//     blurCalled++;\n//   };\n\n//   equal(focusCalled+blurCalled, 0, \"precond - no callbacks called yet\");\n\n//   textArea.$().focus();\n//   equal(focusCalled, 1, \"focus called after field receives focus\");\n\n//   textArea.$().blur();\n//   equal(blurCalled, 1, \"blur alled after field blurs\");\n// });\n\n// test(\"calls correct method for key events\", function() {\n//   var insertNewlineCalled = 0;\n//   var cancelCalled = 0;\n\n//   textArea.insertNewline = function() {\n//     insertNewlineCalled++;\n//     return true;\n//   };\n//   textArea.cancel = function() {\n//     cancelCalled++;\n//     return true;\n//   };\n\n//   textArea.$().focus();\n//   equal(insertNewlineCalled+cancelCalled, 0, \"precond - no callbacks called yet\");\n\n//   Ember.RootResponder.responder.keyup(new Ember.Event({ type: 'keyup', keyCode: 13 }));\n//   equal(insertNewlineCalled, 1, \"calls insertNewline after hitting return\");\n\n//   Ember.RootResponder.responder.keyup(new Ember.Event({ type: 'keyup', keyCode: 27 }));\n//   equal(cancelCalled, 1, \"calls cancel after pressing escape key\");\n// });\n\n\n})();\n//@ sourceURL=ember-handlebars/~tests/controls/text_area_test");minispade.register('ember-handlebars/~tests/controls/text_field_test', "(function() {/*globals TestObject:true */\n\nvar textField;\nvar get = Ember.get, set = function(obj, key, value) {\n  Ember.run(function() { Ember.set(obj, key, value); });\n};\n\nfunction append() {\n  Ember.run(function() {\n    textField.appendTo('#qunit-fixture');\n  });\n}\n\nfunction destroy(view) {\n  Ember.run(function() {\n    view.destroy();\n  });\n}\n\nvar controller;\n\nmodule(\"{{input type='text'}}\", {\n  setup: function() {\n    controller = {\n      val: \"hello\",\n      place: \"Enter some text\",\n      name: \"some-name\",\n      max: 30,\n      size: 30,\n      tab: 5\n    };\n\n    textField = Ember.View.extend({\n      controller: controller,\n      template: compile('{{input type=\"text\" disabled=disabled value=val placeholder=place name=name maxlength=max size=size tabindex=tab}}')\n    }).create();\n\n    append();\n  },\n\n  teardown: function() {\n    destroy(textField);\n  }\n});\n\nvar compile = Ember.Handlebars.compile;\n\ntest(\"should insert a text field into DOM\", function() {\n  equal(textField.$('input').length, 1, \"A single text field was inserted\");\n});\n\ntest(\"should become disabled if the disabled attribute is true\", function() {\n  equal(textField.$('input:disabled').length, 0, \"There are no disabled text fields\");\n\n  set(controller, 'disabled', true);\n  equal(textField.$('input:disabled').length, 1, \"The text field is disabled\");\n\n  set(controller, 'disabled', false);\n  equal(textField.$('input:disabled').length, 0, \"There are no disabled text fields\");\n});\n\ntest(\"input value is updated when setting value property of view\", function() {\n  equal(textField.$('input').val(), \"hello\", \"renders text field with value\");\n  set(controller, 'val', 'bye!');\n  equal(textField.$('input').val(), \"bye!\", \"updates text field after value changes\");\n});\n\ntest(\"input placeholder is updated when setting placeholder property of view\", function() {\n  equal(textField.$('input').attr('placeholder'), \"Enter some text\", \"renders text field with placeholder\");\n  set(controller, 'place', 'Text, please enter it');\n  equal(textField.$('input').attr('placeholder'), \"Text, please enter it\", \"updates text field after placeholder changes\");\n});\n\ntest(\"input name is updated when setting name property of view\", function() {\n  equal(textField.$('input').attr('name'), \"some-name\", \"renders text field with name\");\n  set(controller, 'name', 'other-name');\n  equal(textField.$('input').attr('name'), \"other-name\", \"updates text field after name changes\");\n});\n\ntest(\"input maxlength is updated when setting maxlength property of view\", function() {\n  equal(textField.$('input').attr('maxlength'), \"30\", \"renders text field with maxlength\");\n  set(controller, 'max', 40);\n  equal(textField.$('input').attr('maxlength'), \"40\", \"updates text field after maxlength changes\");\n});\n\ntest(\"input size is updated when setting size property of view\", function() {\n  equal(textField.$('input').attr('size'), \"30\", \"renders text field with size\");\n  set(controller, 'size', 40);\n  equal(textField.$('input').attr('size'), \"40\", \"updates text field after size changes\");\n});\n\ntest(\"input tabindex is updated when setting tabindex property of view\", function() {\n  equal(textField.$('input').attr('tabindex'), \"5\", \"renders text field with the tabindex\");\n  set(controller, 'tab', 3);\n  equal(textField.$('input').attr('tabindex'), \"3\", \"updates text field after tabindex changes\");\n});\n\nmodule(\"{{input type='text'}} - static values\", {\n  setup: function() {\n    controller = {};\n\n    textField = Ember.View.extend({\n      controller: controller,\n      template: compile('{{input type=\"text\" disabled=true value=\"hello\" placeholder=\"Enter some text\" name=\"some-name\" maxlength=30 size=30 tabindex=5}}')\n    }).create();\n\n    append();\n  },\n\n  teardown: function() {\n    destroy(textField);\n  }\n});\n\ntest(\"should insert a text field into DOM\", function() {\n  equal(textField.$('input').length, 1, \"A single text field was inserted\");\n});\n\ntest(\"should become disabled if the disabled attribute is true\", function() {\n  equal(textField.$('input:disabled').length, 1, \"The text field is disabled\");\n});\n\ntest(\"input value is updated when setting value property of view\", function() {\n  equal(textField.$('input').val(), \"hello\", \"renders text field with value\");\n});\n\ntest(\"input placeholder is updated when setting placeholder property of view\", function() {\n  equal(textField.$('input').attr('placeholder'), \"Enter some text\", \"renders text field with placeholder\");\n});\n\ntest(\"input name is updated when setting name property of view\", function() {\n  equal(textField.$('input').attr('name'), \"some-name\", \"renders text field with name\");\n});\n\ntest(\"input maxlength is updated when setting maxlength property of view\", function() {\n  equal(textField.$('input').attr('maxlength'), \"30\", \"renders text field with maxlength\");\n});\n\ntest(\"input size is updated when setting size property of view\", function() {\n  equal(textField.$('input').attr('size'), \"30\", \"renders text field with size\");\n});\n\ntest(\"input tabindex is updated when setting tabindex property of view\", function() {\n  equal(textField.$('input').attr('tabindex'), \"5\", \"renders text field with the tabindex\");\n});\n\nmodule(\"Ember.TextField\", {\n  setup: function() {\n    TestObject = Ember.Object.create({\n      value: null\n    });\n\n    textField = Ember.TextField.create();\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      textField.destroy();\n    });\n    TestObject = textField = null;\n  }\n});\n\ntest(\"should become disabled if the disabled attribute is true\", function() {\n  textField.set('disabled', true);\n  append();\n\n  ok(textField.$().is(\":disabled\"));\n});\n\ntest(\"should become disabled if the disabled attribute is true\", function() {\n  append();\n  ok(textField.$().is(\":not(:disabled)\"));\n\n  Ember.run(function() { textField.set('disabled', true); });\n  ok(textField.$().is(\":disabled\"));\n\n  Ember.run(function() { textField.set('disabled', false); });\n  ok(textField.$().is(\":not(:disabled)\"));\n});\n\ntest(\"input value is updated when setting value property of view\", function() {\n  Ember.run(function() {\n    set(textField, 'value', 'foo');\n    textField.append();\n  });\n\n  equal(textField.$().val(), \"foo\", \"renders text field with value\");\n\n  Ember.run(function() { set(textField, 'value', 'bar'); });\n\n  equal(textField.$().val(), \"bar\", \"updates text field after value changes\");\n});\n\ntest(\"input placeholder is updated when setting placeholder property of view\", function() {\n  Ember.run(function() {\n    set(textField, 'placeholder', 'foo');\n    textField.append();\n  });\n\n  equal(textField.$().attr('placeholder'), \"foo\", \"renders text field with placeholder\");\n\n  Ember.run(function() { set(textField, 'placeholder', 'bar'); });\n\n  equal(textField.$().attr('placeholder'), \"bar\", \"updates text field after placeholder changes\");\n});\n\ntest(\"input name is updated when setting name property of view\", function() {\n  Ember.run(function() {\n    set(textField, 'name', 'foo');\n    textField.append();\n  });\n\n  equal(textField.$().attr('name'), \"foo\", \"renders text field with name\");\n\n  Ember.run(function() { set(textField, 'name', 'bar'); });\n\n  equal(textField.$().attr('name'), \"bar\", \"updates text field after name changes\");\n});\n\ntest(\"input maxlength is updated when setting maxlength property of view\", function() {\n  Ember.run(function() {\n    set(textField, 'maxlength', '30');\n    textField.append();\n  });\n\n  equal(textField.$().attr('maxlength'), \"30\", \"renders text field with maxlength\");\n\n  Ember.run(function() { set(textField, 'maxlength', '40'); });\n\n  equal(textField.$().attr('maxlength'), \"40\", \"updates text field after maxlength changes\");\n});\n\ntest(\"input size is updated when setting size property of view\", function() {\n  Ember.run(function() {\n    set(textField, 'size', '30');\n    textField.append();\n  });\n\n  equal(textField.$().attr('size'), \"30\", \"renders text field with size\");\n\n  Ember.run(function() { set(textField, 'size', '40'); });\n\n  equal(textField.$().attr('size'), \"40\", \"updates text field after size changes\");\n});\n\ntest(\"input tabindex is updated when setting tabindex property of view\", function() {\n  Ember.run(function() {\n    set(textField, 'tabindex', '5');\n    textField.append();\n  });\n\n  equal(textField.$().attr('tabindex'), \"5\", \"renders text field with the tabindex\");\n\n  Ember.run(function() { set(textField, 'tabindex', '3'); });\n\n  equal(textField.$().attr('tabindex'), \"3\", \"updates text field after tabindex changes\");\n});\n\ntest(\"input type is configurable when creating view\", function() {\n  Ember.run(function() {\n    set(textField, 'type', 'password');\n    textField.append();\n  });\n\n  equal(textField.$().attr('type'), 'password', \"renders text field with type\");\n});\n\ntest(\"value binding works properly for inputs that haven't been created\", function() {\n\n  Ember.run(function() {\n    textField.destroy(); // destroy existing textField\n    textField = Ember.TextField.createWithMixins({\n      valueBinding: 'TestObject.value'\n    });\n  });\n\n  equal(get(textField, 'value'), null, \"precond - default value is null\");\n  equal(textField.$(), undefined, \"precond - view doesn't have its layer created yet, thus no input element\");\n\n  Ember.run(function() {\n    set(TestObject, 'value', 'ohai');\n  });\n\n  equal(get(textField, 'value'), 'ohai', \"value property was properly updated\");\n\n  Ember.run(function() { textField.append(); });\n\n  equal(get(textField, 'value'), 'ohai', \"value property remains the same once the view has been appended\");\n  equal(textField.$().val(), 'ohai', \"value is reflected in the input element once it is created\");\n});\n\ntest(\"value binding sets value on the element\", function() {\n  Ember.run(function() {\n    textField.destroy(); // destroy existing textField\n    textField = Ember.TextField.createWithMixins({\n      valueBinding: 'TestObject.value'\n    });\n    textField.append();\n  });\n\n  // Set the value via the DOM\n  Ember.run(function() {\n    textField.$().val('via dom');\n    // Trigger lets the view know we changed this value (like a real user editing)\n    textField.trigger('input', Ember.Object.create({\n      type: 'input'\n    }));\n  });\n\n  equal(get(textField, 'value'), 'via dom', \"value property was properly updated via dom\");\n  equal(textField.$().val(), 'via dom', \"dom property was properly updated via dom\");\n\n  // Now, set it via the binding\n  Ember.run(function() {\n    set(TestObject, 'value', 'via view');\n  });\n\n  equal(get(textField, 'value'), 'via view', \"value property was properly updated via view\");\n  equal(textField.$().val(), 'via view', \"dom property was properly updated via view\");\n});\n\ntest(\"should call the insertNewline method when return key is pressed\", function() {\n  var wasCalled;\n  var event = Ember.Object.create({\n    keyCode: 13\n  });\n\n  Ember.run(function() { textField.append(); });\n\n  textField.insertNewline = function() {\n    wasCalled = true;\n  };\n\n  textField.trigger('keyUp', event);\n  ok(wasCalled, \"invokes insertNewline method\");\n});\n\ntest(\"should call the cancel method when escape key is pressed\", function() {\n  var wasCalled;\n  var event = Ember.Object.create({\n    keyCode: 27\n  });\n\n  Ember.run(function() { textField.append(); });\n\n  textField.cancel = function() {\n    wasCalled = true;\n  };\n\n  textField.trigger('keyUp', event);\n  ok(wasCalled, \"invokes cancel method\");\n});\n\ntest(\"should send an action if one is defined when the return key is pressed\", function() {\n  expect(3);\n\n  var StubController = Ember.Object.extend({\n    send: function(actionName, value, sender) {\n      equal(actionName, 'didTriggerAction', \"text field sent correct action name\");\n      equal(value, \"textFieldValue\", \"text field sent its current value as first argument\");\n      equal(sender, textField, \"text field sent itself as second argument\");\n    }\n  });\n\n  textField.set('action', 'didTriggerAction');\n  textField.set('value', \"textFieldValue\");\n  textField.set('controller', StubController.create());\n\n  Ember.run(function() { textField.append(); });\n\n  var event = {\n    keyCode: 13,\n    stopPropagation: Ember.K\n  };\n\n  textField.trigger('keyUp', event);\n});\n\ntest(\"bubbling of handled actions can be enabled via bubbles property\", function() {\n  textField.set('bubbles', true);\n  textField.set('action', 'didTriggerAction');\n\n  textField.set('controller', Ember.Object.create({\n    send: Ember.K\n  }));\n\n  append();\n\n  var stopPropagationCount = 0;\n  var event = {\n    keyCode: 13,\n    stopPropagation: function() {\n      stopPropagationCount++;\n    }\n  };\n\n  textField.trigger('keyUp', event);\n  equal(stopPropagationCount, 0, \"propagation was not prevented if bubbles is true\");\n\n  textField.set('bubbles', false);\n  textField.trigger('keyUp', event);\n  equal(stopPropagationCount, 1, \"propagation was prevented if bubbles is false\");\n});\n\n// test(\"listens for focus and blur events\", function() {\n//   var focusCalled = 0;\n//   var blurCalled = 0;\n\n//   textField.focus = function() {\n//     focusCalled++;\n//   };\n//   textField.blur = function() {\n//     blurCalled++;\n//   };\n\n//   equal(focusCalled+blurCalled, 0, \"precond - no callbacks called yet\");\n\n//   textField.$().focus();\n//   equal(focusCalled, 1, \"focus called after field receives focus\");\n\n//   textField.$().blur();\n//   equal(blurCalled, 1, \"blur alled after field blurs\");\n// });\n\n// test(\"calls correct method for key events\", function() {\n//   var insertNewlineCalled = 0;\n//   var cancelCalled = 0;\n\n//   textField.insertNewline = function() {\n//     insertNewlineCalled++;\n//     return true;\n//   };\n//   textField.cancel = function() {\n//     cancelCalled++;\n//     return true;\n//   };\n\n//   textField.$().focus();\n//   equal(insertNewlineCalled+cancelCalled, 0, \"precond - no callbacks called yet\");\n\n//   Ember.RootResponder.responder.keyup(new Ember.Event({ type: 'keyup', keyCode: 13 }));\n//   equal(insertNewlineCalled, 1, \"calls insertNewline after hitting return\");\n\n//   Ember.RootResponder.responder.keyup(new Ember.Event({ type: 'keyup', keyCode: 27 }));\n//   equal(cancelCalled, 1, \"calls cancel after pressing escape key\");\n// });\n\n\n})();\n//@ sourceURL=ember-handlebars/~tests/controls/text_field_test");minispade.register('ember-handlebars/~tests/handlebars_test', "(function() {/*globals TemplateTests:true MyApp:true App:true */\n\nvar get = Ember.get, set = Ember.set;\nvar forEach = Ember.EnumerableUtils.forEach;\nvar trim = Ember.$.trim;\n\nvar firstGrandchild = function(view) {\n  return get(get(view, 'childViews').objectAt(0), 'childViews').objectAt(0);\n};\nvar nthChild = function(view, nth) {\n  return get(view, 'childViews').objectAt(nth || 0);\n};\nvar firstChild = nthChild;\n\nvar originalLog, logCalls;\n\n(function() {\n\n  Ember.$.fn.caretPosition = function() {\n      var ctrl = this[0];\n\n      var CaretPos = 0;\n      // IE Support\n      if (document.selection) {\n\n          ctrl.focus();\n          var Sel = document.selection.createRange ();\n\n          Sel.moveStart ('character', -ctrl.value.length);\n\n          CaretPos = Sel.text.length;\n      }\n      // Firefox support\n      else if (ctrl.selectionStart || ctrl.selectionStart === '0') {\n          CaretPos = ctrl.selectionStart;\n      }\n\n      return (CaretPos);\n  };\n\n\n  Ember.$.fn.setCaretPosition = function(pos) {\n      var ctrl = this[0];\n\n      if(ctrl.setSelectionRange) {\n          ctrl.focus();\n          ctrl.setSelectionRange(pos,pos);\n      } else if (ctrl.createTextRange) {\n          var range = ctrl.createTextRange();\n          range.collapse(true);\n          range.moveEnd('character', pos);\n          range.moveStart('character', pos);\n          range.select();\n      }\n  };\n\n})();\n\nvar view;\n\nvar appendView = function() {\n  Ember.run(function() { view.appendTo('#qunit-fixture'); });\n};\n\nvar additionalTeardown;\nvar originalLookup = Ember.lookup, lookup;\nvar TemplateTests, container;\n\n/**\n  This module specifically tests integration with Handlebars and Ember-specific\n  Handlebars extensions.\n\n  If you add additional template support to Ember.View, you should create a new\n  file in which to test.\n*/\nmodule(\"Ember.View - handlebars integration\", {\n  setup: function() {\n    Ember.lookup = lookup = { Ember: Ember };\n    lookup.TemplateTests = TemplateTests = Ember.Namespace.create();\n\n    container = new Ember.Container();\n    container.optionsForType('template', { instantiate: false });\n  },\n\n  teardown: function() {\n    if (view) {\n      Ember.run(function() {\n        view.destroy();\n      });\n      view = null;\n    }\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest(\"template view should call the function of the associated template\", function() {\n  container.register('template:testTemplate', Ember.Handlebars.compile(\"<h1 id='twas-called'>template was called</h1>\"));\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'testTemplate'\n  });\n\n  appendView();\n\n  ok(view.$('#twas-called').length, \"the named template was called\");\n});\n\ntest(\"template view should call the function of the associated template with itself as the context\", function() {\n  container.register('template:testTemplate', Ember.Handlebars.compile(\"<h1 id='twas-called'>template was called for {{view.personName}}. Yea {{view.personName}}</h1>\"));\n\n  view = Ember.View.createWithMixins({\n    container: container,\n    templateName: 'testTemplate',\n\n    _personName: \"Tom DAAAALE\",\n    _i: 0,\n\n    personName: Ember.computed(function() {\n      this._i++;\n      return this._personName + this._i;\n    })\n  });\n\n  appendView();\n\n  equal(\"template was called for Tom DAAAALE1. Yea Tom DAAAALE1\", view.$('#twas-called').text(), \"the named template was called with the view as the data source\");\n});\n\ntest(\"should allow values from normal JavaScript hash objects to be used\", function() {\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#with view.person}}{{firstName}} {{lastName}} (and {{pet.name}}){{/with}}'),\n\n    person: {\n      firstName: 'Seor',\n      lastName: 'CFC',\n      pet: {\n        name: 'Fido'\n      }\n    }\n  });\n\n  appendView();\n\n  equal(view.$().text(), \"Seor CFC (and Fido)\", \"prints out values from a hash\");\n});\n\ntest(\"htmlSafe should return an instance of Handlebars.SafeString\", function() {\n  var safeString = Ember.String.htmlSafe(\"you need to be more <b>bold</b>\");\n\n  ok(safeString instanceof Handlebars.SafeString, \"should return SafeString\");\n});\n\ntest(\"should escape HTML in normal mustaches\", function() {\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{view.output}}'),\n    output: \"you need to be more <b>bold</b>\"\n  });\n\n  Ember.run(function() { view.appendTo('#qunit-fixture'); });\n  equal(view.$('b').length, 0, \"does not create an element\");\n  equal(view.$().text(), 'you need to be more <b>bold</b>', \"inserts entities, not elements\");\n\n  Ember.run(function() { set(view, 'output', \"you are so <i>super</i>\"); });\n  equal(view.$().text(), 'you are so <i>super</i>', \"updates with entities, not elements\");\n  equal(view.$('i').length, 0, \"does not create an element when value is updated\");\n});\n\ntest(\"should not escape HTML in triple mustaches\", function() {\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{{view.output}}}'),\n    output: \"you need to be more <b>bold</b>\"\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('b').length, 1, \"creates an element\");\n\n  Ember.run(function() {\n    set(view, 'output', \"you are so <i>super</i>\");\n  });\n\n  equal(view.$('i').length, 1, \"creates an element when value is updated\");\n});\n\ntest(\"should not escape HTML if string is a Handlebars.SafeString\", function() {\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{view.output}}'),\n    output: new Handlebars.SafeString(\"you need to be more <b>bold</b>\")\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('b').length, 1, \"creates an element\");\n\n  Ember.run(function() {\n    set(view, 'output', new Handlebars.SafeString(\"you are so <i>super</i>\"));\n  });\n\n  equal(view.$('i').length, 1, \"creates an element when value is updated\");\n});\n\ntest(\"child views can be inserted using the {{view}} Handlebars helper\", function() {\n  container.register('template:nester', Ember.Handlebars.compile(\"<h1 id='hello-world'>Hello {{world}}</h1>{{view \\\"TemplateTests.LabelView\\\"}}\"));\n  container.register('template:nested', Ember.Handlebars.compile(\"<div id='child-view'>Goodbye {{cruel}} {{world}}</div>\"));\n\n  var context = {\n    world: \"world!\"\n  };\n\n  TemplateTests.LabelView = Ember.View.extend({\n    container: container,\n    tagName: \"aside\",\n    templateName: 'nested'\n  });\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'nester',\n    context: context\n  });\n\n  Ember.set(context, 'cruel', \"cruel\");\n\n  appendView();\n\n  ok(view.$(\"#hello-world:contains('Hello world!')\").length, \"The parent view renders its contents\");\n  ok(view.$(\"#child-view:contains('Goodbye cruel world!')\").length === 1, \"The child view renders its content once\");\n  ok(view.$().text().match(/Hello world!.*Goodbye cruel world\\!/), \"parent view should appear before the child view\");\n});\n\ntest(\"should accept relative paths to views\", function() {\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('Hey look, at {{view \"view.myCool.view\"}}'),\n\n    myCool: Ember.Object.create({\n      view: Ember.View.extend({\n        template: Ember.Handlebars.compile(\"my cool view\")\n      })\n    })\n  });\n\n  appendView();\n\n  equal(view.$().text(), \"Hey look, at my cool view\");\n});\n\ntest(\"child views can be inserted inside a bind block\", function() {\n  container.register('template:nester', Ember.Handlebars.compile(\"<h1 id='hello-world'>Hello {{world}}</h1>{{view \\\"TemplateTests.BQView\\\"}}\"));\n  container.register('template:nested', Ember.Handlebars.compile(\"<div id='child-view'>Goodbye {{#with content}}{{blah}} {{view \\\"TemplateTests.OtherView\\\"}}{{/with}} {{world}}</div>\"));\n  container.register('template:other', Ember.Handlebars.compile(\"cruel\"));\n\n  var context = {\n    world: \"world!\"\n  };\n\n  TemplateTests.BQView = Ember.View.extend({\n    container: container,\n    tagName: \"blockquote\",\n    templateName: 'nested'\n  });\n\n  TemplateTests.OtherView = Ember.View.extend({\n    container: container,\n    templateName: 'other'\n  });\n\n  view = Ember.View.create({\n    container: container,\n    context: context,\n    templateName: 'nester'\n  });\n\n  Ember.set(context, 'content', Ember.Object.create({ blah: \"wot\" }));\n\n  appendView();\n\n  ok(view.$(\"#hello-world:contains('Hello world!')\").length, \"The parent view renders its contents\");\n\n  ok(view.$(\"blockquote\").text().match(/Goodbye.*wot.*cruel.*world\\!/), \"The child view renders its content once\");\n  ok(view.$().text().match(/Hello world!.*Goodbye.*wot.*cruel.*world\\!/), \"parent view should appear before the child view\");\n});\n\ntest(\"Ember.View should bind properties in the parent context\", function() {\n  var context = {\n    content: Ember.Object.create({\n      wham: 'bam'\n    }),\n\n    blam: \"shazam\"\n  };\n\n  view = Ember.View.create({\n    context: context,\n    template: Ember.Handlebars.compile('<h1 id=\"first\">{{#with content}}{{wham}}-{{../blam}}{{/with}}</h1>')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('#first').text(), \"bam-shazam\", \"renders parent properties\");\n});\n\n\ntest(\"Ember.View should bind properties in the grandparent context\", function() {\n  var context = {\n    content: Ember.Object.create({\n      wham: 'bam',\n      thankYou: Ember.Object.create({\n        value: \"ma'am\"\n      })\n    }),\n\n    blam: \"shazam\"\n  };\n\n  view = Ember.View.create({\n    context: context,\n    template: Ember.Handlebars.compile('<h1 id=\"first\">{{#with content}}{{#with thankYou}}{{value}}-{{../wham}}-{{../../blam}}{{/with}}{{/with}}</h1>')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('#first').text(), \"ma'am-bam-shazam\", \"renders grandparent properties\");\n});\n\ntest(\"Ember.View should update when a property changes and the bind helper is used\", function() {\n  container.register('template:foo', Ember.Handlebars.compile('<h1 id=\"first\">{{#with view.content}}{{bind \"wham\"}}{{/with}}</h1>'));\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'foo',\n\n    content: Ember.Object.create({\n      wham: 'bam',\n      thankYou: \"ma'am\"\n    })\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('#first').text(), \"bam\", \"precond - view renders Handlebars template\");\n\n  Ember.run(function() { set(get(view, 'content'), 'wham', 'bazam'); });\n  equal(view.$('#first').text(), \"bazam\", \"view updates when a bound property changes\");\n});\n\ntest(\"Ember.View should not use keyword incorrectly - Issue #1315\", function() {\n  container.register('template:foo', Ember.Handlebars.compile('{{#each value in view.content}}{{value}}-{{#each option in view.options}}{{option.value}}:{{option.label}} {{/each}}{{/each}}'));\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'foo',\n\n    content: Ember.A(['X', 'Y']),\n    options: Ember.A([\n      { label: 'One', value: 1 },\n      { label: 'Two', value: 2 }\n    ])\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$().text(), 'X-1:One 2:Two Y-1:One 2:Two ');\n});\n\ntest(\"Ember.View should update when a property changes and no bind helper is used\", function() {\n  container.register('template:foo', Ember.Handlebars.compile('<h1 id=\"first\">{{#with view.content}}{{wham}}{{/with}}</h1>'));\n\n  var templates = Ember.Object.create({\n   foo: Ember.Handlebars.compile('<h1 id=\"first\">{{#with view.content}}{{wham}}{{/with}}</h1>')\n  });\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'foo',\n\n    content: Ember.Object.create({\n      wham: 'bam',\n      thankYou: \"ma'am\"\n    })\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('#first').text(), \"bam\", \"precond - view renders Handlebars template\");\n\n  Ember.run(function() { set(get(view, 'content'), 'wham', 'bazam'); });\n\n  equal(view.$('#first').text(), \"bazam\", \"view updates when a bound property changes\");\n});\n\ntest(\"Ember.View should update when the property used with the #with helper changes\", function() {\n  container.register('template:foo', Ember.Handlebars.compile('<h1 id=\"first\">{{#with view.content}}{{wham}}{{/with}}</h1>'));\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'foo',\n\n    content: Ember.Object.create({\n      wham: 'bam',\n      thankYou: \"ma'am\"\n    })\n  });\n\n  appendView();\n\n  equal(view.$('#first').text(), \"bam\", \"precond - view renders Handlebars template\");\n\n  Ember.run(function() {\n    set(view, 'content', Ember.Object.create({\n      wham: 'bazam'\n    }));\n  });\n\n  equal(view.$('#first').text(), \"bazam\", \"view updates when a bound property changes\");\n});\n\ntest(\"should not update when a property is removed from the view\", function() {\n  container.register('template:foo', Ember.Handlebars.compile('<h1 id=\"first\">{{#bind \"view.content\"}}{{#bind \"foo\"}}{{bind \"baz\"}}{{/bind}}{{/bind}}</h1>'));\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'foo',\n\n    content: Ember.Object.create({\n      foo: Ember.Object.create({\n        baz: \"unicorns\"\n      })\n    })\n  });\n\n  appendView();\n\n  equal(view.$('#first').text(), \"unicorns\", \"precond - renders the bound value\");\n\n  var oldContent = get(view, 'content');\n\n  Ember.run(function() {\n    set(view, 'content', Ember.Object.create({\n      foo: Ember.Object.create({\n        baz: \"ninjas\"\n      })\n    }));\n  });\n\n  equal(view.$('#first').text(), 'ninjas', \"updates to new content value\");\n\n  Ember.run(function() {\n    set(oldContent, 'foo.baz', 'rockstars');\n  });\n\n  Ember.run(function() {\n    set(oldContent, 'foo.baz', 'ewoks');\n  });\n\n  equal(view.$('#first').text(), \"ninjas\", \"does not update removed object\");\n});\n\ntest(\"Handlebars templates update properties if a content object changes\", function() {\n  container.register('template:menu', Ember.Handlebars.compile('<h1>Today\\'s Menu</h1>{{#bind \"view.coffee\"}}<h2>{{color}} coffee</h2><span id=\"price\">{{bind \"price\"}}</span>{{/bind}}'));\n\n  Ember.run(function() {\n    view = Ember.View.create({\n      container: container,\n      templateName: 'menu',\n\n      coffee: Ember.Object.create({\n        color: 'brown',\n        price: '$4'\n      })\n    });\n  });\n\n  appendView();\n\n  equal(view.$('h2').text(), \"brown coffee\", \"precond - renders color correctly\");\n  equal(view.$('#price').text(), '$4', \"precond - renders price correctly\");\n\n  Ember.run(function() {\n    set(view, 'coffee', Ember.Object.create({\n      color: \"mauve\",\n      price: \"$4.50\"\n    }));\n  });\n\n  equal(view.$('h2').text(), \"mauve coffee\", \"should update name field when content changes\");\n  equal(view.$('#price').text(), \"$4.50\", \"should update price field when content changes\");\n\n  Ember.run(function() {\n    set(view, 'coffee', Ember.Object.create({\n      color: \"mauve\",\n      price: \"$5.50\"\n    }));\n  });\n\n  equal(view.$('h2').text(), \"mauve coffee\", \"should update name field when content changes\");\n  equal(view.$('#price').text(), \"$5.50\", \"should update price field when content changes\");\n\n  Ember.run(function() {\n    set(view, 'coffee.price', \"$5\");\n  });\n\n  equal(view.$('#price').text(), \"$5\", \"should update price field when price property is changed\");\n\n  Ember.run(function() {\n    view.destroy();\n  });\n});\n\ntest(\"Template updates correctly if a path is passed to the bind helper\", function() {\n  container.register('template:menu', Ember.Handlebars.compile('<h1>{{bind \"view.coffee.price\"}}</h1>'));\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'menu',\n\n    coffee: Ember.Object.create({\n      price: '$4'\n    })\n  });\n\n  appendView();\n\n  equal(view.$('h1').text(), \"$4\", \"precond - renders price\");\n\n  Ember.run(function() {\n    set(view, 'coffee.price', \"$5\");\n  });\n\n  equal(view.$('h1').text(), \"$5\", \"updates when property changes\");\n\n  Ember.run(function() {\n    set(view, 'coffee', { price: \"$6\" });\n  });\n\n  equal(view.$('h1').text(), \"$6\", \"updates when parent property changes\");\n});\n\n// test(\"Template updates correctly if a path is passed to the bind helper and the context object is an Ember.ObjectController\", function() {\n//   var templates;\n\n//   templates = Ember.Object.create({\n//     menu: Ember.Handlebars.compile('<h1>{{bind \"coffee.price\"}}</h1>')\n//   });\n\n//   var controller = Ember.ObjectController.create();\n//   var realObject = Ember.Object.create({\n//     price: \"$4\"\n//   });\n\n//   set(controller, 'content', realObject);\n\n//   var view = Ember.View.create({\n//     templateName: 'menu',\n//     templates: templates,\n\n//     coffee: controller\n//   });\n\n//   view.createElement();\n\n//   equal(view.$('h1').text(), \"$4\", \"precond - renders price\");\n\n//   set(realObject, 'price', \"$5\");\n\n//   equal(view.$('h1').text(), \"$5\", \"updates when property is set on real object\");\n\n//   Ember.run(function() {\n//     set(controller, 'price', \"$6\" );\n//   });\n\n//   equal(view.$('h1').text(), \"$6\", \"updates when property is set on object controller\");\n// });\n\ntest(\"should update the block when object passed to #if helper changes\", function() {\n  container.register('template:menu', Ember.Handlebars.compile('<h1>{{#if view.inception}}{{view.INCEPTION}}{{/if}}</h1>'));\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'menu',\n\n    INCEPTION: \"BOOOOOOOONG doodoodoodoodooodoodoodoo\",\n    inception: 'OOOOoooooOOOOOOooooooo'\n  });\n\n  appendView();\n\n  equal(view.$('h1').text(), \"BOOOOOOOONG doodoodoodoodooodoodoodoo\", \"renders block if a string\");\n\n  var tests = [false, null, undefined, [], '', 0];\n\n  forEach(tests, function(val) {\n    Ember.run(function() {\n      set(view, 'inception', val);\n    });\n\n    equal(view.$('h1').text(), '', Ember.String.fmt(\"hides block when conditional is '%@'\", [String(val)]));\n\n    Ember.run(function() {\n      set(view, 'inception', true);\n    });\n\n    equal(view.$('h1').text(), \"BOOOOOOOONG doodoodoodoodooodoodoodoo\", \"precond - renders block when conditional is true\");\n  });\n});\n\ntest(\"should update the block when object passed to #unless helper changes\", function() {\n  container.register('template:advice', Ember.Handlebars.compile('<h1>{{#unless view.onDrugs}}{{view.doWellInSchool}}{{/unless}}</h1>'));\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'advice',\n\n    onDrugs: true,\n    doWellInSchool: \"Eat your vegetables\"\n  });\n\n  appendView();\n\n  equal(view.$('h1').text(), \"\", \"hides block if true\");\n\n  var tests = [false, null, undefined, [], '', 0];\n\n  forEach(tests, function(val) {\n    Ember.run(function() {\n      set(view, 'onDrugs', val);\n    });\n\n    equal(view.$('h1').text(), 'Eat your vegetables', Ember.String.fmt(\"renders block when conditional is '%@'; %@\", [String(val), Ember.typeOf(val)]));\n\n    Ember.run(function() {\n      set(view, 'onDrugs', true);\n    });\n\n    equal(view.$('h1').text(), \"\", \"precond - hides block when conditional is true\");\n  });\n});\n\ntest(\"should update the block when object passed to #if helper changes and an inverse is supplied\", function() {\n  container.register('template:menu', Ember.Handlebars.compile('<h1>{{#if view.inception}}{{view.INCEPTION}}{{else}}{{view.SAD}}{{/if}}</h1>'));\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'menu',\n\n    INCEPTION: \"BOOOOOOOONG doodoodoodoodooodoodoodoo\",\n    inception: false,\n    SAD: 'BOONG?'\n  });\n\n  appendView();\n\n  equal(view.$('h1').text(), \"BOONG?\", \"renders alternate if false\");\n\n  Ember.run(function() { set(view, 'inception', true); });\n\n  var tests = [false, null, undefined, [], '', 0];\n\n  forEach(tests, function(val) {\n    Ember.run(function() {\n      set(view, 'inception', val);\n    });\n\n    equal(view.$('h1').text(), 'BOONG?', Ember.String.fmt(\"renders alternate if %@\", [String(val)]));\n\n    Ember.run(function() {\n      set(view, 'inception', true);\n    });\n\n    equal(view.$('h1').text(), \"BOOOOOOOONG doodoodoodoodooodoodoodoo\", \"precond - renders block when conditional is true\");\n  });\n});\n\ntest(\"edge case: child conditional should not render children if parent conditional becomes false\", function() {\n  var childCreated = false;\n\n  view = Ember.View.create({\n    cond1: true,\n    cond2: false,\n    viewClass: Ember.View.extend({\n      init: function() {\n        this._super();\n        childCreated = true;\n      }\n    }),\n    template: Ember.Handlebars.compile('{{#if view.cond1}}{{#if view.cond2}}{{#view view.viewClass}}test{{/view}}{{/if}}{{/if}}')\n  });\n\n  appendView();\n\n  Ember.run(function() {\n    // The order of these sets is important for the test\n    view.set('cond2', true);\n    view.set('cond1', false);\n  });\n\n  ok(!childCreated, 'child should not be created');\n});\n\n// test(\"Should insert a localized string if the {{loc}} helper is used\", function() {\n//   Ember.stringsFor('en', {\n//     'Brazil': 'Brasilia'\n//   });\n\n//   templates = Ember.Object.create({\n//     'loc': Ember.Handlebars.compile('<h1>Country: {{loc \"Brazil\"}}')\n//   });\n\n//   var view = Ember.View.create({\n//     templateName: 'loc',\n//     templates: templates,\n\n//     country: 'Brazil'\n//   });\n\n//   view.createElement();\n//   equal(view.$('h1').text(), 'Country: Brasilia', \"returns localized value\");\n// });\n\ntest(\"Template views return throw if their template cannot be found\", function() {\n  view = Ember.View.create({\n    templateName: 'cantBeFound'\n  });\n\n  throws(function() {\n    get(view, 'template');\n  }, /cantBeFound/);\n});\n\ntest(\"Layout views return throw if their layout cannot be found\", function() {\n  view = Ember.View.create({\n    layoutName: 'cantBeFound'\n  });\n\n  throws(function() {\n    get(view, 'layout');\n  }, /cantBeFound/);\n});\n\ntest(\"Template views add an elementId to child views created using the view helper\", function() {\n  container.register('template:parent', Ember.Handlebars.compile('<div>{{view \"TemplateTests.ChildView\"}}</div>'));\n  container.register('template:child', Ember.Handlebars.compile(\"I can't believe it's not butter.\"));\n\n  TemplateTests.ChildView = Ember.View.extend({\n    container: container,\n    templateName: 'child'\n  });\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'parent'\n  });\n\n  appendView();\n  var childView = get(view, 'childViews.firstObject');\n  equal(view.$().children().first().children().first().attr('id'), get(childView, 'elementId'));\n});\n\ntest(\"views set the template of their children to a passed block\", function() {\n  container.register('template:parent', Ember.Handlebars.compile('<h1>{{#view \"TemplateTests.NoTemplateView\"}}<span>It worked!</span>{{/view}}</h1>'));\n\n  TemplateTests.NoTemplateView = Ember.View.extend();\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'parent'\n  });\n\n  appendView();\n  ok(view.$('h1:has(span)').length === 1, \"renders the passed template inside the parent template\");\n});\n\ntest(\"views render their template in the context of the parent view's context\", function() {\n  container.register('template:parent', Ember.Handlebars.compile('<h1>{{#with content}}{{#view}}{{firstName}} {{lastName}}{{/view}}{{/with}}</h1>'));\n\n  var context = {\n    content: {\n      firstName: \"Lana\",\n      lastName: \"del Heeeyyyyyy\"\n    }\n  };\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'parent',\n    context: context\n  });\n\n  appendView();\n  equal(view.$('h1').text(), \"Lana del Heeeyyyyyy\", \"renders properties from parent context\");\n});\n\ntest(\"views make a view keyword available that allows template to reference view context\", function() {\n  container.register('template:parent', Ember.Handlebars.compile('<h1>{{#with view.content}}{{#view subview}}{{view.firstName}} {{lastName}}{{/view}}{{/with}}</h1>'));\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'parent',\n\n    content: {\n      subview: Ember.View.extend({\n        firstName: \"Brodele\"\n      }),\n      firstName: \"Lana\",\n      lastName: \"del Heeeyyyyyy\"\n    }\n  });\n\n  appendView();\n  equal(view.$('h1').text(), \"Brodele del Heeeyyyyyy\", \"renders properties from parent context\");\n});\n\ntest(\"a view helper's bindings are to the parent context\", function(){\n  var Subview = Ember.View.extend({\n    classNameBindings: ['color'],\n    controller: Ember.Object.create({\n      color: 'green',\n      name: \"bar\"\n    }),\n    template: Ember.Handlebars.compile('{{view.someController.name}} {{name}}')\n  });\n  var View = Ember.View.extend({\n    controller: Ember.Object.create({\n      color: \"mauve\",\n      name: 'foo'\n    }),\n    Subview: Subview,\n    template: Ember.Handlebars.compile('<h1>{{view view.Subview colorBinding=\"color\" someControllerBinding=\"this\"}}</h1>')\n  });\n  view = View.create();\n  appendView();\n  equal(view.$('h1 .mauve').length, 1, \"renders property on helper declaration from parent context\");\n  equal(view.$('h1 .mauve').text(), \"foo bar\", \"renders property bound in template from subview context\");\n});\n\ntest(\"should warn if setting a template on a view with a templateName already specified\", function() {\n  view = Ember.View.create({\n    childView: Ember.View.extend({\n      templateName: 'foo'\n    }),\n\n    template: Ember.Handlebars.compile('{{#view childView}}test{{/view}}')\n  });\n\n  raises(function() {\n    appendView();\n  }, Error, \"raises if conflicting template and templateName are provided\");\n\n  Ember.run(function() {\n    view.destroy();\n  });\n\n  view = Ember.View.create({\n    childView: Ember.View.extend(),\n    template: Ember.Handlebars.compile('{{#view childView templateName=\"foo\"}}test{{/view}}')\n  });\n\n  raises(function() {\n    appendView();\n  }, Error, \"raises if conflicting template and templateName are provided via a Handlebars template\");\n});\n\ntest(\"Child views created using the view helper should have their parent view set properly\", function() {\n  TemplateTests = {};\n\n  var template = '{{#view \"Ember.View\"}}{{#view \"Ember.View\"}}{{view \"Ember.View\"}}{{/view}}{{/view}}';\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile(template)\n  });\n\n  appendView();\n\n  var childView = firstGrandchild(view);\n  equal(childView, get(firstChild(childView), 'parentView'), 'parent view is correct');\n});\n\ntest(\"Child views created using the view helper should have their IDs registered for events\", function() {\n  TemplateTests = {};\n\n  var template = '{{view \"Ember.View\"}}{{view \"Ember.View\" id=\"templateViewTest\"}}';\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile(template)\n  });\n\n  appendView();\n\n  var childView = firstChild(view);\n  var id = childView.$()[0].id;\n  equal(Ember.View.views[id], childView, 'childView without passed ID is registered with Ember.View.views so that it can properly receive events from RootResponder');\n\n  childView = nthChild(view, 1);\n  id = childView.$()[0].id;\n  equal(id, 'templateViewTest', 'precond -- id of childView should be set correctly');\n  equal(Ember.View.views[id], childView, 'childView with passed ID is registered with Ember.View.views so that it can properly receive events from RootResponder');\n});\n\ntest(\"Child views created using the view helper and that have a viewName should be registered as properties on their parentView\", function() {\n  TemplateTests = {};\n\n  var template = '{{#view Ember.View}}{{view Ember.View viewName=\"ohai\"}}{{/view}}';\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile(template)\n  });\n\n  appendView();\n\n  var parentView = firstChild(view),\n      childView  = firstGrandchild(view);\n  equal(get(parentView, 'ohai'), childView);\n});\n\ntest(\"Collection views that specify an example view class have their children be of that class\", function() {\n  TemplateTests.ExampleViewCollection = Ember.CollectionView.extend({\n    itemViewClass: Ember.View.extend({\n      isCustom: true\n    }),\n\n    content: Ember.A(['foo'])\n  });\n\n  var parentView = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#collection \"TemplateTests.ExampleViewCollection\"}}OHAI{{/collection}}')\n  });\n\n  Ember.run(function() {\n    parentView.append();\n  });\n\n  ok(firstGrandchild(parentView).isCustom, \"uses the example view class\");\n\n  Ember.run(function() {\n    parentView.destroy();\n  });\n});\n\ntest(\"itemViewClass works in the #collection helper\", function() {\n  TemplateTests.ExampleController = Ember.ArrayProxy.create({\n    content: Ember.A(['alpha'])\n  });\n\n  TemplateTests.ExampleItemView = Ember.View.extend({\n    isAlsoCustom: true\n  });\n\n  var parentView = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#collection contentBinding=\"TemplateTests.ExampleController\" itemViewClass=\"TemplateTests.ExampleItemView\"}}beta{{/collection}}')\n  });\n\n  Ember.run(function() {\n    parentView.append();\n  });\n\n  ok(firstGrandchild(parentView).isAlsoCustom, \"uses the example view class specified in the #collection helper\");\n\n  Ember.run(function() {\n    parentView.destroy();\n  });\n});\n\ntest(\"itemViewClass works in the #collection helper relatively\", function() {\n  TemplateTests.ExampleController = Ember.ArrayProxy.create({\n    content: Ember.A(['alpha'])\n  });\n\n  TemplateTests.ExampleItemView = Ember.View.extend({\n    isAlsoCustom: true\n  });\n\n  TemplateTests.CollectionView = Ember.CollectionView.extend({\n    possibleItemView: TemplateTests.ExampleItemView\n  });\n\n  var parentView = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#collection TemplateTests.CollectionView contentBinding=\"TemplateTests.ExampleController\" itemViewClass=\"possibleItemView\"}}beta{{/collection}}')\n  });\n\n  Ember.run(function() {\n    parentView.append();\n  });\n\n  ok(firstGrandchild(parentView).isAlsoCustom, \"uses the example view class specified in the #collection helper\");\n\n  Ember.run(function() {\n    parentView.destroy();\n  });\n});\n\ntest(\"should update boundIf blocks if the conditional changes\", function() {\n  container.register('template:foo', Ember.Handlebars.compile('<h1 id=\"first\">{{#boundIf \"view.content.myApp.isEnabled\"}}{{view.content.wham}}{{/boundIf}}</h1>'));\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'foo',\n\n    content: Ember.Object.create({\n      wham: 'bam',\n      thankYou: \"ma'am\",\n      myApp: Ember.Object.create({\n        isEnabled: true\n      })\n    })\n  });\n\n  appendView();\n\n  equal(view.$('#first').text(), \"bam\", \"renders block when condition is true\");\n\n  Ember.run(function() {\n    set(get(view, 'content'), 'myApp.isEnabled', false);\n  });\n\n  equal(view.$('#first').text(), \"\", \"re-renders without block when condition is false\");\n\n  Ember.run(function() {\n    set(get(view, 'content'), 'myApp.isEnabled', true);\n  });\n\n  equal(view.$('#first').text(), \"bam\", \"re-renders block when condition changes to true\");\n});\n\ntest(\"should not update boundIf if truthiness does not change\", function() {\n  var renderCount = 0;\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<h1 id=\"first\">{{#boundIf \"view.shouldDisplay\"}}{{view view.InnerViewClass}}{{/boundIf}}</h1>'),\n\n    shouldDisplay: true,\n\n    InnerViewClass: Ember.View.extend({\n      template: Ember.Handlebars.compile(\"bam\"),\n\n      render: function() {\n        renderCount++;\n        return this._super.apply(this, arguments);\n      }\n    })\n  });\n\n  appendView();\n\n  equal(renderCount, 1, \"precond - should have rendered once\");\n  equal(view.$('#first').text(), \"bam\", \"renders block when condition is true\");\n\n  Ember.run(function() {\n    set(view, 'shouldDisplay', 1);\n  });\n\n  equal(renderCount, 1, \"should not have rerendered\");\n  equal(view.$('#first').text(), \"bam\", \"renders block when condition is true\");\n});\n\ntest(\"boundIf should support parent access\", function(){\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile(\n      '<h1 id=\"first\">{{#with view.content}}{{#with thankYou}}'+\n        '{{#boundIf ../view.show}}parent{{/boundIf}}-{{#boundIf ../../view.show}}grandparent{{/boundIf}}'+\n      '{{/with}}{{/with}}</h1>'\n    ),\n\n    content: Ember.Object.create({\n      show: true,\n      thankYou: Ember.Object.create()\n    }),\n\n    show: true\n  });\n\n  appendView();\n\n  equal(view.$('#first').text(), \"parent-grandparent\", \"renders boundIfs using ..\");\n});\n\ntest(\"{{view}} id attribute should set id on layer\", function() {\n  container.register('template:foo', Ember.Handlebars.compile('{{#view \"TemplateTests.IdView\" id=\"bar\"}}baz{{/view}}'));\n\n  TemplateTests.IdView = Ember.View;\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'foo'\n  });\n\n  appendView();\n\n  equal(view.$('#bar').length, 1, \"adds id attribute to layer\");\n  equal(view.$('#bar').text(), 'baz', \"emits content\");\n});\n\ntest(\"{{view}} tag attribute should set tagName of the view\", function() {\n  container.register('template:foo', Ember.Handlebars.compile('{{#view \"TemplateTests.TagView\" tag=\"span\"}}baz{{/view}}'));\n\n  TemplateTests.TagView = Ember.View;\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'foo'\n  });\n\n  appendView();\n\n  equal(view.$('span').length, 1, \"renders with tag name\");\n  equal(view.$('span').text(), 'baz', \"emits content\");\n});\n\ntest(\"{{view}} class attribute should set class on layer\", function() {\n  container.register('template:foo', Ember.Handlebars.compile('{{#view \"TemplateTests.IdView\" class=\"bar\"}}baz{{/view}}'));\n\n  TemplateTests.IdView = Ember.View;\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'foo'\n  });\n\n  appendView();\n\n  equal(view.$('.bar').length, 1, \"adds class attribute to layer\");\n  equal(view.$('.bar').text(), 'baz', \"emits content\");\n});\n\ntest(\"{{view}} should not allow attributeBindings to be set\", function() {\n  raises(function() {\n    view = Ember.View.create({\n      template: Ember.Handlebars.compile('{{view \"Ember.View\" attributeBindings=\"one two\"}}')\n    });\n    appendView();\n  }, /Setting 'attributeBindings' via Handlebars is not allowed/, \"should raise attributeBindings error\");\n});\n\ntest(\"{{view}} should be able to point to a local view\", function() {\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile(\"{{view view.common}}\"),\n\n    common: Ember.View.extend({\n      template: Ember.Handlebars.compile(\"common\")\n    })\n  });\n\n  appendView();\n\n  equal(view.$().text(), \"common\", \"tries to look up view name locally\");\n});\n\ntest(\"{{view}} should evaluate class bindings set to global paths\", function() {\n  var App;\n\n  Ember.run(function() {\n    lookup.App = App = Ember.Application.create({\n      isApp:       true,\n      isGreat:     true,\n      directClass: \"app-direct\",\n      isEnabled:   true\n    });\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{view Ember.TextField class=\"unbound\" classBinding=\"App.isGreat:great App.directClass App.isApp App.isEnabled:enabled:disabled\"}}')\n  });\n\n  appendView();\n\n  ok(view.$('input').hasClass('unbound'),     \"sets unbound classes directly\");\n  ok(view.$('input').hasClass('great'),       \"evaluates classes bound to global paths\");\n  ok(view.$('input').hasClass('app-direct'),  \"evaluates classes bound directly to global paths\");\n  ok(view.$('input').hasClass('is-app'),      \"evaluates classes bound directly to booleans in global paths - dasherizes and sets class when true\");\n  ok(view.$('input').hasClass('enabled'),     \"evaluates ternary operator in classBindings\");\n  ok(!view.$('input').hasClass('disabled'),   \"evaluates ternary operator in classBindings\");\n\n  Ember.run(function() {\n    App.set('isApp', false);\n    App.set('isEnabled', false);\n  });\n\n  ok(!view.$('input').hasClass('is-app'),     \"evaluates classes bound directly to booleans in global paths - removes class when false\");\n  ok(!view.$('input').hasClass('enabled'),    \"evaluates ternary operator in classBindings\");\n  ok(view.$('input').hasClass('disabled'),    \"evaluates ternary operator in classBindings\");\n\n  Ember.run(function() {\n    lookup.App.destroy();\n  });\n});\n\ntest(\"{{view}} should evaluate class bindings set in the current context\", function() {\n  view = Ember.View.create({\n    isView:      true,\n    isEditable:  true,\n    directClass: \"view-direct\",\n    isEnabled: true,\n    template: Ember.Handlebars.compile('{{view Ember.TextField class=\"unbound\" classBinding=\"view.isEditable:editable view.directClass view.isView view.isEnabled:enabled:disabled\"}}')\n  });\n\n  appendView();\n\n  ok(view.$('input').hasClass('unbound'),     \"sets unbound classes directly\");\n  ok(view.$('input').hasClass('editable'),    \"evaluates classes bound in the current context\");\n  ok(view.$('input').hasClass('view-direct'), \"evaluates classes bound directly in the current context\");\n  ok(view.$('input').hasClass('is-view'),     \"evaluates classes bound directly to booleans in the current context - dasherizes and sets class when true\");\n  ok(view.$('input').hasClass('enabled'),     \"evaluates ternary operator in classBindings\");\n  ok(!view.$('input').hasClass('disabled'),   \"evaluates ternary operator in classBindings\");\n\n  Ember.run(function() {\n    view.set('isView', false);\n    view.set('isEnabled', false);\n  });\n\n  ok(!view.$('input').hasClass('is-view'),    \"evaluates classes bound directly to booleans in the current context - removes class when false\");\n  ok(!view.$('input').hasClass('enabled'),    \"evaluates ternary operator in classBindings\");\n  ok(view.$('input').hasClass('disabled'),    \"evaluates ternary operator in classBindings\");\n});\n\ntest(\"{{view}} should evaluate class bindings set with either classBinding or classNameBindings\", function() {\n  var App;\n\n  Ember.run(function() {\n    lookup.App = App = Ember.Application.create({\n      isGreat: true,\n      isEnabled: true\n    });\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{view Ember.TextField class=\"unbound\" classBinding=\"App.isGreat:great App.isEnabled:enabled:disabled\" classNameBindings=\"App.isGreat:really-great App.isEnabled:really-enabled:really-disabled\"}}')\n  });\n\n  appendView();\n\n  ok(view.$('input').hasClass('unbound'),          \"sets unbound classes directly\");\n  ok(view.$('input').hasClass('great'),            \"evaluates classBinding\");\n  ok(view.$('input').hasClass('really-great'),     \"evaluates classNameBinding\");\n  ok(view.$('input').hasClass('enabled'),          \"evaluates ternary operator in classBindings\");\n  ok(view.$('input').hasClass('really-enabled'),   \"evaluates ternary operator in classBindings\");\n  ok(!view.$('input').hasClass('disabled'),        \"evaluates ternary operator in classBindings\");\n  ok(!view.$('input').hasClass('really-disabled'), \"evaluates ternary operator in classBindings\");\n\n  Ember.run(function() {\n    App.set('isEnabled', false);\n  });\n\n  ok(!view.$('input').hasClass('enabled'),        \"evaluates ternary operator in classBindings\");\n  ok(!view.$('input').hasClass('really-enabled'), \"evaluates ternary operator in classBindings\");\n  ok(view.$('input').hasClass('disabled'),        \"evaluates ternary operator in classBindings\");\n  ok(view.$('input').hasClass('really-disabled'), \"evaluates ternary operator in classBindings\");\n\n  Ember.run(function() {\n    lookup.App.destroy();\n  });\n});\n\ntest(\"{{view}} should evaluate other attribute bindings set to global paths\", function() {\n  Ember.run(function() {\n    lookup.App = Ember.Application.create({\n      name: \"myApp\"\n    });\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{view Ember.TextField valueBinding=\"App.name\"}}')\n  });\n\n  appendView();\n\n  equal(view.$('input').attr('value'), \"myApp\", \"evaluates attributes bound to global paths\");\n\n  Ember.run(function() {\n    lookup.App.destroy();\n  });\n});\n\ntest(\"{{view}} should evaluate other attributes bindings set in the current context\", function() {\n  view = Ember.View.create({\n    name: \"myView\",\n    template: Ember.Handlebars.compile('{{view Ember.TextField valueBinding=\"view.name\"}}')\n  });\n\n  appendView();\n\n  equal(view.$('input').attr('value'), \"myView\", \"evaluates attributes bound in the current context\");\n});\n\ntest(\"{{view}} should be able to bind class names to truthy properties\", function() {\n  container.register('template:template', Ember.Handlebars.compile('{{#view \"TemplateTests.classBindingView\" classBinding=\"view.number:is-truthy\"}}foo{{/view}}'));\n\n  TemplateTests.classBindingView = Ember.View.extend();\n\n  view = Ember.View.create({\n    container: container,\n    number: 5,\n    templateName: 'template'\n  });\n\n  appendView();\n\n  equal(view.$('.is-truthy').length, 1, \"sets class name\");\n\n  Ember.run(function() {\n    set(view, 'number', 0);\n  });\n\n  equal(view.$('.is-truthy').length, 0, \"removes class name if bound property is set to falsey\");\n});\n\ntest(\"{{view}} should be able to bind class names to truthy or falsy properties\", function() {\n  container.register('template:template', Ember.Handlebars.compile('{{#view \"TemplateTests.classBindingView\" classBinding=\"view.number:is-truthy:is-falsy\"}}foo{{/view}}'));\n\n  TemplateTests.classBindingView = Ember.View.extend();\n\n  view = Ember.View.create({\n    container: container,\n    number: 5,\n    templateName: 'template'\n  });\n\n  appendView();\n\n  equal(view.$('.is-truthy').length, 1, \"sets class name to truthy value\");\n  equal(view.$('.is-falsy').length, 0, \"doesn't set class name to falsy value\");\n\n  Ember.run(function() {\n    set(view, 'number', 0);\n  });\n\n  equal(view.$('.is-truthy').length, 0, \"doesn't set class name to truthy value\");\n  equal(view.$('.is-falsy').length, 1, \"sets class name to falsy value\");\n});\n\ntest(\"should be able to bind element attributes using {{bindAttr}}\", function() {\n  var template = Ember.Handlebars.compile('<img {{bindAttr src=\"view.content.url\" alt=\"view.content.title\"}}>');\n\n  view = Ember.View.create({\n    template: template,\n    content: Ember.Object.create({\n      url: \"http://www.emberjs.com/assets/images/logo.png\",\n      title: \"The SproutCore Logo\"\n    })\n  });\n\n  appendView();\n\n  equal(view.$('img').attr('src'), \"http://www.emberjs.com/assets/images/logo.png\", \"sets src attribute\");\n  equal(view.$('img').attr('alt'), \"The SproutCore Logo\", \"sets alt attribute\");\n\n  Ember.run(function() {\n    set(view, 'content.title', \"El logo de Eember\");\n  });\n\n  equal(view.$('img').attr('alt'), \"El logo de Eember\", \"updates alt attribute when content's title attribute changes\");\n\n  Ember.run(function() {\n    set(view, 'content', Ember.Object.create({\n      url: \"http://www.thegooglez.com/theydonnothing\",\n      title: \"I CAN HAZ SEARCH\"\n    }));\n  });\n\n  equal(view.$('img').attr('alt'), \"I CAN HAZ SEARCH\", \"updates alt attribute when content object changes\");\n\n  Ember.run(function() {\n    set(view, 'content', {\n      url: \"http://www.emberjs.com/assets/images/logo.png\",\n      title: \"The SproutCore Logo\"\n    });\n  });\n\n  equal(view.$('img').attr('alt'), \"The SproutCore Logo\", \"updates alt attribute when content object is a hash\");\n\n  Ember.run(function() {\n    set(view, 'content', Ember.Object.createWithMixins({\n      url: \"http://www.emberjs.com/assets/images/logo.png\",\n      title: Ember.computed(function() {\n        return \"Nanananana Ember!\";\n      })\n    }));\n  });\n\n  equal(view.$('img').attr('alt'), \"Nanananana Ember!\", \"updates alt attribute when title property is computed\");\n});\n\ntest(\"should be able to bind to view attributes with {{bindAttr}}\", function() {\n  view = Ember.View.create({\n    value: 'Test',\n    template: Ember.Handlebars.compile('<img src=\"test.jpg\" {{bindAttr alt=\"view.value\"}}>')\n  });\n\n  appendView();\n\n  equal(view.$('img').attr('alt'), \"Test\", \"renders initial value\");\n\n  Ember.run(function() {\n    view.set('value', 'Updated');\n  });\n\n  equal(view.$('img').attr('alt'), \"Updated\", \"updates value\");\n});\n\ntest(\"should be able to bind to globals with {{bindAttr}}\", function() {\n  TemplateTests.set('value', 'Test');\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<img src=\"test.jpg\" {{bindAttr alt=\"TemplateTests.value\"}}>')\n  });\n\n  appendView();\n\n  equal(view.$('img').attr('alt'), \"Test\", \"renders initial value\");\n\n  Ember.run(function() {\n    TemplateTests.set('value', 'Updated');\n  });\n\n  equal(view.$('img').attr('alt'), \"Updated\", \"updates value\");\n});\n\ntest(\"should not allow XSS injection via {{bindAttr}}\", function() {\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<img src=\"test.jpg\" {{bindAttr alt=\"view.content.value\"}}>'),\n    content: {\n      value: 'Trololol\" onmouseover=\"alert(\\'HAX!\\');'\n    }\n  });\n\n  appendView();\n\n  equal(view.$('img').attr('onmouseover'), undefined);\n  // If the whole string is here, then it means we got properly escaped\n  equal(view.$('img').attr('alt'), 'Trololol\" onmouseover=\"alert(\\'HAX!\\');');\n});\n\ntest(\"should be able to bind use {{bindAttr}} more than once on an element\", function() {\n  var template = Ember.Handlebars.compile('<img {{bindAttr src=\"view.content.url\"}} {{bindAttr alt=\"view.content.title\"}}>');\n\n  view = Ember.View.create({\n    template: template,\n    content: Ember.Object.create({\n      url: \"http://www.emberjs.com/assets/images/logo.png\",\n      title: \"The SproutCore Logo\"\n    })\n  });\n\n  appendView();\n\n  equal(view.$('img').attr('src'), \"http://www.emberjs.com/assets/images/logo.png\", \"sets src attribute\");\n  equal(view.$('img').attr('alt'), \"The SproutCore Logo\", \"sets alt attribute\");\n\n  Ember.run(function() {\n    set(view, 'content.title', \"El logo de Eember\");\n  });\n\n  equal(view.$('img').attr('alt'), \"El logo de Eember\", \"updates alt attribute when content's title attribute changes\");\n\n  Ember.run(function() {\n    set(view, 'content', Ember.Object.create({\n      url: \"http://www.thegooglez.com/theydonnothing\",\n      title: \"I CAN HAZ SEARCH\"\n    }));\n  });\n\n  equal(view.$('img').attr('alt'), \"I CAN HAZ SEARCH\", \"updates alt attribute when content object changes\");\n\n  Ember.run(function() {\n    set(view, 'content', {\n      url: \"http://www.emberjs.com/assets/images/logo.png\",\n      title: \"The SproutCore Logo\"\n    });\n  });\n\n  equal(view.$('img').attr('alt'), \"The SproutCore Logo\", \"updates alt attribute when content object is a hash\");\n\n  Ember.run(function() {\n    set(view, 'content', Ember.Object.createWithMixins({\n      url: \"http://www.emberjs.com/assets/images/logo.png\",\n      title: Ember.computed(function() {\n        return \"Nanananana Ember!\";\n      })\n    }));\n  });\n\n  equal(view.$('img').attr('alt'), \"Nanananana Ember!\", \"updates alt attribute when title property is computed\");\n\n});\n\ntest(\"should not reset cursor position when text field receives keyUp event\", function() {\n  view = Ember.TextField.create({\n    value: \"Broseidon, King of the Brocean\"\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  view.$().val('Brosiedoon, King of the Brocean');\n  view.$().setCaretPosition(5);\n\n  Ember.run(function() {\n    view.trigger('keyUp', {});\n  });\n\n  equal(view.$().caretPosition(), 5, \"The keyUp event should not result in the cursor being reset due to the bindAttr observers\");\n\n  Ember.run(function() {\n    view.destroy();\n  });\n});\n\ntest(\"should be able to bind element attributes using {{bindAttr}} inside a block\", function() {\n  var template = Ember.Handlebars.compile('{{#with view.content}}<img {{bindAttr src=\"url\" alt=\"title\"}}>{{/with}}');\n\n  view = Ember.View.create({\n    template: template,\n    content: Ember.Object.create({\n      url: \"http://www.emberjs.com/assets/images/logo.png\",\n      title: \"The SproutCore Logo\"\n    })\n  });\n\n  appendView();\n\n  equal(view.$('img').attr('src'), \"http://www.emberjs.com/assets/images/logo.png\", \"sets src attribute\");\n  equal(view.$('img').attr('alt'), \"The SproutCore Logo\", \"sets alt attribute\");\n\n  Ember.run(function() {\n    set(view, 'content.title', \"El logo de Eember\");\n  });\n\n  equal(view.$('img').attr('alt'), \"El logo de Eember\", \"updates alt attribute when content's title attribute changes\");\n});\n\ntest(\"should be able to bind class attribute with {{bindAttr}}\", function() {\n  var template = Ember.Handlebars.compile('<img {{bindAttr class=\"view.foo\"}}>');\n\n  view = Ember.View.create({\n    template: template,\n    foo: 'bar'\n  });\n\n  appendView();\n\n  equal(view.$('img').attr('class'), 'bar', \"renders class\");\n\n  Ember.run(function() {\n    set(view, 'foo', 'baz');\n  });\n\n  equal(view.$('img').attr('class'), 'baz', \"updates class\");\n});\n\ntest(\"should be able to bind class attribute via a truthy property with {{bindAttr}}\", function() {\n  var template = Ember.Handlebars.compile('<img {{bindAttr class=\"view.isNumber:is-truthy\"}}>');\n\n  view = Ember.View.create({\n    template: template,\n    isNumber: 5\n  });\n\n  appendView();\n\n  equal(view.$('.is-truthy').length, 1, \"sets class name\");\n\n  Ember.run(function() {\n    set(view, 'isNumber', 0);\n  });\n\n  equal(view.$('.is-truthy').length, 0, \"removes class name if bound property is set to something non-truthy\");\n});\n\ntest(\"should be able to bind class to view attribute with {{bindAttr}}\", function() {\n  var template = Ember.Handlebars.compile('<img {{bindAttr class=\"view.foo\"}}>');\n\n  view = Ember.View.create({\n    template: template,\n    foo: 'bar'\n  });\n\n  appendView();\n\n  equal(view.$('img').attr('class'), 'bar', \"renders class\");\n\n  Ember.run(function() {\n    set(view, 'foo', 'baz');\n  });\n\n  equal(view.$('img').attr('class'), 'baz', \"updates class\");\n});\n\ntest(\"should not allow XSS injection via {{bindAttr}} with class\", function() {\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<img {{bindAttr class=\"view.foo\"}}>'),\n    foo: '\" onmouseover=\"alert(\\'I am in your classes hacking your app\\');'\n  });\n\n  appendView();\n\n  equal(view.$('img').attr('onmouseover'), undefined);\n  // If the whole string is here, then it means we got properly escaped\n  equal(view.$('img').attr('class'), '\" onmouseover=\"alert(\\'I am in your classes hacking your app\\');');\n});\n\ntest(\"should be able to bind class attribute using ternary operator in {{bindAttr}}\", function() {\n  var template = Ember.Handlebars.compile('<img {{bindAttr class=\"view.content.isDisabled:disabled:enabled\"}} />');\n  var content = Ember.Object.create({\n    isDisabled: true\n  });\n\n  view = Ember.View.create({\n    template: template,\n    content: content\n  });\n\n  appendView();\n\n  ok(view.$('img').hasClass('disabled'), 'disabled class is rendered');\n  ok(!view.$('img').hasClass('enabled'), 'enabled class is not rendered');\n\n  Ember.run(function() {\n    set(content, 'isDisabled', false);\n  });\n\n  ok(!view.$('img').hasClass('disabled'), 'disabled class is not rendered');\n  ok(view.$('img').hasClass('enabled'), 'enabled class is rendered');\n});\n\ntest(\"should be able to add multiple classes using {{bindAttr class}}\", function() {\n  var template = Ember.Handlebars.compile('<div {{bindAttr class=\"view.content.isAwesomeSauce view.content.isAlsoCool view.content.isAmazing:amazing :is-super-duper view.content.isEnabled:enabled:disabled\"}}></div>');\n  var content = Ember.Object.create({\n    isAwesomeSauce: true,\n    isAlsoCool: true,\n    isAmazing: true,\n    isEnabled: true\n  });\n\n  view = Ember.View.create({\n    template: template,\n    content: content\n  });\n\n  appendView();\n\n  ok(view.$('div').hasClass('is-awesome-sauce'), \"dasherizes first property and sets classname\");\n  ok(view.$('div').hasClass('is-also-cool'), \"dasherizes second property and sets classname\");\n  ok(view.$('div').hasClass('amazing'), \"uses alias for third property and sets classname\");\n  ok(view.$('div').hasClass('is-super-duper'), \"static class is present\");\n  ok(view.$('div').hasClass('enabled'), \"truthy class in ternary classname definition is rendered\");\n  ok(!view.$('div').hasClass('disabled'), \"falsy class in ternary classname definition is not rendered\");\n\n  Ember.run(function() {\n    set(content, 'isAwesomeSauce', false);\n    set(content, 'isAmazing', false);\n    set(content, 'isEnabled', false);\n  });\n\n  ok(!view.$('div').hasClass('is-awesome-sauce'), \"removes dasherized class when property is set to false\");\n  ok(!view.$('div').hasClass('amazing'), \"removes aliased class when property is set to false\");\n  ok(view.$('div').hasClass('is-super-duper'), \"static class is still present\");\n  ok(!view.$('div').hasClass('enabled'), \"truthy class in ternary classname definition is not rendered\");\n  ok(view.$('div').hasClass('disabled'), \"falsy class in ternary classname definition is rendered\");\n});\n\ntest(\"should be able to bind classes to globals with {{bindAttr class}}\", function() {\n  TemplateTests.set('isOpen', true);\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<img src=\"test.jpg\" {{bindAttr class=\"TemplateTests.isOpen\"}}>')\n  });\n\n  appendView();\n\n  ok(view.$('img').hasClass('is-open'), \"sets classname to the dasherized value of the global property\");\n\n  Ember.run(function() {\n    TemplateTests.set('isOpen', false);\n  });\n\n  ok(!view.$('img').hasClass('is-open'), \"removes the classname when the global property has changed\");\n});\n\ntest(\"should be able to bindAttr to 'this' in an {{#each}} block\", function() {\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#each view.images}}<img {{bindAttr src=\"this\"}}>{{/each}}'),\n    images: Ember.A(['one.png', 'two.jpg', 'three.gif'])\n  });\n\n  appendView();\n\n  var images = view.$('img');\n  ok(/one\\.png$/.test(images[0].src));\n  ok(/two\\.jpg$/.test(images[1].src));\n  ok(/three\\.gif$/.test(images[2].src));\n});\n\ntest(\"should be able to bind classes to 'this' in an {{#each}} block with {{bindAttr class}}\", function() {\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#each view.items}}<li {{bindAttr class=\"this\"}}>Item</li>{{/each}}'),\n    items: Ember.A(['a', 'b', 'c'])\n  });\n\n  appendView();\n\n  ok(view.$('li').eq(0).hasClass('a'), \"sets classname to the value of the first item\");\n  ok(view.$('li').eq(1).hasClass('b'), \"sets classname to the value of the second item\");\n  ok(view.$('li').eq(2).hasClass('c'), \"sets classname to the value of the third item\");\n});\n\ntest(\"should be able to bindAttr to var in {{#each var in list}} block\", function() {\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#each image in view.images}}<img {{bindAttr src=\"image\"}}>{{/each}}'),\n    images: Ember.A(['one.png', 'two.jpg', 'three.gif'])\n  });\n\n  appendView();\n\n  var images = view.$('img');\n  ok(/one\\.png$/.test(images[0].src));\n  ok(/two\\.jpg$/.test(images[1].src));\n  ok(/three\\.gif$/.test(images[2].src));\n\n  Ember.run(function() {\n    var imagesArray = view.get('images');\n    imagesArray.removeAt(0);\n  });\n\n  images = view.$('img');\n  ok(images.length === 2, \"\");\n  ok(/two\\.jpg$/.test(images[0].src));\n  ok(/three\\.gif$/.test(images[1].src));\n});\n\ntest(\"should be able to output a property without binding\", function(){\n  var context = {\n    content: Ember.Object.create({\n      anUnboundString: \"No spans here, son.\"\n    }),\n\n    anotherUnboundString: \"Not here, either.\"\n  };\n\n  view = Ember.View.create({\n    context: context,\n    template: Ember.Handlebars.compile(\n      '<div id=\"first\">{{unbound content.anUnboundString}}</div>'+\n      '{{#with content}}<div id=\"second\">{{unbound ../anotherUnboundString}}</div>{{/with}}'\n    )\n  });\n\n  appendView();\n\n  equal(view.$('#first').html(), \"No spans here, son.\");\n  equal(view.$('#second').html(), \"Not here, either.\");\n});\n\ntest(\"should allow standard Handlebars template usage\", function() {\n  view = Ember.View.create({\n    context: { name: \"Erik\" },\n    template: Handlebars.compile(\"Hello, {{name}}\")\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$().text(), \"Hello, Erik\");\n});\n\ntest(\"should be able to use standard Handlebars #each helper\", function() {\n  view = Ember.View.create({\n    context: { items: ['a', 'b', 'c'] },\n    template: Handlebars.compile(\"{{#each items}}{{this}}{{/each}}\")\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$().html(), \"abc\");\n});\n\ntest(\"should be able to use unbound helper in #each helper\", function() {\n  view = Ember.View.create({\n    items: Ember.A(['a', 'b', 'c', 1, 2, 3]),\n    template: Ember.Handlebars.compile(\n      \"<ul>{{#each view.items}}<li>{{unbound this}}</li>{{/each}}</ul>\")\n  });\n\n  appendView();\n\n  equal(view.$().text(), \"abc123\");\n  equal(view.$('li').children().length, 0, \"No markers\");\n});\n\ntest(\"should be able to use unbound helper in #each helper (with objects)\", function() {\n  view = Ember.View.create({\n    items: Ember.A([{wham: 'bam'}, {wham: 1}]),\n    template: Ember.Handlebars.compile(\n      \"<ul>{{#each view.items}}<li>{{unbound wham}}</li>{{/each}}</ul>\")\n  });\n\n  appendView();\n\n  equal(view.$().text(), \"bam1\");\n  equal(view.$('li').children().length, 0, \"No markers\");\n});\n\ntest(\"should work with precompiled templates\", function() {\n  var templateString = Ember.Handlebars.precompile(\"{{view.value}}\"),\n      compiledTemplate = Ember.Handlebars.template(eval(templateString));\n  view = Ember.View.create({\n    value: \"rendered\",\n    template: compiledTemplate\n  });\n\n  appendView();\n\n  equal(view.$().text(), \"rendered\", \"the precompiled template was rendered\");\n\n  Ember.run(function() { view.set('value', 'updated'); });\n\n  equal(view.$().text(), \"updated\", \"the precompiled template was updated\");\n});\n\ntest(\"should expose a controller keyword when present on the view\", function() {\n  var templateString = \"{{controller.foo}}{{#view}}{{controller.baz}}{{/view}}\";\n  view = Ember.View.create({\n    controller: Ember.Object.create({\n      foo: \"bar\",\n      baz: \"bang\"\n    }),\n\n    template: Ember.Handlebars.compile(templateString)\n  });\n\n  Ember.run(function() {\n    view.appendTo(\"#qunit-fixture\");\n  });\n\n  equal(view.$().text(), \"barbang\", \"renders values from controller and parent controller\");\n\n  var controller = get(view, 'controller');\n\n  Ember.run(function() {\n    controller.set('foo', \"BAR\");\n    controller.set('baz', \"BLARGH\");\n  });\n\n  equal(view.$().text(), \"BARBLARGH\", \"updates the DOM when a bound value is updated\");\n\n  Ember.run(function() {\n    view.destroy();\n  });\n\n  view = Ember.View.create({\n    controller: \"aString\",\n    template: Ember.Handlebars.compile(\"{{controller}}\")\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$().text(), \"aString\", \"renders the controller itself if no additional path is specified\");\n});\n\ntest(\"should expose a controller keyword that can be used in conditionals\", function() {\n  var templateString = \"{{#view}}{{#if controller}}{{controller.foo}}{{/if}}{{/view}}\";\n  view = Ember.View.create({\n    controller: Ember.Object.create({\n      foo: \"bar\"\n    }),\n\n    template: Ember.Handlebars.compile(templateString)\n  });\n\n  Ember.run(function() {\n    view.appendTo(\"#qunit-fixture\");\n  });\n\n  equal(view.$().text(), \"bar\", \"renders values from controller and parent controller\");\n\n  Ember.run(function() {\n    view.set('controller', null);\n  });\n\n  equal(view.$().text(), \"\", \"updates the DOM when the controller is changed\");\n});\n\ntest(\"should expose a controller keyword that persists through Ember.ContainerView\", function() {\n  var templateString = \"{{view Ember.ContainerView}}\";\n  view = Ember.View.create({\n    controller: Ember.Object.create({\n      foo: \"bar\"\n    }),\n\n    template: Ember.Handlebars.compile(templateString)\n  });\n\n  Ember.run(function() {\n    view.appendTo(\"#qunit-fixture\");\n  });\n\n  var containerView = get(view, 'childViews.firstObject');\n  var viewInstanceToBeInserted = Ember.View.create({\n    template: Ember.Handlebars.compile('{{controller.foo}}')\n  });\n\n  Ember.run(function() {\n    containerView.pushObject(viewInstanceToBeInserted);\n  });\n\n  equal(trim(viewInstanceToBeInserted.$().text()), \"bar\", \"renders value from parent's controller\");\n});\n\ntest(\"should expose a view keyword\", function() {\n  var templateString = '{{#with view.differentContent}}{{view.foo}}{{#view baz=\"bang\"}}{{view.baz}}{{/view}}{{/with}}';\n  view = Ember.View.create({\n    differentContent: {\n      view: {\n        foo: \"WRONG\",\n        baz: \"WRONG\"\n      }\n    },\n\n    foo: \"bar\",\n\n    template: Ember.Handlebars.compile(templateString)\n  });\n\n  Ember.run(function() {\n    view.appendTo(\"#qunit-fixture\");\n  });\n\n  equal(view.$().text(), \"barbang\", \"renders values from view and child view\");\n});\n\ntest(\"Ember.Button targets should respect keywords\", function() {\n  Ember.TESTING_DEPRECATION = true;\n\n  try {\n    var templateString = '{{#with view.anObject}}{{view Ember.Button target=\"controller.foo\"}}{{/with}}';\n    view = Ember.View.create({\n      template: Ember.Handlebars.compile(templateString),\n      anObject: {},\n      controller: {\n        foo: \"bar\"\n      }\n    });\n\n    Ember.run(function() {\n      view.appendTo('#qunit-fixture');\n    });\n\n    var button = view.get('childViews').objectAt(0);\n    equal(button.get('targetObject'), \"bar\", \"resolves the target\");\n  } finally {\n    Ember.TESTING_DEPRECATION = false;\n  }\n});\n\ntest(\"should be able to explicitly set a view's context\", function() {\n  var context = Ember.Object.create({\n    test: 'test'\n  });\n\n  TemplateTests.CustomContextView = Ember.View.extend({\n    context: context,\n    template: Ember.Handlebars.compile(\"{{test}}\")\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile(\"{{view TemplateTests.CustomContextView}}\")\n  });\n\n  appendView();\n\n  equal(view.$().text(), \"test\");\n});\n\nmodule(\"Ember.View - handlebars integration\", {\n  setup: function() {\n    Ember.lookup = lookup = { Ember: Ember };\n\n    originalLog = Ember.Logger.log;\n    logCalls = [];\n    Ember.Logger.log = function(arg) { logCalls.push(arg); };\n  },\n\n  teardown: function() {\n    if (view) {\n      Ember.run(function() {\n        view.destroy();\n      });\n      view = null;\n    }\n\n    Ember.Logger.log = originalLog;\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest(\"should be able to log a property\", function(){\n  var context = {\n    value: 'one',\n    valueTwo: 'two',\n\n    content: Ember.Object.create({})\n  };\n\n  view = Ember.View.create({\n    context: context,\n    template: Ember.Handlebars.compile('{{log value}}{{#with content}}{{log ../valueTwo}}{{/with}}')\n  });\n\n  appendView();\n\n  equal(view.$().text(), \"\", \"shouldn't render any text\");\n  equal(logCalls[0], 'one', \"should call log with value\");\n  equal(logCalls[1], 'two', \"should call log with valueTwo\");\n});\n\ntest(\"should be able to log a view property\", function() {\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{log view.value}}'),\n    value: 'one'\n  });\n\n  appendView();\n\n  equal(view.$().text(), \"\", \"shouldn't render any text\");\n  equal(logCalls[0], 'one', \"should call log with value\");\n});\n\ntest(\"should be able to log `this`\", function() {\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#each view.items}}{{log this}}{{/each}}'),\n    items: Ember.A(['one', 'two'])\n  });\n\n  appendView();\n\n  equal(view.$().text(), \"\", \"shouldn't render any text\");\n  equal(logCalls[0], 'one', \"should call log with item one\");\n  equal(logCalls[1], 'two', \"should call log with item two\");\n});\n\nvar MyApp;\n\nmodule(\"Templates redrawing and bindings\", {\n  setup: function(){\n    Ember.lookup = lookup = { Ember: Ember };\n    MyApp = lookup.MyApp = Ember.Object.create({});\n  },\n  teardown: function(){\n    Ember.run(function() {\n      if (view) view.destroy();\n    });\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest(\"should be able to update when bound property updates\", function(){\n  MyApp.set('controller', Ember.Object.create({name: 'first'}));\n\n  var View = Ember.View.extend({\n    template: Ember.Handlebars.compile('<i>{{view.value.name}}, {{view.computed}}</i>'),\n    valueBinding: 'MyApp.controller',\n    computed: Ember.computed(function(){\n      return this.get('value.name') + ' - computed';\n    }).property('value')\n  });\n\n  Ember.run(function(){\n    view = View.create();\n  });\n\n  appendView();\n\n  Ember.run(function(){\n    MyApp.set('controller', Ember.Object.create({\n      name: 'second'\n    }));\n  });\n\n  equal(view.get('computed'), \"second - computed\", \"view computed properties correctly update\");\n  equal(view.$('i').text(), 'second, second - computed', \"view rerenders when bound properties change\");\n});\n\ntest(\"properties within an if statement should not fail on re-render\", function(){\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#if view.value}}{{view.value}}{{/if}}'),\n    value: null\n  });\n\n  appendView();\n\n  equal(view.$().text(), '');\n\n  Ember.run(function(){\n    view.set('value', 'test');\n  });\n\n  equal(view.$().text(), 'test');\n\n  Ember.run(function(){\n    view.set('value', null);\n  });\n\n  equal(view.$().text(), '');\n});\n\ntest(\"views within an if statement should be sane on re-render\", function(){\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#if view.display}}{{view Ember.TextField}}{{/if}}'),\n    display: false\n  });\n\n  appendView();\n\n  equal(view.$('input').length, 0);\n\n  Ember.run(function(){\n    // Setting twice will trigger the observer twice, this is intentional\n    view.set('display', true);\n    view.set('display', 'yes');\n  });\n\n  var textfield = view.$('input');\n  equal(textfield.length, 1);\n\n  // Make sure the view is still registered in Ember.View.views\n  ok(Ember.View.views[textfield.attr('id')]);\n});\n\ntest(\"the {{this}} helper should not fail on removal\", function(){\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#if view.show}}{{#each view.list}}{{this}}{{/each}}{{/if}}'),\n    show: true,\n    list: Ember.A(['a', 'b', 'c'])\n  });\n\n  appendView();\n\n  equal(view.$().text(), 'abc', \"should start property - precond\");\n\n  Ember.run(function(){\n    view.set('show', false);\n  });\n\n  equal(view.$().text(), '');\n});\n\ntest(\"bindings should be relative to the current context\", function() {\n  view = Ember.View.create({\n    museumOpen: true,\n\n    museumDetails: Ember.Object.create({\n      name: \"SFMoMA\",\n      price: 20\n    }),\n\n    museumView: Ember.View.extend({\n      template: Ember.Handlebars.compile('Name: {{view.name}} Price: ${{view.dollars}}')\n    }),\n\n    template: Ember.Handlebars.compile('{{#if view.museumOpen}} {{view view.museumView nameBinding=\"view.museumDetails.name\" dollarsBinding=\"view.museumDetails.price\"}} {{/if}}')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(Ember.$.trim(view.$().text()), \"Name: SFMoMA Price: $20\", \"should print baz twice\");\n});\n\ntest(\"bindings should respect keywords\", function() {\n  view = Ember.View.create({\n    museumOpen: true,\n\n    controller: {\n      museumOpen: true,\n      museumDetails: Ember.Object.create({\n        name: \"SFMoMA\",\n        price: 20\n      })\n    },\n\n    museumView: Ember.View.extend({\n      template: Ember.Handlebars.compile('Name: {{view.name}} Price: ${{view.dollars}}')\n    }),\n\n    template: Ember.Handlebars.compile('{{#if view.museumOpen}}{{view view.museumView nameBinding=\"controller.museumDetails.name\" dollarsBinding=\"controller.museumDetails.price\"}}{{/if}}')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(Ember.$.trim(view.$().text()), \"Name: SFMoMA Price: $20\", \"should print baz twice\");\n});\n\ntest(\"bindings can be 'this', in which case they *are* the current context\", function() {\n  view = Ember.View.create({\n    museumOpen: true,\n\n    museumDetails: Ember.Object.create({\n      name: \"SFMoMA\",\n      price: 20,\n      museumView: Ember.View.extend({\n        template: Ember.Handlebars.compile('Name: {{view.museum.name}} Price: ${{view.museum.price}}')\n      })\n    }),\n\n\n    template: Ember.Handlebars.compile('{{#if view.museumOpen}} {{#with view.museumDetails}}{{view museumView museumBinding=\"this\"}} {{/with}}{{/if}}')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(Ember.$.trim(view.$().text()), \"Name: SFMoMA Price: $20\", \"should print baz twice\");\n});\n\n// https://github.com/emberjs/ember.js/issues/120\n\ntest(\"should not enter an infinite loop when binding an attribute in Handlebars\", function() {\n  expect(0);\n\n  var App;\n\n  Ember.run(function() {\n    lookup.App = App = Ember.Application.create();\n  });\n\n  App.test = Ember.Object.create({ href: 'test' });\n  App.Link = Ember.View.extend({\n    classNames: ['app-link'],\n    tagName: 'a',\n    attributeBindings: ['href'],\n    href: '#none',\n\n    click: function() {\n      return false;\n    }\n  });\n\n  var parentView = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#view App.Link hrefBinding=\"App.test.href\"}} Test {{/view}}')\n  });\n\n\n  Ember.run(function() {\n    parentView.appendTo('#qunit-fixture');\n    // App.Link.create().appendTo('#qunit-fixture');\n  });\n  // equal(view.$().attr('href'), 'test');\n\n  Ember.run(function() {\n    parentView.destroy();\n  });\n\n  Ember.run(function() {\n    lookup.App.destroy();\n  });\n});\n\ntest(\"should update bound values after the view is removed and then re-appended\", function() {\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile(\"{{#if view.showStuff}}{{view.boundValue}}{{else}}Not true.{{/if}}\"),\n    showStuff: true,\n    boundValue: \"foo\"\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(Ember.$.trim(view.$().text()), \"foo\");\n  Ember.run(function() {\n    set(view, 'showStuff', false);\n  });\n  equal(Ember.$.trim(view.$().text()), \"Not true.\");\n\n  Ember.run(function() {\n    set(view, 'showStuff', true);\n  });\n  equal(Ember.$.trim(view.$().text()), \"foo\");\n\n  Ember.run(function() {\n    view.remove();\n    set(view, 'showStuff', false);\n  });\n  Ember.run(function() {\n    set(view, 'showStuff', true);\n  });\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  Ember.run(function() {\n    set(view, 'boundValue', \"bar\");\n  });\n  equal(Ember.$.trim(view.$().text()), \"bar\");\n});\n\ntest(\"should update bound values after view's parent is removed and then re-appended\", function() {\n  var controller = Ember.Object.create();\n\n  var parentView = Ember.ContainerView.create({\n    childViews: ['testView'],\n\n    controller: controller,\n\n    testView: Ember.View.create({\n      template: Ember.Handlebars.compile(\"{{#if showStuff}}{{boundValue}}{{else}}Not true.{{/if}}\")\n    })\n  });\n\n  controller.setProperties({\n    showStuff: true,\n    boundValue: \"foo\"\n  });\n\n  Ember.run(function() {\n    parentView.appendTo('#qunit-fixture');\n  });\n  view = parentView.get('testView');\n\n  equal(Ember.$.trim(view.$().text()), \"foo\");\n  Ember.run(function() {\n    set(controller, 'showStuff', false);\n  });\n  equal(Ember.$.trim(view.$().text()), \"Not true.\");\n\n  Ember.run(function() {\n    set(controller, 'showStuff', true);\n  });\n  equal(Ember.$.trim(view.$().text()), \"foo\");\n\n\n  Ember.run(function() {\n    parentView.remove();\n    set(controller, 'showStuff', false);\n  });\n  Ember.run(function() {\n    set(controller, 'showStuff', true);\n  });\n  Ember.run(function() {\n    parentView.appendTo('#qunit-fixture');\n  });\n\n  Ember.run(function() {\n    set(controller, 'boundValue', \"bar\");\n  });\n  equal(Ember.$.trim(view.$().text()), \"bar\");\n\n  Ember.run(function() {\n    parentView.destroy();\n  });\n});\n\ntest(\"should call a registered helper for mustache without parameters\", function() {\n  Ember.Handlebars.registerHelper('foobar', function() {\n    return 'foobar';\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile(\"{{foobar}}\")\n  });\n\n  appendView();\n\n  ok(view.$().text() === 'foobar', \"Regular helper was invoked correctly\");\n});\n\ntest(\"should bind to the property if no registered helper found for a mustache without parameters\", function() {\n  view = Ember.View.createWithMixins({\n    template: Ember.Handlebars.compile(\"{{view.foobarProperty}}\"),\n    foobarProperty: Ember.computed(function() {\n      return 'foobarProperty';\n    })\n  });\n\n  appendView();\n\n  ok(view.$().text() === 'foobarProperty', \"Property was bound to correctly\");\n});\n\ntest(\"should accept bindings as a string or an Ember.Binding\", function() {\n  var viewClass = Ember.View.extend({\n    template: Ember.Handlebars.compile(\"binding: {{view.bindingTest}}, string: {{view.stringTest}}\")\n  });\n\n  Ember.Handlebars.registerHelper('boogie', function(id, options) {\n    options.hash = options.hash || {};\n    options.hash.bindingTestBinding = Ember.Binding.oneWay('context.' + id);\n    options.hash.stringTestBinding = id;\n    return Ember.Handlebars.ViewHelper.helper(this, viewClass, options);\n  });\n\n  view = Ember.View.create({\n    context: Ember.Object.create({\n      direction: 'down'\n    }),\n    template: Ember.Handlebars.compile(\"{{boogie direction}}\")\n  });\n\n  appendView();\n\n  equal(Ember.$.trim(view.$().text()), \"binding: down, string: down\");\n});\n\ntest(\"should teardown observers from bound properties on rerender\", function() {\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile(\"{{view.foo}}\"),\n    foo: 'bar'\n  });\n\n  appendView();\n\n  equal(Ember.observersFor(view, 'foo').length, 1);\n\n  Ember.run(function() {\n    view.rerender();\n  });\n\n  equal(Ember.observersFor(view, 'foo').length, 1);\n});\n\ntest(\"should teardown observers from bindAttr on rerender\", function() {\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<span {{bindAttr class=\"view.foo\" name=\"view.foo\"}}>wat</span>'),\n    foo: 'bar'\n  });\n\n  appendView();\n\n  equal(Ember.observersFor(view, 'foo').length, 2);\n\n  Ember.run(function() {\n    view.rerender();\n  });\n\n  equal(Ember.observersFor(view, 'foo').length, 2);\n});\n\n})();\n//@ sourceURL=ember-handlebars/~tests/handlebars_test");minispade.register('ember-handlebars/~tests/helpers/bound_helper_test', "(function() {/*globals TemplateTests*/\n\nvar get = Ember.get, set = Ember.set;\n\nvar view;\n\nvar appendView = function() {\n  Ember.run(function() { view.appendTo('#qunit-fixture'); });\n};\n\nvar registerRepeatHelper = function() {\n  Ember.Handlebars.helper('repeat', function(value, options) {\n    var count = options.hash.count;\n    var a = [];\n    while(a.length < count){\n        a.push(value);\n    }\n    return a.join('');\n  });\n};\n\nmodule(\"Handlebars bound helpers\", {\n  setup: function() {\n    window.TemplateTests = Ember.Namespace.create();\n  },\n  teardown: function() {\n    Ember.run(function(){\n      if (view) {\n        view.destroy();\n      }\n    });\n    window.TemplateTests = undefined;\n  }\n});\n\ntest(\"should update bound helpers when properties change\", function() {\n  Ember.Handlebars.helper('capitalize', function(value) {\n    return value.toUpperCase();\n  });\n\n  view = Ember.View.create({\n    controller: Ember.Object.create({name: \"Brogrammer\"}),\n    template: Ember.Handlebars.compile(\"{{capitalize name}}\")\n  });\n\n  appendView();\n\n  equal(view.$().text(), 'BROGRAMMER', \"helper output is correct\");\n\n  Ember.run(function() {\n    set(view.controller, 'name', 'wes');\n  });\n\n  equal(view.$().text(), 'WES', \"helper output updated\");\n});\n\ntest(\"should allow for computed properties with dependencies\", function() {\n  Ember.Handlebars.helper('capitalizeName', function(value) {\n    return get(value, 'name').toUpperCase();\n  }, 'name');\n\n  view = Ember.View.create({\n    controller: Ember.Object.create({\n      person: Ember.Object.create({\n        name: 'Brogrammer'\n      })\n    }),\n    template: Ember.Handlebars.compile(\"{{capitalizeName person}}\")\n  });\n\n  appendView();\n\n  equal(view.$().text(), 'BROGRAMMER', \"helper output is correct\");\n\n  Ember.run(function() {\n    set(view.controller.person, 'name', 'wes');\n  });\n\n  equal(view.$().text(), 'WES', \"helper output updated\");\n});\n\ntest(\"bound helpers should support options\", function() {\n\n  registerRepeatHelper();\n\n  view = Ember.View.create({\n    controller: Ember.Object.create({text: 'ab'}),\n    template: Ember.Handlebars.compile(\"{{repeat text count=3}}\")\n  });\n\n  appendView();\n\n  ok(view.$().text() === 'ababab', \"helper output is correct\");\n});\n\ntest(\"bound helpers should support keywords\", function() {\n  Ember.Handlebars.helper('capitalize', function(value) {\n    return value.toUpperCase();\n  });\n\n  view = Ember.View.create({\n    text: 'ab',\n    template: Ember.Handlebars.compile(\"{{capitalize view.text}}\")\n  });\n\n  appendView();\n\n  ok(view.$().text() === 'AB', \"helper output is correct\");\n});\n\ntest(\"bound helpers should support global paths\", function() {\n  Ember.Handlebars.helper('capitalize', function(value) {\n    return value.toUpperCase();\n  });\n\n  TemplateTests.text = 'ab';\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile(\"{{capitalize TemplateTests.text}}\")\n  });\n\n  appendView();\n\n  ok(view.$().text() === 'AB', \"helper output is correct\");\n});\n\ntest(\"bound helper should support this keyword\", function() {\n  Ember.Handlebars.helper('capitalize', function(value) {\n    return get(value, 'text').toUpperCase();\n  });\n\n  view = Ember.View.create({\n    controller: Ember.Object.create({text: 'ab'}),\n    template: Ember.Handlebars.compile(\"{{capitalize this}}\")\n  });\n\n  appendView();\n\n  ok(view.$().text() === 'AB', \"helper output is correct\");\n});\n\ntest(\"bound helpers should support bound options\", function() {\n\n  registerRepeatHelper();\n\n  view = Ember.View.create({\n    controller: Ember.Object.create({text: 'ab', numRepeats: 3}),\n    template: Ember.Handlebars.compile('{{repeat text countBinding=\"numRepeats\"}}')\n  });\n\n  appendView();\n\n  equal(view.$().text(), 'ababab', \"helper output is correct\");\n\n  Ember.run(function() {\n    view.set('controller.numRepeats', 4);\n  });\n\n  equal(view.$().text(), 'abababab', \"helper correctly re-rendered after bound option was changed\");\n\n  Ember.run(function() {\n    view.set('controller.numRepeats', 2);\n    view.set('controller.text', \"YES\");\n  });\n\n  equal(view.$().text(), 'YESYES', \"helper correctly re-rendered after both bound option and property changed\");\n});\n\n\ntest(\"bound helpers should support multiple bound properties\", function() {\n\n  Ember.Handlebars.helper('concat', function() {\n    return [].slice.call(arguments, 0, -1).join('');\n  });\n\n  view = Ember.View.create({\n    controller: Ember.Object.create({thing1: 'ZOID', thing2: 'BERG'}),\n    template: Ember.Handlebars.compile('{{concat thing1 thing2}}')\n  });\n\n  appendView();\n\n  equal(view.$().text(), 'ZOIDBERG', \"helper output is correct\");\n\n  Ember.run(function() {\n    view.set('controller.thing2', \"NERD\");\n  });\n\n  equal(view.$().text(), 'ZOIDNERD', \"helper correctly re-rendered after second bound helper property changed\");\n\n  Ember.run(function() {\n    view.controller.setProperties({\n      thing1: \"WOOT\",\n      thing2: \"YEAH\"\n    });\n  });\n\n  equal(view.$().text(), 'WOOTYEAH', \"helper correctly re-rendered after both bound helper properties changed\");\n});\n\ntest(\"bound helpers should expose property names in options.data.properties\", function() {\n  Ember.Handlebars.helper('echo', function() {\n    var options = arguments[arguments.length - 1];\n    var values = [].slice.call(arguments, 0, -1);\n    var a = [];\n    for(var i = 0; i < values.length; ++i) {\n      var propertyName = options.data.properties[i];\n      a.push(propertyName);\n    }\n    return a.join(' ');\n  });\n\n  view = Ember.View.create({\n    controller: Ember.Object.create({\n      thing1: 'ZOID',\n      thing2: 'BERG',\n      thing3: Ember.Object.create({\n        foo: 123\n      })\n    }),\n    template: Ember.Handlebars.compile('{{echo thing1 thing2 thing3.foo}}')\n  });\n\n  appendView();\n\n  equal(view.$().text(), 'thing1 thing2 thing3.foo', \"helper output is correct\");\n});\n\ntest(\"bound helpers can be invoked with zero args\", function() {\n  Ember.Handlebars.helper('troll', function(options) {\n    return options.hash.text || \"TROLOLOL\";\n  });\n\n  view = Ember.View.create({\n    controller: Ember.Object.create({trollText: \"yumad\"}),\n    template: Ember.Handlebars.compile('{{troll}} and {{troll text=\"bork\"}}')\n  });\n\n  appendView();\n\n  equal(view.$().text(), 'TROLOLOL and bork', \"helper output is correct\");\n});\n\n\n})();\n//@ sourceURL=ember-handlebars/~tests/helpers/bound_helper_test");minispade.register('ember-handlebars/~tests/helpers/each_test', "(function() {var get = Ember.get, set = Ember.set;\nvar people, view;\nvar template, templateMyView;\nvar templateFor = function(template) {\n  return Ember.Handlebars.compile(template);\n};\n\nvar originalLookup = Ember.lookup, lookup;\n\nmodule(\"the #each helper\", {\n  setup: function() {\n    Ember.lookup = lookup = { Ember: Ember };\n\n    template = templateFor(\"{{#each view.people}}{{name}}{{/each}}\");\n    people = Ember.A([{ name: \"Steve Holt\" }, { name: \"Annabelle\" }]);\n\n    view = Ember.View.create({\n      template: template,\n      people: people\n    });\n\n\n    templateMyView = templateFor(\"{{name}}\");\n    lookup.MyView = Ember.View.extend({\n        template: templateMyView\n    });\n\n    append(view);\n  },\n\n  teardown: function() {\n    Ember.run(function(){\n      view.destroy();\n      view = null;\n    });\n    Ember.lookup = originalLookup;\n  }\n});\n\n\nvar append = function(view) {\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n};\n\nvar assertHTML = function(view, expectedHTML) {\n  var html = view.$().html();\n\n  // IE 8 (and prior?) adds the \\r\\n\n  html = html.replace(/<script[^>]*><\\/script>/ig, '').replace(/[\\r\\n]/g, '');\n\n  equal(html, expectedHTML);\n};\n\nvar assertText = function(view, expectedText) {\n  equal(view.$().text(), expectedText);\n};\n\ntest(\"it renders the template for each item in an array\", function() {\n  assertHTML(view, \"Steve HoltAnnabelle\");\n});\n\ntest(\"it updates the view if an item is added\", function() {\n  Ember.run(function() {\n    people.pushObject({ name: \"Tom Dale\" });\n  });\n\n  assertHTML(view, \"Steve HoltAnnabelleTom Dale\");\n});\n\ntest(\"it allows you to access the current context using {{this}}\", function() {\n  Ember.run(function() { view.destroy(); }); // destroy existing view\n  view = Ember.View.create({\n    template: templateFor(\"{{#each view.people}}{{this}}{{/each}}\"),\n    people: Ember.A(['Black Francis', 'Joey Santiago', 'Kim Deal', 'David Lovering'])\n  });\n\n  append(view);\n\n  assertHTML(view, \"Black FrancisJoey SantiagoKim DealDavid Lovering\");\n});\n\ntest(\"it updates the view if an item is removed\", function() {\n  Ember.run(function() {\n    people.removeAt(0);\n  });\n\n  assertHTML(view, \"Annabelle\");\n});\n\ntest(\"it updates the view if an item is replaced\", function() {\n  Ember.run(function() {\n    people.removeAt(0);\n    people.insertAt(0, { name: \"Kazuki\" });\n  });\n\n  assertHTML(view, \"KazukiAnnabelle\");\n});\n\ntest(\"can add and replace in the same runloop\", function() {\n  Ember.run(function() {\n    people.pushObject({ name: \"Tom Dale\" });\n    people.removeAt(0);\n    people.insertAt(0, { name: \"Kazuki\" });\n  });\n\n  assertHTML(view, \"KazukiAnnabelleTom Dale\");\n});\n\ntest(\"can add and replace the object before the add in the same runloop\", function() {\n  Ember.run(function() {\n    people.pushObject({ name: \"Tom Dale\" });\n    people.removeAt(1);\n    people.insertAt(1, { name: \"Kazuki\" });\n  });\n\n  assertHTML(view, \"Steve HoltKazukiTom Dale\");\n});\n\ntest(\"can add and replace complicatedly\", function() {\n  Ember.run(function() {\n    people.pushObject({ name: \"Tom Dale\" });\n    people.removeAt(1);\n    people.insertAt(1, { name: \"Kazuki\" });\n    people.pushObject({ name: \"Firestone\" });\n    people.pushObject({ name: \"McMunch\" });\n    people.removeAt(3);\n  });\n\n  assertHTML(view, \"Steve HoltKazukiTom DaleMcMunch\");\n});\n\ntest(\"can add and replace complicatedly harder\", function() {\n  Ember.run(function() {\n    people.pushObject({ name: \"Tom Dale\" });\n    people.removeAt(1);\n    people.insertAt(1, { name: \"Kazuki\" });\n    people.pushObject({ name: \"Firestone\" });\n    people.pushObject({ name: \"McMunch\" });\n    people.removeAt(2);\n  });\n\n  assertHTML(view, \"Steve HoltKazukiFirestoneMcMunch\");\n});\n\ntest(\"it works inside a ul element\", function() {\n  var ulView = Ember.View.create({\n    template: templateFor('<ul>{{#each view.people}}<li>{{name}}</li>{{/each}}</ul>'),\n    people: people\n  });\n\n  append(ulView);\n\n  equal(ulView.$('li').length, 2, \"renders two <li> elements\");\n\n  Ember.run(function() {\n    people.pushObject({name: \"Black Francis\"});\n  });\n\n  equal(ulView.$('li').length, 3, \"renders an additional <li> element when an object is added\");\n\n  Ember.run(function() {\n    ulView.destroy();\n  });\n});\n\ntest(\"it works inside a table element\", function() {\n  var tableView = Ember.View.create({\n    template: templateFor('<table><tbody>{{#each view.people}}<tr><td>{{name}}</td></tr>{{/each}}</tbody></table>'),\n    people: people\n  });\n\n  append(tableView);\n\n  equal(tableView.$('td').length, 2, \"renders two <td> elements\");\n\n  Ember.run(function() {\n    people.pushObject({name: \"Black Francis\"});\n  });\n\n  equal(tableView.$('td').length, 3, \"renders an additional <td> element when an object is added\");\n\n  Ember.run(function() {\n    people.insertAt(0, {name: \"Kim Deal\"});\n  });\n\n  equal(tableView.$('td').length, 4, \"renders an additional <td> when an object is inserted at the beginning of the array\");\n\n  Ember.run(function() {\n    tableView.destroy();\n  });\n});\n\ntest(\"it supports itemController\", function() {\n  var Controller = Ember.Controller.extend({\n    controllerName: Ember.computed(function() {\n      return \"controller:\"+this.get('content.name');\n    })\n  });\n\n  var container = new Ember.Container();\n\n  Ember.run(function() { view.destroy(); }); // destroy existing view\n\n  var parentController = {\n    container: container\n  };\n\n  view = Ember.View.create({\n    template: templateFor('{{#each view.people itemController=\"person\"}}{{controllerName}}{{/each}}'),\n    people: people,\n    controller: parentController\n  });\n\n  container.register('controller:person', Controller);\n\n  append(view);\n\n  equal(view.$().text(), \"controller:Steve Holtcontroller:Annabelle\");\n\n  Ember.run(function() {\n    view.rerender();\n  });\n\n  assertText(view, \"controller:Steve Holtcontroller:Annabelle\");\n\n  Ember.run(function() {\n    people.pushObject({ name: \"Yehuda Katz\" });\n  });\n\n  assertText(view, \"controller:Steve Holtcontroller:Annabellecontroller:Yehuda Katz\");\n\n  Ember.run(function() {\n    set(view, 'people', Ember.A([{ name: \"Trek Glowacki\" }, { name: \"Geoffrey Grosenbach\" }]));\n  });\n\n  assertText(view, \"controller:Trek Glowackicontroller:Geoffrey Grosenbach\");\n\n  var controller = view.get('_childViews')[0].get('controller');\n  strictEqual(view.get('_childViews')[0].get('_arrayController.target'), parentController, \"the target property of the child controllers are set correctly\");\n});\n\ntest(\"it supports itemController when using a custom keyword\", function() {\n  var Controller = Ember.Controller.extend({\n    controllerName: Ember.computed(function() {\n      return \"controller:\"+this.get('content.name');\n    })\n  });\n\n  var container = new Ember.Container();\n\n  Ember.run(function() { view.destroy(); }); // destroy existing view\n  view = Ember.View.create({\n    template: templateFor('{{#each person in view.people itemController=\"person\"}}{{person.controllerName}}{{/each}}'),\n    people: people,\n    controller: {\n      container: container\n    }\n  });\n\n  container.register('controller:person', Controller);\n\n  append(view);\n\n  equal(view.$().text(), \"controller:Steve Holtcontroller:Annabelle\");\n\n  Ember.run(function() {\n    view.rerender();\n  });\n\n  equal(view.$().text(), \"controller:Steve Holtcontroller:Annabelle\");\n});\n\ntest(\"it supports {{itemViewClass=}}\", function() {\n  Ember.run(function() { view.destroy(); }); // destroy existing view\n  view = Ember.View.create({\n    template: templateFor('{{each view.people itemViewClass=\"MyView\"}}'),\n    people: people\n  });\n\n  append(view);\n\n  assertText(view, \"Steve HoltAnnabelle\");\n\n});\n\ntest(\"it supports {{itemViewClass=}} with tagName\", function() {\n  Ember.TESTING_DEPRECATION = true;\n\n  try {\n    Ember.run(function() { view.destroy(); }); // destroy existing view\n    view = Ember.View.create({\n        template: templateFor('{{each view.people itemViewClass=\"MyView\" tagName=\"ul\"}}'),\n        people: people\n    });\n\n    append(view);\n\n    var html = view.$().html();\n\n    // IE 8 (and prior?) adds the \\r\\n\n    html = html.replace(/<script[^>]*><\\/script>/ig, '').replace(/[\\r\\n]/g, '');\n    html = html.replace(/<div[^>]*><\\/div>/ig, '').replace(/[\\r\\n]/g, '');\n    html = html.replace(/<li[^>]*/ig, '<li');\n\n    // Use lowercase since IE 8 make tagnames uppercase\n    equal(html.toLowerCase(), \"<ul><li>steve holt</li><li>annabelle</li></ul>\");\n  } finally {\n    Ember.TESTING_DEPRECATION = false;\n  }\n});\n\ntest(\"it supports {{itemViewClass=}} with in format\", function() {\n\n  lookup.MyView = Ember.View.extend({\n      template: templateFor(\"{{person.name}}\")\n  });\n\n  Ember.run(function() { view.destroy(); }); // destroy existing view\n  view = Ember.View.create({\n    template: templateFor('{{each person in view.people itemViewClass=\"MyView\"}}'),\n    people: people\n  });\n\n  append(view);\n\n  assertText(view, \"Steve HoltAnnabelle\");\n\n});\n\ntest(\"it supports {{else}}\", function() {\n  Ember.run(function() { view.destroy(); }); // destroy existing view\n  view = Ember.View.create({\n    template: templateFor(\"{{#each view.items}}{{this}}{{else}}Nothing{{/each}}\"),\n    items: Ember.A(['one', 'two'])\n  });\n\n  append(view);\n\n  assertHTML(view, \"onetwo\");\n\n  stop();\n\n  // We really need to make sure we get to the re-render\n  Ember.run.next(function() {\n    Ember.run(function() {\n      view.set('items', Ember.A([]));\n    });\n\n    start();\n\n    assertHTML(view, \"Nothing\");\n  });\n});\n\ntest(\"it works with the controller keyword\", function() {\n  var controller = Ember.ArrayController.create({\n    content: Ember.A([\"foo\", \"bar\", \"baz\"])\n  });\n\n  Ember.run(function() { view.destroy(); }); // destroy existing view\n  view = Ember.View.create({\n    controller: controller,\n    template: templateFor(\"{{#view}}{{#each controller}}{{this}}{{/each}}{{/view}}\")\n  });\n\n  append(view);\n\n  equal(view.$().text(), \"foobarbaz\");\n});\n\nmodule(\"{{#each foo in bar}}\", {\n  teardown: function() {\n    Ember.run(function() {\n      view.destroy();\n    });\n  }\n});\n\ntest(\"#each accepts a name binding\", function() {\n  view = Ember.View.create({\n    template: templateFor(\"{{#each item in view.items}}{{view.title}} {{item}}{{/each}}\"),\n    title: \"My Cool Each Test\",\n    items: Ember.A([1, 2])\n  });\n\n  append(view);\n\n  equal(view.$().text(), \"My Cool Each Test 1My Cool Each Test 2\");\n});\n\ntest(\"#each accepts a name binding and does not change the context\", function() {\n  var controller = Ember.Controller.create({\n    name: 'bob the controller'\n  }),\n  obj = Ember.Object.create({\n    name: 'henry the item'\n  });\n\n  view = Ember.View.create({\n    template: templateFor(\"{{#each item in view.items}}{{name}}{{/each}}\"),\n    title: \"My Cool Each Test\",\n    items: Ember.A([obj]),\n    controller: controller\n  });\n\n  append(view);\n\n  equal(view.$().text(), \"bob the controller\");\n});\n\n\ntest(\"#each accepts a name binding and can display child properties\", function() {\n  view = Ember.View.create({\n    template: templateFor(\"{{#each item in view.items}}{{view.title}} {{item.name}}{{/each}}\"),\n    title: \"My Cool Each Test\",\n    items: Ember.A([{ name: 1 }, { name: 2 }])\n  });\n\n  append(view);\n\n  equal(view.$().text(), \"My Cool Each Test 1My Cool Each Test 2\");\n});\n\ntest(\"#each accepts 'this' as the right hand side\", function() {\n  view = Ember.View.create({\n    template: templateFor(\"{{#each item in this}}{{view.title}} {{item.name}}{{/each}}\"),\n    title: \"My Cool Each Test\",\n    controller: Ember.A([{ name: 1 }, { name: 2 }])\n  });\n\n  append(view);\n\n  equal(view.$().text(), \"My Cool Each Test 1My Cool Each Test 2\");\n});\ntest(\"#each accepts 'this' as the right hand side\", function() {\n  view = Ember.View.create({\n    template: templateFor(\"{{#each item in this}}{{view.title}} {{item.name}}{{/each}}\"),\n    title: \"My Cool Each Test\",\n    controller: Ember.A([{ name: 1 }, { name: 2 }])\n  });\n\n  append(view);\n\n  equal(view.$().text(), \"My Cool Each Test 1My Cool Each Test 2\");\n});\n\ntest(\"views inside #each preserve the new context\", function() {\n  var controller = Ember.A([ { name: \"Adam\" }, { name: \"Steve\" } ]);\n\n  view = Ember.View.create({\n    controller: controller,\n    template: templateFor('{{#each controller}}{{#view}}{{name}}{{/view}}{{/each}}')\n  });\n\n  append(view);\n\n  equal(view.$().text(), \"AdamSteve\");\n});\n\ntest(\"controller is assignable inside an #each\", function() {\n  var controller = Ember.ArrayController.create({\n    content: Ember.A([ { name: \"Adam\" }, { name: \"Steve\" } ])\n  });\n\n  view = Ember.View.create({\n    controller: controller,\n    template: templateFor('{{#each itemController in this}}{{#view controllerBinding=\"itemController\"}}{{name}}{{/view}}{{/each}}')\n  });\n\n  append(view);\n\n  equal(view.$().text(), \"AdamSteve\");\n});\n\n})();\n//@ sourceURL=ember-handlebars/~tests/helpers/each_test");minispade.register('ember-handlebars/~tests/helpers/group_test', "(function() {var trim = Ember.$.trim;\n\nvar view;\n\nmodule(\"Ember.Handlebars - group flag\", {\n  setup: function() {},\n\n  teardown: function() {\n    Ember.run(function() {\n      view.destroy();\n    });\n    Ember.run.cancelTimers();\n  }\n});\n\nfunction createGroupedView(template, context) {\n  var options = {\n    context: context,\n    template: Ember.Handlebars.compile(template),\n    templateData: {insideGroup: true, keywords: {}}\n  };\n  Ember.run(function() {\n    view = Ember.View.create(options);\n  });\n}\n\nfunction appendView() {\n  Ember.run(function() { view.appendTo('#qunit-fixture'); });\n}\n\ntest(\"should properly modify behavior inside the block\", function() {\n  createGroupedView(\"{{msg}}\", {msg: 'ohai'});\n  appendView();\n\n  equal(view.$('script').length, 0, \"No Metamorph markers are output\");\n  equal(view.$().text(), 'ohai', 'Original value was rendered');\n\n  Ember.run(function() {\n    view.set('context.msg', 'ohbai');\n  });\n  equal(view.$().text(), 'ohbai', 'Updated value was rendered');\n\n  Ember.run(function() {\n    view.set('context.msg', null);\n  });\n  equal(view.$().text(), '', 'null value properly rendered as a blank');\n\n  Ember.run(function() {\n    view.set('context.msg', undefined);\n  });\n  equal(view.$().text(), '', 'undefined value properly rendered as a blank');\n});\n\ntest(\"property changes inside views should only rerender their view\", function() {\n  createGroupedView(\n    '{{#view}}{{msg}}{{/view}}',\n    {msg: 'ohai'}\n  );\n  var rerenderWasCalled = false;\n  view.reopen({\n    rerender: function() { rerenderWasCalled = true; this._super(); }\n  });\n  appendView();\n  equal(view.$('script').length, 0, \"No Metamorph markers are output\");\n  equal(trim(view.$().text()), 'ohai', 'Original value was rendered');\n\n  Ember.run(function() {\n    view.set('context.msg', 'ohbai');\n  });\n  ok(!rerenderWasCalled, \"The GroupView rerender method was not called\");\n  equal(trim(view.$().text()), 'ohbai', \"The updated value was rendered\");\n});\n\ntest(\"should work with bindAttr\", function() {\n  createGroupedView(\n    '<button {{bindAttr class=\"innerClass\"}}>ohai</button>',\n    {innerClass: 'magic'}\n  );\n  appendView();\n  equal(view.$('.magic').length, 1);\n\n  Ember.run(function() {\n    view.set('context.innerClass', 'bindings');\n  });\n  equal(view.$('.bindings').length, 1);\n\n  Ember.run(function() {\n    view.rerender();\n  });\n  equal(view.$('.bindings').length, 1);\n});\n\ntest(\"should work with the #if helper\", function() {\n  createGroupedView(\n    '{{#if something}}hooray{{else}}boo{{/if}}',\n    {something: true}\n  );\n  appendView();\n\n  equal(view.$('script').length, 0, \"No Metamorph markers are output\");\n  equal(trim(view.$().text()), 'hooray', 'Truthy text was rendered');\n\n  Ember.run(function() {\n    view.set('context.something', false);\n  });\n  equal(trim(view.$().text()), 'boo', \"The falsy value was rendered\");\n});\n\ntest(\"#each can be nested\", function() {\n  createGroupedView(\n    \"{{#each numbers}}{{this}}{{/each}}\",\n    {numbers: Ember.A([1, 2, 3])}\n  );\n  appendView();\n  equal(view.$('script').length, 0, \"No Metamorph markers are output\");\n  equal(view.$().text(), '123', \"The content was rendered\");\n\n  Ember.run(function() {\n    view.get('context.numbers').pushObject(4);\n  });\n\n  equal(view.$().text(), '1234', \"The array observer properly updated the rendered output\");\n\n  Ember.run(function() {\n    view.set('context.numbers', Ember.A(['a', 'b', 'c']));\n  });\n\n  equal(view.$().text(), 'abc', \"Replacing the array properly updated the rendered output\");\n});\n\ntest(\"#each can be used with an ArrayProxy\", function() {\n  createGroupedView(\n    \"{{#each numbers}}{{this}}{{/each}}\",\n    {numbers: Ember.ArrayProxy.create({content: Ember.A([1, 2, 3])})}\n  );\n  appendView();\n  equal(view.$('script').length, 0, \"No Metamorph markers are output\");\n  equal(view.$().text(), '123', \"The content was rendered\");\n});\n\ntest(\"an #each can be nested with a view inside\", function() {\n  var yehuda = {name: 'Yehuda'};\n  createGroupedView(\n    '{{#each people}}{{#view}}{{name}}{{/view}}{{/each}}',\n    {people: Ember.A([yehuda, {name: 'Tom'}])}\n  );\n  appendView();\n  equal(view.$('script').length, 0, \"No Metamorph markers are output\");\n  equal(view.$().text(), 'YehudaTom', \"The content was rendered\");\n\n  Ember.run(function() {\n    Ember.set(yehuda, 'name', 'Erik');\n  });\n\n  equal(view.$().text(), 'ErikTom', \"The updated object's view was rerendered\");\n});\n\ntest(\"#each with groupedRows=true behaves like a normal bound #each\", function() {\n  createGroupedView(\n    '{{#each numbers groupedRows=true}}{{this}}{{/each}}',\n    {numbers: Ember.A([1, 2, 3])}\n  );\n  appendView();\n  equal(view.$('script').length, 8, \"Correct number of Metamorph markers are output\");\n  equal(view.$().text(), '123');\n\n  Ember.run(function() {\n    view.get('context.numbers').pushObject(4);\n  });\n\n  equal(view.$('script').length, 10, \"Correct number of Metamorph markers are output\");\n  equal(view.$().text(), '1234');\n});\n\ntest(\"#each with itemViewClass behaves like a normal bound #each\", function() {\n  createGroupedView(\n    '{{#each people itemViewClass=\"Ember.View\"}}{{name}}{{/each}}',\n    {people: Ember.A([{name: 'Erik'}, {name: 'Peter'}])}\n  );\n  appendView();\n  equal(view.$('script').length, 2, \"Correct number of Metamorph markers are output\");\n  equal(view.$('.ember-view').length, 2, \"Correct number of views are output\");\n  equal(view.$().text(), 'ErikPeter');\n\n  Ember.run(function() {\n    view.get('context.people').pushObject({name: 'Tom'});\n  });\n\n  equal(view.$('script').length, 2, \"Correct number of Metamorph markers are output\");\n  equal(view.$('.ember-view').length, 3, \"Correct number of views are output\");\n  // IE likes to add newlines\n  equal(view.$().text().replace(/\\s+/g, ''), 'ErikPeterTom');\n});\n\n})();\n//@ sourceURL=ember-handlebars/~tests/helpers/group_test");minispade.register('ember-handlebars/~tests/helpers/if_unless_test', "(function() {var appendView = function(view) {\n  Ember.run(function() { view.appendTo('#qunit-fixture'); });\n};\n\nvar compile = Ember.Handlebars.compile;\n\nvar view;\n\nmodule(\"Handlebars {{#if}} and {{#unless}} helpers\", {\n  teardown: function() {\n    Ember.run(function(){\n      if (view) {\n        view.destroy();\n      }\n    });\n  }\n});\n\ntest(\"unless should keep the current context (#784)\", function() {\n  view = Ember.View.create({\n    o: Ember.Object.create({foo: '42'}),\n\n    template: compile('{{#with view.o}}{{#view Ember.View}}{{#unless view.doesNotExist}}foo: {{foo}}{{/unless}}{{/view}}{{/with}}')\n  });\n\n  appendView(view);\n\n  equal(view.$().text(), 'foo: 42');\n});\n\ntest(\"The `if` helper tests for `isTruthy` if available\", function() {\n  view = Ember.View.create({\n    truthy: Ember.Object.create({ isTruthy: true }),\n    falsy: Ember.Object.create({ isTruthy: false }),\n\n    template: compile('{{#if view.truthy}}Yep{{/if}}{{#if view.falsy}}Nope{{/if}}')\n  });\n\n  appendView(view);\n\n  equal(view.$().text(), 'Yep');\n});\n\ntest(\"The `if` helper does not print the contents for an object proxy without content\", function() {\n  view = Ember.View.create({\n    truthy: Ember.ObjectProxy.create({ content: {} }),\n    falsy: Ember.ObjectProxy.create({ content: null }),\n\n    template: compile('{{#if view.truthy}}Yep{{/if}}{{#if view.falsy}}Nope{{/if}}')\n  });\n\n  appendView(view);\n\n  equal(view.$().text(), 'Yep');\n});\n\ntest(\"The `if` helper updates if an object proxy gains or loses context\", function() {\n  view = Ember.View.create({\n    proxy: Ember.ObjectProxy.create({ content: null }),\n\n    template: compile('{{#if view.proxy}}Yep{{/if}}')\n  });\n\n  appendView(view);\n\n  equal(view.$().text(), '');\n\n  Ember.run(function() {\n    view.set('proxy.content', {});\n  });\n\n  equal(view.$().text(), 'Yep');\n\n  Ember.run(function() {\n    view.set('proxy.content', null);\n  });\n\n  equal(view.$().text(), '');\n});\n\ntest(\"The `if` helper updates if an array is empty or not\", function() {\n  view = Ember.View.create({\n    array: Ember.A([]),\n\n    template: compile('{{#if view.array}}Yep{{/if}}')\n  });\n\n  appendView(view);\n\n  equal(view.$().text(), '');\n\n  Ember.run(function() {\n    view.get('array').pushObject(1);\n  });\n\n  equal(view.$().text(), 'Yep');\n\n  Ember.run(function() {\n    view.get('array').removeObject(1);\n  });\n\n  equal(view.$().text(), '');\n});\n\n})();\n//@ sourceURL=ember-handlebars/~tests/helpers/if_unless_test");minispade.register('ember-handlebars/~tests/helpers/partial_test', "(function() {var MyApp;\nvar originalLookup = Ember.lookup, lookup, TemplateTests, view, container;\n\nmodule(\"Support for {{partial}} helper\", {\n  setup: function(){\n    Ember.lookup = lookup = { Ember: Ember };\n    MyApp = lookup.MyApp = Ember.Object.create({});\n    container = new Ember.Container();\n    container.optionsForType('template', { instantiate: false });\n  },\n  teardown: function(){\n    Ember.run(function() {\n      if (view) {\n        view.destroy();\n      }\n    });\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest(\"should render other templates registered with the container\", function() {\n  container.register('template:_subTemplateFromContainer', Ember.Handlebars.compile('sub-template'));\n\n  view = Ember.View.create({\n    container: container,\n    template: Ember.Handlebars.compile('This {{partial \"subTemplateFromContainer\"}} is pretty great.')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(Ember.$.trim(view.$().text()), \"This sub-template is pretty great.\");\n});\n\ntest(\"should render other slash-separated templates registered with the container\", function() {\n  container.register('template:child/_subTemplateFromContainer', Ember.Handlebars.compile(\"sub-template\"));\n\n  view = Ember.View.create({\n    container: container,\n    template: Ember.Handlebars.compile('This {{partial \"child/subTemplateFromContainer\"}} is pretty great.')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(Ember.$.trim(view.$().text()), \"This sub-template is pretty great.\");\n});\n\ntest(\"should use the current view's context\", function(){\n  container.register('template:_person_name', Ember.Handlebars.compile(\"{{{firstName}} {{lastName}}\"));\n\n  view = Ember.View.create({\n    container: container,\n    template: Ember.Handlebars.compile('Who is {{partial \"person_name\"}}?')\n  });\n  view.set('controller', Ember.Object.create({\n    firstName: 'Kris',\n    lastName: 'Selden'\n  }));\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(Ember.$.trim(view.$().text()), \"Who is Kris Selden?\");\n});\n\n})();\n//@ sourceURL=ember-handlebars/~tests/helpers/partial_test");minispade.register('ember-handlebars/~tests/helpers/template_test', "(function() {var MyApp;\nvar originalLookup = Ember.lookup, lookup, TemplateTests, view, container;\n\nmodule(\"Support for {{template}} helper\", {\n  setup: function(){\n    Ember.lookup = lookup = { Ember: Ember };\n    MyApp = lookup.MyApp = Ember.Object.create({});\n    container = new Ember.Container();\n    container.optionsForType('template', { instantiate: false });\n  },\n  teardown: function(){\n    Ember.run(function() {\n      if (view) {\n        view.destroy();\n      }\n    });\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest(\"should render other templates via the container\", function() {\n  container.register('template:sub_template_from_container', Ember.Handlebars.compile('sub-template'));\n\n  view = Ember.View.create({\n    container: container,\n    template: Ember.Handlebars.compile('This {{template \"sub_template_from_container\"}} is pretty great.')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(Ember.$.trim(view.$().text()), \"This sub-template is pretty great.\");\n});\n\ntest(\"should use the current view's context\", function(){\n  container.register('template:person_name', Ember.Handlebars.compile(\"{{{firstName}} {{lastName}}\"));\n\n  view = Ember.View.create({\n    container: container,\n    template: Ember.Handlebars.compile('Who is {{template \"person_name\"}}?')\n  });\n  view.set('controller', Ember.Object.create({\n    firstName: 'Kris',\n    lastName: 'Selden'\n  }));\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(Ember.$.trim(view.$().text()), \"Who is Kris Selden?\");\n});\n\n})();\n//@ sourceURL=ember-handlebars/~tests/helpers/template_test");minispade.register('ember-handlebars/~tests/helpers/unbound_test', "(function() {/*globals Foo */\n\nvar get = Ember.get, set = Ember.set;\n\nvar appendView = function(view) {\n  Ember.run(function() { view.appendTo('#qunit-fixture'); });\n};\n\nvar view;\nvar originalLookup = Ember.lookup, lookup;\n\nmodule(\"Handlebars {{#unbound}} helper -- classic single-property usage\", {\n  setup: function() {\n    Ember.lookup = lookup = { Ember: Ember };\n\n    view = Ember.View.create({\n      template: Ember.Handlebars.compile(\"{{unbound foo}} {{unbound bar}}\"),\n      context: Ember.Object.create({\n        foo: \"BORK\",\n        barBinding: 'foo'\n      })\n    });\n\n    appendView(view);\n  },\n\n  teardown: function() {\n    Ember.run(function(){\n      view.destroy();\n    });\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest(\"it should render the current value of a property on the context\", function() {\n  equal(view.$().text(), \"BORK BORK\", \"should render the current value of a property\");\n});\n\ntest(\"it should not re-render if the property changes\", function() {\n  Ember.run(function() {\n    view.set('context.foo', 'OOF');\n  });\n  equal(view.$().text(), \"BORK BORK\", \"should not re-render if the property changes\");\n});\n\n\nmodule(\"Handlebars {{#unbound boundHelper arg1 arg2... argN}} form: render unbound helper invocations\", {\n  setup: function() {\n    Ember.lookup = lookup = { Ember: Ember };\n\n    Ember.Handlebars.registerBoundHelper('capitalize', function(value) {\n      return value.toUpperCase();\n    });\n\n    Ember.Handlebars.registerBoundHelper('capitalizeName', function(value) {\n      return get(value, 'firstName').toUpperCase();\n    }, 'firstName');\n\n    Ember.Handlebars.registerBoundHelper('concat', function(value) {\n      return [].slice.call(arguments, 0, -1).join('');\n    });\n\n    Ember.Handlebars.registerBoundHelper('concatNames', function(value) {\n      return get(value, 'firstName') + get(value, 'lastName');\n    }, 'firstName', 'lastName');\n  },\n\n  teardown: function() {\n    Ember.run(function(){\n      view.destroy();\n    });\n    Ember.lookup = originalLookup;\n  }\n});\n\n\ntest(\"should be able to render an unbound helper invocation\", function() {\n\n  Ember.Handlebars.registerBoundHelper('repeat', function(value, options) {\n    var count = options.hash.count;\n    var a = [];\n    while(a.length < count){\n        a.push(value);\n    }\n    return a.join('');\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{unbound repeat foo countBinding=\"bar\"}} {{repeat foo countBinding=\"bar\"}} {{unbound repeat foo count=2}} {{repeat foo count=4}}'),\n    context: Ember.Object.create({\n      foo: \"X\",\n      numRepeatsBinding: \"bar\",\n      bar: 5\n    })\n  });\n  appendView(view);\n\n  equal(view.$().text(), \"XXXXX XXXXX XX XXXX\", \"first render is correct\");\n\n  Ember.run(function() {\n    set(view, 'context.bar', 1);\n  });\n\n  equal(view.$().text(), \"XXXXX X XX XXXX\", \"only unbound bound options changed\");\n});\n\n\ntest(\"should be able to render unbound forms of multi-arg helpers\", function() {\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile(\"{{concat foo bar bing}} {{unbound concat foo bar bing}}\"),\n    context: Ember.Object.create({\n      foo: \"a\",\n      bar: \"b\",\n      bing: \"c\"\n    })\n  });\n  appendView(view);\n\n  equal(view.$().text(), \"abc abc\", \"first render is correct\");\n\n  Ember.run(function() {\n    set(view, 'context.bar', 'X');\n  });\n\n  equal(view.$().text(), \"aXc abc\", \"unbound helpers/properties stayed the same\");\n});\n\n\ntest(\"should be able to render an unbound helper invocation for helpers with dependent keys\", function() {\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile(\"{{capitalizeName person}} {{unbound capitalizeName person}} {{concatNames person}} {{unbound concatNames person}}\"),\n    context: Ember.Object.create({\n      person: Ember.Object.create({\n        firstName: 'shooby',\n        lastName:  'taylor'\n      })\n    })\n  });\n  appendView(view);\n\n  equal(view.$().text(), \"SHOOBY SHOOBY shoobytaylor shoobytaylor\", \"first render is correct\");\n\n  Ember.run(function() {\n    set(view, 'context.person.firstName', 'sally');\n  });\n\n  equal(view.$().text(), \"SALLY SHOOBY sallytaylor shoobytaylor\", \"only bound values change\");\n});\n\n\ntest(\"should be able to render an unbound helper invocation with bound hash options\", function() {\n\n  Ember.Handlebars.registerBoundHelper('repeat', function(value) {\n    return [].slice.call(arguments, 0, -1).join('');\n  });\n\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile(\"{{capitalizeName person}} {{unbound capitalizeName person}} {{concatNames person}} {{unbound concatNames person}}\"),\n    context: Ember.Object.create({\n      person: Ember.Object.create({\n        firstName: 'shooby',\n        lastName:  'taylor'\n      })\n    })\n  });\n  appendView(view);\n\n  equal(view.$().text(), \"SHOOBY SHOOBY shoobytaylor shoobytaylor\", \"first render is correct\");\n\n  Ember.run(function() {\n    set(view, 'context.person.firstName', 'sally');\n  });\n\n  equal(view.$().text(), \"SALLY SHOOBY sallytaylor shoobytaylor\", \"only bound values change\");\n});\n\n\n})();\n//@ sourceURL=ember-handlebars/~tests/helpers/unbound_test");minispade.register('ember-handlebars/~tests/helpers/with_test', "(function() {/*globals Foo */\n\nvar appendView = function(view) {\n  Ember.run(function() { view.appendTo('#qunit-fixture'); });\n};\n\nvar view;\nvar originalLookup = Ember.lookup, lookup;\n\nmodule(\"Handlebars {{#with}} helper\", {\n  setup: function() {\n    Ember.lookup = lookup = { Ember: Ember };\n\n    view = Ember.View.create({\n      template: Ember.Handlebars.compile(\"{{#with person as tom}}{{title}}: {{tom.name}}{{/with}}\"),\n      context: {\n        title: \"Seor Engineer\",\n        person: { name: \"Tom Dale\" }\n      }\n    });\n\n    appendView(view);\n  },\n\n  teardown: function() {\n    Ember.run(function(){\n      view.destroy();\n    });\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest(\"it should support #with foo as bar\", function() {\n  equal(view.$().text(), \"Seor Engineer: Tom Dale\", \"should be properly scoped\");\n});\n\ntest(\"updating the context should update the alias\", function() {\n  Ember.run(function() {\n    view.set('context.person', {\n      name: \"Yehuda Katz\"\n    });\n  });\n\n  equal(view.$().text(), \"Seor Engineer: Yehuda Katz\", \"should be properly scoped after updating\");\n});\n\ntest(\"updating a property on the context should update the HTML\", function() {\n  Ember.run(function() {\n    Ember.set(view, 'context.person.name', \"Yehuda Katz\");\n  });\n\n  equal(view.$().text(), \"Seor Engineer: Yehuda Katz\", \"should be properly scoped after updating\");\n});\n\ntest(\"updating a property on the view should update the HTML\", function() {\n  Ember.run(function() {\n    view.set('context.title', \"Seorette Engineer\");\n  });\n\n  equal(view.$().text(), \"Seorette Engineer: Tom Dale\", \"should be properly scoped after updating\");\n});\n\nmodule(\"Handlebars {{#with}} globals helper\", {\n  setup: function() {\n    Ember.lookup = lookup = { Ember: Ember };\n\n    lookup.Foo = { bar: 'baz' };\n    view = Ember.View.create({\n      template: Ember.Handlebars.compile(\"{{#with Foo.bar as qux}}{{qux}}{{/with}}\")\n    });\n\n    appendView(view);\n  },\n\n  teardown: function() {\n    Ember.run(function(){\n      view.destroy();\n    });\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest(\"it should support #with Foo.bar as qux\", function() {\n  equal(view.$().text(), \"baz\", \"should be properly scoped\");\n\n  Ember.run(function() {\n    Ember.set(lookup.Foo, 'bar', 'updated');\n  });\n\n  equal(view.$().text(), \"updated\", \"should update\");\n});\n\nmodule(\"Handlebars {{#with keyword as foo}}\");\n\ntest(\"it should support #with view as foo\", function() {\n  var view = Ember.View.create({\n    template: Ember.Handlebars.compile(\"{{#with view as myView}}{{myView.name}}{{/with}}\"),\n    name: \"Sonics\"\n  });\n\n  appendView(view);\n  equal(view.$().text(), \"Sonics\", \"should be properly scoped\");\n\n  Ember.run(function() {\n    Ember.set(view, 'name', \"Thunder\");\n  });\n\n  equal(view.$().text(), \"Thunder\", \"should update\");\n\n  Ember.run(function() {\n    view.destroy();\n  });\n});\n\ntest(\"it should support #with name as food, then #with foo as bar\", function() {\n  var view = Ember.View.create({\n    template: Ember.Handlebars.compile(\"{{#with name as foo}}{{#with foo as bar}}{{bar}}{{/with}}{{/with}}\"),\n    context: { name: \"caterpillar\" }\n  });\n\n  appendView(view);\n  equal(view.$().text(), \"caterpillar\", \"should be properly scoped\");\n\n  Ember.run(function() {\n    Ember.set(view, 'context.name', \"butterfly\");\n  });\n\n  equal(view.$().text(), \"butterfly\", \"should update\");\n\n  Ember.run(function() {\n    view.destroy();\n  });\n});\n\nmodule(\"Handlebars {{#with this as foo}}\");\n\ntest(\"it should support #with this as qux\", function() {\n  var view = Ember.View.create({\n    template: Ember.Handlebars.compile(\"{{#with this as person}}{{person.name}}{{/with}}\"),\n    controller: Ember.Object.create({ name: \"Los Pivots\" })\n  });\n\n  appendView(view);\n  equal(view.$().text(), \"Los Pivots\", \"should be properly scoped\");\n\n  Ember.run(function() {\n    Ember.set(view, 'controller.name', \"l'Pivots\");\n  });\n\n  equal(view.$().text(), \"l'Pivots\", \"should update\");\n\n  Ember.run(function() {\n    view.destroy();\n  });\n});\n\n})();\n//@ sourceURL=ember-handlebars/~tests/helpers/with_test");minispade.register('ember-handlebars/~tests/helpers/yield_test', "(function() {var set = Ember.set, get = Ember.get;\n\nvar originalLookup = Ember.lookup, lookup, TemplateTests, view, container;\n\nmodule(\"Support for {{yield}} helper (#307)\", {\n  setup: function() {\n    Ember.lookup = lookup = { Ember: Ember };\n\n    lookup.TemplateTests = TemplateTests = Ember.Namespace.create();\n\n    container = new Ember.Container();\n    container.optionsForType('template', { instantiate: false });\n  },\n  teardown: function() {\n    Ember.run(function(){\n      if (view) {\n        view.destroy();\n      }}\n    );\n\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest(\"a view with a layout set renders its template where the {{yield}} helper appears\", function() {\n  TemplateTests.ViewWithLayout = Ember.View.extend({\n    layout: Ember.Handlebars.compile('<div class=\"wrapper\"><h1>{{title}}</h1>{{yield}}</div>')\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#view TemplateTests.ViewWithLayout title=\"My Fancy Page\"}}<div class=\"page-body\">Show something interesting here</div>{{/view}}')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('div.wrapper div.page-body').length, 1, 'page-body is embedded within wrapping my-page');\n});\n\ntest(\"block should work properly even when templates are not hard-coded\", function() {\n  container.register('template:nester', Ember.Handlebars.compile('<div class=\"wrapper\"><h1>{{title}}</h1>{{yield}}</div>'));\n  container.register('template:nested', Ember.Handlebars.compile('{{#view TemplateTests.ViewWithLayout title=\"My Fancy Page\"}}<div class=\"page-body\">Show something interesting here</div>{{/view}}'));\n\n  TemplateTests.ViewWithLayout = Ember.View.extend({\n    container: container,\n    layoutName: 'nester'\n  });\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'nested'\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('div.wrapper div.page-body').length, 1, 'page-body is embedded within wrapping my-page');\n\n});\n\ntest(\"templates should yield to block, when the yield is embedded in a hierarchy of virtual views\", function() {\n  TemplateTests.TimesView = Ember.View.extend({\n    layout: Ember.Handlebars.compile('<div class=\"times\">{{#each view.index}}{{yield}}{{/each}}</div>'),\n    n: null,\n    index: Ember.computed(function() {\n      var n = Ember.get(this, 'n'), indexArray = Ember.A([]);\n      for (var i=0; i < n; i++) {\n        indexArray[i] = i;\n      }\n      return indexArray;\n    })\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<div id=\"container\"><div class=\"title\">Counting to 5</div>{{#view TemplateTests.TimesView n=5}}<div class=\"times-item\">Hello</div>{{/view}}</div>')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('div#container div.times-item').length, 5, 'times-item is embedded within wrapping container 5 times, as expected');\n});\n\ntest(\"templates should yield to block, when the yield is embedded in a hierarchy of non-virtual views\", function() {\n  TemplateTests.NestingView = Ember.View.extend({\n    layout: Ember.Handlebars.compile('{{#view Ember.View tagName=\"div\" classNames=\"nesting\"}}{{yield}}{{/view}}')\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<div id=\"container\">{{#view TemplateTests.NestingView}}<div id=\"block\">Hello</div>{{/view}}</div>')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('div#container div.nesting div#block').length, 1, 'nesting view yields correctly even within a view hierarchy in the nesting view');\n});\n\ntest(\"block should not be required\", function() {\n  TemplateTests.YieldingView = Ember.View.extend({\n    layout: Ember.Handlebars.compile('{{#view Ember.View tagName=\"div\" classNames=\"yielding\"}}{{yield}}{{/view}}')\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<div id=\"container\">{{view TemplateTests.YieldingView}}</div>')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('div#container div.yielding').length, 1, 'yielding view is rendered as expected');\n});\n\n\n})();\n//@ sourceURL=ember-handlebars/~tests/helpers/yield_test");minispade.register('ember-handlebars/~tests/loader_test', "(function() {var originalLookup = Ember.lookup, lookup, Tobias;\n\nmodule(\"test Ember.Handlebars.bootstrap\", {\n  setup: function() {\n    Ember.lookup = lookup = { Ember: Ember };\n  },\n  teardown: function() {\n    Ember.TEMPLATES = {};\n    Ember.lookup = originalLookup;\n  }\n});\n\nfunction checkTemplate(templateName) {\n  Ember.run(function() {\n    Ember.Handlebars.bootstrap(Ember.$('#qunit-fixture'));\n  });\n  var template = Ember.TEMPLATES[templateName];\n  ok(template, 'template is available on Ember.TEMPLATES');\n  equal(Ember.$('#qunit-fixture script').length, 0, 'script removed');\n  var view = Ember.View.create({\n    template: template,\n    context: {\n      firstName: 'Tobias',\n      drug: 'teamocil'\n    }\n  });\n  Ember.run(function() {\n    view.createElement();\n  });\n  equal(Ember.$.trim(view.$().text()), 'Tobias takes teamocil', 'template works');\n  Ember.run(function() {\n    view.destroy();\n  });\n}\n\ntest('template with data-template-name should add a new template to Ember.TEMPLATES', function() {\n  Ember.$('#qunit-fixture').html('<script type=\"text/x-handlebars\" data-template-name=\"funkyTemplate\">{{firstName}} takes {{drug}}</script>');\n\n  checkTemplate('funkyTemplate');\n});\n\ntest('template with id instead of data-template-name should add a new template to Ember.TEMPLATES', function() {\n  Ember.$('#qunit-fixture').html('<script type=\"text/x-handlebars\" id=\"funkyTemplate\" >{{firstName}} takes {{drug}}</script>');\n\n  checkTemplate('funkyTemplate');\n});\n\ntest('template without data-template-name or id should default to application', function() {\n  Ember.$('#qunit-fixture').html('<script type=\"text/x-handlebars\">{{firstName}} takes {{drug}}</script>');\n\n  checkTemplate('application');\n});\n\ntest('template with type text/x-raw-handlebars should be parsed', function() {\n  Ember.$('#qunit-fixture').html('<script type=\"text/x-raw-handlebars\" data-template-name=\"funkyTemplate\">{{name}}</script>');\n\n  Ember.run(function() {\n    Ember.Handlebars.bootstrap(Ember.$('#qunit-fixture'));\n  });\n\n  ok(Ember.TEMPLATES['funkyTemplate'], 'template with name funkyTemplate available');\n\n  // This won't even work with Ember templates\n  equal(Ember.$.trim(Ember.TEMPLATES['funkyTemplate']({ name: 'Tobias' })), \"Tobias\");\n});\n\n})();\n//@ sourceURL=ember-handlebars/~tests/loader_test");minispade.register('ember-handlebars/~tests/lookup_test', "(function() {module(\"Ember.Handlebars.resolveParams\");\n\ntest(\"Raw string parameters should be returned as Strings\", function() {\n  var params = Ember.Handlebars.resolveParams({}, [\"foo\", \"bar\", \"baz\"], { types: [\"STRING\", \"STRING\", \"STRING\"] });\n  deepEqual(params, [\"foo\", \"bar\", \"baz\"]);\n});\n\ntest(\"Raw boolean parameters should be returned as Booleans\", function() {\n  var params = Ember.Handlebars.resolveParams({}, [true, false], { types: [\"BOOLEAN\", \"BOOLEAN\"] });\n  deepEqual(params, [true, false]);\n});\n\ntest(\"Raw numeric parameters should be returned as Numbers\", function() {\n  var params = Ember.Handlebars.resolveParams({}, [1, 1.0, 1.5, 0.5], { types: [\"NUMBER\", \"NUMBER\", \"NUMBER\", \"NUMBER\"] });\n  deepEqual(params, [1, 1, 1.5, 0.5]);\n});\n\ntest(\"ID parameters should be looked up on the context\", function() {\n  var context = {\n    salutation: \"Mr\",\n    name: {\n      first: \"Tom\",\n      last: \"Dale\"\n    }\n  };\n\n  var params = Ember.Handlebars.resolveParams(context, [\"salutation\", \"name.first\", \"name.last\"], { types: [\"ID\", \"ID\", \"ID\"] });\n  deepEqual(params, [\"Mr\", \"Tom\", \"Dale\"]);\n});\n\ntest(\"ID parameters can look up keywords\", function() {\n  var controller = {\n    salutation: \"Mr\"\n  };\n\n  var view = {\n    name: { first: \"Tom\", last: \"Dale\" }\n  };\n\n  var context = {\n    yuno: \"State Charts\"\n  };\n\n  var options = {\n    types: [\"ID\", \"ID\", \"ID\", \"ID\"],\n    data: {\n      keywords: {\n        controller: controller,\n        view: view\n      }\n    }\n  };\n\n  var params = Ember.Handlebars.resolveParams(context, [\"controller.salutation\", \"view.name.first\", \"view.name.last\", \"yuno\"], options);\n  deepEqual(params, [\"Mr\", \"Tom\", \"Dale\", \"State Charts\"]);\n});\n\nmodule(\"Ember.Handlebars.resolveHash\");\n\ntest(\"Raw string parameters should be returned as Strings\", function() {\n  var hash = Ember.Handlebars.resolveHash({}, { string: \"foo\" }, { hashTypes: { string: \"STRING\" } });\n  deepEqual(hash, { string: \"foo\" });\n});\n\ntest(\"Raw boolean parameters should be returned as Booleans\", function() {\n  var hash = Ember.Handlebars.resolveHash({}, { yes: true, no: false }, { hashTypes: { yes: \"BOOLEAN\", no: \"BOOLEAN\" } });\n  deepEqual(hash, { yes: true, no: false });\n});\n\ntest(\"Raw numeric parameters should be returned as Numbers\", function() {\n  var hash = Ember.Handlebars.resolveHash({}, { one: 1, oneFive: 1.5, ohFive: 0.5 }, { hashTypes: { one: \"NUMBER\", oneFive: \"NUMBER\", ohFive: \"NUMBER\" } });\n  deepEqual(hash, { one: 1, oneFive: 1.5, ohFive: 0.5 });\n});\n\ntest(\"ID parameters should be looked up on the context\", function() {\n  var context = {\n    salutation: \"Mr\",\n    name: {\n      first: \"Tom\",\n      last: \"Dale\"\n    }\n  };\n\n  var hash = Ember.Handlebars.resolveHash(context, { mr: \"salutation\", firstName: \"name.first\", lastName: \"name.last\" }, { hashTypes: { mr: \"ID\", firstName: \"ID\", lastName: \"ID\" } });\n  deepEqual(hash, { mr: \"Mr\", firstName: \"Tom\", lastName: \"Dale\" });\n});\n\ntest(\"ID parameters can look up keywords\", function() {\n  var controller = {\n    salutation: \"Mr\"\n  };\n\n  var view = {\n    name: { first: \"Tom\", last: \"Dale\" }\n  };\n\n  var context = {\n    yuno: \"State Charts\"\n  };\n\n  var options = {\n    hashTypes: { mr: \"ID\", firstName: \"ID\", lastName: \"ID\", yuno: \"ID\" },\n    data: {\n      keywords: {\n        controller: controller,\n        view: view\n      }\n    }\n  };\n\n  var hash = Ember.Handlebars.resolveHash(context, { mr: \"controller.salutation\", firstName: \"view.name.first\", lastName: \"view.name.last\", yuno: \"yuno\" }, options);\n  deepEqual(hash, { mr: \"Mr\", firstName: \"Tom\", lastName: \"Dale\", yuno: \"State Charts\" });\n});\n\n})();\n//@ sourceURL=ember-handlebars/~tests/lookup_test");minispade.register('ember-handlebars/~tests/views/collection_view_test', "(function() {/*globals TemplateTests:true App:true */\n\nvar set = Ember.set, get = Ember.get, trim = Ember.$.trim;\nvar firstGrandchild = function(view) {\n  return get(get(view, 'childViews').objectAt(0), 'childViews').objectAt(0);\n};\nvar nthChild = function(view, nth) {\n  return get(view, 'childViews').objectAt(nth || 0);\n};\nvar firstChild = nthChild;\n\nvar originalLookup = Ember.lookup, lookup, TemplateTests, view;\n\nmodule(\"ember-handlebars/tests/views/collection_view_test\", {\n  setup: function() {\n    Ember.lookup = lookup = { Ember: Ember };\n    lookup.TemplateTests = TemplateTests = Ember.Namespace.create();\n  },\n  teardown: function() {\n    Ember.run(function(){\n      if (view) {\n        view.destroy();\n      }\n    });\n\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest(\"passing a block to the collection helper sets it as the template for example views\", function() {\n  TemplateTests.CollectionTestView = Ember.CollectionView.extend({\n    tagName: 'ul',\n    content: Ember.A(['foo', 'bar', 'baz'])\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#collection TemplateTests.CollectionTestView}} <label></label> {{/collection}}')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('label').length, 3, 'one label element is created for each content item');\n});\n\ntest(\"collection helper should accept relative paths\", function() {\n  Ember.TESTING_DEPRECATION = true;\n\n  try {\n    view = Ember.View.create({\n      template: Ember.Handlebars.compile('{{#collection view.collection}} <label></label> {{/collection}}'),\n      collection: Ember.CollectionView.extend({\n        tagName: 'ul',\n        content: Ember.A(['foo', 'bar', 'baz'])\n      })\n    });\n\n    Ember.run(function() {\n      view.appendTo('#qunit-fixture');\n    });\n\n    equal(view.$('label').length, 3, 'one label element is created for each content item');\n  } finally {\n    Ember.TESTING_DEPRECATION = false;\n  }\n});\n\ntest(\"empty views should be removed when content is added to the collection (regression, ht: msofaer)\", function() {\n  var App;\n\n  Ember.run(function() {\n    lookup.App = App = Ember.Application.create();\n  });\n\n  App.EmptyView = Ember.View.extend({\n    template : Ember.Handlebars.compile(\"<td>No Rows Yet</td>\")\n  });\n\n  App.ListView = Ember.CollectionView.extend({\n    emptyView: App.EmptyView\n  });\n\n  App.listController = Ember.ArrayProxy.create({\n    content : Ember.A()\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#collection App.ListView contentBinding=\"App.listController\" tagName=\"table\"}} <td>{{view.content.title}}</td> {{/collection}}')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('tr').length, 1, 'Make sure the empty view is there (regression)');\n\n  Ember.run(function() {\n    App.listController.pushObject({title : \"Go Away, Placeholder Row!\"});\n  });\n\n  equal(view.$('tr').length, 1, 'has one row');\n  equal(view.$('tr:nth-child(1) td').text(), 'Go Away, Placeholder Row!', 'The content is the updated data.');\n\n  Ember.run(function(){ App.destroy(); });\n});\n\ntest(\"should be able to specify which class should be used for the empty view\", function() {\n  Ember.TESTING_DEPRECATION = true;\n\n  try {\n    var App;\n\n    Ember.run(function() {\n      lookup.App = App = Ember.Application.create();\n    });\n\n    App.EmptyView = Ember.View.extend({\n      template: Ember.Handlebars.compile('This is an empty view')\n    });\n\n    view = Ember.View.create({\n      template: Ember.Handlebars.compile('{{collection emptyViewClass=\"App.EmptyView\"}}')\n    });\n\n    Ember.run(function() {\n      view.appendTo('#qunit-fixture');\n    });\n\n    equal(view.$().text(), 'This is an empty view', \"Empty view should be rendered.\");\n\n    Ember.run(function() {\n      App.destroy();\n    });\n  } finally {\n    Ember.TESTING_DEPRECATION = false;\n  }\n});\n\ntest(\"if no content is passed, and no 'else' is specified, nothing is rendered\", function() {\n  TemplateTests.CollectionTestView = Ember.CollectionView.extend({\n    tagName: 'ul',\n    content: Ember.A()\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#collection \"TemplateTests.CollectionTestView\"}} <aside></aside> {{/collection}}')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('li').length, 0, 'if no \"else\" is specified, nothing is rendered');\n});\n\ntest(\"if no content is passed, and 'else' is specified, the else block is rendered\", function() {\n  TemplateTests.CollectionTestView = Ember.CollectionView.extend({\n    tagName: 'ul',\n    content: Ember.A()\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#collection \"TemplateTests.CollectionTestView\"}} <aside></aside> {{ else }} <del></del> {{/collection}}')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('li:has(del)').length, 1, 'the else block is rendered');\n});\n\ntest(\"a block passed to a collection helper defaults to the content property of the context\", function() {\n  TemplateTests.CollectionTestView = Ember.CollectionView.extend({\n    tagName: 'ul',\n    content: Ember.A(['foo', 'bar', 'baz'])\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#collection \"TemplateTests.CollectionTestView\"}} <label>{{view.content}}</label> {{/collection}}')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('li:nth-child(1) label').length, 1);\n  equal(view.$('li:nth-child(1) label').text(), 'foo');\n  equal(view.$('li:nth-child(2) label').length, 1);\n  equal(view.$('li:nth-child(2) label').text(), 'bar');\n  equal(view.$('li:nth-child(3) label').length, 1);\n  equal(view.$('li:nth-child(3) label').text(), 'baz');\n});\n\ntest(\"a block passed to a collection helper defaults to the view\", function() {\n  TemplateTests.CollectionTestView = Ember.CollectionView.extend({\n    tagName: 'ul',\n    content: Ember.A(['foo', 'bar', 'baz'])\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#collection \"TemplateTests.CollectionTestView\"}} <label>{{view.content}}</label> {{/collection}}')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  // Preconds\n  equal(view.$('li:nth-child(1) label').length, 1);\n  equal(view.$('li:nth-child(1) label').text(), 'foo');\n  equal(view.$('li:nth-child(2) label').length, 1);\n  equal(view.$('li:nth-child(2) label').text(), 'bar');\n  equal(view.$('li:nth-child(3) label').length, 1);\n  equal(view.$('li:nth-child(3) label').text(), 'baz');\n\n  Ember.run(function() {\n    set(firstChild(view), 'content', Ember.A());\n  });\n  equal(view.$('label').length, 0, \"all list item views should be removed from DOM\");\n});\n\ntest(\"should include an id attribute if id is set in the options hash\", function() {\n  TemplateTests.CollectionTestView = Ember.CollectionView.extend({\n    tagName: 'ul',\n    content: Ember.A(['foo', 'bar', 'baz'])\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#collection \"TemplateTests.CollectionTestView\" id=\"baz\"}}foo{{/collection}}')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('ul#baz').length, 1, \"adds an id attribute\");\n});\n\ntest(\"should give its item views the class specified by itemClass\", function() {\n  TemplateTests.itemClassTestCollectionView = Ember.CollectionView.extend({\n    tagName: 'ul',\n    content: Ember.A(['foo', 'bar', 'baz'])\n  });\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#collection \"TemplateTests.itemClassTestCollectionView\" itemClass=\"baz\"}}foo{{/collection}}')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('ul li.baz').length, 3, \"adds class attribute\");\n});\n\ntest(\"should give its item views the classBinding specified by itemClassBinding\", function() {\n  TemplateTests.itemClassBindingTestCollectionView = Ember.CollectionView.extend({\n    tagName: 'ul',\n    content: Ember.A([Ember.Object.create({ isBaz: false }), Ember.Object.create({ isBaz: true }), Ember.Object.create({ isBaz: true })])\n  });\n\n  view = Ember.View.create({\n    isBar: true,\n    template: Ember.Handlebars.compile('{{#collection \"TemplateTests.itemClassBindingTestCollectionView\" itemClassBinding=\"view.isBar\"}}foo{{/collection}}')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('ul li.is-bar').length, 3, \"adds class on initial rendering\");\n\n  // NOTE: in order to bind an item's class to a property of the item itself (e.g. `isBaz` above), it will be necessary\n  // to introduce a new keyword that could be used from within `itemClassBinding`. For instance, `itemClassBinding=\"item.isBaz\"`.\n});\n\ntest(\"should give its item views the property specified by itemPropertyBinding\", function() {\n  Ember.TESTING_DEPRECATION = true;\n\n  try {\n    TemplateTests.itemPropertyBindingTestItemView = Ember.View.extend({\n      tagName: 'li'\n    });\n\n    // Use preserveContext=false so the itemView handlebars context is the view context\n    // Set itemView bindings using item*\n    view = Ember.View.create({\n      baz: \"baz\",\n      content: Ember.A([Ember.Object.create(), Ember.Object.create(), Ember.Object.create()]),\n      template: Ember.Handlebars.compile('{{#collection contentBinding=\"view.content\" tagName=\"ul\" itemViewClass=\"TemplateTests.itemPropertyBindingTestItemView\" itemPropertyBinding=\"view.baz\" preserveContext=false}}{{view.property}}{{/collection}}')\n    });\n\n    Ember.run(function() {\n      view.appendTo('#qunit-fixture');\n    });\n\n    equal(view.$('ul li').length, 3, \"adds 3 itemView\");\n\n    view.$('ul li').each(function(i, li){\n      equal(Ember.$(li).text(), \"baz\", \"creates the li with the property = baz\");\n    });\n\n    Ember.run(function() {\n      set(view, 'baz', \"yobaz\");\n    });\n\n    equal(view.$('ul li:first').text(), \"yobaz\", \"change property of sub view\");\n  } finally {\n    Ember.TESTING_DEPRECATION = false;\n  }\n});\n\ntest(\"should work inside a bound {{#if}}\", function() {\n  var testData = Ember.A([Ember.Object.create({ isBaz: false }), Ember.Object.create({ isBaz: true }), Ember.Object.create({ isBaz: true })]);\n  TemplateTests.ifTestCollectionView = Ember.CollectionView.extend({\n    tagName: 'ul',\n    content: testData\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#if view.shouldDisplay}}{{#collection \"TemplateTests.ifTestCollectionView\"}}{{content.isBaz}}{{/collection}}{{/if}}'),\n    shouldDisplay: true\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('ul li').length, 3, \"renders collection when conditional is true\");\n\n  Ember.run(function() { set(view, 'shouldDisplay', false); });\n  equal(view.$('ul li').length, 0, \"removes collection when conditional changes to false\");\n\n  Ember.run(function() { set(view, 'shouldDisplay', true); });\n  equal(view.$('ul li').length, 3, \"collection renders when conditional changes to true\");\n});\n\ntest(\"should pass content as context when using {{#each}} helper\", function() {\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#each view.releases}}Mac OS X {{version}}: {{name}} {{/each}}'),\n\n    releases: Ember.A([\n                { version: '10.7',\n                  name: 'Lion' },\n                { version: '10.6',\n                  name: 'Snow Leopard' },\n                { version: '10.5',\n                  name: 'Leopard' }\n              ])\n  });\n\n  Ember.run(function() { view.appendTo('#qunit-fixture'); });\n\n  equal(view.$().text(), \"Mac OS X 10.7: Lion Mac OS X 10.6: Snow Leopard Mac OS X 10.5: Leopard \", \"prints each item in sequence\");\n});\n\ntest(\"should re-render when the content object changes\", function() {\n  TemplateTests.RerenderTest = Ember.CollectionView.extend({\n    tagName: 'ul',\n    content: Ember.A()\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#collection TemplateTests.RerenderTest}}{{view.content}}{{/collection}}')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  Ember.run(function() {\n    set(firstChild(view), 'content', Ember.A(['bing', 'bat', 'bang']));\n  });\n\n  Ember.run(function() {\n    set(firstChild(view), 'content', Ember.A(['ramalamadingdong']));\n  });\n\n  equal(view.$('li').length, 1, \"rerenders with correct number of items\");\n  equal(trim(view.$('li:eq(0)').text()), \"ramalamadingdong\");\n\n});\n\ntest(\"select tagName on collection helper automatically sets child tagName to option\", function() {\n  TemplateTests.RerenderTest = Ember.CollectionView.extend({\n    content: Ember.A(['foo'])\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#collection TemplateTests.RerenderTest tagName=\"select\"}}{{view.content}}{{/collection}}')\n  });\n\n  Ember.run(function() {\n    view.appendTo('qunit-fixture');\n  });\n\n  equal(view.$('option').length, 1, \"renders the correct child tag name\");\n\n});\n\ntest(\"tagName works in the #collection helper\", function() {\n  TemplateTests.RerenderTest = Ember.CollectionView.extend({\n    content: Ember.A(['foo', 'bar'])\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#collection TemplateTests.RerenderTest tagName=\"ol\"}}{{view.content}}{{/collection}}')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('ol').length, 1, \"renders the correct tag name\");\n  equal(view.$('li').length, 2, \"rerenders with correct number of items\");\n\n  Ember.run(function() {\n    set(firstChild(view), 'content', Ember.A(['bing', 'bat', 'bang']));\n  });\n\n  equal(view.$('li').length, 3, \"rerenders with correct number of items\");\n  equal(trim(view.$('li:eq(0)').text()), \"bing\");\n});\n\ntest(\"should render nested collections\", function() {\n\n  TemplateTests.InnerList = Ember.CollectionView.extend({\n    tagName: 'ul',\n    content: Ember.A(['one','two','three'])\n  });\n\n  TemplateTests.OuterList = Ember.CollectionView.extend({\n    tagName: 'ul',\n    content: Ember.A(['foo'])\n  });\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#collection TemplateTests.OuterList class=\"outer\"}}{{content}}{{#collection TemplateTests.InnerList class=\"inner\"}}{{content}}{{/collection}}{{/collection}}')\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('ul.outer > li').length, 1, \"renders the outer list with correct number of items\");\n  equal(view.$('ul.inner').length, 1, \"the inner list exsits\");\n  equal(view.$('ul.inner > li').length, 3, \"renders the inner list with correct number of items\");\n\n});\n\ntest(\"should render multiple, bound nested collections (#68)\", function() {\n  var view;\n\n  Ember.run(function() {\n    TemplateTests.contentController = Ember.ArrayProxy.create({\n      content: Ember.A(['foo','bar'])\n    });\n\n    TemplateTests.InnerList = Ember.CollectionView.extend({\n      tagName: 'ul',\n      contentBinding: 'parentView.innerListContent'\n    });\n\n    TemplateTests.OuterListItem = Ember.View.extend({\n      template: Ember.Handlebars.compile('{{#collection TemplateTests.InnerList class=\"inner\"}}{{content}}{{/collection}}{{content}}'),\n      innerListContent: Ember.computed(function() {\n        return Ember.A([1,2,3]);\n      })\n    });\n\n    TemplateTests.OuterList = Ember.CollectionView.extend({\n      tagName: 'ul',\n      contentBinding: 'TemplateTests.contentController',\n      itemViewClass: TemplateTests.OuterListItem\n    });\n\n    view = Ember.View.create({\n      template: Ember.Handlebars.compile('{{collection TemplateTests.OuterList class=\"outer\"}}')\n    });\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('ul.outer > li').length, 2, \"renders the outer list with correct number of items\");\n  equal(view.$('ul.inner').length, 2, \"renders the correct number of inner lists\");\n  equal(view.$('ul.inner:first > li').length, 3, \"renders the first inner list with correct number of items\");\n  equal(view.$('ul.inner:last > li').length, 3, \"renders the second list with correct number of items\");\n\n  Ember.run(function() {\n    view.destroy();\n  });\n});\n\ntest(\"should allow view objects to be swapped out without throwing an error (#78)\", function() {\n  var view, dataset, secondDataset;\n\n  Ember.run(function() {\n    TemplateTests.datasetController = Ember.Object.create();\n\n    TemplateTests.ReportingView = Ember.View.extend({\n      datasetBinding: 'TemplateTests.datasetController.dataset',\n      readyBinding: 'dataset.ready',\n      itemsBinding: 'dataset.items',\n      template: Ember.Handlebars.compile(\"{{#if view.ready}}{{collection TemplateTests.CollectionView}}{{else}}Loading{{/if}}\")\n    });\n\n    TemplateTests.CollectionView = Ember.CollectionView.extend({\n      contentBinding: 'parentView.items',\n      tagName: 'ul',\n      template: Ember.Handlebars.compile(\"{{view.content}}\")\n    });\n\n    view = TemplateTests.ReportingView.create();\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$().text(), \"Loading\", \"renders the loading text when the dataset is not ready\");\n\n  Ember.run(function() {\n    dataset = Ember.Object.create({\n      ready: true,\n      items: Ember.A([1,2,3])\n    });\n    TemplateTests.datasetController.set('dataset',dataset);\n  });\n\n  equal(view.$('ul > li').length, 3, \"renders the collection with the correct number of items when the dataset is ready\");\n\n  Ember.run(function() {\n    secondDataset = Ember.Object.create({ready: false});\n    TemplateTests.datasetController.set('dataset',secondDataset);\n  });\n\n  equal(view.$().text(), \"Loading\", \"renders the loading text when the second dataset is not ready\");\n\n  Ember.run(function() {\n    view.destroy();\n  });\n});\n\ntest(\"context should be content\", function(){\n  var App, view;\n\n  Ember.run(function(){\n    lookup.App = App = Ember.Application.create();\n  });\n\n  App.items = Ember.A([\n    Ember.Object.create({name: 'Dave'}),\n    Ember.Object.create({name: 'Mary'}),\n    Ember.Object.create({name: 'Sara'})\n  ]);\n\n  App.AnItemView = Ember.View.extend({\n    template: Ember.Handlebars.compile(\"Greetings {{name}}\")\n  });\n\n  App.AView = Ember.View.extend({\n    template: Ember.Handlebars.compile('{{collection contentBinding=\"App.items\" itemViewClass=\"App.AnItemView\"}}')\n  });\n\n  Ember.run(function(){\n    view = App.AView.create();\n  });\n\n  Ember.run(function(){\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$().text(), \"Greetings DaveGreetings MaryGreetings Sara\");\n\n  Ember.run(function(){\n    view.destroy();\n    App.destroy();\n  });\n});\n\n})();\n//@ sourceURL=ember-handlebars/~tests/views/collection_view_test");minispade.register('ember-handlebars/~tests/views/metamorph_view_test', "(function() {var view, childView, metamorphView;\n\nmodule(\"Metamorph views\", {\n  setup: function() {\n    view = Ember.View.create({\n      render: function(buffer) {\n        buffer.push(\"<h1>View</h1>\");\n        this.appendChild(metamorphView);\n      }\n    });\n  },\n\n  teardown: function() {\n    Ember.run(function(){\n      view.destroy();\n      if (childView && !childView.isDestroyed) {\n        childView.destroy();\n      }\n\n      if (metamorphView && !metamorphView.isDestroyed) {\n        metamorphView.destroy();\n      }\n    });\n  }\n});\n\nvar get = Ember.get, set = Ember.set;\n\ntest(\"a Metamorph view is not a view's parentView\", function() {\n  childView = Ember.View.create({\n    render: function(buffer) {\n      buffer.push(\"<p>Bye bros</p>\");\n    }\n  });\n\n  metamorphView = Ember._MetamorphView.create({\n    render: function(buffer) {\n      buffer.push(\"<h2>Meta</h2>\");\n      this.appendChild(childView);\n    }\n  });\n\n  Ember.run(function() {\n    view.appendTo(\"#qunit-fixture\");\n  });\n\n  equal(get(childView, 'parentView'), view, \"A child of a metamorph view cannot see the metamorph view as its parent\");\n\n  var children = get(view, 'childViews');\n\n  equal(get(children, 'length'), 1, \"precond - there is only one child of the main node\");\n  equal(children.objectAt(0), childView, \"... and it is not the metamorph\");\n});\n\nmodule(\"Metamorph views correctly handle DOM\", {\n  setup: function() {\n    view = Ember.View.create({\n      render: function(buffer) {\n        buffer.push(\"<h1>View</h1>\");\n        this.appendChild(metamorphView);\n      }\n    });\n\n    metamorphView = Ember._MetamorphView.create({\n      powerRanger: \"Jason\",\n\n      render: function(buffer) {\n        buffer.push(\"<h2 id='from-meta'>\"+get(this, 'powerRanger')+\"</h2>\");\n      }\n    });\n\n    Ember.run(function() {\n      view.appendTo(\"#qunit-fixture\");\n    });\n  },\n\n  teardown: function() {\n    Ember.run(function(){\n      view.destroy();\n      if (!metamorphView.isDestroyed) {\n        metamorphView.destroy();\n      }\n    });\n  }\n});\n\ntest(\"a metamorph view generates without a DOM node\", function() {\n  var meta = Ember.$(\"> h2\", \"#\" + get(view, 'elementId'));\n\n  equal(meta.length, 1, \"The metamorph element should be directly inside its parent\");\n});\n\ntest(\"a metamorph view can be removed from the DOM\", function() {\n  Ember.run(function() {\n    metamorphView.destroy();\n  });\n\n  var meta = Ember.$('#from-morph');\n  equal(meta.length, 0, \"the associated DOM was removed\");\n});\n\ntest(\"a metamorph view can be rerendered\", function() {\n  equal(Ember.$('#from-meta').text(), \"Jason\", \"precond - renders to the DOM\");\n\n  set(metamorphView, 'powerRanger', 'Trini');\n  Ember.run(function() {\n    metamorphView.rerender();\n  });\n\n  equal(Ember.$('#from-meta').text(), \"Trini\", \"updates value when re-rendering\");\n});\n\n\n// Redefining without setup/teardown\nmodule(\"Metamorph views correctly handle DOM\");\n\ntest(\"a metamorph view calls its childrens' willInsertElement and didInsertElement\", function(){\n  var parentView;\n  var willInsertElementCalled = false;\n  var didInsertElementCalled = false;\n  var didInsertElementSawElement = false;\n\n  parentView = Ember.View.create({\n    ViewWithCallback: Ember.View.extend({\n      template: Ember.Handlebars.compile('<div id=\"do-i-exist\"></div>'),\n\n      willInsertElement: function(){\n        willInsertElementCalled = true;\n      },\n      didInsertElement: function(){\n        didInsertElementCalled = true;\n        didInsertElementSawElement = (this.$('div').length === 1);\n      }\n    }),\n\n    template: Ember.Handlebars.compile('{{#if view.condition}}{{view \"view.ViewWithCallback\"}}{{/if}}'),\n    condition: false\n  });\n\n  Ember.run(function() {\n    parentView.append();\n  });\n  Ember.run(function() {\n    parentView.set('condition', true);\n  });\n\n  ok(willInsertElementCalled, \"willInsertElement called\");\n  ok(didInsertElementCalled, \"didInsertElement called\");\n  ok(didInsertElementSawElement, \"didInsertElement saw element\");\n\n  Ember.run(function(){\n    parentView.destroy();\n  });\n\n});\n\ntest(\"replacing a Metamorph should invalidate childView elements\", function() {\n  var insertedElement;\n\n  view = Ember.View.create({\n    show: false,\n\n    CustomView: Ember.View.extend({\n      init: function() {\n        this._super();\n        // This will be called in preRender\n        // We want it to cache a null value\n        // Hopefully it will be invalidated when `show` is toggled\n        this.get('element');\n      },\n\n      didInsertElement: function(){\n        insertedElement = this.get('element');\n      }\n    }),\n\n    template: Ember.Handlebars.compile(\"{{#if view.show}}{{view view.CustomView}}{{/if}}\")\n  });\n\n  Ember.run(function(){ view.append(); });\n\n  Ember.run(function(){ view.set('show', true); });\n\n  ok(insertedElement, \"should have an element\");\n\n  Ember.run(function(){ view.destroy(); });\n});\n\ntest(\"trigger rerender of parent and SimpleHandlebarsView\", function () {\n  var view = Ember.View.create({\n    show: true,\n    foo: 'bar',\n    template: Ember.Handlebars.compile(\"{{#if view.show}}{{#if view.foo}}{{view.foo}}{{/if}}{{/if}}\")\n  });\n\n  Ember.run(function(){ view.append(); });\n\n  equal(view.$().text(), 'bar');\n\n  Ember.run(function(){\n    view.set('foo', 'baz'); // schedule render of simple bound\n    view.set('show', false); // destroy tree\n  });\n\n  equal(view.$().text(), '');\n\n  Ember.run(function() {\n    view.destroy();\n  });\n});\n\ntest(\"re-rendering and then changing the property does not raise an exception\", function() {\n  view = Ember.View.create({\n    show: true,\n    foo: 'bar',\n    metamorphView: Ember._MetamorphView,\n    template: Ember.Handlebars.compile(\"{{#view view.metamorphView}}truth{{/view}}\")\n  });\n\n  Ember.run(function(){ view.appendTo('#qunit-fixture'); });\n\n  equal(view.$().text(), 'truth');\n\n  Ember.run(function(){\n    view.get('_childViews')[0].rerender();\n    view.get('_childViews')[0].rerender();\n  });\n\n  equal(view.$().text(), 'truth');\n\n  Ember.run(function() {\n    view.destroy();\n  });\n});\n\n})();\n//@ sourceURL=ember-handlebars/~tests/views/metamorph_view_test");minispade.register('ember-metal/~tests/accessors/getPath_test', "(function() {/*globals Foo:true $foo:true */\n\nvar obj, moduleOpts = {\n  setup: function() {\n    obj = {\n      foo: {\n        bar: {\n          baz: { biff: 'BIFF' }\n        }\n      }\n\n    };\n\n    window.Foo = {\n      bar: {\n        baz: { biff: 'FooBiff' }\n      }\n    };\n\n    window.$foo = {\n      bar: {\n        baz: { biff: '$FOOBIFF' }\n      }\n    };\n  },\n\n  teardown: function() {\n    obj = undefined;\n    window.Foo = undefined;\n    window.$foo = undefined;\n  }\n};\n\nmodule('Ember.get with path', moduleOpts);\n\n// ..........................................................\n// LOCAL PATHS\n//\n\ntest('[obj, foo] -> obj.foo', function() {\n  deepEqual(Ember.get(obj, 'foo'), obj.foo);\n});\n\ntest('[obj, foo.bar] -> obj.foo.bar', function() {\n  deepEqual(Ember.get(obj, 'foo.bar'), obj.foo.bar);\n});\n\ntest('[obj, this.foo] -> obj.foo', function() {\n  deepEqual(Ember.get(obj, 'this.foo'), obj.foo);\n});\n\ntest('[obj, this.foo.bar] -> obj.foo.bar', function() {\n  deepEqual(Ember.get(obj, 'this.foo.bar'), obj.foo.bar);\n});\n\ntest('[obj, this.Foo.bar] -> (null)', function() {\n  deepEqual(Ember.get(obj, 'this.Foo.bar'), undefined);\n});\n\n// ..........................................................\n// NO TARGET\n//\n\ntest('[null, Foo] -> Foo', function() {\n  deepEqual(Ember.get('Foo'), Foo);\n});\n\ntest('[null, Foo.bar] -> Foo.bar', function() {\n  deepEqual(Ember.get('Foo.bar'), Foo.bar);\n});\n\n\n})();\n//@ sourceURL=ember-metal/~tests/accessors/getPath_test");minispade.register('ember-metal/~tests/accessors/get_test', "(function() {minispade.require('ember-metal/~tests/props_helper');\n\nmodule('Ember.get');\n\ntest('should get arbitrary properties on an object', function() {\n  var obj = {\n    string: 'string',\n    number: 23,\n    boolTrue: true,\n    boolFalse: false,\n    nullValue: null\n  };\n\n  for(var key in obj) {\n    if (!obj.hasOwnProperty(key)) continue;\n    equal(Ember.get(obj, key), obj[key], key);\n  }\n\n});\n\ntestBoth(\"should call unknownProperty on watched values if the value is undefined\", function(get, set) {\n  var obj = {\n    count: 0,\n    unknownProperty: function(key) {\n      equal(key, 'foo', \"should pass key\");\n      this.count++;\n      return \"FOO\";\n    }\n  };\n\n  var count = 0;\n  Ember.addObserver(obj, 'foo', function() {\n    count++;\n  });\n\n  equal(get(obj, 'foo'), 'FOO', 'should return value from unknown');\n});\n\ntest('warn on attempts to get a property of undefined', function(){\n  raises(function() {\n    Ember.get(undefined, 'aProperty');\n  });\n});\n\ntest('warn on attempts to get a property path of undefined', function(){\n  raises(function() {\n    Ember.get(undefined, 'aProperty.on.aPath');\n  });\n});\n\n// ..........................................................\n// BUGS\n//\n\ntest('(regression) watched properties on unmodified inherited objects should still return their original value', function() {\n\n  var MyMixin = Ember.Mixin.create({\n    someProperty: 'foo',\n    propertyDidChange: Ember.observer(function() {\n      // NOTHING TO DO\n    }, 'someProperty')\n  });\n\n  var baseObject = MyMixin.apply({});\n  var theRealObject = Ember.create(baseObject);\n\n  equal(Ember.get(theRealObject, 'someProperty'), 'foo', 'should return the set value, not false');\n});\n\nmodule(\"Ember.getWithDefault\");\n\ntest('should get arbitrary properties on an object', function() {\n  var obj = {\n    string: 'string',\n    number: 23,\n    boolTrue: true,\n    boolFalse: false,\n    nullValue: null\n  };\n\n  for(var key in obj) {\n    if (!obj.hasOwnProperty(key)) continue;\n    equal(Ember.getWithDefault(obj, key, \"fail\"), obj[key], key);\n  }\n\n  obj = {\n    undef: undefined\n  };\n\n  equal(Ember.getWithDefault(obj, \"undef\", \"default\"), \"default\", \"explicit undefined retrieves the default\");\n  equal(Ember.getWithDefault(obj, \"not-present\", \"default\"), \"default\", \"non-present key retrieves the default\");\n});\n\ntest('should call unknownProperty if defined and value is undefined', function() {\n\n  var obj = {\n    count: 0,\n    unknownProperty: function(key) {\n      equal(key, 'foo', 'should pass key');\n      this.count++;\n      return 'FOO';\n    }\n  };\n\n  equal(Ember.get(obj, 'foo'), 'FOO', 'should return value from unknown');\n  equal(obj.count, 1, 'should have invoked');\n});\n\ntestBoth(\"if unknownProperty is present, it is called\", function(get, set) {\n  var obj = {\n    count: 0,\n    unknownProperty: function(key) {\n      if (key === \"foo\") {\n        equal(key, 'foo', \"should pass key\");\n        this.count++;\n        return \"FOO\";\n      }\n    }\n  };\n\n  var count = 0;\n  Ember.addObserver(obj, 'foo', function() {\n    count++;\n  });\n\n  equal(Ember.getWithDefault(obj, 'foo', \"fail\"), 'FOO', 'should return value from unknownProperty');\n  equal(Ember.getWithDefault(obj, 'bar', \"default\"), 'default', 'should convert undefined from unknownProperty into default');\n});\n\n// ..........................................................\n// BUGS\n//\n\ntest('(regression) watched properties on unmodified inherited objects should still return their original value', function() {\n\n  var MyMixin = Ember.Mixin.create({\n    someProperty: 'foo',\n    propertyDidChange: Ember.observer(function() {\n      // NOTHING TO DO\n    }, 'someProperty')\n  });\n\n  var baseObject = MyMixin.apply({});\n  var theRealObject = Ember.create(baseObject);\n\n  equal(Ember.getWithDefault(theRealObject, 'someProperty', \"fail\"), 'foo', 'should return the set value, not false');\n});\n\n\n})();\n//@ sourceURL=ember-metal/~tests/accessors/get_test");minispade.register('ember-metal/~tests/accessors/isGlobalPath_test', "(function() {module('Ember.isGlobalPath');\n\ntest(\"global path's are recognized\", function(){\n  ok( Ember.isGlobalPath('App.myProperty') );\n  ok( Ember.isGlobalPath('App.myProperty.subProperty') );\n});\n\ntest(\"if there is a 'this' in the path, it's not a global path\", function(){\n  ok( !Ember.isGlobalPath('this.myProperty') );\n  ok( !Ember.isGlobalPath('this') );\n});\n\ntest(\"if the path starts with a lowercase character, it is not a global path\", function(){\n  ok( !Ember.isGlobalPath('myObj') );\n  ok( !Ember.isGlobalPath('myObj.SecondProperty') );\n});\n})();\n//@ sourceURL=ember-metal/~tests/accessors/isGlobalPath_test");minispade.register('ember-metal/~tests/accessors/normalizeTuple_test', "(function() {/*globals Foo:true $foo:true */\n\nvar obj, moduleOpts = {\n  setup: function() {\n    obj = {\n      foo: {\n        bar: {\n          baz: {}\n        }\n      }\n    };\n\n    window.Foo = {\n      bar: {\n        baz: {}\n      }\n    };\n\n    window.$foo = {\n      bar: {\n        baz: {}\n      }\n    };\n  },\n\n  teardown: function() {\n    obj = undefined;\n    window.Foo = undefined;\n    window.$foo = undefined;\n  }\n};\n\nmodule('Ember.normalizeTuple', moduleOpts);\n\n// ..........................................................\n// LOCAL PATHS\n//\n\ntest('[obj, foo] -> [obj, foo]', function() {\n  deepEqual(Ember.normalizeTuple(obj, 'foo'), [obj, 'foo']);\n});\n\ntest('[obj, *] -> [obj, *]', function() {\n  deepEqual(Ember.normalizeTuple(obj, '*'), [obj, '*']);\n});\n\ntest('[obj, foo.bar] -> [obj, foo.bar]', function() {\n  deepEqual(Ember.normalizeTuple(obj, 'foo.bar'), [obj, 'foo.bar']);\n});\n\ntest('[obj, foo.*] -> [obj, foo.*]', function() {\n  deepEqual(Ember.normalizeTuple(obj, 'foo.*'), [obj, 'foo.*']);\n});\n\ntest('[obj, foo.*.baz] -> [obj, foo.*.baz]', function() {\n  deepEqual(Ember.normalizeTuple(obj, 'foo.*.baz'), [obj, 'foo.*.baz']);\n});\n\ntest('[obj, this.foo] -> [obj, foo]', function() {\n  deepEqual(Ember.normalizeTuple(obj, 'this.foo'), [obj, 'foo']);\n});\n\ntest('[obj, this.foo.bar] -> [obj, foo.bar]', function() {\n  deepEqual(Ember.normalizeTuple(obj, 'this.foo.bar'), [obj, 'foo.bar']);\n});\n\ntest('[obj, .foo.bar] -> [obj, foo.bar]', function() {\n  deepEqual(Ember.normalizeTuple(obj, 'this.foo.bar'), [obj, 'foo.bar']);\n});\n\ntest('[obj, this.Foo.bar] -> [obj, Foo.bar]', function() {\n  deepEqual(Ember.normalizeTuple(obj, 'this.Foo.bar'), [obj, 'Foo.bar']);\n});\n\n// ..........................................................\n// GLOBAL PATHS\n//\n\ntest('[obj, Foo] -> [obj, Foo]', function() {\n  deepEqual(Ember.normalizeTuple(obj, 'Foo'), [obj, 'Foo']);\n});\n\ntest('[obj, Foo.bar] -> [Foo, bar]', function() {\n  deepEqual(Ember.normalizeTuple(obj, 'Foo.bar'), [Foo, 'bar']);\n});\n\ntest('[obj, $foo.bar.baz] -> [$foo, bar.baz]', function() {\n  deepEqual(Ember.normalizeTuple(obj, '$foo.bar.baz'), [$foo, 'bar.baz']);\n});\n\n// ..........................................................\n// NO TARGET\n//\n\ntest('[null, Foo] -> EXCEPTION', function() {\n  raises(function() {\n    Ember.normalizeTuple(null, 'Foo');\n  }, Error);\n});\n\ntest('[null, Foo.bar] -> [Foo, bar]', function() {\n  deepEqual(Ember.normalizeTuple(null, 'Foo.bar'), [Foo, 'bar']);\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/accessors/normalizeTuple_test");minispade.register('ember-metal/~tests/accessors/setPath_test', "(function() {var originalLookup = Ember.lookup;\n\nvar obj, moduleOpts = {\n  setup: function() {\n    obj = {\n      foo: {\n        bar: {\n          baz: { biff: 'BIFF' }\n        }\n      }\n\n    };\n\n    Ember.lookup = {\n      Foo: {\n        bar: {\n          baz: { biff: 'FooBiff' }\n        }\n      },\n\n      $foo: {\n        bar: {\n          baz: { biff: '$FOOBIFF' }\n        }\n      }\n    };\n  },\n\n  teardown: function() {\n    obj = null;\n    Ember.lookup = originalLookup;\n  }\n};\n\nmodule('Ember.set with path', moduleOpts);\n\ntest('[Foo, bar] -> Foo.bar', function() {\n  Ember.lookup.Foo = {toString: function() { return 'Foo'; }}; // Behave like an Ember.Namespace\n\n  Ember.set(Ember.lookup.Foo, 'bar', 'baz');\n  equal(Ember.get(Ember.lookup.Foo, 'bar'), 'baz');\n});\n\n// ..........................................................\n// LOCAL PATHS\n//\n\ntest('[obj, foo] -> obj.foo', function() {\n  Ember.set(obj, 'foo', \"BAM\");\n  equal(Ember.get(obj, 'foo'), \"BAM\");\n});\n\ntest('[obj, foo.bar] -> obj.foo.bar', function() {\n  Ember.set(obj, 'foo.bar', \"BAM\");\n  equal(Ember.get(obj, 'foo.bar'), \"BAM\");\n});\n\ntest('[obj, this.foo] -> obj.foo', function() {\n  Ember.set(obj, 'this.foo', \"BAM\");\n  equal(Ember.get(obj, 'foo'), \"BAM\");\n});\n\ntest('[obj, this.foo.bar] -> obj.foo.bar', function() {\n  Ember.set(obj, 'this.foo.bar', \"BAM\");\n  equal(Ember.get(obj, 'foo.bar'), \"BAM\");\n});\n\n// ..........................................................\n// NO TARGET\n//\n\ntest('[null, Foo.bar] -> Foo.bar', function() {\n  Ember.set(null, 'Foo.bar', \"BAM\");\n  equal(Ember.get(Ember.lookup.Foo, 'bar'), \"BAM\");\n});\n\n// ..........................................................\n// DEPRECATED\n//\n\nmodule(\"Ember.set with path - deprecated\", {\n  setup: function() {\n    Ember.TESTING_DEPRECATION = true;\n    moduleOpts.setup();\n  },\n  teardown: function() {\n    Ember.TESTING_DEPRECATION = false;\n    moduleOpts.teardown();\n  }\n});\n\ntest('[obj, foo.baz.bat] -> EXCEPTION', function() {\n  raises(function() {\n    Ember.set(obj, 'foo.baz.bat', \"BAM\");\n  }, Error);\n});\n\ntest('[obj, foo.baz.bat] -> EXCEPTION', function() {\n  Ember.trySet(obj, 'foo.baz.bat', \"BAM\");\n  ok(true, \"does not raise\");\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/accessors/setPath_test");minispade.register('ember-metal/~tests/accessors/set_test', "(function() {module('Ember.set');\n\ntest('should set arbitrary properties on an object', function() {\n  var obj = {\n    string: 'string',\n    number: 23,\n    boolTrue: true,\n    boolFalse: false,\n    nullValue: null\n  };\n\n  var newObj = {};\n\n  for(var key in obj) {\n    if (!obj.hasOwnProperty(key)) continue;\n    equal(Ember.set(newObj, key, obj[key]), obj[key], 'should return value');\n    equal(Ember.get(newObj, key), obj[key], 'should set value');\n  }\n\n});\n\ntest('should call setUnknownProperty if defined and value is undefined', function() {\n\n  var obj = {\n    count: 0,\n\n    unknownProperty: function(key, value) {\n      ok(false, 'should not invoke unknownProperty is setUnknownProperty is defined');\n    },\n\n    setUnknownProperty: function(key, value) {\n      equal(key, 'foo', 'should pass key');\n      equal(value, 'BAR', 'should pass key');\n      this.count++;\n      return 'FOO';\n    }\n  };\n\n  equal(Ember.set(obj, 'foo', \"BAR\"), 'BAR', 'should return set value');\n  equal(obj.count, 1, 'should have invoked');\n});\n\n\n})();\n//@ sourceURL=ember-metal/~tests/accessors/set_test");minispade.register('ember-metal/~tests/binding/connect_test', "(function() {/*globals GlobalA:true GlobalB:true */\nminispade.require('ember-metal/~tests/props_helper');\n\nvar previousPreventRunloop;\n\nfunction performTest(binding, a, b, get, set, connect) {\n  if (connect === undefined) connect = function(){binding.connect(a);};\n\n  ok(!Ember.run.currentRunLoop, 'performTest should not have a currentRunLoop');\n\n  equal(get(a, 'foo'), 'FOO', 'a should not have changed');\n  equal(get(b, 'bar'), 'BAR', 'b should not have changed');\n\n  connect();\n\n  equal(get(a, 'foo'), 'BAR', 'a should have changed');\n  equal(get(b, 'bar'), 'BAR', 'b should have changed');\n  //\n  // make sure changes sync both ways\n  Ember.run(function () {\n    set(b, 'bar', 'BAZZ');\n  });\n  equal(get(a, 'foo'), 'BAZZ', 'a should have changed');\n\n  Ember.run(function () {\n    set(a, 'foo', 'BARF');\n  });\n  equal(get(b, 'bar'), 'BARF', 'a should have changed');\n}\n\nmodule(\"Ember.Binding\");\n\ntestBoth('Connecting a binding between two properties', function(get, set) {\n  var a = { foo: 'FOO', bar: 'BAR' };\n\n  // a.bar -> a.foo\n  var binding = new Ember.Binding('foo', 'bar');\n\n  performTest(binding, a, a, get, set);\n});\n\ntestBoth('Connecting a binding between two objects', function(get, set) {\n  var b = { bar: 'BAR' };\n  var a = { foo: 'FOO', b: b };\n\n  // b.bar -> a.foo\n  var binding = new Ember.Binding('foo', 'b.bar');\n\n  performTest(binding, a, b, get, set);\n});\n\ntestBoth('Connecting a binding to path', function(get, set) {\n  var a = { foo: 'FOO' };\n  GlobalB = {\n    b: { bar: 'BAR' }\n  };\n\n  var b = get(GlobalB, 'b');\n\n  // globalB.b.bar -> a.foo\n  var binding = new Ember.Binding('foo', 'GlobalB.b.bar');\n\n  performTest(binding, a, b, get, set);\n\n  // make sure modifications update\n  b = { bar: 'BIFF' };\n\n  Ember.run(function(){\n    set(GlobalB, 'b', b);\n  });\n\n  equal(get(a, 'foo'), 'BIFF', 'a should have changed');\n\n});\n\ntestBoth('Calling connect more than once', function(get, set) {\n  var b = { bar: 'BAR' };\n  var a = { foo: 'FOO', b: b };\n\n  // b.bar -> a.foo\n  var binding = new Ember.Binding('foo', 'b.bar');\n\n  performTest(binding, a, b, get, set, function () {\n    binding.connect(a);\n\n    binding.connect(a);\n  });\n});\n\ntestBoth('Bindings should be inherited', function(get, set) {\n\n  var a = { foo: 'FOO', b: { bar: 'BAR' } };\n  var binding = new Ember.Binding('foo', 'b.bar');\n  var a2;\n\n  Ember.run(function () {\n    binding.connect(a);\n\n    a2 = Ember.create(a);\n    Ember.rewatch(a2);\n  });\n\n  equal(get(a2, 'foo'), \"BAR\", \"Should have synced binding on child\");\n  equal(get(a,  'foo'), \"BAR\", \"Should NOT have synced binding on parent\");\n\n  Ember.run(function () {\n    set(a2, 'b', { bar: 'BAZZ' });\n  });\n\n  equal(get(a2, 'foo'), \"BAZZ\", \"Should have synced binding on child\");\n  equal(get(a,  'foo'), \"BAR\", \"Should NOT have synced binding on parent\");\n\n});\n\ntest('inherited bindings should sync on create', function() {\n  var a;\n  Ember.run(function () {\n    var A = function() {\n      Ember.bind(this, 'foo', 'bar.baz');\n    };\n\n    a = new A();\n    Ember.set(a, 'bar', { baz: 'BAZ' });\n  });\n\n  equal(Ember.get(a, 'foo'), 'BAZ', 'should have synced binding on new obj');\n});\n\n\n})();\n//@ sourceURL=ember-metal/~tests/binding/connect_test");minispade.register('ember-metal/~tests/binding/oneWay_test', "(function() {/*globals MyApp:true */\n\nmodule('system/mixin/binding/oneWay_test', {\n  setup: function() {\n    MyApp = {\n      foo: { value: 'FOO' },\n      bar: { value: 'BAR' }\n    };\n  },\n\n  teardown: function() {\n    MyApp = null;\n  }\n});\n\ntest('oneWay(true) should only sync one way', function() {\n  var binding;\n  Ember.run(function(){\n    binding = Ember.oneWay(MyApp, 'bar.value', 'foo.value');\n  });\n\n  equal(Ember.get('MyApp.foo.value'), 'FOO', 'foo synced');\n  equal(Ember.get('MyApp.bar.value'), 'FOO', 'bar synced');\n\n  Ember.run(function(){\n    Ember.set('MyApp.bar.value', 'BAZ');\n  });\n\n  equal(Ember.get('MyApp.foo.value'), 'FOO', 'foo synced');\n  equal(Ember.get('MyApp.bar.value'), 'BAZ', 'bar not synced');\n\n  Ember.run(function(){\n    Ember.set('MyApp.foo.value', 'BIFF');\n  });\n\n  equal(Ember.get('MyApp.foo.value'), 'BIFF', 'foo synced');\n  equal(Ember.get('MyApp.bar.value'), 'BIFF', 'foo synced');\n\n});\n\n\n})();\n//@ sourceURL=ember-metal/~tests/binding/oneWay_test");minispade.register('ember-metal/~tests/binding/sync_test', "(function() {module(\"system/binding/sync_test.js\");\n\ntestBoth(\"bindings should not sync twice in a single run loop\", function(get, set) {\n  var a, b, setValue, setCalled=0, getCalled=0;\n\n  Ember.run(function() {\n    a = {};\n\n    Ember.defineProperty(a, 'foo', Ember.computed(function(key, value) {\n      if (arguments.length === 2) {\n        setCalled++;\n        setValue = value;\n        return value;\n      } else {\n        getCalled++;\n        return setValue;\n      }\n    }).volatile());\n\n    b = {\n      a: a\n    };\n    Ember.bind(b, 'foo', 'a.foo');\n  });\n\n  // reset after initial binding synchronization\n  getCalled = 0;\n\n  Ember.run(function() {\n    set(a, 'foo', 'trollface');\n  });\n\n  equal(get(b, 'foo'), \"trollface\", \"the binding should sync\");\n  equal(setCalled, 1, \"Set should only be called once\");\n  equal(getCalled, 1, \"Get should only be called once\");\n});\n\ntestBoth(\"bindings should not infinite loop if computed properties return objects\", function(get, set) {\n  var a, b, getCalled=0;\n\n  Ember.run(function() {\n    a = {};\n\n    Ember.defineProperty(a, 'foo', Ember.computed(function() {\n      getCalled++;\n      if (getCalled > 1000) {\n        throw 'infinite loop detected';\n      }\n      return ['foo', 'bar'];\n    }));\n\n    b = {\n      a: a\n    };\n    Ember.bind(b, 'foo', 'a.foo');\n  });\n\n  deepEqual(get(b, 'foo'), ['foo', 'bar'], \"the binding should sync\");\n  equal(getCalled, 1, \"Get should only be called once\");\n});\n\ntestBoth(\"bindings should do the right thing when observers trigger bindings in the opposite direction\", function(get, set) {\n  var a, b, c;\n\n  Ember.run(function() {\n    a = {\n      foo: 'trololol'\n    };\n\n    b = {\n      a: a\n    };\n    Ember.bind(b, 'foo', 'a.foo');\n\n    c = {\n      a: a\n    };\n    Ember.bind(c, 'foo', 'a.foo');\n  });\n\n  Ember.addObserver(b, 'foo', function() {\n    set(c, 'foo', \"what is going on\");\n  });\n\n  Ember.run(function() {\n    set(a, 'foo', 'trollface');\n  });\n\n  equal(get(a, 'foo'), \"what is going on\");\n});\n\ntestBoth(\"bindings should do the right thing when binding is in prototype\", function(get, set) {\n  var obj, proto, a, b, selectionChanged;\n  Ember.run(function() {\n    obj = {\n      selection: null\n    };\n\n    selectionChanged = 0;\n\n    Ember.addObserver(obj, 'selection', function () {\n      selectionChanged++;\n    });\n\n    proto = {\n      obj: obj,\n      changeSelection: function (value) {\n        set(this, 'selection', value);\n      }\n    };\n    Ember.bind(proto, 'selection', 'obj.selection');\n\n    a = Ember.create(proto);\n    b = Ember.create(proto);\n    Ember.rewatch(a);\n    Ember.rewatch(b);\n  });\n\n  Ember.run(function () {\n    set(a, 'selection', 'a');\n  });\n\n  Ember.run(function () {\n    set(b, 'selection', 'b');\n  });\n\n  Ember.run(function () {\n    set(a, 'selection', 'a');\n  });\n\n  equal(selectionChanged, 3);\n  equal(get(obj, 'selection'), 'a');\n});\n\ntestBoth(\"bindings should not try to sync destroyed objects\", function(get, set) {\n  var a, b;\n\n  Ember.run(function() {\n    a = {\n      foo: 'trololol'\n    };\n\n    b = {\n      a: a\n    };\n    Ember.bind(b, 'foo', 'a.foo');\n  });\n\n  Ember.run(function() {\n    set(a, 'foo', 'trollface');\n    set(b, 'isDestroyed', true);\n    ok(true, \"should not raise\");\n  });\n\n  Ember.run(function() {\n    a = {\n      foo: 'trololol'\n    };\n\n    b = {\n      a: a\n    };\n    Ember.bind(b, 'foo', 'a.foo');\n  });\n\n  Ember.run(function() {\n    set(b, 'foo', 'trollface');\n    set(a, 'isDestroyed', true);\n    ok(true, \"should not raise\");\n  });\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/binding/sync_test");minispade.register('ember-metal/~tests/computed_test', "(function() {/*globals Global:true */\nminispade.require('ember-metal/~tests/props_helper');\n\nvar obj, count;\n\nmodule('Ember.computed');\n\ntest('computed property should be an instance of descriptor', function() {\n  ok(Ember.computed(function() {}) instanceof Ember.Descriptor);\n});\n\ntest('defining computed property should invoke property on get', function() {\n\n  var obj = {};\n  var count = 0;\n  Ember.defineProperty(obj, 'foo', Ember.computed(function(key) {\n    count++;\n    return 'computed '+key;\n  }));\n\n  equal(Ember.get(obj, 'foo'), 'computed foo', 'should return value');\n  equal(count, 1, 'should have invoked computed property');\n});\n\ntest('defining computed property should invoke property on set', function() {\n\n  var obj = {};\n  var count = 0;\n  Ember.defineProperty(obj, 'foo', Ember.computed(function(key, value) {\n    if (value !== undefined) {\n      count++;\n      this['__'+key] = 'computed '+value;\n    }\n    return this['__'+key];\n  }));\n\n  equal(Ember.set(obj, 'foo', 'bar'), 'bar', 'should return set value');\n  equal(count, 1, 'should have invoked computed property');\n  equal(Ember.get(obj, 'foo'), 'computed bar', 'should return new value');\n});\n\nvar objA, objB;\nmodule('Ember.computed should inherit through prototype', {\n  setup: function() {\n    objA = { __foo: 'FOO' } ;\n    Ember.defineProperty(objA, 'foo', Ember.computed(function(key, value) {\n      if (value !== undefined) {\n        this['__'+key] = 'computed '+value;\n      }\n      return this['__'+key];\n    }));\n\n    objB = Ember.create(objA);\n    objB.__foo = 'FOO'; // make a copy;\n  },\n\n  teardown: function() {\n    objA = objB = null;\n  }\n});\n\ntestBoth('using get() and set()', function(get, set) {\n  equal(get(objA, 'foo'), 'FOO', 'should get FOO from A');\n  equal(get(objB, 'foo'), 'FOO', 'should get FOO from B');\n\n  set(objA, 'foo', 'BIFF');\n  equal(get(objA, 'foo'), 'computed BIFF', 'should change A');\n  equal(get(objB, 'foo'), 'FOO', 'should NOT change B');\n\n  set(objB, 'foo', 'bar');\n  equal(get(objB, 'foo'), 'computed bar', 'should change B');\n  equal(get(objA, 'foo'), 'computed BIFF', 'should NOT change A');\n\n  set(objA, 'foo', 'BAZ');\n  equal(get(objA, 'foo'), 'computed BAZ', 'should change A');\n  equal(get(objB, 'foo'), 'computed bar', 'should NOT change B');\n});\n\nmodule('redefining computed property to normal', {\n  setup: function() {\n    objA = { __foo: 'FOO' } ;\n    Ember.defineProperty(objA, 'foo', Ember.computed(function(key, value) {\n      if (value !== undefined) {\n        this['__'+key] = 'computed '+value;\n      }\n      return this['__'+key];\n    }));\n\n    objB = Ember.create(objA);\n    Ember.defineProperty(objB, 'foo'); // make this just a normal property.\n  },\n\n  teardown: function() {\n    objA = objB = null;\n  }\n});\n\ntestBoth('using get() and set()', function(get, set) {\n  equal(get(objA, 'foo'), 'FOO', 'should get FOO from A');\n  equal(get(objB, 'foo'), undefined, 'should get undefined from B');\n\n  set(objA, 'foo', 'BIFF');\n  equal(get(objA, 'foo'), 'computed BIFF', 'should change A');\n  equal(get(objB, 'foo'), undefined, 'should NOT change B');\n\n  set(objB, 'foo', 'bar');\n  equal(get(objB, 'foo'), 'bar', 'should change B');\n  equal(get(objA, 'foo'), 'computed BIFF', 'should NOT change A');\n\n  set(objA, 'foo', 'BAZ');\n  equal(get(objA, 'foo'), 'computed BAZ', 'should change A');\n  equal(get(objB, 'foo'), 'bar', 'should NOT change B');\n});\n\nmodule('redefining computed property to another property', {\n  setup: function() {\n    objA = { __foo: 'FOO' } ;\n    Ember.defineProperty(objA, 'foo', Ember.computed(function(key, value) {\n      if (value !== undefined) {\n        this['__'+key] = 'A '+value;\n      }\n      return this['__'+key];\n    }));\n\n    objB = Ember.create(objA);\n    objB.__foo = 'FOO';\n    Ember.defineProperty(objB, 'foo', Ember.computed(function(key, value) {\n      if (value !== undefined) {\n        this['__'+key] = 'B '+value;\n      }\n      return this['__'+key];\n    }));\n  },\n\n  teardown: function() {\n    objA = objB = null;\n  }\n});\n\ntestBoth('using get() and set()', function(get, set) {\n  equal(get(objA, 'foo'), 'FOO', 'should get FOO from A');\n  equal(get(objB, 'foo'), 'FOO', 'should get FOO from B');\n\n  set(objA, 'foo', 'BIFF');\n  equal(get(objA, 'foo'), 'A BIFF', 'should change A');\n  equal(get(objB, 'foo'), 'FOO', 'should NOT change B');\n\n  set(objB, 'foo', 'bar');\n  equal(get(objB, 'foo'), 'B bar', 'should change B');\n  equal(get(objA, 'foo'), 'A BIFF', 'should NOT change A');\n\n  set(objA, 'foo', 'BAZ');\n  equal(get(objA, 'foo'), 'A BAZ', 'should change A');\n  equal(get(objB, 'foo'), 'B bar', 'should NOT change B');\n});\n\nmodule('Ember.computed - metadata');\n\ntest(\"can set metadata on a computed property\", function() {\n  var computedProperty = Ember.computed(function() { });\n  computedProperty.meta({ key: 'keyValue' });\n\n  equal(computedProperty.meta().key, 'keyValue', \"saves passed meta hash to the _meta property\");\n});\n\ntest(\"meta should return an empty hash if no meta is set\", function() {\n  var computedProperty = Ember.computed(function() { });\n  deepEqual(computedProperty.meta(), {}, \"returned value is an empty hash\");\n});\n\n// ..........................................................\n// CACHEABLE\n//\n\nmodule('Ember.computed - cacheable', {\n  setup: function() {\n    obj = {};\n    count = 0;\n    Ember.defineProperty(obj, 'foo', Ember.computed(function(key, value) {\n      count++;\n      return 'bar '+count;\n    }));\n  },\n\n  teardown: function() {\n    obj = count = null;\n  }\n});\n\ntestBoth('cacheable should cache', function(get, set) {\n  equal(get(obj, 'foo'), 'bar 1', 'first get');\n  equal(get(obj, 'foo'), 'bar 1', 'second get');\n  equal(count, 1, 'should only invoke once');\n});\n\ntestBoth('modifying a cacheable property should update cache', function(get, set) {\n  equal(get(obj, 'foo'), 'bar 1', 'first get');\n  equal(get(obj, 'foo'), 'bar 1', 'second get');\n\n  equal(set(obj, 'foo', 'baz'), 'baz', 'setting');\n  equal(get(obj, 'foo'), 'bar 2', 'third get');\n  equal(count, 2, 'should not invoke again');\n});\n\ntestBoth('inherited property should not pick up cache', function(get, set) {\n  var objB = Ember.create(obj);\n\n  equal(get(obj, 'foo'), 'bar 1', 'obj first get');\n  equal(get(objB, 'foo'), 'bar 2', 'objB first get');\n\n  equal(get(obj, 'foo'), 'bar 1', 'obj second get');\n  equal(get(objB, 'foo'), 'bar 2', 'objB second get');\n\n  set(obj, 'foo', 'baz'); // modify A\n  equal(get(obj, 'foo'), 'bar 3', 'obj third get');\n  equal(get(objB, 'foo'), 'bar 2', 'objB third get');\n});\n\ntestBoth('cacheFor should return the cached value', function(get, set) {\n  equal(Ember.cacheFor(obj, 'foo'), undefined, \"should not yet be a cached value\");\n\n  get(obj, 'foo');\n\n  equal(Ember.cacheFor(obj, 'foo'), \"bar 1\", \"should retrieve cached value\");\n});\n\ntestBoth('cacheFor should return falsy cached values', function(get, set) {\n\n  Ember.defineProperty(obj, 'falsy', Ember.computed(function() {\n    return false;\n  }));\n\n  equal(Ember.cacheFor(obj, 'falsy'), undefined, \"should not yet be a cached value\");\n\n  get(obj, 'falsy');\n\n  equal(Ember.cacheFor(obj, 'falsy'), false, \"should retrieve cached value\");\n});\n\ntestBoth(\"setting a cached computed property passes the old value as the third argument\", function(get, set) {\n  var obj = {\n    foo: 0\n  };\n\n  var receivedOldValue;\n\n  Ember.defineProperty(obj, 'plusOne', Ember.computed(\n    function(key, value, oldValue) {\n      receivedOldValue = oldValue;\n      return value;\n    }).property('foo')\n  );\n\n  set(obj, 'plusOne', 1);\n  strictEqual(receivedOldValue, undefined, \"oldValue should be undefined\");\n\n  set(obj, 'plusOne', 2);\n  strictEqual(receivedOldValue, 1, \"oldValue should be 1\");\n\n  set(obj, 'plusOne', 3);\n  strictEqual(receivedOldValue, 2, \"oldValue should be 2\");\n});\n\ntestBoth(\"the old value is only passed in if the computed property specifies three arguments\", function(get, set) {\n  var obj = {\n    foo: 0\n  };\n\n  var receivedOldValue;\n\n  Ember.defineProperty(obj, 'plusOne', Ember.computed(\n    function(key, value) {\n      equal(arguments.length, 2, \"computed property is only invoked with two arguments\");\n      return value;\n    }).property('foo')\n  );\n\n  set(obj, 'plusOne', 1);\n  set(obj, 'plusOne', 2);\n  set(obj, 'plusOne', 3);\n});\n\n// ..........................................................\n// DEPENDENT KEYS\n//\n\nmodule('Ember.computed - dependentkey', {\n  setup: function() {\n    obj = { bar: 'baz' };\n    count = 0;\n    Ember.defineProperty(obj, 'foo', Ember.computed(function(key, value) {\n      count++;\n      return 'bar '+count;\n    }).property('bar'));\n  },\n\n  teardown: function() {\n    obj = count = null;\n  }\n});\n\ntest('should lazily watch dependent keys when watched itself', function () {\n  equal(Ember.isWatching(obj, 'bar'), false, 'precond not watching dependent key');\n  Ember.watch(obj, 'foo');\n  equal(Ember.isWatching(obj, 'bar'), true, 'lazily watching dependent key');\n});\n\ntestBoth('should lazily watch dependent keys on set', function (get, set) {\n  equal(Ember.isWatching(obj, 'bar'), false, 'precond not watching dependent key');\n  set(obj, 'foo', 'bar');\n  equal(Ember.isWatching(obj, 'bar'), true, 'lazily watching dependent key');\n});\n\ntestBoth('should lazily watch dependent keys on get', function (get, set) {\n  equal(Ember.isWatching(obj, 'bar'), false, 'precond not watching dependent key');\n  get(obj, 'foo');\n  equal(Ember.isWatching(obj, 'bar'), true, 'lazily watching dependent key');\n});\n\ntestBoth('local dependent key should invalidate cache', function(get, set) {\n  equal(Ember.isWatching(obj, 'bar'), false, 'precond not watching dependent key');\n  equal(get(obj, 'foo'), 'bar 1', 'get once');\n  equal(Ember.isWatching(obj, 'bar'), true, 'lazily setup watching dependent key');\n  equal(get(obj, 'foo'), 'bar 1', 'cached retrieve');\n\n  set(obj, 'bar', 'BIFF'); // should invalidate foo\n\n  equal(get(obj, 'foo'), 'bar 2', 'should recache');\n  equal(get(obj, 'foo'), 'bar 2', 'cached retrieve');\n});\n\ntestBoth('should invalidate multiple nested dependent keys', function(get, set) {\n\n  Ember.defineProperty(obj, 'bar', Ember.computed(function() {\n    count++;\n    return 'baz '+count;\n  }).property('baz'));\n\n  equal(Ember.isWatching(obj, 'bar'), false, 'precond not watching dependent key');\n  equal(Ember.isWatching(obj, 'baz'), false, 'precond not watching dependent key');\n  equal(get(obj, 'foo'), 'bar 1', 'get once');\n  equal(Ember.isWatching(obj, 'bar'), true, 'lazily setup watching dependent key');\n  equal(Ember.isWatching(obj, 'baz'), true, 'lazily setup watching dependent key');\n  equal(get(obj, 'foo'), 'bar 1', 'cached retrieve');\n\n  set(obj, 'baz', 'BIFF'); // should invalidate bar -> foo\n  equal(Ember.isWatching(obj, 'bar'), false, 'should not be watching dependent key after cache cleared');\n  equal(Ember.isWatching(obj, 'baz'), false, 'should not be watching dependent key after cache cleared');\n\n  equal(get(obj, 'foo'), 'bar 2', 'should recache');\n  equal(get(obj, 'foo'), 'bar 2', 'cached retrieve');\n  equal(Ember.isWatching(obj, 'bar'), true, 'lazily setup watching dependent key');\n  equal(Ember.isWatching(obj, 'baz'), true, 'lazily setup watching dependent key');\n});\n\ntestBoth('circular keys should not blow up', function(get, set) {\n\n  Ember.defineProperty(obj, 'bar', Ember.computed(function(key, value) {\n    count++;\n    return 'bar '+count;\n  }).property('foo'));\n\n  Ember.defineProperty(obj, 'foo', Ember.computed(function(key, value) {\n    count++;\n    return 'foo '+count;\n  }).property('bar'));\n\n  equal(get(obj, 'foo'), 'foo 1', 'get once');\n  equal(get(obj, 'foo'), 'foo 1', 'cached retrieve');\n\n  set(obj, 'bar', 'BIFF'); // should invalidate bar -> foo -> bar\n\n  equal(get(obj, 'foo'), 'foo 3', 'should recache');\n  equal(get(obj, 'foo'), 'foo 3', 'cached retrieve');\n});\n\ntestBoth('redefining a property should undo old depenent keys', function(get ,set) {\n\n  equal(Ember.isWatching(obj, 'bar'), false, 'precond not watching dependent key');\n  equal(get(obj, 'foo'), 'bar 1');\n  equal(Ember.isWatching(obj, 'bar'), true, 'lazily watching dependent key');\n\n  Ember.defineProperty(obj, 'foo', Ember.computed(function() {\n    count++;\n    return 'baz '+count;\n  }).property('baz'));\n\n  equal(Ember.isWatching(obj, 'bar'), false, 'after redefining should not be watching dependent key');\n\n  equal(get(obj, 'foo'), 'baz 2');\n\n  set(obj, 'bar', 'BIFF'); // should not kill cache\n  equal(get(obj, 'foo'), 'baz 2');\n\n  set(obj, 'baz', 'BOP');\n  equal(get(obj, 'foo'), 'baz 3');\n});\n\n// ..........................................................\n// CHAINED DEPENDENT KEYS\n//\n\nvar func, moduleOpts = {\n  setup: function() {\n    obj = {\n      foo: {\n        bar: {\n          baz: {\n            biff: \"BIFF\"\n          }\n        }\n      }\n    };\n\n    Global = {\n      foo: {\n        bar: {\n          baz: {\n            biff: \"BIFF\"\n          }\n        }\n      }\n    };\n\n    count = 0;\n    func = function() {\n      count++;\n      return Ember.get(obj, 'foo.bar.baz.biff')+' '+count;\n    };\n  },\n\n  teardown: function() {\n    obj = count = func = Global = null;\n  }\n};\n\nmodule('Ember.computed - dependentkey with chained properties', moduleOpts);\n\ntestBoth('depending on simple chain', function(get, set) {\n\n  // assign computed property\n  Ember.defineProperty(obj, 'prop',\n    Ember.computed(func).property('foo.bar.baz.biff'));\n\n  equal(get(obj, 'prop'), 'BIFF 1');\n\n  set(Ember.get(obj, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equal(get(obj, 'prop'), 'BUZZ 2');\n  equal(get(obj, 'prop'), 'BUZZ 2');\n\n  set(Ember.get(obj, 'foo.bar'),  'baz', { biff: 'BLOB' });\n  equal(get(obj, 'prop'), 'BLOB 3');\n  equal(get(obj, 'prop'), 'BLOB 3');\n\n  set(Ember.get(obj, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equal(get(obj, 'prop'), 'BUZZ 4');\n  equal(get(obj, 'prop'), 'BUZZ 4');\n\n  set(Ember.get(obj, 'foo'), 'bar', { baz: { biff: 'BOOM' } });\n  equal(get(obj, 'prop'), 'BOOM 5');\n  equal(get(obj, 'prop'), 'BOOM 5');\n\n  set(Ember.get(obj, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equal(get(obj, 'prop'), 'BUZZ 6');\n  equal(get(obj, 'prop'), 'BUZZ 6');\n\n  set(obj, 'foo', { bar: { baz: { biff: 'BLARG' } } });\n  equal(get(obj, 'prop'), 'BLARG 7');\n  equal(get(obj, 'prop'), 'BLARG 7');\n\n  set(Ember.get(obj, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equal(get(obj, 'prop'), 'BUZZ 8');\n  equal(get(obj, 'prop'), 'BUZZ 8');\n\n  Ember.defineProperty(obj, 'prop');\n  set(obj, 'prop', 'NONE');\n  equal(get(obj, 'prop'), 'NONE');\n\n  set(obj, 'foo', { bar: { baz: { biff: 'BLARG' } } });\n  equal(get(obj, 'prop'), 'NONE'); // should do nothing\n  equal(count, 8, 'should be not have invoked computed again');\n\n});\n\ntestBoth('depending on Global chain', function(get, set) {\n\n  // assign computed property\n  Ember.defineProperty(obj, 'prop', Ember.computed(function() {\n    count++;\n    return Ember.get('Global.foo.bar.baz.biff')+' '+count;\n  }).property('Global.foo.bar.baz.biff'));\n\n  equal(get(obj, 'prop'), 'BIFF 1');\n\n  set(Ember.get(Global, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equal(get(obj, 'prop'), 'BUZZ 2');\n  equal(get(obj, 'prop'), 'BUZZ 2');\n\n  set(Ember.get(Global, 'foo.bar'), 'baz', { biff: 'BLOB' });\n  equal(get(obj, 'prop'), 'BLOB 3');\n  equal(get(obj, 'prop'), 'BLOB 3');\n\n  set(Ember.get(Global, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equal(get(obj, 'prop'), 'BUZZ 4');\n  equal(get(obj, 'prop'), 'BUZZ 4');\n\n  set(Ember.get(Global, 'foo'), 'bar', { baz: { biff: 'BOOM' } });\n  equal(get(obj, 'prop'), 'BOOM 5');\n  equal(get(obj, 'prop'), 'BOOM 5');\n\n  set(Ember.get(Global, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equal(get(obj, 'prop'), 'BUZZ 6');\n  equal(get(obj, 'prop'), 'BUZZ 6');\n\n  set(Global, 'foo', { bar: { baz: { biff: 'BLARG' } } });\n  equal(get(obj, 'prop'), 'BLARG 7');\n  equal(get(obj, 'prop'), 'BLARG 7');\n\n  set(Ember.get(Global, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equal(get(obj, 'prop'), 'BUZZ 8');\n  equal(get(obj, 'prop'), 'BUZZ 8');\n\n  Ember.defineProperty(obj, 'prop');\n  set(obj, 'prop', 'NONE');\n  equal(get(obj, 'prop'), 'NONE');\n\n  set(Global, 'foo', { bar: { baz: { biff: 'BLARG' } } });\n  equal(get(obj, 'prop'), 'NONE'); // should do nothing\n  equal(count, 8, 'should be not have invoked computed again');\n\n});\n\ntestBoth('chained dependent keys should evaluate computed properties lazily', function(get,set){\n  Ember.defineProperty(obj.foo.bar, 'b', Ember.computed(func));\n  Ember.defineProperty(obj.foo, 'c', Ember.computed(function(){}).property('bar.b'));\n  equal(count, 0, 'b should not run');\n});\n\n\n// ..........................................................\n// BUGS\n//\n\nmodule('computed edge cases');\n\ntest('adding a computed property should show up in key iteration',function() {\n\n  var obj = {};\n  Ember.defineProperty(obj, 'foo', Ember.computed(function() {}));\n\n  var found = [];\n  for(var key in obj) found.push(key);\n  ok(Ember.EnumerableUtils.indexOf(found, 'foo')>=0, 'should find computed property in iteration found='+found);\n  ok('foo' in obj, 'foo in obj should pass');\n});\n\n\nmodule('Ember.computed - setter');\n\ntestBoth('setting a watched computed property', function(get, set) {\n  var obj = {\n    firstName: 'Yehuda',\n    lastName: 'Katz'\n  };\n  Ember.defineProperty(obj, 'fullName', Ember.computed(\n    function(key, value) {\n      if (arguments.length > 1) {\n        var values = value.split(' ');\n        set(this, 'firstName', values[0]);\n        set(this, 'lastName', values[1]);\n        return value;\n      }\n      return get(this, 'firstName') + ' ' + get(this, 'lastName');\n    }).property('firstName', 'lastName')\n  );\n  var fullNameWillChange = 0,\n      fullNameDidChange = 0,\n      firstNameWillChange = 0,\n      firstNameDidChange = 0,\n      lastNameWillChange = 0,\n      lastNameDidChange = 0;\n  Ember.addBeforeObserver(obj, 'fullName', function () {\n    fullNameWillChange++;\n  });\n  Ember.addObserver(obj, 'fullName', function () {\n    fullNameDidChange++;\n  });\n  Ember.addBeforeObserver(obj, 'firstName', function () {\n    firstNameWillChange++;\n  });\n  Ember.addObserver(obj, 'firstName', function () {\n    firstNameDidChange++;\n  });\n  Ember.addBeforeObserver(obj, 'lastName', function () {\n    lastNameWillChange++;\n  });\n  Ember.addObserver(obj, 'lastName', function () {\n    lastNameDidChange++;\n  });\n\n  equal(get(obj, 'fullName'), 'Yehuda Katz');\n\n  set(obj, 'fullName', 'Yehuda Katz');\n\n  set(obj, 'fullName', 'Kris Selden');\n\n  equal(get(obj, 'fullName'), 'Kris Selden');\n  equal(get(obj, 'firstName'), 'Kris');\n  equal(get(obj, 'lastName'), 'Selden');\n\n  equal(fullNameWillChange, 1);\n  equal(fullNameDidChange, 1);\n  equal(firstNameWillChange, 1);\n  equal(firstNameDidChange, 1);\n  equal(lastNameWillChange, 1);\n  equal(lastNameDidChange, 1);\n});\n\ntestBoth('setting a cached computed property that modifies the value you give it', function(get, set) {\n  var obj = {\n    foo: 0\n  };\n  Ember.defineProperty(obj, 'plusOne', Ember.computed(\n    function(key, value) {\n      if (arguments.length > 1) {\n        set(this, 'foo', value);\n        return value + 1;\n      }\n      return get(this, 'foo') + 1;\n    }).property('foo')\n  );\n  var plusOneWillChange = 0,\n      plusOneDidChange = 0;\n  Ember.addBeforeObserver(obj, 'plusOne', function () {\n    plusOneWillChange++;\n  });\n  Ember.addObserver(obj, 'plusOne', function () {\n    plusOneDidChange++;\n  });\n\n  equal(get(obj, 'plusOne'), 1);\n  set(obj, 'plusOne', 1);\n  equal(get(obj, 'plusOne'), 2);\n  set(obj, 'plusOne', 1);\n  equal(get(obj, 'plusOne'), 2);\n\n  equal(plusOneWillChange, 1);\n  equal(plusOneDidChange, 1);\n\n  set(obj, 'foo', 5);\n  equal(get(obj, 'plusOne'), 6);\n\n  equal(plusOneWillChange, 2);\n  equal(plusOneDidChange, 2);\n});\n\nmodule('Ember.computed - default setter');\n\ntestBoth(\"when setting a value on a computed property that doesn't handle sets\", function(get, set) {\n  var obj = {}, observerFired = false;\n\n  Ember.defineProperty(obj, 'foo', Ember.computed(function() {\n    return 'foo';\n  }));\n\n  Ember.addObserver(obj, 'foo', null, function() {\n    observerFired = true;\n  });\n\n  Ember.set(obj, 'foo', 'bar');\n\n  equal(Ember.get(obj, 'foo'), 'bar', 'The set value is properly returned');\n  ok(!Ember.meta(obj).descs.foo, 'The computed property was removed');\n  ok(observerFired, 'The observer was still notified');\n});\n\nmodule('Ember.computed - readOnly');\n\ntest('is chainable', function() {\n  var computed = Ember.computed(function(){}).readOnly();\n\n  ok(computed instanceof Ember.Descriptor);\n  ok(computed instanceof Ember.ComputedProperty);\n});\n\ntestBoth('protects against setting', function(get, set) {\n  var obj = {  };\n\n  Ember.defineProperty(obj, 'bar', Ember.computed(function(key){\n    return 'barValue';\n  }).readOnly());\n\n  equal(get(obj, 'bar'), 'barValue');\n\n  raises(function(){\n    set(obj, 'bar', 'newBar');\n  }, /Cannot Set: bar on:/ );\n\n  equal(get(obj, 'bar'), 'barValue');\n});\n\nmodule('CP macros');\n\ntestBoth('Ember.computed.not', function(get, set) {\n  var obj = {foo: true};\n  Ember.defineProperty(obj, 'notFoo', Ember.computed.not('foo'));\n  equal(get(obj, 'notFoo'), false);\n\n  obj = {foo: {bar: true}};\n  Ember.defineProperty(obj, 'notFoo', Ember.computed.not('foo.bar'));\n  equal(get(obj, 'notFoo'), false);\n});\n\ntestBoth('Ember.computed.empty', function(get, set) {\n  var obj = {foo: [], bar: undefined, baz: null, quz: ''};\n  Ember.defineProperty(obj, 'fooEmpty', Ember.computed.empty('foo'));\n  Ember.defineProperty(obj, 'barEmpty', Ember.computed.empty('bar'));\n  Ember.defineProperty(obj, 'bazEmpty', Ember.computed.empty('baz'));\n  Ember.defineProperty(obj, 'quzEmpty', Ember.computed.empty('quz'));\n\n  equal(get(obj, 'fooEmpty'), true);\n  set(obj, 'foo', [1]);\n  equal(get(obj, 'fooEmpty'), false);\n  equal(get(obj, 'barEmpty'), true);\n  equal(get(obj, 'bazEmpty'), true);\n  equal(get(obj, 'quzEmpty'), true);\n  set(obj, 'quz', 'asdf');\n  equal(get(obj, 'quzEmpty'), false);\n});\n\ntestBoth('Ember.computed.bool', function(get, set) {\n  var obj = {foo: function(){}, bar: 'asdf', baz: null, quz: false};\n  Ember.defineProperty(obj, 'fooBool', Ember.computed.bool('foo'));\n  Ember.defineProperty(obj, 'barBool', Ember.computed.bool('bar'));\n  Ember.defineProperty(obj, 'bazBool', Ember.computed.bool('baz'));\n  Ember.defineProperty(obj, 'quzBool', Ember.computed.bool('quz'));\n  equal(get(obj, 'fooBool'), true);\n  equal(get(obj, 'barBool'), true);\n  equal(get(obj, 'bazBool'), false);\n  equal(get(obj, 'quzBool'), false);\n});\n\ntestBoth('Ember.computed.alias', function(get, set) {\n  var obj = { bar: 'asdf', baz: null, quz: false};\n  Ember.defineProperty(obj, 'bay', Ember.computed(function(key){\n    return 'apple';\n  }));\n\n  Ember.defineProperty(obj, 'barAlias', Ember.computed.alias('bar'));\n  Ember.defineProperty(obj, 'bazAlias', Ember.computed.alias('baz'));\n  Ember.defineProperty(obj, 'quzAlias', Ember.computed.alias('quz'));\n  Ember.defineProperty(obj, 'bayAlias', Ember.computed.alias('bay'));\n\n  equal(get(obj, 'barAlias'), 'asdf');\n  equal(get(obj, 'bazAlias'), null);\n  equal(get(obj, 'quzAlias'), false);\n  equal(get(obj, 'bayAlias'), 'apple');\n\n  set(obj, 'barAlias', 'newBar');\n  set(obj, 'bazAlias', 'newBaz');\n  set(obj, 'quzAlias', null);\n\n  equal(get(obj, 'barAlias'), 'newBar');\n  equal(get(obj, 'bazAlias'), 'newBaz');\n  equal(get(obj, 'quzAlias'), null);\n\n  equal(get(obj, 'bar'), 'newBar');\n  equal(get(obj, 'baz'), 'newBaz');\n  equal(get(obj, 'quz'), null);\n});\n\ntestBoth('Ember.computed.defaultTo', function(get, set) {\n  var obj = { source: 'original source value' };\n  Ember.defineProperty(obj, 'copy', Ember.computed.defaultTo('source'));\n\n  equal(get(obj, 'copy'), 'original source value');\n\n  set(obj, 'copy', 'new copy value');\n  equal(get(obj, 'source'), 'original source value');\n  equal(get(obj, 'copy'), 'new copy value');\n\n  set(obj, 'source', 'new source value');\n  equal(get(obj, 'copy'), 'new copy value');\n\n  set(obj, 'copy', null);\n  equal(get(obj, 'copy'), 'new source value');\n});\n\ntestBoth('Ember.computed.match', function(get, set) {\n  var obj = { name: 'Paul' };\n  Ember.defineProperty(obj, 'isPaul', Ember.computed.match('name', /Paul/));\n\n  equal(get(obj, 'isPaul'), true, 'is Paul');\n\n  set(obj, 'name', 'Pierre');\n\n  equal(get(obj, 'isPaul'), false, 'is not Paul anymore');\n});\n\ntestBoth('Ember.computed.notEmpty', function(get, set) {\n  var obj = { items: [1] };\n  Ember.defineProperty(obj, 'hasItems', Ember.computed.notEmpty('items'));\n\n  equal(get(obj, 'hasItems'), true, 'is not empty');\n\n  set(obj, 'items', []);\n\n  equal(get(obj, 'hasItems'), false, 'is empty');\n});\n\ntestBoth('Ember.computed.equal', function(get, set) {\n  var obj = { name: 'Paul' };\n  Ember.defineProperty(obj, 'isPaul', Ember.computed.equal('name', 'Paul'));\n\n  equal(get(obj, 'isPaul'), true, 'is Paul');\n\n  set(obj, 'name', 'Pierre');\n\n  equal(get(obj, 'isPaul'), false, 'is not Paul anymore');\n});\n\ntestBoth('Ember.computed.gt', function(get, set) {\n  var obj = { number: 2 };\n  Ember.defineProperty(obj, 'isGreaterThenOne', Ember.computed.gt('number', 1));\n\n  equal(get(obj, 'isGreaterThenOne'), true, 'is gt');\n\n  set(obj, 'number', 1);\n\n  equal(get(obj, 'isGreaterThenOne'), false, 'is not gt');\n\n  set(obj, 'number', 0);\n\n  equal(get(obj, 'isGreaterThenOne'), false, 'is not gt');\n});\n\ntestBoth('Ember.computed.gte', function(get, set) {\n  var obj = { number: 2 };\n  Ember.defineProperty(obj, 'isGreaterOrEqualThenOne', Ember.computed.gte('number', 1));\n\n  equal(get(obj, 'isGreaterOrEqualThenOne'), true, 'is gte');\n\n  set(obj, 'number', 1);\n\n  equal(get(obj, 'isGreaterOrEqualThenOne'), true, 'is gte');\n\n  set(obj, 'number', 0);\n\n  equal(get(obj, 'isGreaterOrEqualThenOne'), false, 'is not gte');\n});\n\ntestBoth('Ember.computed.lt', function(get, set) {\n  var obj = { number: 0 };\n  Ember.defineProperty(obj, 'isLesserThenOne', Ember.computed.lt('number', 1));\n\n  equal(get(obj, 'isLesserThenOne'), true, 'is lt');\n\n  set(obj, 'number', 1);\n\n  equal(get(obj, 'isLesserThenOne'), false, 'is not lt');\n\n  set(obj, 'number', 2);\n\n  equal(get(obj, 'isLesserThenOne'), false, 'is not lt');\n});\n\ntestBoth('Ember.computed.lte', function(get, set) {\n  var obj = { number: 0 };\n  Ember.defineProperty(obj, 'isLesserOrEqualThenOne', Ember.computed.lte('number', 1));\n\n  equal(get(obj, 'isLesserOrEqualThenOne'), true, 'is lte');\n\n  set(obj, 'number', 1);\n\n  equal(get(obj, 'isLesserOrEqualThenOne'), true, 'is lte');\n\n  set(obj, 'number', 2);\n\n  equal(get(obj, 'isLesserOrEqualThenOne'), false, 'is not lte');\n});\n\ntestBoth('Ember.computed.and', function(get, set) {\n  var obj = { one: true, two: true };\n  Ember.defineProperty(obj, 'oneAndTwo', Ember.computed.and('one', 'two'));\n\n  equal(get(obj, 'oneAndTwo'), true, 'one and two');\n\n  set(obj, 'one', false);\n\n  equal(get(obj, 'oneAndTwo'), false, 'one and not two');\n});\n\ntestBoth('Ember.computed.or', function(get, set) {\n  var obj = { one: true, two: true };\n  Ember.defineProperty(obj, 'oneOrTwo', Ember.computed.or('one', 'two'));\n\n  equal(get(obj, 'oneOrTwo'), true, 'one or two');\n\n  set(obj, 'one', false);\n\n  equal(get(obj, 'oneOrTwo'), true, 'one or two');\n\n  set(obj, 'two', false);\n\n  equal(get(obj, 'oneOrTwo'), false, 'nore one nore two');\n\n  set(obj, 'one', true);\n\n  equal(get(obj, 'oneOrTwo'), true, 'one or two');\n});\n\ntestBoth('Ember.computed.any', function(get, set) {\n  var obj = { one: 'foo', two: 'bar' };\n  Ember.defineProperty(obj, 'anyOf', Ember.computed.any('one', 'two'));\n\n  equal(get(obj, 'anyOf'), 'foo', 'is foo');\n\n  set(obj, 'one', false);\n\n  equal(get(obj, 'anyOf'), 'bar', 'is bar');\n});\n\ntestBoth('Ember.computed.map', function(get, set) {\n  var obj = { one: 'foo', two: 'bar', three: null };\n  Ember.defineProperty(obj, 'all', Ember.computed.map('one', 'two', 'three', 'four'));\n\n  deepEqual(get(obj, 'all'), ['foo', 'bar', null, null], 'have all of them');\n\n  set(obj, 'four', true);\n\n  deepEqual(get(obj, 'all'), ['foo', 'bar', null, true], 'have all of them');\n\n  var a = [];\n  set(obj, 'one', 0);\n  set(obj, 'three', a);\n\n  deepEqual(get(obj, 'all'), [0, 'bar', a, true], 'have all of them');\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/computed_test");minispade.register('ember-metal/~tests/core/is_empty_test', "(function() {module(\"Ember.isEmpty\");\n\ntest(\"Ember.isEmpty\", function() {\n  var string = \"string\", fn = function() {},\n      object = {length: 0};\n\n  equal(true,  Ember.isEmpty(null),      \"for null\");\n  equal(true,  Ember.isEmpty(undefined), \"for undefined\");\n  equal(true,  Ember.isEmpty(\"\"),        \"for an empty String\");\n  equal(false, Ember.isEmpty(true),      \"for true\");\n  equal(false, Ember.isEmpty(false),     \"for false\");\n  equal(false, Ember.isEmpty(string),    \"for a String\");\n  equal(false, Ember.isEmpty(fn),        \"for a Function\");\n  equal(false, Ember.isEmpty(0),         \"for 0\");\n  equal(true,  Ember.isEmpty([]),        \"for an empty Array\");\n  equal(false, Ember.isEmpty({}),        \"for an empty Object\");\n  equal(true,  Ember.isEmpty(object),     \"for an Object that has zero 'length'\");\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/core/is_empty_test");minispade.register('ember-metal/~tests/core/is_none_test', "(function() {module(\"Ember.isNone\");\n\ntest(\"Ember.isNone\", function() {\n  var string = \"string\", fn = function() {};\n\n  equal(true,  Ember.isNone(null),      \"for null\");\n  equal(true,  Ember.isNone(undefined), \"for undefined\");\n  equal(false, Ember.isNone(\"\"),        \"for an empty String\");\n  equal(false, Ember.isNone(true),      \"for true\");\n  equal(false, Ember.isNone(false),     \"for false\");\n  equal(false, Ember.isNone(string),    \"for a String\");\n  equal(false, Ember.isNone(fn),        \"for a Function\");\n  equal(false, Ember.isNone(0),         \"for 0\");\n  equal(false, Ember.isNone([]),        \"for an empty Array\");\n  equal(false, Ember.isNone({}),        \"for an empty Object\");\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/core/is_none_test");minispade.register('ember-metal/~tests/enumerable_utils_test', "(function() {module('Ember.EnumerableUtils.intersection');\n\ntest('returns an array of objects that appear in both enumerables', function() {\n  var a = [1,2,3], b = [2,3,4], result;\n\n  result = Ember.EnumerableUtils.intersection(a, b);\n\n  deepEqual(result, [2,3]);\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/enumerable_utils_test");minispade.register('ember-metal/~tests/events_test', "(function() {module('system/props/events_test');\n\ntest('listener should receive event - removing should remove', function() {\n  var obj = {}, count = 0;\n  var F = function() { count++; };\n\n  Ember.addListener(obj, 'event!', F);\n  equal(count, 0, 'nothing yet');\n\n  Ember.sendEvent(obj, 'event!');\n  equal(count, 1, 'received event');\n\n  Ember.removeListener(obj, 'event!', F);\n\n  count = 0;\n  Ember.sendEvent(obj, 'event!');\n  equal(count, 0, 'received event');\n});\n\ntest('listeners should be inherited', function() {\n  var obj = {}, count = 0;\n  var F = function() { count++; };\n\n  Ember.addListener(obj, 'event!', F);\n\n  var obj2 = Ember.create(obj);\n\n  equal(count, 0, 'nothing yet');\n\n  Ember.sendEvent(obj2, 'event!');\n  equal(count, 1, 'received event');\n\n  Ember.removeListener(obj2, 'event!', F);\n\n  count = 0;\n  Ember.sendEvent(obj2, 'event!');\n  equal(count, 0, 'did not receive event');\n\n  Ember.sendEvent(obj, 'event!');\n  equal(count, 1, 'should still invoke on parent');\n\n});\n\n\ntest('adding a listener more than once should only invoke once', function() {\n\n  var obj = {}, count = 0;\n  var F = function() { count++; };\n  Ember.addListener(obj, 'event!', F);\n  Ember.addListener(obj, 'event!', F);\n\n  Ember.sendEvent(obj, 'event!');\n  equal(count, 1, 'should only invoke once');\n});\n\ntest('adding a listener with a target should invoke with target', function() {\n  var obj = {}, target;\n\n  target = {\n    count: 0,\n    method: function() { this.count++; }\n  };\n\n  Ember.addListener(obj, 'event!', target, target.method);\n  Ember.sendEvent(obj, 'event!');\n  equal(target.count, 1, 'should invoke');\n});\n\ntest('suspending a listener should not invoke during callback', function() {\n  var obj = {}, target, otherTarget;\n\n  target = {\n    count: 0,\n    method: function() { this.count++; }\n  };\n\n  otherTarget = {\n    count: 0,\n    method: function() { this.count++; }\n  };\n\n  Ember.addListener(obj, 'event!', target, target.method);\n  Ember.addListener(obj, 'event!', otherTarget, otherTarget.method);\n\n  function callback() {\n      equal(this, target);\n\n      Ember.sendEvent(obj, 'event!');\n\n      return 'result';\n  }\n\n  Ember.sendEvent(obj, 'event!');\n\n  equal(Ember._suspendListener(obj, 'event!', target, target.method, callback), 'result');\n\n  Ember.sendEvent(obj, 'event!');\n\n  equal(target.count, 2, 'should invoke');\n  equal(otherTarget.count, 3, 'should invoke');\n});\n\ntest('adding a listener with string method should lookup method on event delivery', function() {\n  var obj = {}, target;\n\n  target = {\n    count: 0,\n    method: function() {}\n  };\n\n  Ember.addListener(obj, 'event!', target, 'method');\n  Ember.sendEvent(obj, 'event!');\n  equal(target.count, 0, 'should invoke but do nothing');\n\n  target.method = function() { this.count++; };\n  Ember.sendEvent(obj, 'event!');\n  equal(target.count, 1, 'should invoke now');\n});\n\ntest('calling sendEvent with extra params should be passed to listeners', function() {\n\n  var obj = {}, params = null;\n  Ember.addListener(obj, 'event!', function() {\n    params = Array.prototype.slice.call(arguments);\n  });\n\n  Ember.sendEvent(obj, 'event!', ['foo', 'bar']);\n  deepEqual(params, ['foo', 'bar'], 'params should be saved');\n});\n\ntest('implementing sendEvent on object should invoke', function() {\n  var obj = {\n    sendEvent: function(eventName, params) {\n      equal(eventName, 'event!', 'eventName');\n      deepEqual(params, ['foo', 'bar']);\n      this.count++;\n    },\n\n    count: 0\n  };\n\n  Ember.addListener(obj, 'event!', obj, function() { this.count++; });\n\n  Ember.sendEvent(obj, 'event!', ['foo', 'bar']);\n  equal(obj.count, 2, 'should have invoked method & listener');\n});\n\ntest('hasListeners tells you if there are listeners for a given event', function() {\n\n  var obj = {}, F = function() {}, F2 = function() {};\n\n  equal(Ember.hasListeners(obj, 'event!'), false, 'no listeners at first');\n\n  Ember.addListener(obj, 'event!', F);\n  Ember.addListener(obj, 'event!', F2);\n\n  equal(Ember.hasListeners(obj, 'event!'), true, 'has listeners');\n\n  Ember.removeListener(obj, 'event!', F);\n  equal(Ember.hasListeners(obj, 'event!'), true, 'has listeners');\n\n  Ember.removeListener(obj, 'event!', F2);\n  equal(Ember.hasListeners(obj, 'event!'), false, 'has no more listeners');\n\n  Ember.addListener(obj, 'event!', F);\n  equal(Ember.hasListeners(obj, 'event!'), true, 'has listeners');\n});\n\ntest('calling removeListener without method should remove all listeners', function() {\n  var obj = {}, F = function() {}, F2 = function() {};\n\n  equal(Ember.hasListeners(obj, 'event!'), false, 'no listeners at first');\n\n  Ember.addListener(obj, 'event!', F);\n  Ember.addListener(obj, 'event!', F2);\n\n  equal(Ember.hasListeners(obj, 'event!'), true, 'has listeners');\n\n  Ember.removeListener(obj, 'event!');\n\n  equal(Ember.hasListeners(obj, 'event!'), false, 'has no more listeners');\n});\n\ntest('while suspended, it should not be possible to add a duplicate listener', function() {\n  var obj = {}, target;\n\n  target = {\n    count: 0,\n    method: function() { this.count++; }\n  };\n\n  Ember.addListener(obj, 'event!', target, target.method);\n\n  function callback() {\n    Ember.addListener(obj, 'event!', target, target.method);\n  }\n\n  Ember.sendEvent(obj, 'event!');\n\n  Ember._suspendListener(obj, 'event!', target, target.method, callback);\n\n  equal(target.count, 1, 'should invoke');\n  equal(Ember.meta(obj).listeners['event!'].length, 1, \"a duplicate listener wasn't added\");\n\n  // now test _suspendListeners...\n\n  Ember.sendEvent(obj, 'event!');\n\n  Ember._suspendListeners(obj, ['event!'], target, target.method, callback);\n\n  equal(target.count, 2, 'should have invoked again');\n  equal(Ember.meta(obj).listeners['event!'].length, 1, \"a duplicate listener wasn't added\");\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/events_test");minispade.register('ember-metal/~tests/instrumentation_test', "(function() {var instrument = Ember.Instrumentation;\n\nmodule(\"Ember Instrumentation\", {\n  setup: function() {\n\n  },\n  teardown: function() {\n    instrument.reset();\n  }\n});\n\ntest(\"subscribing to a simple path receives the listener\", function() {\n  expect(12);\n\n  var sentPayload = {}, count = 0;\n\n  instrument.subscribe(\"render\", {\n    before: function(name, timestamp, payload) {\n      if (count === 0) {\n        strictEqual(name, \"render\");\n      } else {\n        strictEqual(name, \"render.handlebars\");\n      }\n\n      ok(typeof timestamp === 'number');\n      strictEqual(payload, sentPayload);\n    },\n\n    after: function(name, timestamp, payload) {\n      if (count === 0) {\n        strictEqual(name, \"render\");\n      } else {\n        strictEqual(name, \"render.handlebars\");\n      }\n\n      ok(typeof timestamp === 'number');\n      strictEqual(payload, sentPayload);\n\n      count++;\n    }\n  });\n\n  instrument.instrument(\"render\", sentPayload, function() {\n\n  });\n\n  instrument.instrument(\"render.handlebars\", sentPayload, function() {\n\n  });\n});\n\ntest(\"returning a value from the before callback passes it to the after callback\", function() {\n  expect(2);\n\n  var passthru1 = {}, passthru2 = {};\n\n  instrument.subscribe(\"render\", {\n    before: function(name, timestamp, payload) {\n      return passthru1;\n    },\n    after: function(name, timestamp, payload, beforeValue) {\n      strictEqual(beforeValue, passthru1);\n    }\n  });\n\n  instrument.subscribe(\"render\", {\n    before: function(name, timestamp, payload) {\n      return passthru2;\n    },\n    after: function(name, timestamp, payload, beforeValue) {\n      strictEqual(beforeValue, passthru2);\n    }\n  });\n\n  instrument.instrument(\"render\", null, function() {});\n});\n\ntest(\"raising an exception in the instrumentation attaches it to the payload\", function() {\n  expect(2);\n\n  var error = new Error(\"Instrumentation\");\n\n  instrument.subscribe(\"render\", {\n    before: function() {},\n    after: function(name, timestamp, payload) {\n      strictEqual(payload.exception, error);\n    }\n  });\n\n  instrument.subscribe(\"render\", {\n    before: function() {},\n    after: function(name, timestamp, payload) {\n      strictEqual(payload.exception, error);\n    }\n  });\n\n  instrument.instrument(\"render.handlebars\", null, function() {\n    throw error;\n  });\n});\n\ntest(\"it is possible to add a new subscriber after the first instrument\", function() {\n  instrument.instrument(\"render.handlebars\", null, function() {});\n\n  instrument.subscribe(\"render\", {\n    before: function() {\n      ok(true, \"Before callback was called\");\n    },\n    after: function() {\n      ok(true, \"After callback was called\");\n    }\n  });\n\n  instrument.instrument(\"render.handlebars\", null, function() {});\n});\n\ntest(\"it is possible to remove a subscriber\", function() {\n  expect(4);\n\n  var count = 0;\n\n  var subscriber = instrument.subscribe(\"render\", {\n    before: function() {\n      equal(count, 0);\n      ok(true, \"Before callback was called\");\n    },\n    after: function() {\n      equal(count, 0);\n      ok(true, \"After callback was called\");\n      count++;\n    }\n  });\n\n  instrument.instrument(\"render.handlebars\", null, function() {});\n\n  instrument.unsubscribe(subscriber);\n\n  instrument.instrument(\"render.handlebars\", null, function() {});\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/instrumentation_test");minispade.register('ember-metal/~tests/map_test', "(function() {var object, number, string, map;\n\nvar varieties = ['Map', 'MapWithDefault'], variety;\n\nfunction testMap(variety) {\n  module(\"Ember.\" + variety + \" (forEach and get are implicitly tested)\", {\n    setup: function() {\n      object = {};\n      number = 42;\n      string = \"foo\";\n\n      map = Ember[variety].create();\n    }\n  });\n\n  var mapHasLength = function(expected, theMap) {\n    theMap = theMap || map;\n\n    var length = 0;\n    theMap.forEach(function() {\n      length++;\n    });\n\n    equal(length, expected, \"map should contain \" + expected + \" items\");\n  };\n\n  var mapHasEntries = function(entries, theMap) {\n    theMap = theMap || map;\n\n    for (var i = 0, l = entries.length; i < l; i++) {\n      equal(theMap.get(entries[i][0]), entries[i][1]);\n      equal(theMap.has(entries[i][0]), true);\n    }\n\n    mapHasLength(entries.length, theMap);\n  };\n\n  test(\"add\", function() {\n    map.set(object, \"winning\");\n    map.set(number, \"winning\");\n    map.set(string, \"winning\");\n\n    mapHasEntries([\n      [ object, \"winning\" ],\n      [ number, \"winning\" ],\n      [ string, \"winning\" ]\n    ]);\n\n    map.set(object, \"losing\");\n    map.set(number, \"losing\");\n    map.set(string, \"losing\");\n\n    mapHasEntries([\n      [ object, \"losing\" ],\n      [ number, \"losing\" ],\n      [ string, \"losing\" ]\n    ]);\n\n    equal(map.has(\"nope\"), false);\n    equal(map.has({}), false);\n  });\n\n  test(\"remove\", function() {\n    map.set(object, \"winning\");\n    map.set(number, \"winning\");\n    map.set(string, \"winning\");\n\n    map.remove(object);\n    map.remove(number);\n    map.remove(string);\n\n    // doesn't explode\n    map.remove({});\n\n    mapHasEntries([]);\n  });\n\n  test(\"copy and then update\", function() {\n    map.set(object, \"winning\");\n    map.set(number, \"winning\");\n    map.set(string, \"winning\");\n\n    var map2 = map.copy();\n\n    map2.set(object, \"losing\");\n    map2.set(number, \"losing\");\n    map2.set(string, \"losing\");\n\n    mapHasEntries([\n      [ object, \"winning\" ],\n      [ number, \"winning\" ],\n      [ string, \"winning\" ]\n    ]);\n\n    mapHasEntries([\n      [ object, \"losing\" ],\n      [ number, \"losing\" ],\n      [ string, \"losing\" ]\n    ], map2);\n  });\n\n  test(\"copy and then remove\", function() {\n    map.set(object, \"winning\");\n    map.set(number, \"winning\");\n    map.set(string, \"winning\");\n\n    var map2 = map.copy();\n\n    map2.remove(object);\n    map2.remove(number);\n    map2.remove(string);\n\n    mapHasEntries([\n      [ object, \"winning\" ],\n      [ number, \"winning\" ],\n      [ string, \"winning\" ]\n    ]);\n\n    mapHasEntries([ ], map2);\n  });\n}\n\nfor (var i = 0;  i < varieties.length;  i++) {\n  testMap(varieties[i]);\n}\n\nmodule(\"MapWithDefault - default values\");\n\ntest(\"Retrieving a value that has not been set returns and sets a default value\", function() {\n  var map = Ember.MapWithDefault.create({\n    defaultValue: function(key) {\n      return [key];\n    }\n  });\n\n  var value = map.get('ohai');\n  deepEqual(value, [ 'ohai' ]);\n\n  strictEqual(value, map.get('ohai'));\n});\n\ntest(\"Copying a MapWithDefault copies the default value\", function() {\n  var map = Ember.MapWithDefault.create({\n    defaultValue: function(key) {\n      return [key];\n    }\n  });\n\n  map.set('ohai', 1);\n  map.get('bai');\n\n  var map2 = map.copy();\n\n  equal(map2.get('ohai'), 1);\n  deepEqual(map2.get('bai'), ['bai']);\n\n  map2.set('kthx', 3);\n\n  deepEqual(map.get('kthx'), ['kthx']);\n  equal(map2.get('kthx'), 3);\n\n  deepEqual(map2.get('default'), ['default']);\n\n  map2.defaultValue = function(key) {\n    return ['tom is on', key];\n  };\n\n  deepEqual(map2.get('drugs'), ['tom is on', 'drugs']);\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/map_test");minispade.register('ember-metal/~tests/mixin/alias_method_test', "(function() {module('Ember.aliasMethod');\n\nfunction validateAliasMethod(obj) {\n  equal(obj.fooMethod(), 'FOO', 'obj.fooMethod()');\n  equal(obj.barMethod(), 'FOO', 'obj.barMethod should be a copy of foo');\n}\n\ntest('methods of another name are aliased when the mixin is applied', function() {\n\n  var MyMixin = Ember.Mixin.create({\n    fooMethod: function() { return 'FOO'; },\n    barMethod: Ember.aliasMethod('fooMethod')\n  });\n\n  var obj = MyMixin.apply({});\n  validateAliasMethod(obj);\n});\n\ntest('should follow aliasMethods all the way down', function() {\n  var MyMixin = Ember.Mixin.create({\n    bar: Ember.aliasMethod('foo'), // put first to break ordered iteration\n    baz: function(){ return 'baz'; },\n    foo: Ember.aliasMethod('baz')\n  });\n\n  var obj = MyMixin.apply({});\n  equal(Ember.get(obj, 'bar')(), 'baz', 'should have followed aliasMethods');\n});\n\ntest('should alias methods from other dependent mixins', function() {\n\n  var BaseMixin = Ember.Mixin.create({\n    fooMethod: function() { return 'FOO'; }\n  });\n\n  var MyMixin = Ember.Mixin.create(BaseMixin, {\n    barMethod: Ember.aliasMethod('fooMethod')\n  });\n\n  var obj = MyMixin.apply({});\n  validateAliasMethod(obj);\n});\n\ntest('should alias methods from other mixins applied at same time', function() {\n\n  var BaseMixin = Ember.Mixin.create({\n    fooMethod: function() { return 'FOO'; }\n  });\n\n  var MyMixin = Ember.Mixin.create({\n    barMethod: Ember.aliasMethod('fooMethod')\n  });\n\n  var obj = Ember.mixin({}, BaseMixin, MyMixin);\n  validateAliasMethod(obj);\n});\n\ntest('should alias methods from mixins already applied on object', function() {\n\n  var BaseMixin = Ember.Mixin.create({\n    quxMethod: function() { return 'qux'; }\n  });\n\n  var MyMixin = Ember.Mixin.create({\n    bar: Ember.aliasMethod('foo'),\n    barMethod: Ember.aliasMethod('fooMethod')\n  });\n\n  var obj = {\n    fooMethod: function() { return 'FOO'; }\n  };\n\n  BaseMixin.apply(obj);\n  MyMixin.apply(obj);\n\n  validateAliasMethod(obj);\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/mixin/alias_method_test");minispade.register('ember-metal/~tests/mixin/alias_test', "(function() {module('Ember.alias');\n\nfunction validateAlias(obj) {\n  var get = Ember.get;\n  equal(get(obj, 'foo'), 'foo', 'obj.foo');\n  equal(get(obj, 'bar'), 'foo', 'obj.bar should be a copy of foo');\n\n  equal(get(obj, 'computedFoo'), 'cfoo', 'obj.computedFoo');\n  equal(get(obj, 'computedBar'), 'cfoo', 'obj.computedBar should be a copy of computedFoo');\n\n  equal(obj.fooMethod(), 'FOO', 'obj.fooMethod()');\n  equal(obj.barMethod(), 'FOO', 'obj.barMethod should be a copy of foo');\n}\n\ntest('copies the property values from another key when the mixin is applied', function() {\n\n  var MyMixin = Ember.Mixin.create({\n    foo: 'foo',\n    bar: Ember.alias('foo'),\n\n    computedFoo: Ember.computed(function() {\n      return 'cfoo';\n    }),\n\n    computedBar: Ember.alias('computedFoo'),\n\n    fooMethod: function() { return 'FOO'; },\n    barMethod: Ember.alias('fooMethod')\n  });\n\n  var obj = MyMixin.apply({});\n  validateAlias(obj);\n});\n\ntest('should follow aliases all the way down', function() {\n  var MyMixin = Ember.Mixin.create({\n    bar: Ember.alias('foo'), // put first to break ordered iteration\n    baz: 'baz',\n    foo: Ember.alias('baz')\n  });\n\n  var obj = MyMixin.apply({});\n  equal(Ember.get(obj, 'bar'), 'baz', 'should have followed aliases');\n});\n\ntest('should copy from other dependent mixins', function() {\n\n  var BaseMixin = Ember.Mixin.create({\n    foo: 'foo',\n\n    computedFoo: Ember.computed(function() {\n      return 'cfoo';\n    }),\n\n    fooMethod: function() { return 'FOO'; }\n  });\n\n  var MyMixin = Ember.Mixin.create(BaseMixin, {\n    bar: Ember.alias('foo'),\n    computedBar: Ember.alias('computedFoo'),\n    barMethod: Ember.alias('fooMethod')\n  });\n\n  var obj = MyMixin.apply({});\n  validateAlias(obj);\n});\n\ntest('should copy from other mixins applied at same time', function() {\n\n  var BaseMixin = Ember.Mixin.create({\n    foo: 'foo',\n\n    computedFoo: Ember.computed(function() {\n      return 'cfoo';\n    }),\n\n    fooMethod: function() { return 'FOO'; }\n  });\n\n  var MyMixin = Ember.Mixin.create({\n    bar: Ember.alias('foo'),\n    computedBar: Ember.alias('computedFoo'),\n    barMethod: Ember.alias('fooMethod')\n  });\n\n  var obj = Ember.mixin({}, BaseMixin, MyMixin);\n  validateAlias(obj);\n});\n\ntest('should copy from properties already applied on object', function() {\n\n  var BaseMixin = Ember.Mixin.create({\n    foo: 'foo',\n\n    computedFoo: Ember.computed(function() {\n      return 'cfoo';\n    })\n\n  });\n\n  var MyMixin = Ember.Mixin.create({\n    bar: Ember.alias('foo'),\n    computedBar: Ember.alias('computedFoo'),\n    barMethod: Ember.alias('fooMethod')\n  });\n\n  var obj = {\n    fooMethod: function() { return 'FOO'; }\n  };\n\n  BaseMixin.apply(obj);\n  MyMixin.apply(obj);\n\n  validateAlias(obj);\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/mixin/alias_test");minispade.register('ember-metal/~tests/mixin/apply_test', "(function() {/*globals raises */\n\nmodule('Ember.Mixin.apply');\n\nfunction K() {}\n\ntest('using apply() should apply properties', function() {\n  var MixinA = Ember.Mixin.create({ foo: 'FOO', baz: K });\n  var obj = {};\n  Ember.mixin(obj, MixinA);\n\n  equal(Ember.get(obj, 'foo'), \"FOO\", 'should apply foo');\n  equal(Ember.get(obj, 'baz'), K, 'should apply foo');\n});\n\ntest('applying anonymous properties', function() {\n  var obj = {};\n  Ember.mixin(obj, {\n    foo: 'FOO',\n    baz: K\n  });\n\n  equal(Ember.get(obj, 'foo'), \"FOO\", 'should apply foo');\n  equal(Ember.get(obj, 'baz'), K, 'should apply foo');\n});\n\ntest('applying null values', function() {\n  raises(function() {\n    Ember.mixin({}, null);\n  }, Error);\n});\n\ntest('applying a property with an undefined value', function() {\n  var obj = { tagName: '' };\n  Ember.mixin(obj, { tagName: undefined });\n\n  strictEqual(Ember.get(obj, 'tagName'), '');\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/mixin/apply_test");minispade.register('ember-metal/~tests/mixin/computed_test', "(function() {var get = Ember.get;\n\nmodule('Ember.Mixin Computed Properties');\n\ntest('overriding computed properties', function() {\n  var MixinA, MixinB, MixinC, MixinD;\n  var obj;\n\n  MixinA = Ember.Mixin.create({\n    aProp: Ember.computed(function() {\n      return 'A';\n    })\n  });\n\n  MixinB = Ember.Mixin.create(MixinA, {\n    aProp: Ember.computed(function() {\n      return this._super()+'B';\n    })\n  });\n\n  MixinC = Ember.Mixin.create(MixinA, {\n    aProp: Ember.computed(function() {\n      return this._super()+'C';\n    })\n  });\n\n  MixinD = Ember.Mixin.create({\n    aProp: Ember.computed(function() {\n      return this._super()+'D';\n    })\n  });\n\n  obj = {};\n  MixinB.apply(obj);\n  equal(get(obj, 'aProp'), 'AB', \"should expose super for B\");\n\n  obj = {};\n  MixinC.apply(obj);\n  equal(get(obj, 'aProp'), 'AC', \"should expose super for C\");\n\n  obj = {};\n\n  MixinA.apply(obj);\n  MixinD.apply(obj);\n  equal(get(obj, 'aProp'), 'AD', \"should define super for D\");\n\n  obj = { };\n  Ember.defineProperty(obj, 'aProp', Ember.computed(function(key, value) {\n    return 'obj';\n  }));\n  MixinD.apply(obj);\n  equal(get(obj, 'aProp'), \"objD\", \"should preserve original computed property\");\n});\n\ntest('setter behavior works properly when overriding computed properties', function() {\n  var obj = {};\n\n  var MixinA = Ember.Mixin.create({\n    cpWithSetter2: Ember.computed(Ember.K),\n    cpWithSetter3: Ember.computed(Ember.K),\n    cpWithoutSetter: Ember.computed(Ember.K)\n  });\n\n  var cpWasCalled = false;\n\n  var MixinB = Ember.Mixin.create({\n    cpWithSetter2: Ember.computed(function(k, v) {\n      cpWasCalled = true;\n    }),\n\n    cpWithSetter3: Ember.computed(function(k, v) {\n      cpWasCalled = true;\n    }),\n\n    cpWithoutSetter: Ember.computed(function(k) {\n      cpWasCalled = true;\n    })\n  });\n\n  MixinA.apply(obj);\n  MixinB.apply(obj);\n\n  Ember.set(obj, 'cpWithSetter2', 'test');\n  ok(cpWasCalled, \"The computed property setter was called when defined with two args\");\n  cpWasCalled = false;\n\n  Ember.set(obj, 'cpWithSetter3', 'test');\n  ok(cpWasCalled, \"The computed property setter was called when defined with three args\");\n  cpWasCalled = false;\n\n  Ember.set(obj, 'cpWithoutSetter', 'test');\n  equal(Ember.get(obj, 'cpWithoutSetter'), 'test', \"The default setter was called, the value is correct\");\n  ok(!cpWasCalled, \"The default setter was called, not the CP itself\");\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/mixin/computed_test");minispade.register('ember-metal/~tests/mixin/concatenatedProperties_test', "(function() {/*globals setup */\n\nmodule('Ember.Mixin concatenatedProperties');\n\ntest('defining concatenated properties should concat future version', function() {\n\n  var MixinA = Ember.Mixin.create({\n    concatenatedProperties: ['foo'],\n    foo: ['a', 'b', 'c']\n  });\n\n  var MixinB = Ember.Mixin.create({\n    foo: ['d', 'e', 'f']\n  });\n\n  var obj = Ember.mixin({}, MixinA, MixinB);\n  deepEqual(Ember.get(obj, 'foo'), ['a', 'b', 'c', 'd', 'e', 'f']);\n});\n\ntest('concatenatedProperties should be concatenated', function() {\n\n  var MixinA = Ember.Mixin.create({\n    concatenatedProperties: ['foo'],\n    foo: ['a', 'b', 'c']\n  });\n\n  var MixinB = Ember.Mixin.create({\n    concatenatedProperties: 'bar',\n    foo: ['d', 'e', 'f'],\n    bar: [1,2,3]\n  });\n\n  var MixinC = Ember.Mixin.create({\n    bar: [4,5,6]\n  });\n\n  var obj = Ember.mixin({}, MixinA, MixinB, MixinC);\n  deepEqual(Ember.get(obj, 'concatenatedProperties'), ['foo', 'bar'], 'get concatenatedProperties');\n  deepEqual(Ember.get(obj, 'foo'), ['a', 'b', 'c', 'd', 'e', 'f'], 'get foo');\n  deepEqual(Ember.get(obj, 'bar'), [1,2,3,4,5,6], 'get bar');\n});\n\ntest('adding a prop that is not an array should make array', function() {\n\n  var MixinA = Ember.Mixin.create({\n    concatenatedProperties: ['foo'],\n    foo: [1,2,3]\n  });\n\n  var MixinB = Ember.Mixin.create({\n    foo: 4\n  });\n\n  var obj = Ember.mixin({}, MixinA, MixinB);\n  deepEqual(Ember.get(obj, 'foo'), [1,2,3,4]);\n});\n\ntest('adding a prop that is not an array should make array', function() {\n\n  var MixinA = Ember.Mixin.create({\n    concatenatedProperties: ['foo'],\n    foo: 'bar'\n  });\n\n  var obj = Ember.mixin({}, MixinA);\n  deepEqual(Ember.get(obj, 'foo'), ['bar']);\n});\n\ntest('adding a non-concatenable property that already has a defined value should result in an array with both values', function() {\n\n  var mixinA = Ember.Mixin.create({\n    foo: 1\n  });\n\n  var mixinB = Ember.Mixin.create({\n    concatenatedProperties: ['foo'],\n    foo: 2\n  });\n\n  var obj = Ember.mixin({}, mixinA, mixinB);\n  deepEqual(Ember.get(obj, 'foo'), [1, 2]);\n});\n\ntest('adding a concatenable property that already has a defined value should result in a concatenated value', function() {\n\n  var mixinA = Ember.Mixin.create({\n    foobar: 'foo'\n  });\n\n  var mixinB = Ember.Mixin.create({\n    concatenatedProperties: ['foobar'],\n    foobar: 'bar'\n  });\n\n  var obj = Ember.mixin({}, mixinA, mixinB);\n  equal(Ember.get(obj, 'foobar'), 'foobar');\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/mixin/concatenatedProperties_test");minispade.register('ember-metal/~tests/mixin/detect_test', "(function() {module('Mixin.detect');\n\ntest('detect() finds a directly applied mixin', function() {\n\n  var MixinA = Ember.Mixin.create();\n  var obj = {};\n\n  equal(MixinA.detect(obj), false, 'MixinA.detect(obj) before apply()');\n\n  MixinA.apply(obj);\n  equal(MixinA.detect(obj), true, 'MixinA.detect(obj) after apply()');\n});\n\ntest('detect() finds nested mixins', function() {\n  var MixinA = Ember.Mixin.create({});\n  var MixinB = Ember.Mixin.create(MixinA);\n  var obj = {};\n\n  equal(MixinA.detect(obj), false, 'MixinA.detect(obj) before apply()');\n\n  MixinB.apply(obj);\n  equal(MixinA.detect(obj), true, 'MixinA.detect(obj) after apply()');\n});\n\ntest('detect() finds mixins on other mixins', function() {\n  var MixinA = Ember.Mixin.create({});\n  var MixinB = Ember.Mixin.create(MixinA);\n  equal(MixinA.detect(MixinB), true, 'MixinA is part of MixinB');\n  equal(MixinB.detect(MixinA), false, 'MixinB is not part of MixinA');\n});\n\ntest('detect handles null values', function() {\n  var MixinA = Ember.Mixin.create();\n  equal(MixinA.detect(null), false);\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/mixin/detect_test");minispade.register('ember-metal/~tests/mixin/introspection_test', "(function() {// NOTE: A previous iteration differentiated between public and private props\n// as well as methods vs props.  We are just keeping these for testing; the\n// current impl doesn't care about the differences as much...\n\nvar PrivateProperty = Ember.Mixin.create({\n  _foo: '_FOO'\n});\n\nvar PublicProperty = Ember.Mixin.create({\n  foo: 'FOO'\n});\n\nvar PrivateMethod = Ember.Mixin.create({\n  _fooMethod: function() {}\n});\n\nvar PublicMethod = Ember.Mixin.create({\n  fooMethod: function() {}\n});\n\nvar BarProperties = Ember.Mixin.create({\n  _bar: '_BAR',\n  bar: 'bar'\n});\n\nvar BarMethods = Ember.Mixin.create({\n  _barMethod: function() {},\n  barMethod: function() {}\n});\n\nvar Combined = Ember.Mixin.create(BarProperties, BarMethods);\n\nvar obj ;\n\nmodule('Basic introspection', {\n  setup: function() {\n    obj = {};\n    Ember.mixin(obj, PrivateProperty, PublicProperty, PrivateMethod, PublicMethod, Combined);\n  }\n});\n\ntest('Ember.mixins()', function() {\n\n  function mapGuids(ary) {\n    return Ember.EnumerableUtils.map(ary, function(x) { return Ember.guidFor(x); });\n  }\n\n  deepEqual(mapGuids(Ember.Mixin.mixins(obj)), mapGuids([PrivateProperty, PublicProperty, PrivateMethod, PublicMethod, Combined, BarProperties, BarMethods]), 'should return included mixins');\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/mixin/introspection_test");minispade.register('ember-metal/~tests/mixin/method_test', "(function() {/*globals raises */\n\nmodule('Mixin Methods');\n\ntest('defining simple methods', function() {\n\n  var MixinA, obj, props;\n\n  props = {\n    publicMethod: function() { return 'publicMethod'; },\n    _privateMethod: function() { return 'privateMethod'; }\n  };\n\n  MixinA = Ember.Mixin.create(props);\n  obj = {};\n  MixinA.apply(obj);\n\n  // but should be defined\n  equal(props.publicMethod(), 'publicMethod', 'publicMethod is func');\n  equal(props._privateMethod(), 'privateMethod', 'privateMethod is func');\n});\n\ntest('overriding public methods', function() {\n  var MixinA, MixinB, MixinC, MixinD, MixinE, MixinF, obj;\n\n  MixinA = Ember.Mixin.create({\n    publicMethod: function() { return 'A'; }\n  });\n\n  MixinB = Ember.Mixin.create(MixinA, {\n    publicMethod: function() { return this._super()+'B'; }\n  });\n\n  MixinD = Ember.Mixin.create(MixinA, {\n    publicMethod: function() { return this._super()+'D'; }\n  });\n\n  MixinF = Ember.Mixin.create({\n    publicMethod: function() { return this._super()+'F'; }\n  });\n\n  obj = {};\n  MixinB.apply(obj);\n  equal(obj.publicMethod(), 'AB', 'should define super for A and B');\n\n  obj = {};\n  MixinD.apply(obj);\n  equal(obj.publicMethod(), 'AD', 'should define super for A and B');\n\n  obj = {};\n  MixinA.apply(obj);\n  MixinF.apply(obj);\n  equal(obj.publicMethod(), 'AF', 'should define super for A and F');\n\n  obj = { publicMethod: function() { return 'obj'; } };\n  MixinF.apply(obj);\n  equal(obj.publicMethod(), 'objF', 'should define super for F');\n});\n\n\ntest('overriding inherited objects', function() {\n\n  var cnt = 0;\n  var MixinA = Ember.Mixin.create({\n    foo: function() { cnt++; }\n  });\n\n  var MixinB = Ember.Mixin.create({\n    foo: function() { this._super(); cnt++; }\n  });\n\n  var objA = {};\n  MixinA.apply(objA);\n\n  var objB = Ember.create(objA);\n  MixinB.apply(objB);\n\n  cnt = 0;\n  objB.foo();\n  equal(cnt, 2, 'should invoke both methods');\n\n  cnt = 0;\n  objA.foo();\n  equal(cnt, 1, 'should not screw w/ parent obj');\n});\n\ntest('Including the same mixin more than once will only run once', function() {\n  var cnt = 0;\n  var MixinA = Ember.Mixin.create({\n    foo: function() { cnt++; }\n  });\n\n  var MixinB = Ember.Mixin.create(MixinA, {\n    foo: function() { this._super(); }\n  });\n\n  var MixinC = Ember.Mixin.create(MixinA, {\n    foo: function() { this._super(); }\n  });\n\n  var MixinD = Ember.Mixin.create(MixinB, MixinC, MixinA, {\n    foo: function() { this._super(); }\n  });\n\n  var obj = {};\n  MixinD.apply(obj);\n  MixinA.apply(obj); // try to apply again..\n\n  cnt = 0;\n  obj.foo();\n\n  equal(cnt, 1, 'should invoke MixinA.foo one time');\n});\n\n// ..........................................................\n// CONFLICTS\n//\n\nmodule('Method Conflicts');\n\n\ntest('overriding toString', function() {\n  var MixinA = Ember.Mixin.create({\n    toString: function() { return 'FOO'; }\n  });\n\n  var obj = {};\n  MixinA.apply(obj);\n  equal(obj.toString(), 'FOO', 'should override toString w/o error');\n\n  obj = {};\n  Ember.mixin(obj, { toString: function() { return 'FOO'; } });\n  equal(obj.toString(), 'FOO', 'should override toString w/o error');\n});\n\n// ..........................................................\n// BUGS\n//\n\nmodule('system/mixin/method_test BUGS');\n\ntest('applying several mixins at once with sup already defined causes infinite loop', function() {\n\n  var cnt = 0;\n  var MixinA = Ember.Mixin.create({\n    foo: function() { cnt++; }\n  });\n\n  var MixinB = Ember.Mixin.create({\n    foo: function() { this._super(); cnt++; }\n  });\n\n  var MixinC = Ember.Mixin.create({\n    foo: function() { this._super(); cnt++; }\n  });\n\n  var obj = {};\n  Ember.mixin(obj, MixinA); // sup already exists\n  Ember.mixin(obj, MixinB, MixinC); // must be more than one mixin\n\n  cnt = 0;\n  obj.foo();\n  equal(cnt, 3, 'should invoke all 3 methods');\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/mixin/method_test");minispade.register('ember-metal/~tests/mixin/observer_test', "(function() {/*globals testBoth */\nminispade.require('ember-metal/~tests/props_helper');\n\nmodule('Ember.Mixin observer');\n\ntestBoth('global observer helper', function(get, set) {\n\n  var MyMixin = Ember.Mixin.create({\n\n    count: 0,\n\n    foo: Ember.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar')\n\n  });\n\n  var obj = Ember.mixin({}, MyMixin);\n  equal(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj, 'bar', \"BAZ\");\n  equal(get(obj, 'count'), 1, 'should invoke observer after change');\n});\n\ntestBoth('global observer helper takes multiple params', function(get, set) {\n\n  var MyMixin = Ember.Mixin.create({\n\n    count: 0,\n\n    foo: Ember.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar', 'baz')\n\n  });\n\n  var obj = Ember.mixin({}, MyMixin);\n  equal(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj, 'bar', \"BAZ\");\n  set(obj, 'baz', \"BAZ\");\n  equal(get(obj, 'count'), 2, 'should invoke observer after change');\n});\n\n\ntestBoth('replacing observer should remove old observer', function(get, set) {\n\n  var MyMixin = Ember.Mixin.create({\n\n    count: 0,\n\n    foo: Ember.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar')\n\n  });\n\n  var Mixin2 = Ember.Mixin.create({\n    foo: Ember.observer(function() {\n      set(this, 'count', get(this, 'count')+10);\n    }, 'baz')\n  });\n\n  var obj = Ember.mixin({}, MyMixin, Mixin2);\n  equal(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj, 'bar', \"BAZ\");\n  equal(get(obj, 'count'), 0, 'should not invoke observer after change');\n\n  set(obj, 'baz', \"BAZ\");\n  equal(get(obj, 'count'), 10, 'should invoke observer after change');\n\n});\n\ntestBoth('observing chain with property before', function(get, set) {\n  var obj2 = {baz: 'baz'};\n\n  var MyMixin = Ember.Mixin.create({\n    count: 0,\n    bar: obj2,\n    foo: Ember.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar.baz')\n  });\n\n  var obj = Ember.mixin({}, MyMixin);\n  equal(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj2, 'baz', \"BAZ\");\n  equal(get(obj, 'count'), 1, 'should invoke observer after change');\n});\n\ntestBoth('observing chain with property after', function(get, set) {\n  var obj2 = {baz: 'baz'};\n\n  var MyMixin = Ember.Mixin.create({\n    count: 0,\n    foo: Ember.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar.baz'),\n    bar: obj2\n  });\n\n  var obj = Ember.mixin({}, MyMixin);\n  equal(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj2, 'baz', \"BAZ\");\n  equal(get(obj, 'count'), 1, 'should invoke observer after change');\n});\n\ntestBoth('observing chain with property in mixin applied later', function(get, set) {\n  var obj2 = {baz: 'baz'};\n\n  var MyMixin = Ember.Mixin.create({\n\n    count: 0,\n    foo: Ember.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar.baz')\n  });\n\n  var MyMixin2 = Ember.Mixin.create({bar: obj2});\n\n  var obj = Ember.mixin({}, MyMixin);\n  equal(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  MyMixin2.apply(obj);\n  equal(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj2, 'baz', \"BAZ\");\n  equal(get(obj, 'count'), 1, 'should invoke observer after change');\n});\n\ntestBoth('observing chain with existing property', function(get, set) {\n  var obj2 = {baz: 'baz'};\n\n  var MyMixin = Ember.Mixin.create({\n    count: 0,\n    foo: Ember.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar.baz')\n  });\n\n  var obj = Ember.mixin({bar: obj2}, MyMixin);\n  equal(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj2, 'baz', \"BAZ\");\n  equal(get(obj, 'count'), 1, 'should invoke observer after change');\n});\n\ntestBoth('observing chain with property in mixin before', function(get, set) {\n  var obj2 = {baz: 'baz'};\n  var MyMixin2 = Ember.Mixin.create({bar: obj2});\n\n  var MyMixin = Ember.Mixin.create({\n    count: 0,\n    foo: Ember.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar.baz')\n  });\n\n  var obj = Ember.mixin({}, MyMixin2, MyMixin);\n  equal(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj2, 'baz', \"BAZ\");\n  equal(get(obj, 'count'), 1, 'should invoke observer after change');\n});\n\ntestBoth('observing chain with property in mixin after', function(get, set) {\n  var obj2 = {baz: 'baz'};\n  var MyMixin2 = Ember.Mixin.create({bar: obj2});\n\n  var MyMixin = Ember.Mixin.create({\n    count: 0,\n    foo: Ember.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar.baz')\n  });\n\n  var obj = Ember.mixin({}, MyMixin, MyMixin2);\n  equal(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj2, 'baz', \"BAZ\");\n  equal(get(obj, 'count'), 1, 'should invoke observer after change');\n});\n\ntestBoth('observing chain with overriden property', function(get, set) {\n  var obj2 = {baz: 'baz'};\n  var obj3 = {baz: 'foo'};\n\n  var MyMixin2 = Ember.Mixin.create({bar: obj3});\n\n  var MyMixin = Ember.Mixin.create({\n    count: 0,\n    foo: Ember.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar.baz')\n  });\n\n  var obj = Ember.mixin({bar: obj2}, MyMixin, MyMixin2);\n  equal(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  equal(Ember.isWatching(obj2, 'baz'), false, 'should not be watching baz');\n  equal(Ember.isWatching(obj3, 'baz'), true, 'should be watching baz');\n\n  set(obj2, 'baz', \"BAZ\");\n  equal(get(obj, 'count'), 0, 'should not invoke observer after change');\n\n  set(obj3, 'baz', \"BEAR\");\n  equal(get(obj, 'count'), 1, 'should invoke observer after change');\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/mixin/observer_test");minispade.register('ember-metal/~tests/mixin/reopen_test', "(function() {module('Ember.Mixin#reopen');\n\ntest('using reopen() to add more properties to a simple', function() {\n  var MixinA = Ember.Mixin.create({ foo: 'FOO', baz: 'BAZ' });\n  MixinA.reopen({ bar: 'BAR', foo: 'FOO2' });\n  var obj = {};\n  MixinA.apply(obj);\n\n  equal(Ember.get(obj, 'foo'), 'FOO2', 'mixin() should override');\n  equal(Ember.get(obj, 'baz'), 'BAZ', 'preserve MixinA props');\n  equal(Ember.get(obj, 'bar'), 'BAR', 'include MixinB props');\n});\n\n\n})();\n//@ sourceURL=ember-metal/~tests/mixin/reopen_test");minispade.register('ember-metal/~tests/mixin/required_test', "(function() {/*globals setup raises */\n\nvar PartialMixin, FinalMixin, obj;\n\nmodule('Module.required', {\n  setup: function() {\n    PartialMixin = Ember.Mixin.create({\n      foo: Ember.required(),\n      bar: 'BAR'\n    });\n\n    FinalMixin = Ember.Mixin.create({\n      foo: 'FOO'\n    });\n\n    obj = {};\n  },\n\n  teardown: function() {\n    PartialMixin = FinalMixin = obj = null;\n  }\n});\n\ntest('applying a mixin to meet requirement', function() {\n  FinalMixin.apply(obj);\n  PartialMixin.apply(obj);\n  equal(Ember.get(obj, 'foo'), 'FOO', 'should now be defined');\n});\n\ntest('combined mixins to meet requirement', function() {\n  Ember.Mixin.create(PartialMixin, FinalMixin).apply(obj);\n  equal(Ember.get(obj, 'foo'), 'FOO', 'should now be defined');\n});\n\ntest('merged mixin', function() {\n  Ember.Mixin.create(PartialMixin, { foo: 'FOO' }).apply(obj);\n  equal(Ember.get(obj, 'foo'), 'FOO', 'should now be defined');\n});\n\ntest('define property on source object', function() {\n  obj.foo = 'FOO';\n  PartialMixin.apply(obj);\n  equal(Ember.get(obj, 'foo'), 'FOO', 'should now be defined');\n});\n\ntest('using apply', function() {\n  Ember.mixin(obj, PartialMixin, { foo: 'FOO' });\n  equal(Ember.get(obj, 'foo'), 'FOO', 'should now be defined');\n});\n\n\n})();\n//@ sourceURL=ember-metal/~tests/mixin/required_test");minispade.register('ember-metal/~tests/mixin/without_test', "(function() {/*globals setup */\n\ntest('without should create a new mixin excluding named properties', function() {\n\n  var MixinA = Ember.Mixin.create({\n    foo: 'FOO',\n    bar: 'BAR'\n  });\n\n  var MixinB = MixinA.without('bar');\n\n  var obj = {};\n  MixinB.apply(obj);\n\n  equal(obj.foo, 'FOO', 'should defined foo');\n  equal(obj.bar, undefined, 'should not define bar');\n\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/mixin/without_test");minispade.register('ember-metal/~tests/observer_test', "(function() {/*globals Global:true */\nminispade.require('ember-metal/~tests/props_helper');\n\n// ..........................................................\n// ADD OBSERVER\n//\n\nmodule('Ember.addObserver');\n\ntestBoth('observer should fire when property is modified', function(get,set) {\n\n  var obj = {};\n  var count = 0;\n\n  Ember.addObserver(obj, 'foo', function() {\n    equal(get(obj, 'foo'), 'bar', 'should invoke AFTER value changed');\n    count++;\n  });\n\n  set(obj, 'foo', 'bar');\n  equal(count, 1, 'should have invoked observer');\n});\n\ntestBoth('observer should fire when dependent property is modified', function(get, set) {\n  var obj = { bar: 'bar' };\n  Ember.defineProperty(obj, 'foo', Ember.computed(function() {\n    return get(this,'bar').toUpperCase();\n  }).property('bar'));\n\n  var count = 0;\n  Ember.addObserver(obj, 'foo', function() {\n    equal(get(obj, 'foo'), 'BAZ', 'should have invoked after prop change');\n    count++;\n  });\n\n  set(obj, 'bar', 'baz');\n  equal(count, 1, 'should have invoked observer');\n});\n\ntestBoth('nested observers should fire in order', function(get,set) {\n  var obj = { foo: 'foo', bar: 'bar' };\n  var fooCount = 0, barCount = 0;\n\n  Ember.addObserver(obj, 'foo' ,function() { fooCount++; });\n  Ember.addObserver(obj, 'bar', function() {\n    set(obj, 'foo', 'BAZ');\n    equal(fooCount, 1, 'fooCount should have fired already');\n    barCount++;\n  });\n\n  set(obj, 'bar', 'BIFF');\n  equal(barCount, 1, 'barCount should have fired');\n  equal(fooCount, 1, 'foo should have fired');\n\n});\n\ntestBoth('suspending an observer should not fire during callback', function(get,set) {\n  var obj = {}, target, otherTarget;\n\n  target = {\n    values: [],\n    method: function() { this.values.push(get(obj, 'foo')); }\n  };\n\n  otherTarget = {\n    values: [],\n    method: function() { this.values.push(get(obj, 'foo')); }\n  };\n\n  Ember.addObserver(obj, 'foo', target, target.method);\n  Ember.addObserver(obj, 'foo', otherTarget, otherTarget.method);\n\n  function callback() {\n      equal(this, target);\n\n      set(obj, 'foo', '2');\n\n      return 'result';\n  }\n\n  set(obj, 'foo', '1');\n\n  equal(Ember._suspendObserver(obj, 'foo', target, target.method, callback), 'result');\n\n  set(obj, 'foo', '3');\n\n  deepEqual(target.values, ['1', '3'], 'should invoke');\n  deepEqual(otherTarget.values, ['1', '2', '3'], 'should invoke');\n});\n\n\ntestBoth('suspending an observer should not defer change notifications during callback', function(get,set) {\n  var obj = {}, target, otherTarget;\n\n  target = {\n    values: [],\n    method: function() { this.values.push(get(obj, 'foo')); }\n  };\n\n  otherTarget = {\n    values: [],\n    method: function() { this.values.push(get(obj, 'foo')); }\n  };\n\n  Ember.addObserver(obj, 'foo', target, target.method);\n  Ember.addObserver(obj, 'foo', otherTarget, otherTarget.method);\n\n  function callback() {\n      equal(this, target);\n\n      set(obj, 'foo', '2');\n\n      return 'result';\n  }\n\n  set(obj, 'foo', '1');\n\n  Ember.beginPropertyChanges();\n  equal(Ember._suspendObserver(obj, 'foo', target, target.method, callback), 'result');\n  Ember.endPropertyChanges();\n\n  set(obj, 'foo', '3');\n\n  deepEqual(target.values, ['1', '3'], 'should invoke');\n  deepEqual(otherTarget.values, ['1', '2', '3'], 'should invoke');\n});\n\ntestBoth('suspending observers should not fire during callback', function(get,set) {\n  var obj = {}, target, otherTarget;\n\n  target = {\n    values: [],\n    method: function() { this.values.push(get(obj, 'foo')); }\n  };\n\n  otherTarget = {\n    values: [],\n    method: function() { this.values.push(get(obj, 'foo')); }\n  };\n\n  Ember.addObserver(obj, 'foo', target, target.method);\n  Ember.addObserver(obj, 'foo', otherTarget, otherTarget.method);\n\n  function callback() {\n      equal(this, target);\n\n      set(obj, 'foo', '2');\n\n      return 'result';\n  }\n\n  set(obj, 'foo', '1');\n\n  equal(Ember._suspendObservers(obj, ['foo'], target, target.method, callback), 'result');\n\n  set(obj, 'foo', '3');\n\n  deepEqual(target.values, ['1', '3'], 'should invoke');\n  deepEqual(otherTarget.values, ['1', '2', '3'], 'should invoke');\n});\n\n\ntestBoth('suspending observers should not defer change notifications during callback', function(get,set) {\n  var obj = {}, target, otherTarget;\n\n  target = {\n    values: [],\n    method: function() { this.values.push(get(obj, 'foo')); }\n  };\n\n  otherTarget = {\n    values: [],\n    method: function() { this.values.push(get(obj, 'foo')); }\n  };\n\n  Ember.addObserver(obj, 'foo', target, target.method);\n  Ember.addObserver(obj, 'foo', otherTarget, otherTarget.method);\n\n  function callback() {\n      equal(this, target);\n\n      set(obj, 'foo', '2');\n\n      return 'result';\n  }\n\n  set(obj, 'foo', '1');\n\n  Ember.beginPropertyChanges();\n  equal(Ember._suspendObservers(obj, ['foo'], target, target.method, callback), 'result');\n  Ember.endPropertyChanges();\n\n  set(obj, 'foo', '3');\n\n  deepEqual(target.values, ['1', '3'], 'should invoke');\n  deepEqual(otherTarget.values, ['1', '2', '3'], 'should invoke');\n});\n\ntestBoth('deferring property change notifications', function(get,set) {\n  var obj = { foo: 'foo' };\n  var fooCount = 0;\n\n  Ember.addObserver(obj, 'foo' ,function() { fooCount++; });\n\n  Ember.beginPropertyChanges(obj);\n  set(obj, 'foo', 'BIFF');\n  set(obj, 'foo', 'BAZ');\n  Ember.endPropertyChanges(obj);\n\n  equal(fooCount, 1, 'foo should have fired once');\n});\n\ntestBoth('deferring property change notifications safely despite exceptions', function(get,set) {\n  var obj = { foo: 'foo' };\n  var fooCount = 0;\n  var exc = new Error(\"Something unexpected happened!\");\n\n  expect(2);\n  Ember.addObserver(obj, 'foo' ,function() { fooCount++; });\n\n  try {\n    Ember.changeProperties(function(){\n      set(obj, 'foo', 'BIFF');\n      set(obj, 'foo', 'BAZ');\n      throw exc;\n    });\n  } catch(err) {\n    if (err !== exc)\n      throw err;\n  }\n\n  equal(fooCount, 1, 'foo should have fired once');\n\n  Ember.changeProperties(function(){\n    set(obj, 'foo', 'BIFF2');\n    set(obj, 'foo', 'BAZ2');\n  });\n\n  equal(fooCount, 2, 'foo should have fired again once');\n});\n\ntestBoth('deferring property change notifications will not defer before observers', function(get,set) {\n  var obj = { foo: 'foo' };\n  var fooCount = 0;\n\n  Ember.addBeforeObserver(obj, 'foo' ,function() { fooCount++; });\n\n  Ember.beginPropertyChanges(obj);\n  set(obj, 'foo', 'BIFF');\n  equal(fooCount, 1, 'should fire before observer immediately');\n  set(obj, 'foo', 'BAZ');\n  Ember.endPropertyChanges(obj);\n\n  equal(fooCount, 1, 'should not fire before observer twice');\n});\n\ntestBoth('implementing sendEvent on object should invoke when deferring property change notifications ends', function(get, set) {\n  var count = 0, events = [];\n  var obj = {\n    sendEvent: function(eventName) {\n      events.push(eventName);\n    },\n    foo: 'baz'\n  };\n\n  Ember.addObserver(obj, 'foo', function() { count++; });\n\n  Ember.beginPropertyChanges(obj);\n  set(obj, 'foo', 'BAZ');\n\n  equal(count, 0, 'should have not invoked observer');\n  equal(events.length, 1, 'should have invoked sendEvent for before');\n\n  Ember.endPropertyChanges(obj);\n\n  equal(count, 1, 'should have invoked observer');\n  equal(events.length, 2, 'should have invoked sendEvent');\n  equal(events[0], 'foo:before');\n  equal(events[1], 'foo:change');\n});\n\ntestBoth('addObserver should propagate through prototype', function(get,set) {\n  var obj = { foo: 'foo', count: 0 }, obj2;\n\n  Ember.addObserver(obj, 'foo', function() { this.count++; });\n  obj2 = Ember.create(obj);\n\n  set(obj2, 'foo', 'bar');\n\n  equal(obj2.count, 1, 'should have invoked observer on inherited');\n  equal(obj.count, 0, 'should not have invoked observer on parent');\n\n  obj2.count = 0;\n  set(obj, 'foo', 'baz');\n  equal(obj.count, 1, 'should have invoked observer on parent');\n  equal(obj2.count, 0, 'should not have invoked observer on inherited');\n});\n\ntestBoth('addObserver should respect targets with methods', function(get,set){\n  var observed = { foo: 'foo' };\n\n  var target1 = {\n    count: 0,\n\n    didChange: function(obj, keyName) {\n      var value = get(obj, keyName);\n      equal(this, target1, 'should invoke with this');\n      equal(obj, observed, 'param1 should be observed object');\n      equal(keyName, 'foo', 'param2 should be keyName');\n      equal(value, 'BAZ', 'param3 should new value');\n      this.count++;\n    }\n  };\n\n  var target2 = {\n    count: 0,\n\n    didChange: function(obj, keyName) {\n      var value = get(obj, keyName);\n      equal(this, target2, 'should invoke with this');\n      equal(obj, observed, 'param1 should be observed object');\n      equal(keyName, 'foo', 'param2 should be keyName');\n      equal(value, 'BAZ', 'param3 should new value');\n      this.count++;\n    }\n  };\n\n  Ember.addObserver(observed, 'foo', target1, 'didChange');\n  Ember.addObserver(observed, 'foo', target2, target2.didChange);\n\n  set(observed, 'foo', 'BAZ');\n  equal(target1.count, 1, 'target1 observer should have fired');\n  equal(target2.count, 1, 'target2 observer should have fired');\n\n});\n\ntestBoth('addObserver should allow multiple objects to observe a property', function(get, set) { var observed = { foo: 'foo' };\n\n  var target1 = {\n    count: 0,\n\n    didChange: function(obj, keyName, value) {\n      this.count++;\n    }\n  };\n\n  var target2 = {\n    count: 0,\n\n    didChange: function(obj, keyName, value) {\n      this.count++;\n    }\n  };\n\n  Ember.addObserver(observed, 'foo', target1, 'didChange');\n  Ember.addObserver(observed, 'foo', target2, 'didChange');\n\n  set(observed, 'foo', 'BAZ');\n  equal(target1.count, 1, 'target1 observer should have fired');\n  equal(target2.count, 1, 'target2 observer should have fired');\n});\n\n// ..........................................................\n// REMOVE OBSERVER\n//\n\nmodule('Ember.removeObserver');\n\ntestBoth('removing observer should stop firing', function(get,set) {\n\n  var obj = {};\n  var count = 0;\n  function F() { count++; }\n  Ember.addObserver(obj, 'foo', F);\n\n  set(obj, 'foo', 'bar');\n  equal(count, 1, 'should have invoked observer');\n\n  Ember.removeObserver(obj, 'foo', F);\n\n  set(obj, 'foo', 'baz');\n  equal(count, 1, \"removed observer shouldn't fire\");\n});\n\ntestBoth('local observers can be removed', function(get, set) {\n  var barObserved = 0;\n\n  var MyMixin = Ember.Mixin.create({\n    foo1: Ember.observer(function() {\n      barObserved++;\n    }, 'bar'),\n\n    foo2: Ember.observer(function() {\n      barObserved++;\n    }, 'bar')\n  });\n\n  var obj = {};\n  MyMixin.apply(obj);\n\n  set(obj, 'bar', 'HI!');\n  equal(barObserved, 2, 'precond - observers should be fired');\n\n  Ember.removeObserver(obj, 'bar', null, 'foo1');\n\n  barObserved = 0;\n  set(obj, 'bar', 'HI AGAIN!');\n\n  equal(barObserved, 1, 'removed observers should not be called');\n});\n\ntestBoth('removeObserver should respect targets with methods', function(get,set){\n  var observed = { foo: 'foo' };\n\n  var target1 = {\n    count: 0,\n\n    didChange: function() {\n      this.count++;\n    }\n  };\n\n  var target2 = {\n    count: 0,\n\n    didChange: function() {\n      this.count++;\n    }\n  };\n\n  Ember.addObserver(observed, 'foo', target1, 'didChange');\n  Ember.addObserver(observed, 'foo', target2, target2.didChange);\n\n  set(observed, 'foo', 'BAZ');\n  equal(target1.count, 1, 'target1 observer should have fired');\n  equal(target2.count, 1, 'target2 observer should have fired');\n\n  Ember.removeObserver(observed, 'foo', target1, 'didChange');\n  Ember.removeObserver(observed, 'foo', target2, target2.didChange);\n\n  target1.count = target2.count = 0;\n  set(observed, 'foo', 'BAZ');\n  equal(target1.count, 0, 'target1 observer should not fire again');\n  equal(target2.count, 0, 'target2 observer should not fire again');\n});\n\n// ..........................................................\n// BEFORE OBSERVER\n//\n\nmodule('Ember.addBeforeObserver');\n\ntestBoth('observer should fire before a property is modified', function(get,set) {\n\n  var obj = { foo: 'foo' };\n  var count = 0;\n\n  Ember.addBeforeObserver(obj, 'foo', function() {\n    equal(get(obj, 'foo'), 'foo', 'should invoke before value changed');\n    count++;\n  });\n\n  set(obj, 'foo', 'bar');\n  equal(count, 1, 'should have invoked observer');\n});\n\ntestBoth('observer should fire before dependent property is modified', function(get, set) {\n  var obj = { bar: 'bar' };\n  Ember.defineProperty(obj, 'foo', Ember.computed(function() {\n    return get(this,'bar').toUpperCase();\n  }).property('bar'));\n\n  var count = 0;\n  Ember.addBeforeObserver(obj, 'foo', function() {\n    equal(get(obj, 'foo'), 'BAR', 'should have invoked after prop change');\n    count++;\n  });\n\n  set(obj, 'bar', 'baz');\n  equal(count, 1, 'should have invoked observer');\n});\n\ntestBoth('addBeforeObserver should propagate through prototype', function(get,set) {\n  var obj = { foo: 'foo', count: 0 }, obj2;\n\n  Ember.addBeforeObserver(obj, 'foo', function() { this.count++; });\n  obj2 = Ember.create(obj);\n\n  set(obj2, 'foo', 'bar');\n  equal(obj2.count, 1, 'should have invoked observer on inherited');\n  equal(obj.count, 0, 'should not have invoked observer on parent');\n\n  obj2.count = 0;\n  set(obj, 'foo', 'baz');\n  equal(obj.count, 1, 'should have invoked oberver on parent');\n  equal(obj2.count, 0, 'should not have invoked observer on inherited');\n});\n\ntestBoth('addBeforeObserver should respect targets with methods', function(get,set){\n  var observed = { foo: 'foo' };\n\n  var target1 = {\n    count: 0,\n\n    willChange: function(obj, keyName) {\n      var value = get(obj, keyName);\n      equal(this, target1, 'should invoke with this');\n      equal(obj, observed, 'param1 should be observed object');\n      equal(keyName, 'foo', 'param2 should be keyName');\n      equal(value, 'foo', 'param3 should old value');\n      this.count++;\n    }\n  };\n\n  var target2 = {\n    count: 0,\n\n    willChange: function(obj, keyName) {\n      var value = get(obj, keyName);\n      equal(this, target2, 'should invoke with this');\n      equal(obj, observed, 'param1 should be observed object');\n      equal(keyName, 'foo', 'param2 should be keyName');\n      equal(value, 'foo', 'param3 should old value');\n      this.count++;\n    }\n  };\n\n  Ember.addBeforeObserver(observed, 'foo', target1, 'willChange');\n  Ember.addBeforeObserver(observed, 'foo', target2, target2.willChange);\n\n  set(observed, 'foo', 'BAZ');\n  equal(target1.count, 1, 'target1 observer should have fired');\n  equal(target2.count, 1, 'target2 observer should have fired');\n\n});\n\n// ..........................................................\n// CHAINED OBSERVERS\n//\n\nvar obj, count;\nvar originalLookup = Ember.lookup, lookup;\n\nmodule('Ember.addObserver - dependentkey with chained properties', {\n  setup: function() {\n    obj = {\n      foo: {\n        bar: {\n          baz: {\n            biff: \"BIFF\"\n          }\n        }\n      }\n    };\n\n    Ember.lookup = lookup = {\n      Global: {\n        foo: {\n          bar: {\n            baz: {\n              biff: \"BIFF\"\n            }\n          }\n        }\n      }\n    };\n\n    count = 0;\n  },\n\n  teardown: function() {\n    obj = count = null;\n    Ember.lookup = originalLookup;\n  }\n});\n\ntestBoth('depending on a simple chain', function(get, set) {\n\n  var val ;\n  Ember.addObserver(obj, 'foo.bar.baz.biff', function(target, key) {\n    val = Ember.get(target, key);\n    count++;\n  });\n\n  set(Ember.get(obj, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equal(val, 'BUZZ');\n  equal(count, 1);\n\n  set(Ember.get(obj, 'foo.bar'), 'baz', { biff: 'BLARG' });\n  equal(val, 'BLARG');\n  equal(count, 2);\n\n  set(Ember.get(obj, 'foo'), 'bar', { baz: { biff: 'BOOM' } });\n  equal(val, 'BOOM');\n  equal(count, 3);\n\n  set(obj, 'foo', { bar: { baz: { biff: 'BLARG' } } });\n  equal(val, 'BLARG');\n  equal(count, 4);\n\n  set(Ember.get(obj, 'foo.bar.baz'), 'biff', 'BUZZ');\n  equal(val, 'BUZZ');\n  equal(count, 5);\n\n  var foo = get(obj, 'foo');\n\n  set(obj, 'foo', 'BOO');\n  equal(val, undefined);\n  equal(count, 6);\n\n  set(foo.bar.baz, 'biff', \"BOOM\");\n  equal(count, 6, 'should be not have invoked observer');\n});\n\ntestBoth('depending on a Global chain', function(get, set) {\n  var Global = lookup.Global, val;\n\n  Ember.addObserver(obj, 'Global.foo.bar.baz.biff', function(target, key){\n    val = Ember.get(lookup, key);\n    count++;\n  });\n\n  set(Ember.get(Global, 'foo.bar.baz'),  'biff', 'BUZZ');\n  equal(val, 'BUZZ');\n  equal(count, 1);\n\n  set(Ember.get(Global, 'foo.bar'),  'baz', { biff: 'BLARG' });\n  equal(val, 'BLARG');\n  equal(count, 2);\n\n  set(Ember.get(Global, 'foo'),  'bar', { baz: { biff: 'BOOM' } });\n  equal(val, 'BOOM');\n  equal(count, 3);\n\n  set(Global, 'foo', { bar: { baz: { biff: 'BLARG' } } });\n  equal(val, 'BLARG');\n  equal(count, 4);\n\n  set(Ember.get(Global, 'foo.bar.baz'),  'biff', 'BUZZ');\n  equal(val, 'BUZZ');\n  equal(count, 5);\n\n  var foo = get(obj, 'foo');\n\n  set(Global, 'foo', 'BOO');\n  equal(val, undefined);\n  equal(count, 6);\n\n  set(foo.bar.baz, 'biff', \"BOOM\");\n  equal(count, 6, 'should be not have invoked observer');\n});\n\n// ..........................................................\n// SETTING IDENTICAL VALUES\n//\n\nmodule('props/observer_test - setting identical values');\n\ntestBoth('setting simple prop should not trigger', function(get, set) {\n\n  var obj = { foo: 'bar' };\n  var count = 0;\n\n  Ember.addObserver(obj, 'foo', function() { count++; });\n\n  set(obj, 'foo', 'bar');\n  equal(count, 0, 'should not trigger observer');\n\n  set(obj, 'foo', 'baz');\n  equal(count, 1, 'should trigger observer');\n\n  set(obj, 'foo', 'baz');\n  equal(count, 1, 'should not trigger observer again');\n});\n\n// The issue here is when a computed property is directly set with a value, then has a\n// dependent key change (which triggers a cache expiration and recomputation), observers will\n// not be fired if the CP setter is called with the last set value.\ntestBoth('setting a cached computed property whose value has changed should trigger', function(get, set) {\n  var obj = {};\n\n  Ember.defineProperty(obj, 'foo', Ember.computed(function(key, value) {\n    if (arguments.length === 2) { return value; }\n    return get(this, 'baz');\n  }).property('baz'));\n\n  var count = 0;\n\n  Ember.addObserver(obj, 'foo', function() { count++; });\n\n  set(obj, 'foo', 'bar');\n  equal(count, 1);\n  equal(get(obj, 'foo'), 'bar');\n\n  set(obj, 'baz', 'qux');\n  equal(count, 2);\n  equal(get(obj, 'foo'), 'qux');\n\n  get(obj, 'foo');\n  set(obj, 'foo', 'bar');\n  equal(count, 3);\n  equal(get(obj, 'foo'), 'bar');\n});\n\nmodule(\"Ember.immediateObserver\");\n\ntestBoth(\"immediate observers should fire synchronously\", function(get, set) {\n  var obj = {},\n      observerCalled = 0,\n      mixin;\n\n  // explicitly create a run loop so we do not inadvertently\n  // trigger deferred behavior\n  Ember.run(function() {\n    mixin = Ember.Mixin.create({\n      fooDidChange: Ember.immediateObserver(function() {\n        observerCalled++;\n        equal(get(this, 'foo'), \"barbaz\", \"newly set value is immediately available\");\n      }, 'foo')\n    });\n\n    mixin.apply(obj);\n\n    Ember.defineProperty(obj, 'foo', Ember.computed(function(key, value) {\n      if (arguments.length > 1) {\n        return value;\n      }\n      return \"yes hello this is foo\";\n    }));\n\n    equal(get(obj, 'foo'), \"yes hello this is foo\", \"precond - computed property returns a value\");\n    equal(observerCalled, 0, \"observer has not yet been called\");\n\n    set(obj, 'foo', 'barbaz');\n\n    equal(observerCalled, 1, \"observer was called once\");\n  });\n});\n\ntestBoth(\"immediate observers are for internal properties only\", function(get, set) {\n  raises(function() {\n    Ember.immediateObserver(Ember.K, 'foo.bar');\n  });\n});\n\nmodule(\"Ember.changeProperties\");\n\ntestBoth(\"observers added/removed during changeProperties should do the right thing.\", function(get,set) {\n  var obj = {\n    foo: 0\n  };\n  function Observer() {\n    this.willChangeCount = 0;\n    this.didChangeCount = 0;\n  }\n  Observer.prototype = {\n    add: function () {\n      Ember.addBeforeObserver(obj, 'foo', this, 'willChange');\n      Ember.addObserver(obj, 'foo', this, 'didChange');\n    },\n    remove: function() {\n      Ember.removeBeforeObserver(obj, 'foo', this, 'willChange');\n      Ember.removeObserver(obj, 'foo', this, 'didChange');\n    },\n    willChange: function () {\n      this.willChangeCount++;\n    },\n    didChange: function () {\n      this.didChangeCount++;\n    }\n  };\n  var addedBeforeFirstChangeObserver = new Observer();\n  var addedAfterFirstChangeObserver = new Observer();\n  var addedAfterLastChangeObserver = new Observer();\n  var removedBeforeFirstChangeObserver = new Observer();\n  var removedBeforeLastChangeObserver = new Observer();\n  var removedAfterLastChangeObserver = new Observer();\n  removedBeforeFirstChangeObserver.add();\n  removedBeforeLastChangeObserver.add();\n  removedAfterLastChangeObserver.add();\n  Ember.changeProperties(function () {\n    removedBeforeFirstChangeObserver.remove();\n    addedBeforeFirstChangeObserver.add();\n\n    set(obj, 'foo', 1);\n\n    equal(addedBeforeFirstChangeObserver.willChangeCount, 1, 'addBeforeObserver called before the first change invoked immediately');\n    equal(addedBeforeFirstChangeObserver.didChangeCount, 0, 'addObserver called before the first change is deferred');\n\n    addedAfterFirstChangeObserver.add();\n    removedBeforeLastChangeObserver.remove();\n\n    set(obj, 'foo', 2);\n\n    equal(addedAfterFirstChangeObserver.willChangeCount, 1, 'addBeforeObserver called after the first change invoked immediately');\n    equal(addedAfterFirstChangeObserver.didChangeCount, 0, 'addObserver called after the first change is deferred');\n\n    addedAfterLastChangeObserver.add();\n    removedAfterLastChangeObserver.remove();\n  });\n\n  equal(removedBeforeFirstChangeObserver.willChangeCount, 0, 'removeBeforeObserver called before the first change sees none');\n  equal(removedBeforeFirstChangeObserver.didChangeCount,  0, 'removeObserver called before the first change sees none');\n  equal(addedBeforeFirstChangeObserver.willChangeCount,   1, 'addBeforeObserver called before the first change sees only 1');\n  equal(addedBeforeFirstChangeObserver.didChangeCount,    1, 'addObserver called before the first change sees only 1');\n  equal(addedAfterFirstChangeObserver.willChangeCount,    1, 'addBeforeObserver called after the first change sees 1');\n  equal(addedAfterFirstChangeObserver.didChangeCount,     1, 'addObserver called after the first change sees 1');\n  equal(addedAfterLastChangeObserver.willChangeCount,     0, 'addBeforeObserver called after the last change sees none');\n  equal(addedAfterLastChangeObserver.didChangeCount,      0, 'addObserver called after the last change sees none');\n  equal(removedBeforeLastChangeObserver.willChangeCount,  1, 'removeBeforeObserver called before the last change still sees 1');\n  equal(removedBeforeLastChangeObserver.didChangeCount,   1, 'removeObserver called before the last change still sees 1');\n  equal(removedAfterLastChangeObserver.willChangeCount,   1, 'removeBeforeObserver called after the last change still sees 1');\n  equal(removedAfterLastChangeObserver.didChangeCount,    1, 'removeObserver called after the last change still sees 1');\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/observer_test");minispade.register('ember-metal/~tests/performance_test', "(function() {/*\n  This test file is designed to capture performance regressions related to\n  deferred computation. Things like run loops, computed properties, and bindings\n  should run the minimum amount of times to achieve best performance, so any\n  bugs that cause them to get evaluated more than necessary should be put here.\n*/\n\nmodule(\"Computed Properties - Number of times evaluated\");\n\ntest(\"computed properties that depend on multiple properties should run only once per run loop\", function() {\n  var obj = {a: 'a', b: 'b', c: 'c'};\n  var cpCount = 0, obsCount = 0;\n\n  Ember.defineProperty(obj, 'abc', Ember.computed(function(key) {\n    cpCount++;\n    return 'computed '+key;\n  }).property('a', 'b', 'c'));\n\n  Ember.addObserver(obj, 'abc', function() {\n    obsCount++;\n  });\n\n  Ember.beginPropertyChanges();\n  Ember.set(obj, 'a', 'aa');\n  Ember.set(obj, 'b', 'bb');\n  Ember.set(obj, 'c', 'cc');\n  Ember.endPropertyChanges();\n\n  Ember.get(obj, 'abc');\n\n  equal(cpCount, 1, \"The computed property is only invoked once\");\n  equal(obsCount, 1, \"The observer is only invoked once\");\n});\n\ntest(\"computed properties are not executed if they are the last segment of an observer chain pain\", function() {\n  var foo = { bar: { baz: { } } };\n\n  var count = 0;\n\n  Ember.defineProperty(foo.bar.baz, 'bam', Ember.computed(function() {\n    count++;\n  }));\n\n  Ember.addObserver(foo, 'bar.baz.bam', function() {});\n\n  Ember.propertyDidChange(Ember.get(foo, 'bar.baz'), 'bam');\n\n  equal(count, 0, \"should not have recomputed property\");\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/performance_test");minispade.register('ember-metal/~tests/platform/create_test', "(function() {module(\"Ember.create()\");\n\ntest(\"should inherit the properties from the parent object\", function() {\n  var obj = { foo: 'FOO' };\n  var obj2 = Ember.create(obj);\n  ok(obj !== obj2, 'should be a new instance');\n  equal(obj2.foo, obj.foo, 'should inherit from parent');\n\n  obj2.foo = 'BAR';\n  equal(obj2.foo, 'BAR', 'should change foo');\n  equal(obj.foo, 'FOO', 'modifying obj2 should not modify obj');\n});\n\n// NOTE: jshint may interfere with this test since it defines its own Object.create if missing\ntest(\"passing additional property descriptors should define\", function() {\n  var obj = { foo: 'FOO', repl: 'obj' };\n  var obj2 = Ember.create(obj, {\n    bar: {\n      value: 'BAR'\n    },\n\n    repl: {\n      value: 'obj2'\n    }\n  });\n\n  equal(obj2.bar, 'BAR', 'should have defined');\n  equal(obj2.repl, 'obj2', 'should have replaced parent');\n});\n\n\n})();\n//@ sourceURL=ember-metal/~tests/platform/create_test");minispade.register('ember-metal/~tests/platform/defineProperty_test', "(function() {function isEnumerable(obj, keyName) {\n  var keys = [];\n  for(var key in obj) {\n    if (obj.hasOwnProperty(key)) keys.push(key);\n  }\n  return Ember.EnumerableUtils.indexOf(keys, keyName)>=0;\n}\n\nmodule(\"Ember.platform.defineProperty()\");\n\ntest(\"defining a simple property\", function() {\n  var obj = {};\n  Ember.platform.defineProperty(obj, 'foo', {\n    enumerable:   true,\n    writable:     true,\n    value: 'FOO'\n  });\n\n  equal(obj.foo, 'FOO', 'should have added property');\n\n  obj.foo = \"BAR\";\n  equal(obj.foo, 'BAR', 'writable defined property should be writable');\n  equal(isEnumerable(obj, 'foo'), true, 'foo should be enumerable');\n});\n\ntest('defining a read only property', function() {\n  var obj = {};\n  Ember.platform.defineProperty(obj, 'foo', {\n    enumerable:   true,\n    writable:     false,\n    value: 'FOO'\n  });\n\n  equal(obj.foo, 'FOO', 'should have added property');\n\n  obj.foo = \"BAR\";\n  if (Ember.platform.defineProperty.isSimulated) {\n    equal(obj.foo, 'BAR', 'simulated defineProperty should silently work');\n  } else {\n    equal(obj.foo, 'FOO', 'real defined property should not be writable');\n  }\n\n});\n\ntest('defining a non enumerable property', function() {\n  var obj = {};\n  Ember.platform.defineProperty(obj, 'foo', {\n    enumerable:   false,\n    writable:     true,\n    value: 'FOO'\n  });\n\n  if (Ember.platform.defineProperty.isSimulated) {\n    equal(isEnumerable(obj, 'foo'), true, 'simulated defineProperty will leave properties enumerable');\n  } else {\n    equal(isEnumerable(obj, 'foo'), false, 'real defineProperty will make property not-enumerable');\n  }\n});\n\n// If accessors don't exist, behavior that relies on getters\n// and setters don't do anything\nif (Ember.platform.hasPropertyAccessors) {\n  test('defining a getter/setter', function() {\n    var obj = {}, getCnt = 0, setCnt = 0, v = 'FOO';\n\n    var desc = {\n      enumerable: true,\n      get: function() { getCnt++; return v; },\n      set: function(val) { setCnt++; v = val; }\n    };\n\n    if (Ember.platform.hasPropertyAccessors) {\n      Ember.platform.defineProperty(obj, 'foo', desc);\n      equal(obj.foo, 'FOO', 'should return getter');\n      equal(getCnt, 1, 'should have invoked getter');\n\n      obj.foo = 'BAR';\n      equal(obj.foo, 'BAR', 'setter should have worked');\n      equal(setCnt, 1, 'should have invoked setter');\n\n    }\n\n  });\n\n  test('defining getter/setter along with writable', function() {\n    var obj  ={};\n    raises(function() {\n      Ember.platform.defineProperty(obj, 'foo', {\n        enumerable: true,\n        get: function() {},\n        set: function() {},\n        writable: true\n      });\n    }, Error, 'defining writable and get/set should throw exception');\n  });\n\n  test('defining getter/setter along with value', function() {\n    var obj  ={};\n    raises(function() {\n      Ember.platform.defineProperty(obj, 'foo', {\n        enumerable: true,\n        get: function() {},\n        set: function() {},\n        value: 'FOO'\n      });\n    }, Error, 'defining value and get/set should throw exception');\n  });\n}\n\n})();\n//@ sourceURL=ember-metal/~tests/platform/defineProperty_test");minispade.register('ember-metal/~tests/properties_test', "(function() {module('Ember.defineProperty');\n\ntest('toString', function() {\n\n  var obj = {};\n  Ember.defineProperty(obj, 'toString', undefined, function() { return 'FOO'; });\n  equal(obj.toString(), 'FOO', 'should replace toString');\n});\n\ntest(\"for data properties, didDefineProperty hook should be called if implemented\", function() {\n  expect(2);\n\n  var obj = {\n    didDefineProperty: function(obj, keyName, value) {\n      equal(keyName, 'foo', \"key name should be foo\");\n      equal(value, 'bar', \"value should be bar\");\n    }\n  };\n\n  Ember.defineProperty(obj, 'foo', undefined, \"bar\");\n});\n\ntest(\"for descriptor properties, didDefineProperty hook should be called if implemented\", function() {\n  expect(2);\n\n  var computedProperty = Ember.computed(Ember.K);\n\n  var obj = {\n    didDefineProperty: function(obj, keyName, value) {\n      equal(keyName, 'foo', \"key name should be foo\");\n      strictEqual(value, computedProperty, \"value should be passed descriptor\");\n    }\n  };\n\n  Ember.defineProperty(obj, 'foo', computedProperty);\n});\n\n\n})();\n//@ sourceURL=ember-metal/~tests/properties_test");minispade.register('ember-metal/~tests/props_helper', "(function() {/*global testBoth:true */\n\n// used by unit tests to test both accessor mode and non-accessor mode\ntestBoth = function(testname, callback) {\n  test(testname+' using Ember.get()/Ember.set()', function() {\n    callback(Ember.get, Ember.set);\n  });\n\n  // test(testname+' using accessors', function() {\n  //   if (Ember.USES_ACCESSORS) callback(aget, aset);\n  //   else ok('SKIPPING ACCESSORS');\n  // });\n};\n\n})();\n//@ sourceURL=ember-metal/~tests/props_helper");minispade.register('ember-metal/~tests/run_loop/later_test', "(function() {\nvar originalSetTimeout = window.setTimeout,\n    originalDateValueOf = Date.prototype.valueOf;\n\nmodule('Ember.run.later', {\n  teardown: function() {\n    window.setTimeout = originalSetTimeout;\n    Date.prototype.valueOf = originalDateValueOf;\n  }\n});\n\nvar previousPreventRunloop;\n\nasyncTest('should invoke after specified period of time - function only', function() {\n\n  var invoked = false;\n\n  Ember.run(function() {\n    Ember.run.later(function() { invoked = true; }, 100);\n  });\n\n  setTimeout(function() {\n    start();\n    equal(invoked, true, 'should have invoked later item');\n  }, 150);\n\n});\n\n\nasyncTest('should invoke after specified period of time - target/method', function() {\n\n  var obj = { invoked: false } ;\n\n  Ember.run(function() {\n    Ember.run.later(obj, function() { this.invoked = true; }, 100);\n  });\n\n  setTimeout(function() {\n    start();\n    equal(obj.invoked, true, 'should have invoked later item');\n  }, 150);\n\n});\n\n\nasyncTest('should invoke after specified period of time - target/method/args', function() {\n\n  var obj = { invoked: 0 } ;\n\n  Ember.run(function() {\n    Ember.run.later(obj, function(amt) { this.invoked += amt; }, 10, 100);\n  });\n\n  setTimeout(function() {\n    start();\n    equal(obj.invoked, 10, 'should have invoked later item');\n  }, 150);\n\n});\n\nasyncTest('should always invoke within a separate runloop', function() {\n  var obj = { invoked: 0 }, firstRunLoop, secondRunLoop;\n\n  Ember.run(function() {\n    firstRunLoop = Ember.run.currentRunLoop;\n\n    Ember.run.later(obj, function(amt) {\n      this.invoked += amt;\n      secondRunLoop = Ember.run.currentRunLoop;\n    }, 10, 1);\n\n    // Synchronous \"sleep\". This simulates work being done\n    // after run.later was called but before the run loop\n    // has flushed. In previous versions, this would have\n    // caused the run.later callback to have run from\n    // within the run loop flush, since by the time the\n    // run loop has to flush, it would have considered\n    // the timer already expired.\n    var pauseUntil = +new Date() + 100;\n    while(+new Date() < pauseUntil) { /* do nothing - sleeping */ }\n  });\n\n  ok(firstRunLoop, \"first run loop captured\");\n  ok(!Ember.run.currentRunLoop, \"shouldn't be in a run loop after flush\");\n  equal(obj.invoked, 0, \"shouldn't have invoked later item yet\");\n\n  setTimeout(function() {\n    start();\n    equal(obj.invoked, 10, \"should have invoked later item\");\n    ok(secondRunLoop, \"second run loop took place\");\n    ok(secondRunLoop !== firstRunLoop, \"two different run loops took place\");\n  }, 150);\n});\n\nasyncTest('callback order', function() {\n\n  var array = [];\n  function fn(val) { array.push(val); }\n\n  Ember.run(function() {\n    Ember.run.later(this, fn, 4, 130);\n    Ember.run.later(this, fn, 1, 10);\n    Ember.run.later(this, fn, 5, 200);\n    Ember.run.later(this, fn, 2, 80);\n    Ember.run.later(this, fn, 3, 80);\n  });\n\n  deepEqual(array, []);\n\n  setTimeout(function() {\n    start();\n    deepEqual(array, [1,2,3,4,5], 'callbacks were called in expected order');\n  }, 250);\n});\n\nasyncTest('callbacks coalesce into same run loop if expiring at the same time', function() {\n\n\n  var array = [];\n  function fn(val) { array.push(Ember.run.currentRunLoop); }\n\n  Ember.run(function() {\n\n    // Force +new Date to return the same result while scheduling\n    // run.later timers. Otherwise: non-determinism!\n    var now = +new Date();\n    Date.prototype.valueOf = function() { return now; };\n\n    Ember.run.later(this, fn, 10);\n    Ember.run.later(this, fn, 100);\n    Ember.run.later(this, fn, 100);\n\n    Date.prototype.valueOf = originalDateValueOf;\n  });\n\n  deepEqual(array, []);\n\n  setTimeout(function() {\n    start();\n    equal(array.length, 3, 'all callbacks called');\n    ok(array[0] !== array[1], 'first two callbacks have different run loops');\n    ok(array[0], 'first runloop present');\n    ok(array[1], 'second runloop present');\n    equal(array[1], array[2], 'last two callbacks got the same run loop');\n  }, 200);\n});\n\nasyncTest('inception calls to run.later should run callbacks in separate run loops', function() {\n\n  var runLoop, finished;\n\n  Ember.run(function() {\n    runLoop = Ember.run.currentRunLoop;\n    ok(runLoop);\n\n    Ember.run.later(function() {\n      ok(Ember.run.currentRunLoop && Ember.run.currentRunLoop !== runLoop,\n         'first later callback has own run loop');\n      runLoop = Ember.run.currentRunLoop;\n\n      Ember.run.later(function() {\n        ok(Ember.run.currentRunLoop && Ember.run.currentRunLoop !== runLoop,\n           'second later callback has own run loop');\n        finished = true;\n      }, 40);\n    }, 40);\n  });\n\n  setTimeout(function() {\n    start();\n    ok(finished, 'all .later callbacks run');\n  }, 150);\n});\n\nasyncTest('setTimeout should never run with a negative wait', function() {\n\n  // Rationale: The old run loop code was susceptible to an occasional\n  // bug where invokeLaterTimers would be scheduled with a setTimeout\n  // with a negative wait. Modern browsers normalize this to 0, but\n  // older browsers (IE <= 8) break with a negative wait, which\n  // happens when an expired timer callback takes a while to run,\n  // which is what we simulate here.\n  var newSetTimeoutUsed;\n  window.setTimeout = function() {\n    var wait = arguments[arguments.length - 1];\n    newSetTimeoutUsed = true;\n    ok(!isNaN(wait) && wait >= 0, 'wait is a non-negative number');\n    originalSetTimeout.apply(this, arguments);\n  };\n\n  var count = 0;\n  Ember.run(function() {\n\n    Ember.run.later(function() {\n      count++;\n\n      // This will get run first. Waste some time.\n      // This is intended to break invokeLaterTimers code by taking a\n      // long enough time that other timers should technically expire. It's\n      // fine that they're not called in this run loop; just need to\n      // make sure that invokeLaterTimers doesn't end up scheduling\n      // a negative setTimeout.\n      var pauseUntil = +new Date() + 60;\n      while(+new Date() < pauseUntil) { /* do nothing - sleeping */ }\n    }, 1);\n\n    Ember.run.later(function() {\n      equal(count, 1, 'callbacks called in order');\n    }, 50);\n  });\n\n  originalSetTimeout(function() {\n    window.setTimeout = originalSetTimeout;\n    start();\n    ok(newSetTimeoutUsed, 'stub setTimeout was used');\n  }, 200);\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/run_loop/later_test");minispade.register('ember-metal/~tests/run_loop/next_test', "(function() {module('Ember.run.next');\n\nasyncTest('should invoke immediately on next timeout', function() {\n\n  var invoked = false;\n\n  Ember.run(function() {\n    Ember.run.next(function() { invoked = true; });\n  });\n\n  equal(invoked, false, 'should not have invoked yet');\n\n\n  setTimeout(function() {\n    start();\n    equal(invoked, true, 'should have invoked later item');\n  }, 20);\n\n});\n\nasyncTest('callback should be called from within separate loop', function() {\n  var firstRunLoop, secondRunLoop;\n  Ember.run(function() {\n    firstRunLoop = Ember.run.currentRunLoop;\n    Ember.run.next(function() { secondRunLoop = Ember.run.currentRunLoop; });\n  });\n\n  setTimeout(function() {\n    start();\n    ok(secondRunLoop, 'callback was called from within run loop');\n    ok(firstRunLoop && secondRunLoop !== firstRunLoop, 'two seperate run loops were invoked');\n  }, 20);\n});\n\nasyncTest('multiple calls to Ember.run.next share coalesce callbacks into same run loop', function() {\n  var firstRunLoop, secondRunLoop, thirdRunLoop;\n  Ember.run(function() {\n    firstRunLoop = Ember.run.currentRunLoop;\n    Ember.run.next(function() { secondRunLoop = Ember.run.currentRunLoop; });\n    Ember.run.next(function() { thirdRunLoop  = Ember.run.currentRunLoop; });\n  });\n\n  setTimeout(function() {\n    start();\n    ok(secondRunLoop && secondRunLoop === thirdRunLoop, 'callbacks coalesced into same run loop');\n  }, 20);\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/run_loop/next_test");minispade.register('ember-metal/~tests/run_loop/once_test', "(function() {module('system/run_loop/once_test');\n\ntest('calling invokeOnce more than once invokes only once', function() {\n\n  var count = 0;\n  Ember.run(function() {\n    var F = function() { count++; };\n    Ember.run.once(F);\n    Ember.run.once(F);\n    Ember.run.once(F);\n  });\n\n  equal(count, 1, 'should have invoked once');\n});\n\ntest('should differentiate based on target', function() {\n\n  var A = { count: 0 }, B = { count: 0 };\n  Ember.run(function() {\n    var F = function() { this.count++; };\n    Ember.run.once(A, F);\n    Ember.run.once(B, F);\n    Ember.run.once(A, F);\n    Ember.run.once(B, F);\n  });\n\n  equal(A.count, 1, 'should have invoked once on A');\n  equal(B.count, 1, 'should have invoked once on B');\n});\n\n\ntest('should ignore other arguments - replacing previous ones', function() {\n\n  var A = { count: 0 }, B = { count: 0 };\n  Ember.run(function() {\n    var F = function(amt) { this.count += amt; };\n    Ember.run.once(A, F, 10);\n    Ember.run.once(B, F, 20);\n    Ember.run.once(A, F, 30);\n    Ember.run.once(B, F, 40);\n  });\n\n  equal(A.count, 30, 'should have invoked once on A');\n  equal(B.count, 40, 'should have invoked once on B');\n});\n\ntest('should be inside of a runloop when running', function() {\n\n  Ember.run(function() {\n    Ember.run.once(function() {\n      ok(!!Ember.run.currentRunLoop, 'should have a runloop');\n    });\n  });\n});\n\n\n\n})();\n//@ sourceURL=ember-metal/~tests/run_loop/once_test");minispade.register('ember-metal/~tests/run_loop/onerror_test', "(function() {module('system/run_loop/onerror_test');\n\ntest('With Ember.onerror undefined, errors in Ember.run are thrown', function () {\n  var thrown = new Error('Boom!'),\n      caught;\n\n  try {\n    Ember.run(function() { throw thrown; });\n  } catch (error) {\n    caught = error;\n  }\n\n  deepEqual(caught, thrown);\n});\n\ntest('With Ember.onerror set, errors in Ember.run are caught', function () {\n  var thrown = new Error('Boom!'),\n      caught;\n\n  Ember.onerror = function(error) { caught = error; };\n\n  Ember.run(function() { throw thrown; });\n\n  deepEqual(caught, thrown);\n\n  Ember.onerror = undefined;\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/run_loop/onerror_test");minispade.register('ember-metal/~tests/run_loop/run_test', "(function() {module('system/run_loop/run_test');\n\ntest('Ember.run invokes passed function, returning value', function() {\n  var obj = {\n    foo: function() { return [this.bar, 'FOO']; },\n    bar: 'BAR',\n    checkArgs: function(arg1, arg2) { return [ arg1, this.bar, arg2 ]; }\n  };\n\n  equal(Ember.run(function() { return 'FOO'; }), 'FOO', 'pass function only');\n  deepEqual(Ember.run(obj, obj.foo), ['BAR', 'FOO'], 'pass obj and obj.method');\n  deepEqual(Ember.run(obj, 'foo'), ['BAR', 'FOO'], 'pass obj and \"method\"');\n  deepEqual(Ember.run(obj, obj.checkArgs, 'hello', 'world'), ['hello', 'BAR', 'world'], 'pass obj, obj.method, and extra arguments');\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/run_loop/run_test");minispade.register('ember-metal/~tests/run_loop/schedule_test', "(function() {module('system/run_loop/schedule_test');\n\ntest('scheduling item in queue should defer until finished', function() {\n  var cnt = 0;\n\n  Ember.run(function() {\n    Ember.run.schedule('actions', function() { cnt++; });\n    Ember.run.schedule('actions', function() { cnt++; });\n    equal(cnt, 0, 'should not run action yet') ;\n  });\n\n  equal(cnt, 2, 'should flush actions now');\n\n});\n\ntest('nested runs should queue each phase independently', function() {\n  var cnt = 0;\n\n  Ember.run(function() {\n    Ember.run.schedule('actions', function() { cnt++; });\n    equal(cnt, 0, 'should not run action yet') ;\n\n    Ember.run(function() {\n      Ember.run.schedule('actions', function() { cnt++; });\n    });\n    equal(cnt, 1, 'should not run action yet') ;\n\n  });\n\n  equal(cnt, 2, 'should flush actions now');\n\n});\n\ntest('prior queues should be flushed before moving on to next queue', function() {\n  var order = [];\n\n  Ember.run(function() {\n    var runLoop = Ember.run.currentRunLoop;\n    ok(runLoop, 'run loop present');\n\n    Ember.run.schedule('sync', function() {\n      order.push('sync');\n      equal(runLoop, Ember.run.currentRunLoop, 'same run loop used');\n    });\n    Ember.run.schedule('actions', function() {\n      order.push('actions');\n      equal(runLoop, Ember.run.currentRunLoop, 'same run loop used');\n\n      Ember.run.schedule('actions', function() {\n        order.push('actions');\n        equal(runLoop, Ember.run.currentRunLoop, 'same run loop used');\n      });\n\n      Ember.run.schedule('sync', function() {\n        order.push('sync');\n        equal(runLoop, Ember.run.currentRunLoop, 'same run loop used');\n      });\n    });\n    Ember.run.schedule('destroy', function() {\n      order.push('destroy');\n      equal(runLoop, Ember.run.currentRunLoop, 'same run loop used');\n    });\n  });\n\n  deepEqual(order, ['sync', 'actions', 'sync', 'actions', 'destroy']);\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/run_loop/schedule_test");minispade.register('ember-metal/~tests/run_loop/sync_test', "(function() {module('system/run_loop/schedule_test');\n\ntest('sync() will immediately flush the sync queue only', function() {\n  var cnt = 0;\n\n  Ember.run(function() {\n\n    function cntup() { cnt++; }\n\n    function syncfunc() {\n      if (++cnt<5) Ember.run.schedule('sync', syncfunc);\n      Ember.run.schedule('actions', cntup);\n    }\n\n    syncfunc();\n\n    equal(cnt, 1, 'should not run action yet') ;\n    Ember.run.sync();\n\n    equal(cnt, 5, 'should have run sync queue continuously');\n  });\n\n  equal(cnt, 10, 'should flush actions now too');\n\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/run_loop/sync_test");minispade.register('ember-metal/~tests/run_loop/unwind_test', "(function() {module('system/run_loop/unwind_test');\n\ntest('RunLoop unwinds despite unhandled exception', function() {\n  var initialRunLoop = Ember.run.currentRunLoop;\n\n  raises(function(){\n    Ember.run(function() {\n      Ember.run.schedule('actions', function() { throw new Error(\"boom!\"); });\n    });\n  }, Error, \"boom!\");\n\n  // The real danger at this point is that calls to autorun will stick\n  // tasks into the already-dead runloop, which will never get\n  // flushed. I can't easily demonstrate this in a unit test because\n  // autorun explicitly doesn't work in test mode. - ef4\n  equal(Ember.run.currentRunLoop, initialRunLoop, \"Previous run loop should be cleaned up despite exception\");\n\n  // Prevent a failure in this test from breaking subsequent tests.\n  Ember.run.currentRunLoop = initialRunLoop;\n\n});\n\ntest('Ember.run unwinds despite unhandled exception', function() {\n  var initialRunLoop = Ember.run.currentRunLoop;\n\n  raises(function(){\n    Ember.run(function() {\n      throw new Error(\"boom!\");\n    });\n  }, Error, \"boom!\");\n\n  equal(Ember.run.currentRunLoop, initialRunLoop, \"Previous run loop should be cleaned up despite exception\");\n\n  // Prevent a failure in this test from breaking subsequent tests.\n  Ember.run.currentRunLoop = initialRunLoop;\n\n});\n\n\n})();\n//@ sourceURL=ember-metal/~tests/run_loop/unwind_test");minispade.register('ember-metal/~tests/utils/can_invoke_test', "(function() {var obj;\n\nmodule(\"Ember.canInvoke\", {\n  setup: function() {\n    obj = {\n      foobar: \"foobar\",\n      aMethodThatExists: function() {}\n    };\n  },\n\n  teardown: function() {\n    obj = undefined;\n  }\n});\n\ntest(\"should return false if the object doesn't exist\", function() {\n  equal(Ember.canInvoke(undefined, 'aMethodThatDoesNotExist'), false);\n});\n\ntest(\"should return true if the method exists on the object\", function() {\n  equal(Ember.canInvoke(obj, 'aMethodThatExists'), true);\n});\n\ntest(\"should return false if the method doesn't exist on the object\", function() {\n  equal(Ember.canInvoke(obj, 'aMethodThatDoesNotExist'), false);\n});\n\ntest(\"should return false if the property exists on the object but is a non-function\", function() {\n  equal(Ember.canInvoke(obj, 'foobar'), false);\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/utils/can_invoke_test");minispade.register('ember-metal/~tests/utils/guidFor_test', "(function() {module(\"Ember.guidFor\");\n\nvar sameGuid = function(a, b, message) {\n  equal( Ember.guidFor(a), Ember.guidFor(b), message );\n};\n\nvar diffGuid = function(a, b, message) {\n  ok( Ember.guidFor(a) !== Ember.guidFor(b), message);\n};\n\nvar nanGuid = function(obj) {\n  var type = typeof obj;\n  ok( isNaN(parseInt(Ember.guidFor(obj), 0)), \"guids for \" + type + \"don't parse to numbers\");\n};\n\ntest(\"Object\", function() {\n  var a = {}, b = {};\n\n  sameGuid( a, a, \"same object always yields same guid\" );\n  diffGuid( a, b, \"different objects yield different guids\" );\n  nanGuid( a );\n});\n\ntest(\"Object with prototype\", function() {\n  var Class = function() { };\n\n  Ember.guidFor(Class.prototype);\n\n  var a = new Class();\n  var b = new Class();\n\n  sameGuid( a, b , \"without calling rewatch, objects copy the guid from their prototype\");\n\n  Ember.rewatch(a);\n  Ember.rewatch(b);\n\n  diffGuid( a, b, \"after calling rewatch, objects don't share guids\" );\n});\n\ntest(\"strings\", function() {\n  var a = \"string A\", aprime = \"string A\", b = \"String B\";\n\n  sameGuid( a, a,      \"same string always yields same guid\" );\n  sameGuid( a, aprime, \"identical strings always yield the same guid\" );\n  diffGuid( a, b,      \"different strings yield different guids\" );\n  nanGuid( a );\n});\n\ntest(\"numbers\", function() {\n  var a = 23, aprime = 23, b = 34;\n\n  sameGuid( a, a,      \"same numbers always yields same guid\" );\n  sameGuid( a, aprime, \"identical numbers always yield the same guid\" );\n  diffGuid( a, b,      \"different numbers yield different guids\" );\n  nanGuid( a );\n});\n\ntest(\"numbers\", function() {\n  var a = true, aprime = true, b = false;\n\n  sameGuid( a, a,      \"same booleans always yields same guid\" );\n  sameGuid( a, aprime, \"identical booleans always yield the same guid\" );\n  diffGuid( a, b,      \"different boolean yield different guids\" );\n  nanGuid( a );\n  nanGuid( b );\n});\n\ntest(\"null and undefined\", function() {\n  var a = null, aprime = null, b;\n\n  sameGuid( a, a,      \"null always returns the same guid\" );\n  sameGuid( b, b,      \"undefined always returns the same guid\" );\n  sameGuid( a, aprime, \"different nulls return the same guid\" );\n  diffGuid( a, b,      \"null and undefined return different guids\" );\n  nanGuid( a );\n  nanGuid( b );\n});\n\ntest(\"arrays\", function() {\n  var a = [\"a\", \"b\", \"c\"], aprime = [\"a\", \"b\", \"c\"], b = [\"1\", \"2\", \"3\"];\n\n  sameGuid( a, a,      \"same instance always yields same guid\" );\n  diffGuid( a, aprime, \"identical arrays always yield the same guid\" );\n  diffGuid( a, b,      \"different arrays yield different guids\" );\n  nanGuid( a );\n});\n\n\n})();\n//@ sourceURL=ember-metal/~tests/utils/guidFor_test");minispade.register('ember-metal/~tests/utils/is_array_test', "(function() {module(\"Ember Type Checking\");\n\nvar global = this;\n\ntest(\"Ember.isArray\" ,function(){\n  var numarray      = [1,2,3],\n      number        = 23,\n      strarray      = [\"Hello\", \"Hi\"],\n      string        = \"Hello\",\n      object         = {},\n      length        = {length: 12},\n      fn            = function() {};\n\n  equal( Ember.isArray(numarray), true,  \"[1,2,3]\" );\n  equal( Ember.isArray(number),   false, \"23\" );\n  equal( Ember.isArray(strarray), true,  '[\"Hello\", \"Hi\"]' );\n  equal( Ember.isArray(string),   false, '\"Hello\"' );\n  equal( Ember.isArray(object),   false, \"{}\" );\n  equal( Ember.isArray(length),   true,  \"{length: 12}\" );\n  equal( Ember.isArray(global),   false, \"global\" );\n  equal( Ember.isArray(fn),       false, \"function() {}\" );\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/utils/is_array_test");minispade.register('ember-metal/~tests/utils/meta_test', "(function() {/*global jQuery*/\n\nmodule(\"Ember.meta\");\n\ntest(\"should return the same hash for an object\", function() {\n  var obj = {};\n\n  Ember.meta(obj).foo = \"bar\";\n\n  equal(Ember.meta(obj).foo, \"bar\", \"returns same hash with multiple calls to Ember.meta()\");\n});\n\nmodule(\"Ember.metaPath\");\n\ntest(\"should not create nested objects if writable is false\", function() {\n  var obj = {};\n\n  ok(!Ember.meta(obj).foo, \"precond - foo property on meta does not yet exist\");\n  equal(Ember.metaPath(obj, ['foo', 'bar', 'baz'], false), undefined, \"should return undefined when writable is false and doesn't already exist\") ;\n  equal(Ember.meta(obj).foo, undefined, \"foo property is not created\");\n});\n\ntest(\"should create nested objects if writable is true\", function() {\n  var obj = {};\n\n  ok(!Ember.meta(obj).foo, \"precond - foo property on meta does not yet exist\");\n\n  equal(typeof Ember.metaPath(obj, ['foo', 'bar', 'baz'], true), \"object\", \"should return hash when writable is true and doesn't already exist\") ;\n  ok(Ember.meta(obj).foo.bar.baz['bat'] = true, \"can set a property on the newly created hash\");\n});\n\ntest(\"getMeta and setMeta\", function() {\n  var obj = {};\n\n  ok(!Ember.getMeta(obj, 'foo'), \"precond - foo property on meta does not yet exist\");\n  Ember.setMeta(obj, 'foo', \"bar\");\n  equal(Ember.getMeta(obj, 'foo'), \"bar\", \"foo property on meta now exists\");\n});\n\nmodule(\"Ember.meta enumerable\");\n// Tests fix for https://github.com/emberjs/ember.js/issues/344\n// This is primarily for older browsers such as IE8\nif (Ember.platform.defineProperty.isSimulated) {\n  if (Ember.imports.jQuery) {\n    test(\"meta is not jQuery.isPlainObject\", function () {\n      var proto, obj;\n      proto = {foo: 'bar'};\n      equal(jQuery.isPlainObject(Ember.meta(proto)), false, 'meta should not be isPlainObject when meta property cannot be marked as enumerable: false');\n      obj = Ember.create(proto);\n      equal(jQuery.isPlainObject(Ember.meta(obj)), false, 'meta should not be isPlainObject when meta property cannot be marked as enumerable: false');\n    });\n  }\n} else {\n  test(\"meta is not enumerable\", function () {\n    var proto, obj, props, prop;\n    proto = {foo: 'bar'};\n    Ember.meta(proto);\n    obj = Ember.create(proto);\n    Ember.meta(obj);\n    obj.bar = 'baz';\n    props = [];\n    for (prop in obj) {\n      props.push(prop);\n    }\n    deepEqual(props.sort(), ['bar', 'foo']);\n    if (typeof JSON !== 'undefined' && 'stringify' in JSON) {\n      try {\n        JSON.stringify(obj);\n      } catch (e) {\n        ok(false, 'meta should not fail JSON.stringify');\n      }\n    }\n  });\n}\n\n})();\n//@ sourceURL=ember-metal/~tests/utils/meta_test");minispade.register('ember-metal/~tests/utils/try_catch_finally_test', "(function() {var tryCount, catchCount, finalizeCount, tryable, catchable, finalizer, error,\ntryableResult, catchableResult, finalizerResult;\n\nmodule(\"Ember.tryFinally\", {\n  setup: function() {\n    error = new Error('Test Error');\n    tryCount = 0;\n    finalizeCount = 0;\n    catchCount = 0;\n    tryableResult = 'tryable return value';\n    catchableResult = 'catchable return value';\n    finalizerResult = undefined;\n\n    tryable   = function() { tryCount++;      return tryableResult;   };\n    catchable = function() { catchCount++;    return catchableResult; };\n    finalizer = function() { finalizeCount++; return finalizerResult; };\n  },\n\n  teardown: function() {\n    tryCount = catchCount, finalizeCount = tryable = catchable = finalizer =\n    finalizeCount =tryableResult = null;\n  }\n});\n\nfunction callTryCatchFinallyWithError(){\n  var errorWasThrown;\n  try {\n    Ember.tryCatchFinally(tryable, catchable, finalizer);\n  } catch(e) {\n    errorWasThrown = true;\n    equal(e, error, 'correct error was thrown');\n  }\n\n  equal(errorWasThrown, true,  'error was thrown');\n}\n\ntest(\"no failure\", function() {\n  equal(Ember.tryCatchFinally(tryable, catchable, finalizer), tryableResult, 'correct return value');\n\n  equal(tryCount,      1, 'tryable was called once');\n  equal(catchCount,    0, 'catchable was never called');\n  equal(finalizeCount, 1, 'finalize was called once');\n});\n\ntest(\"no failure, return from finally\", function() {\n  finalizerResult = 'finalizer return value';\n\n  equal(Ember.tryCatchFinally(tryable, catchable, finalizer), finalizerResult, 'correct return value');\n\n  equal(tryCount,      1, 'tryable was called once');\n  equal(catchCount,    0, 'catchable was never called');\n  equal(finalizeCount, 1, 'finalize was called once');\n});\n\ntest(\"try failed\", function() {\n  tryable = function() { tryCount++; throw error; };\n\n  var result = Ember.tryCatchFinally(tryable, catchable, finalizer);\n\n  equal(result, catchableResult, 'correct return value');\n\n  equal(tryCount,      1, 'tryable was called once');\n  equal(catchCount,    1, 'catchable was called once');\n  equal(finalizeCount, 1, 'finalize was called once');\n});\n\ntest(\"catch failed\", function() {\n  catchable = function() { catchCount++; throw error; };\n\n  Ember.tryCatchFinally(tryable, catchable, finalizer);\n\n  equal(tryCount,      1, 'tryable was called once');\n  equal(catchCount,    0, 'catchable was called once');\n  equal(finalizeCount, 1, 'finalize was called once');\n});\n\ntest(\"try and catch failed\", function() {\n  tryable = function() { tryCount++; throw error; };\n  catchable = function() { catchCount++; throw error; };\n\n  callTryCatchFinallyWithError();\n\n  equal(tryCount,      1, 'tryable was called once');\n  equal(catchCount,    1, 'catchable was called once');\n  equal(finalizeCount, 1, 'finalize was called once');\n});\n\ntest(\"finally failed\", function() {\n  finalizer = function() { finalizeCount++; throw error; };\n\n  callTryCatchFinallyWithError();\n\n  equal(tryCount,      1, 'tryable was called once');\n  equal(catchCount,    0, 'catchable was never called');\n  equal(finalizeCount, 1, 'finalize was called once');\n});\n\ntest(\"finally and try failed\", function() {\n  tryable   = function() { tryCount++;      throw error; };\n  finalizer = function() { finalizeCount++; throw error; };\n\n  callTryCatchFinallyWithError();\n\n  equal(tryCount,      1, 'tryable was called once');\n  equal(catchCount,    1, 'catchable was called once');\n  equal(finalizeCount, 1, 'finalize was called once');\n});\n\ntest(\"finally, catch and try failed\", function() {\n  tryable   = function() { tryCount++;      throw error; };\n  catchable = function() { catchCount++; throw error; };\n  finalizer = function() { finalizeCount++; throw error; };\n\n  callTryCatchFinallyWithError();\n\n  equal(tryCount,      1, 'tryable was called once');\n  equal(catchCount,    1, 'catchable was called once');\n  equal(finalizeCount, 1, 'finalize was called once');\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/utils/try_catch_finally_test");minispade.register('ember-metal/~tests/utils/try_finally_test', "(function() {var tryCount, finalizeCount, tryable, finalizer, error, tryableResult, finalizerResult;\n\nmodule(\"Ember.tryFinally\", {\n  setup: function() {\n    error = new Error('Test Error');\n    tryCount = 0;\n    finalizeCount = 0;\n    tryableResult = 'tryable return value';\n    finalizerResult = undefined;\n\n    tryable   = function() { tryCount++;      return tryableResult;   };\n    finalizer = function() { finalizeCount++; return finalizerResult; };\n  },\n\n  teardown: function() {\n    tryCount = finalizeCount = tryable = finalizer = finalizeCount, tryableResult = null;\n  }\n});\n\nfunction callTryFinallyWithError(){\n  var errorWasThrown;\n  try {\n    Ember.tryFinally(tryable, finalizer);\n  } catch(e) {\n    errorWasThrown = true;\n    equal(e, error, 'correct error was thrown');\n  }\n\n  equal(errorWasThrown, true,  'error was thrown');\n}\n\ntest(\"no failure\", function() {\n  equal(Ember.tryFinally(tryable, finalizer), tryableResult, 'correct return value');\n\n  equal(tryCount,      1, 'tryable was called once');\n  equal(finalizeCount, 1, 'finalize was called once');\n});\n\ntest(\"no failure, return from finally\", function() {\n  finalizerResult = 'finalizer return value';\n\n  equal(Ember.tryFinally(tryable, finalizer), finalizerResult, 'crrect return value');\n\n  equal(tryCount,      1, 'tryable was called once');\n  equal(finalizeCount, 1, 'finalize was called once');\n});\n\ntest(\"try failed\", function() {\n  tryable = function() { tryCount++; throw error; };\n\n  callTryFinallyWithError();\n\n  equal(tryCount,      1, 'tryable was called once');\n  equal(finalizeCount, 1, 'finalize was called once');\n});\n\ntest(\"finally failed\", function() {\n  finalizer = function() { finalizeCount++; throw error; };\n\n  callTryFinallyWithError();\n\n  equal(tryCount,      1, 'tryable was called once');\n  equal(finalizeCount, 1, 'finalize was called once');\n});\n\ntest(\"finally and try failed\", function() {\n  tryable   = function() { tryCount++;      throw error; };\n  finalizer = function() { finalizeCount++; throw error; };\n\n  callTryFinallyWithError();\n\n  equal(tryCount,      1, 'tryable was called once');\n  equal(finalizeCount, 1, 'finalize was called once');\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/utils/try_finally_test");minispade.register('ember-metal/~tests/utils/try_invoke_test', "(function() {var obj;\n\nmodule(\"Ember.tryInvoke\", {\n  setup: function() {\n    obj = {\n      aMethodThatExists: function() { return true; },\n      aMethodThatTakesArguments: function(arg1, arg2) { return arg1 === arg2; }\n    };\n  },\n\n  teardown: function() {\n    obj = undefined;\n  }\n});\n\ntest(\"should return undefined when the object doesn't exist\", function() {\n  equal(Ember.tryInvoke(undefined, 'aMethodThatDoesNotExist'), undefined);\n});\n\ntest(\"should return undefined when asked to perform a method that doesn't exist on the object\", function() {\n  equal(Ember.tryInvoke(obj, 'aMethodThatDoesNotExist'), undefined);\n});\n\ntest(\"should return what the method returns when asked to perform a method that exists on the object\", function() {\n  equal(Ember.tryInvoke(obj, 'aMethodThatExists'), true);\n});\n\ntest(\"should return what the method returns when asked to perform a method that takes arguments and exists on the object\", function() {\n  equal(Ember.tryInvoke(obj, 'aMethodThatTakesArguments', [true, true]), true);\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/utils/try_invoke_test");minispade.register('ember-metal/~tests/watching/isWatching_test', "(function() {module('Ember.isWatching');\n\nvar testObserver = function(setup, teardown) {\n  var obj = {}, key = 'foo', fn = function() {};\n\n  equal(Ember.isWatching(obj, 'foo'), false, \"precond - isWatching is false by default\");\n  setup(obj, key, fn);\n  equal(Ember.isWatching(obj, 'foo'), true, \"isWatching is true when observers are added\");\n  teardown(obj, key, fn);\n  equal(Ember.isWatching(obj, 'foo'), false, \"isWatching is false after observers are removed\");\n};\n\ntest(\"isWatching is true for regular local observers\", function() {\n  testObserver(function(obj, key, fn) {\n    Ember.Mixin.create({\n      didChange: Ember.observer(fn, key)\n    }).apply(obj);\n  }, function(obj, key, fn) {\n    Ember.removeObserver(obj, key, obj, fn);\n  });\n});\n\ntest(\"isWatching is true for nonlocal observers\", function() {\n  testObserver(function(obj, key, fn) {\n    Ember.addObserver(obj, key, obj, fn);\n  }, function(obj, key, fn) {\n    Ember.removeObserver(obj, key, obj, fn);\n  });\n});\n\ntest(\"isWatching is true for chained observers\", function() {\n  testObserver(function(obj, key, fn) {\n    Ember.addObserver(obj, key + '.bar', obj, fn);\n  }, function(obj, key, fn) {\n    Ember.removeObserver(obj, key + '.bar', obj, fn);\n  });\n});\n\ntest(\"isWatching is true for computed properties\", function() {\n  testObserver(function(obj, key, fn) {\n    Ember.defineProperty(obj, 'computed', Ember.computed(fn).property(key));\n    Ember.watch(obj, 'computed');\n  }, function(obj, key, fn) {\n    Ember.defineProperty(obj, 'computed', null);\n  });\n});\n\ntest(\"isWatching is true for chained computed properties\", function() {\n  testObserver(function(obj, key, fn) {\n    Ember.defineProperty(obj, 'computed', Ember.computed(fn).property(key + '.bar'));\n    Ember.watch(obj, 'computed');\n  }, function(obj, key, fn) {\n    Ember.defineProperty(obj, 'computed', null);\n  });\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/watching/isWatching_test");minispade.register('ember-metal/~tests/watching/unwatch_test', "(function() {/*globals testBoth */\nminispade.require('ember-metal/~tests/props_helper');\n\nvar willCount = 0 , didCount = 0,\n    willChange = Ember.propertyWillChange,\n    didChange = Ember.propertyDidChange;\n\nmodule('Ember.unwatch', {\n  setup: function() {\n    willCount = didCount = 0;\n    Ember.propertyWillChange = function(cur, keyName) {\n      willCount++;\n      willChange.call(this, cur, keyName);\n    };\n\n    Ember.propertyDidChange = function(cur, keyName) {\n      didCount++;\n      didChange.call(this, cur, keyName);\n    };\n  },\n\n  teardown: function() {\n    Ember.propertyWillChange = willChange;\n    Ember.propertyDidChange  = didChange;\n  }\n});\n\ntestBoth('unwatching a computed property - regular get/set', function(get, set) {\n\n  var obj = {};\n  Ember.defineProperty(obj, 'foo', Ember.computed(function(keyName, value) {\n    if (value !== undefined) this.__foo = value;\n    return this.__foo;\n  }));\n\n  Ember.watch(obj, 'foo');\n  set(obj, 'foo', 'bar');\n  equal(willCount, 1, 'should have invoked willCount');\n  equal(didCount, 1, 'should have invoked didCount');\n\n  Ember.unwatch(obj, 'foo');\n  willCount = didCount = 0;\n  set(obj, 'foo', 'BAZ');\n  equal(willCount, 0, 'should NOT have invoked willCount');\n  equal(didCount, 0, 'should NOT have invoked didCount');\n});\n\n\ntestBoth('unwatching a regular property - regular get/set', function(get, set) {\n\n  var obj = { foo: 'BIFF' };\n\n  Ember.watch(obj, 'foo');\n  set(obj, 'foo', 'bar');\n  equal(willCount, 1, 'should have invoked willCount');\n  equal(didCount, 1, 'should have invoked didCount');\n\n  Ember.unwatch(obj, 'foo');\n  willCount = didCount = 0;\n  set(obj, 'foo', 'BAZ');\n  equal(willCount, 0, 'should NOT have invoked willCount');\n  equal(didCount, 0, 'should NOT have invoked didCount');\n});\n\ntest('unwatching should be nested', function() {\n\n  var obj = { foo: 'BIFF' };\n\n  Ember.watch(obj, 'foo');\n  Ember.watch(obj, 'foo');\n  Ember.set(obj, 'foo', 'bar');\n  equal(willCount, 1, 'should have invoked willCount');\n  equal(didCount, 1, 'should have invoked didCount');\n\n  Ember.unwatch(obj, 'foo');\n  willCount = didCount = 0;\n  Ember.set(obj, 'foo', 'BAZ');\n  equal(willCount, 1, 'should NOT have invoked willCount');\n  equal(didCount, 1, 'should NOT have invoked didCount');\n\n  Ember.unwatch(obj, 'foo');\n  willCount = didCount = 0;\n  Ember.set(obj, 'foo', 'BAZ');\n  equal(willCount, 0, 'should NOT have invoked willCount');\n  equal(didCount, 0, 'should NOT have invoked didCount');\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/watching/unwatch_test");minispade.register('ember-metal/~tests/watching/watch_test', "(function() {/*globals Global:true */\nminispade.require('ember-metal/~tests/props_helper');\n\nvar willCount = 0 , didCount = 0,\n    willKeys = [] , didKeys = [],\n    willChange = Ember.propertyWillChange,\n    didChange = Ember.propertyDidChange,\n    indexOf = Ember.EnumerableUtils.indexOf;\n\nmodule('Ember.watch', {\n  setup: function() {\n    willCount = didCount = 0;\n    willKeys = [];\n    didKeys = [];\n    Ember.propertyWillChange = function(cur, keyName) {\n      willCount++;\n      willKeys.push(keyName);\n      willChange.call(this, cur, keyName);\n    };\n\n    Ember.propertyDidChange = function(cur, keyName) {\n      didCount++;\n      didKeys.push(keyName);\n      didChange.call(this, cur, keyName);\n    };\n  },\n\n  teardown: function() {\n    Ember.propertyWillChange = willChange;\n    Ember.propertyDidChange  = didChange;\n  }\n});\n\ntestBoth('watching a computed property', function(get, set) {\n\n  var obj = {};\n  Ember.defineProperty(obj, 'foo', Ember.computed(function(keyName, value) {\n    if (value !== undefined) this.__foo = value;\n    return this.__foo;\n  }));\n\n  Ember.watch(obj, 'foo');\n  set(obj, 'foo', 'bar');\n  equal(willCount, 1, 'should have invoked willCount');\n  equal(didCount, 1, 'should have invoked didCount');\n});\n\ntestBoth('watching a regular defined property', function(get, set) {\n\n  var obj = { foo: 'baz' };\n\n  Ember.watch(obj, 'foo');\n  equal(get(obj, 'foo'), 'baz', 'should have original prop');\n\n  set(obj, 'foo', 'bar');\n  equal(willCount, 1, 'should have invoked willCount');\n  equal(didCount, 1, 'should have invoked didCount');\n\n  equal(get(obj, 'foo'), 'bar', 'should get new value');\n  equal(obj.foo, 'bar', 'property should be accessible on obj');\n});\n\ntestBoth('watching a regular undefined property', function(get, set) {\n\n  var obj = { };\n\n  Ember.watch(obj, 'foo');\n\n  equal('foo' in obj, false, 'precond undefined');\n\n  set(obj, 'foo', 'bar');\n\n  equal(willCount, 1, 'should have invoked willCount');\n  equal(didCount, 1, 'should have invoked didCount');\n\n  equal(get(obj, 'foo'), 'bar', 'should get new value');\n  equal(obj.foo, 'bar', 'property should be accessible on obj');\n});\n\ntestBoth('watches should inherit', function(get, set) {\n\n  var obj = { foo: 'baz' };\n  var objB = Ember.create(obj);\n\n  Ember.watch(obj, 'foo');\n  equal(get(obj, 'foo'), 'baz', 'should have original prop');\n\n  set(obj, 'foo', 'bar');\n  set(objB, 'foo', 'baz');\n  equal(willCount, 2, 'should have invoked willCount once only');\n  equal(didCount, 2, 'should have invoked didCount once only');\n});\n\ntest(\"watching an object THEN defining it should work also\", function() {\n\n  var obj = {};\n  Ember.watch(obj, 'foo');\n\n  Ember.defineProperty(obj, 'foo');\n  Ember.set(obj, 'foo', 'bar');\n\n  equal(Ember.get(obj, 'foo'), 'bar', 'should have set');\n  equal(willCount, 1, 'should have invoked willChange once');\n  equal(didCount, 1, 'should have invoked didChange once');\n\n});\n\ntest(\"watching a chain then defining the property\", function () {\n  var obj = {};\n  var foo = {bar: 'bar'};\n  Ember.watch(obj, 'foo.bar');\n\n  Ember.defineProperty(obj, 'foo', undefined, foo);\n  Ember.set(foo, 'bar', 'baz');\n\n  deepEqual(willKeys, ['bar', 'foo.bar'], 'should have invoked willChange with bar, foo.bar');\n  deepEqual(didKeys, ['bar', 'foo.bar'], 'should have invoked didChange with bar, foo.bar');\n  equal(willCount, 2, 'should have invoked willChange twice');\n  equal(didCount, 2, 'should have invoked didChange twice');\n});\n\ntest(\"watching a chain then defining the nested property\", function () {\n  var bar = {};\n  var obj = {foo: bar};\n  var baz = {baz: 'baz'};\n  Ember.watch(obj, 'foo.bar.baz');\n\n  Ember.defineProperty(bar, 'bar', undefined, baz);\n  Ember.set(baz, 'baz', 'BOO');\n\n  deepEqual(willKeys, ['baz', 'foo.bar.baz'], 'should have invoked willChange with bar, foo.bar');\n  deepEqual(didKeys, ['baz', 'foo.bar.baz'], 'should have invoked didChange with bar, foo.bar');\n  equal(willCount, 2, 'should have invoked willChange twice');\n  equal(didCount, 2, 'should have invoked didChange twice');\n});\n\ntestBoth('watching an object value then unwatching should restore old value', function(get, set) {\n\n  var obj = { foo: { bar: { baz: { biff: 'BIFF' } } } };\n  Ember.watch(obj, 'foo.bar.baz.biff');\n\n  var foo = Ember.get(obj, 'foo');\n  equal(get(get(get(foo, 'bar'), 'baz'), 'biff'), 'BIFF', 'biff should exist');\n\n  Ember.unwatch(obj, 'foo.bar.baz.biff');\n  equal(get(get(get(foo, 'bar'), 'baz'), 'biff'), 'BIFF', 'biff should exist');\n});\n\ntestBoth('watching a global object that does not yet exist should queue', function(get, set) {\n\n  Global = null;\n\n  var obj = {};\n  Ember.watch(obj, 'Global.foo'); // only works on global chained props\n\n  equal(willCount, 0, 'should not have fired yet');\n  equal(didCount, 0, 'should not have fired yet');\n\n  Global = { foo: 'bar' };\n  Ember.watch.flushPending(); // this will also be invoked automatically on ready\n\n  equal(willCount, 0, 'should not have fired yet');\n  equal(didCount, 0, 'should not have fired yet');\n\n  set(Global, 'foo', 'baz');\n\n  // should fire twice because this is a chained property (once on key, once\n  // on path)\n  equal(willCount, 2, 'should be watching');\n  equal(didCount, 2, 'should be watching');\n\n  Global = null; // reset\n});\n\ntest('when watching a global object, destroy should remove chain watchers from the global object', function() {\n\n  Global = { foo: 'bar' };\n  var obj = {};\n\n  Ember.watch(obj, 'Global.foo');\n\n  var meta_Global = Ember.meta(Global);\n  var chainNode = Ember.meta(obj).chains._chains.Global._chains.foo;\n  var index = indexOf(meta_Global.chainWatchers.foo, chainNode);\n\n  equal(meta_Global.watching.foo, 1, 'should be watching foo');\n  strictEqual(meta_Global.chainWatchers.foo[index], chainNode, 'should have chain watcher');\n\n  Ember.destroy(obj);\n\n  index = indexOf(meta_Global.chainWatchers.foo, chainNode);\n  equal(meta_Global.watching.foo, 0, 'should not be watching foo');\n  equal(index, -1, 'should not have chain watcher');\n\n  Global = null; // reset\n});\n\ntest('when watching another object, destroy should remove chain watchers from the other object', function() {\n\n  var objA = {};\n  var objB = {foo: 'bar'};\n  objA.b = objB;\n\n  Ember.watch(objA, 'b.foo');\n\n  var meta_objB = Ember.meta(objB);\n  var chainNode = Ember.meta(objA).chains._chains.b._chains.foo;\n  var index = indexOf(meta_objB.chainWatchers.foo, chainNode);\n\n  equal(meta_objB.watching.foo, 1, 'should be watching foo');\n  strictEqual(meta_objB.chainWatchers.foo[index], chainNode, 'should have chain watcher');\n\n  Ember.destroy(objA);\n\n  index = indexOf(meta_objB.chainWatchers.foo, chainNode);\n  equal(meta_objB.watching.foo, 0, 'should not be watching foo');\n  equal(index, -1, 'should not have chain watcher');\n});\n\n})();\n//@ sourceURL=ember-metal/~tests/watching/watch_test");minispade.register('ember-old-router/~tests/application_test', "(function() {var set = Ember.set, get = Ember.get, trim = Ember.$.trim;\nvar app;\n\nmodule(\"Ember.Application initialization\", {\n  teardown: function() {\n    Ember.run(function(){ app.destroy(); });\n  }\n});\n\ntest('initialized application go to initial route', function() {\n  Ember.run(function() {\n    app = Ember.Application.create({\n      rootElement: '#qunit-fixture'\n    });\n\n    app.stateManager = Ember.Router.create({\n      location: {\n        getURL: function() {\n          return '/';\n        },\n        setURL: function() {},\n        onUpdateURL: function() {}\n      },\n\n      root: Ember.Route.extend({\n        index: Ember.Route.extend({\n          route: '/'\n        })\n      })\n    });\n\n\n    app.ApplicationView = Ember.View.extend({\n      template: function() { return \"Hello!\"; }\n    });\n\n    app.ApplicationController = Ember.Controller.extend();\n\n    Ember.run(function() { app.initialize(app.stateManager); });\n  });\n\n  equal(app.get('router.currentState.path'), 'root.index', \"The router moved the state into the right place\");\n});\n\ntest(\"Minimal Application initialized with an application template and injections\", function() {\n  Ember.$('#qunit-fixture').html('<script type=\"text/x-handlebars\">Hello {{controller.name}}!</script>');\n\n  Ember.run(function () {\n    app = Ember.Application.create({\n      router: false,\n      rootElement: '#qunit-fixture'\n    });\n  });\n\n  app.ApplicationController = Ember.Controller.extend({name: 'Kris'});\n\n  Ember.run(function () {\n    // required to receive injections\n    var stateManager = Ember.Object.create();\n    app.initialize(stateManager);\n  });\n\n  equal(trim(Ember.$('#qunit-fixture').text()), 'Hello Kris!');\n});\n\n\n})();\n//@ sourceURL=ember-old-router/~tests/application_test");minispade.register('ember-old-router/~tests/controller_test', "(function() {var originalLookup = Ember.lookup, TestApp, lookup, view, containerView;\n\nmodule(\"Ember.Controller#connectOutlet\", {\n  setup: function() {\n    lookup = Ember.lookup = {};\n\n    Ember.run(function () {\n      lookup.TestApp = TestApp = Ember.Application.create();\n    });\n\n\n    TestApp.ApplicationController = Ember.Controller.extend();\n\n    TestApp.PostController = Ember.Controller.extend();\n    TestApp.PostView = Ember.View.extend();\n  },\n\n  teardown: function() {\n    Ember.run(function () {\n      if (view) { view.destroy(); }\n      if (containerView) { containerView.destroy(); }\n      lookup.TestApp.destroy();\n    });\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest(\"connectOutlet instantiates a view, controller, and connects them\", function() {\n  var postController = Ember.Controller.create();\n\n  var appController = TestApp.ApplicationController.create({\n    controllers: { postController: postController },\n    namespace: { PostView: TestApp.PostView }\n  });\n  view = appController.connectOutlet('post');\n\n  ok(view instanceof TestApp.PostView, \"the view is an instance of PostView\");\n  equal(view.get('controller'), postController, \"the controller is looked up on the parent's controllers hash\");\n  equal(appController.get('view'), view, \"the app controller's view is set\");\n});\n\ntest(\"connectOutlet takes an optional outlet name\", function() {\n  var postController = Ember.Controller.create();\n\n  var appController = TestApp.ApplicationController.create({\n    controllers: { postController: postController },\n    namespace: { PostView: TestApp.PostView }\n  });\n  view = appController.connectOutlet({ name: 'post', outletName: 'mainView' });\n\n  ok(view instanceof TestApp.PostView, \"the view is an instance of PostView\");\n  equal(view.get('controller'), postController, \"the controller is looked up on the parent's controllers hash\");\n  equal(appController.get('mainView'), view, \"the app controller's view is set\");\n});\n\ntest(\"connectOutlet takes an optional controller context\", function() {\n  var postController = Ember.Controller.create(),\n      context = {};\n\n  var appController = TestApp.ApplicationController.create({\n    controllers: { postController: postController },\n    namespace: { PostView: TestApp.PostView }\n  });\n  view = appController.connectOutlet('post', context);\n\n  ok(view instanceof TestApp.PostView, \"the view is an instance of PostView\");\n  equal(view.get('controller'), postController, \"the controller is looked up on the parent's controllers hash\");\n  equal(appController.get('view'), view, \"the app controller's view is set\");\n  equal(view.get('controller.content'), context, \"the controller receives the context\");\n});\n\ntest(\"connectOutlet with outletName, name syntax\", function() {\n  var postController = Ember.Controller.create(),\n      context = {};\n\n  var appController = TestApp.ApplicationController.create({\n    controllers: { postController: postController },\n    namespace: { PostView: TestApp.PostView }\n  });\n\n  view = appController.connectOutlet('main', 'post', context);\n\n  ok(view instanceof TestApp.PostView, \"the view is an instance of PostView\");\n  equal(view.get('controller'), postController, \"the controller is looked up on the parent's controllers hash\");\n  equal(appController.get('main'), view, \"the app controller's view is set\");\n  equal(view.get('controller.content'), context, \"the controller receives the context\");\n});\n\ntest(\"connectOutlet works if all three parameters are provided\", function() {\n  var postController = Ember.Controller.create(),\n      context = {};\n\n  var appController = TestApp.ApplicationController.create({\n    controllers: { postController: postController },\n    namespace: { PostView: TestApp.PostView }\n  });\n  view = appController.connectOutlet({ name: 'post', outletName: 'mainView', context: context });\n\n  ok(view instanceof TestApp.PostView, \"the view is an instance of PostView\");\n  equal(view.get('controller'), postController, \"the controller is looked up on the parent's controllers hash\");\n  equal(appController.get('mainView'), view, \"the app controller's view is set\");\n  equal(view.get('controller.content'), context, \"the controller receives the context\");\n});\n\ntest(\"connectOutlet works if a hash of options is passed\", function() {\n  var postController = Ember.Controller.create(),\n      context = {};\n\n  var appController = TestApp.ApplicationController.create({\n    controllers: { postController: postController }\n  });\n\n  view = appController.connectOutlet({\n    outletName: 'mainView',\n    viewClass: TestApp.PostView,\n    controller: postController,\n    context: context\n  });\n\n  ok(view instanceof TestApp.PostView, \"the view is an instance of PostView\");\n  equal(view.get('controller'), postController, \"the controller is looked up on the parent's controllers hash\");\n  equal(appController.get('mainView'), view, \"the app controller's view is set\");\n  equal(view.get('controller.content'), context, \"the controller receives the context\");\n});\n\ntest(\"if the controller is explicitly set to null while connecting an outlet, the instantiated view will inherit its controller from its parent view\", function() {\n  var postController = Ember.Controller.create(),\n      context = {};\n\n  var appController = TestApp.ApplicationController.create({\n    controllers: { postController: postController }\n  });\n\n  view = appController.connectOutlet({\n    outletName: 'mainView',\n    viewClass: TestApp.PostView,\n    controller: null\n  });\n\n  ok(view instanceof TestApp.PostView, \"the view is an instance of PostView\");\n  equal(view.get('controller'), null, \"the controller is looked up on the parent's controllers hash\");\n  equal(appController.get('mainView'), view, \"the app controller's view is set\");\n\n  containerView = Ember.ContainerView.create({\n    controller: postController\n  });\n\n  containerView.pushObject(view);\n  equal(view.get('controller'), postController, \"the controller was inherited from the parent\");\n});\n\ntest(\"if the controller is not given while connecting an outlet, the instantiated view will inherit its controller from its parent view\", function() {\n  var postController = Ember.Controller.create();\n\n  var appController = TestApp.ApplicationController.create({\n    controllers: {},\n    namespace: TestApp\n  });\n\n  view = appController.connectOutlet('post');\n\n  ok(view instanceof TestApp.PostView, \"the view is an instance of PostView\");\n  equal(view.get('controller'), null, \"the controller is looked up on the parent's controllers hash\");\n  equal(appController.get('view'), view, \"the app controller's view is set\");\n\n  containerView = Ember.ContainerView.create({\n    controller: postController\n  });\n\n  containerView.pushObject(view);\n  equal(view.get('controller'), postController, \"the controller was inherited from the parent\");\n});\n\ntest(\"can disconnect outlet from controller\", function() {\n  var appController = TestApp.ApplicationController.create({\n    controllers: {},\n    namespace: TestApp\n  });\n\n  view = appController.connectOutlet('post');\n\n  equal(appController.get('view'), view, \"the app controller's view is set\");\n\n  appController.disconnectOutlet();\n\n  equal(appController.get('view'), null, \"the app controller's view is null\");\n\n  Ember.run(function() { view.destroy(); });\n  view = appController.connectOutlet({outletName: 'master', name: 'post'});\n\n  equal(appController.get('master'), view, \"the app controller's master view is set\");\n\n  appController.disconnectOutlet('master');\n\n  equal(appController.get('master'), null, \"the app controller's master view is null\");\n});\n\nmodule(\"Ember.Controller#connectControllers\", {\n  setup: function() {\n    lookup = Ember.lookup = {};\n\n    Ember.run(function () {\n      lookup.TestApp = TestApp = Ember.Application.create();\n    });\n\n\n    TestApp.ApplicationController = Ember.Controller.extend();\n\n    TestApp.PostController = Ember.Controller.extend();\n    TestApp.PostView = Ember.View.extend();\n  },\n\n  teardown: function() {\n    Ember.run(function () {\n      lookup.TestApp.destroy();\n    });\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest(\"connectControllers injects other controllers\", function() {\n  var postController = {}, commentController = {};\n\n  var controller = Ember.Controller.create({\n    controllers: {\n      postController: postController,\n      commentController: commentController\n    }\n  });\n\n  controller.connectControllers('post', 'comment');\n\n  equal(controller.get('postController'), postController, \"should connect postController\");\n  equal(controller.get('commentController'), commentController, \"should connect commentController\");\n});\n\n})();\n//@ sourceURL=ember-old-router/~tests/controller_test");minispade.register('ember-old-router/~tests/helpers/action_test', "(function() {var dispatcher, view,\n    ActionHelper = Ember.Handlebars.ActionHelper,\n    originalRegisterAction = ActionHelper.registerAction;\n\nvar appendView = function() {\n  Ember.run(function() { view.appendTo('#qunit-fixture'); });\n};\n\nmodule(\"Ember.Handlebars - action helper\", {\n  setup: function() {\n    dispatcher = Ember.EventDispatcher.create();\n    dispatcher.setup();\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      dispatcher.destroy();\n      if (view) { view.destroy(); }\n    });\n  }\n});\n\ntest(\"should output a data attribute with a guid\", function() {\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\"}}>edit</a>')\n  });\n\n  appendView();\n\n  ok(view.$('a').attr('data-ember-action').match(/\\d+/), \"A data-ember-action attribute with a guid was added\");\n});\n\ntest(\"should by default register a click event\", function() {\n  var registeredEventName;\n\n  ActionHelper.registerAction = function(actionName, options) {\n    registeredEventName = options.eventName;\n  };\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\"}}>edit</a>')\n  });\n\n  appendView();\n\n  equal(registeredEventName, 'click', \"The click event was properly registered\");\n\n  ActionHelper.registerAction = originalRegisterAction;\n});\n\ntest(\"should allow alternative events to be handled\", function() {\n  var registeredEventName;\n\n  ActionHelper.registerAction = function(actionName, options) {\n    registeredEventName = options.eventName;\n  };\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\" on=\"mouseUp\"}}>edit</a>')\n  });\n\n  appendView();\n\n  equal(registeredEventName, 'mouseUp', \"The alternative mouseUp event was properly registered\");\n\n  ActionHelper.registerAction = originalRegisterAction;\n});\n\ntest(\"should by default target the parent view\", function() {\n  var registeredTarget;\n\n  ActionHelper.registerAction = function(actionName, options) {\n    registeredTarget = options.target;\n  };\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\"}}>edit</a>')\n  });\n\n  appendView();\n\n  equal(registeredTarget, view, \"The parent view was registered as the target\");\n\n  ActionHelper.registerAction = originalRegisterAction;\n});\n\ntest(\"should by default target the state manager on the controller if it exists\", function() {\n  var registeredTarget;\n\n  var sent = 0;\n\n  view = Ember.View.create({\n    controller: Ember.Controller.create({\n      target: Ember.Object.create({\n        isState: true,\n        send: function(context) {\n          sent++;\n        }\n      })\n    }),\n    template: Ember.Handlebars.compile('<a id=\"ember-link\" href=\"#\" {{action \"edit\"}}>edit</a>')\n  });\n\n  appendView();\n\n  Ember.$(\"#ember-link\").click();\n  equal(sent, 1, \"The action was sent to the state manager\");\n});\n\ntest(\"should allow a target to be specified\", function() {\n  var registeredTarget;\n\n  ActionHelper.registerAction = function(actionName, options) {\n    registeredTarget = options.target;\n  };\n\n  var anotherTarget = Ember.View.create();\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\" target=\"view.anotherTarget\"}}>edit</a>'),\n    anotherTarget: anotherTarget\n  });\n\n  appendView();\n\n  equal(registeredTarget, anotherTarget, \"The specified target was registered\");\n\n  ActionHelper.registerAction = originalRegisterAction;\n\n  Ember.run(function() { anotherTarget.destroy(); });\n});\n\ntest(\"should register an event handler\", function() {\n  var eventHandlerWasCalled = false;\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\"}}>click me</a>'),\n    edit: function() { eventHandlerWasCalled = true; }\n  });\n\n  appendView();\n\n  var actionId = view.$('a[data-ember-action]').attr('data-ember-action');\n\n  ok(Ember.Handlebars.ActionHelper.registeredActions[actionId], \"The action was registered\");\n\n  view.$('a').trigger('click');\n\n  ok(eventHandlerWasCalled, \"The event handler was called\");\n});\n\ntest(\"should be able to use action more than once for the same event within a view\", function() {\n  var editWasCalled = false,\n      deleteWasCalled = false,\n      originalEventHandlerWasCalled = false;\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile(\n      '<a id=\"edit\" href=\"#\" {{action \"edit\"}}>edit</a><a id=\"delete\" href=\"#\" {{action \"delete\"}}>delete</a>'\n    ),\n    click: function() { originalEventHandlerWasCalled = true; },\n    edit: function() { editWasCalled = true; return false; },\n    \"delete\": function() { deleteWasCalled = true; return false; }\n  });\n\n  appendView();\n\n  view.$('#edit').trigger('click');\n\n  ok(editWasCalled && !deleteWasCalled && !originalEventHandlerWasCalled, \"Only the edit action was called\");\n\n  editWasCalled = deleteWasCalled = originalEventHandlerWasCalled = false;\n\n  view.$('#delete').trigger('click');\n\n  ok(!editWasCalled && deleteWasCalled && !originalEventHandlerWasCalled, \"Only the delete action was called\");\n\n  editWasCalled = deleteWasCalled = originalEventHandlerWasCalled = false;\n\n  view.$().trigger('click');\n\n  ok(!editWasCalled && !deleteWasCalled && originalEventHandlerWasCalled, \"Only the original event handler was called\");\n});\n\ntest(\"should work properly in an #each block\", function() {\n  var eventHandlerWasCalled = false;\n\n  view = Ember.View.create({\n    items: Ember.A([1, 2, 3, 4]),\n    template: Ember.Handlebars.compile('{{#each view.items}}<a href=\"#\" {{action \"edit\"}}>click me</a>{{/each}}'),\n    edit: function() { eventHandlerWasCalled = true; }\n  });\n\n  appendView();\n\n  view.$('a').trigger('click');\n\n  ok(eventHandlerWasCalled, \"The event handler was called\");\n});\n\ntest(\"should work properly in a #with block\", function() {\n  var eventHandlerWasCalled = false;\n\n  view = Ember.View.create({\n    something: {ohai: 'there'},\n    template: Ember.Handlebars.compile('{{#with view.something}}<a href=\"#\" {{action \"edit\"}}>click me</a>{{/with}}'),\n    edit: function() { eventHandlerWasCalled = true; }\n  });\n\n  appendView();\n\n  view.$('a').trigger('click');\n\n  ok(eventHandlerWasCalled, \"The event handler was called\");\n});\n\ntest(\"should unregister event handlers on rerender\", function() {\n  var eventHandlerWasCalled = false;\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\"}}>click me</a>'),\n    edit: function() { eventHandlerWasCalled = true; }\n  });\n\n  appendView();\n\n  var previousActionId = view.$('a[data-ember-action]').attr('data-ember-action');\n\n  Ember.run(function(){\n    view.rerender();\n  });\n\n  ok(!Ember.Handlebars.ActionHelper.registeredActions[previousActionId], \"On rerender, the event handler was removed\");\n\n  var newActionId = view.$('a[data-ember-action]').attr('data-ember-action');\n\n  ok(Ember.Handlebars.ActionHelper.registeredActions[newActionId], \"After rerender completes, a new event handler was added\");\n});\n\ntest(\"should properly capture events on child elements of a container with an action\", function() {\n  var eventHandlerWasCalled = false;\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<div {{action \"edit\"}}><button>click me</button></div>'),\n    edit: function() { eventHandlerWasCalled = true; }\n  });\n\n  appendView();\n\n  view.$('button').trigger('click');\n\n  ok(eventHandlerWasCalled, \"Event on a child element triggered the action of it's parent\");\n});\n\ntest(\"should allow bubbling of events from action helper to original parent event\", function() {\n  var eventHandlerWasCalled = false,\n      originalEventHandlerWasCalled = false;\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\"}}>click me</a>'),\n    click: function() { originalEventHandlerWasCalled = true; },\n    edit: function() { eventHandlerWasCalled = true; }\n  });\n\n  appendView();\n\n  view.$('a').trigger('click');\n\n  ok(eventHandlerWasCalled && originalEventHandlerWasCalled, \"Both event handlers were called\");\n});\n\ntest(\"should not bubble an event from action helper to original parent event if it returns false\", function() {\n  var eventHandlerWasCalled = false,\n      originalEventHandlerWasCalled = false;\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\"}}>click me</a>'),\n    click: function() { originalEventHandlerWasCalled = true; },\n    edit: function() { eventHandlerWasCalled = true; return false; }\n  });\n\n  appendView();\n\n  view.$('a').trigger('click');\n\n  ok(eventHandlerWasCalled, \"The child handler was called\");\n  ok(!originalEventHandlerWasCalled, \"The parent handler was not called\");\n});\n\ntest(\"should be compatible with sending events to a state manager\", function() {\n  var eventNameCalled,\n      eventObjectSent,\n      manager = {\n        isState: true,\n        send: function(eventName, eventObject) { eventNameCalled = eventName; eventObjectSent = eventObject; }\n      };\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\" target=\"view.manager\"}}>click me</a>'),\n    manager: manager\n  });\n\n  appendView();\n\n  view.$('a').trigger('click');\n\n  equal(eventNameCalled, \"edit\", \"The state manager's send method was called\");\n  ok(eventObjectSent, \"The state manager's send method was called with an event object\");\n});\n\ntest(\"should allow 'send' as action name (#594)\", function() {\n  var eventHandlerWasCalled = false;\n  var eventObjectSent;\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"send\" }}>send</a>'),\n    send: function(evt){ eventHandlerWasCalled = true; eventObjectSent = evt; }\n  });\n\n  appendView();\n\n  view.$('a').trigger('click');\n\n  ok(eventHandlerWasCalled, \"The view's send method was called\");\n  ok(eventObjectSent, \"Callback was called with an event object\");\n});\n\n\ntest(\"should send the view, event and current Handlebars context to the action\", function() {\n  var passedTarget;\n  var passedView;\n  var passedEvent;\n  var passedContext;\n\n  var aTarget = Ember.View.create({\n    edit: function(event) {\n      passedTarget = this;\n      passedEvent = event;\n    }\n  });\n\n  var aContext = { aTarget: aTarget };\n\n  view = Ember.View.create({\n    aContext: aContext,\n    template: Ember.Handlebars.compile('{{#with view.aContext}}<a id=\"edit\" href=\"#\" {{action edit this target=\"aTarget\"}}>edit</a>{{/with}}')\n  });\n\n  appendView();\n\n  view.$('#edit').trigger('click');\n\n  strictEqual(passedTarget, aTarget, \"the action is called with the target as this\");\n  strictEqual(passedEvent.view, view, \"the view passed is the view containing the action helper\");\n  deepEqual(passedEvent.context, aContext, \"the context is passed\");\n  equal(passedEvent.type, 'click', \"the event passed is the event triggered for the action helper\");\n\n  Ember.run(function(){ aTarget.destroy(); });\n});\n\ntest(\"should only trigger actions for the event they were registered on\", function() {\n  var editWasCalled = false;\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\"}}>edit</a>'),\n    edit: function() { editWasCalled = true; }\n  });\n\n  appendView();\n\n  view.$('a').trigger('mouseover');\n\n  ok(!editWasCalled, \"The action wasn't called\");\n});\n\ntest(\"should allow a context to be specified\", function() {\n  var passedContext,\n      model = Ember.Object.create();\n\n  view = Ember.View.create({\n    people: Ember.A([model]),\n    template: Ember.Handlebars.compile('{{#each person in view.people}}<button {{action edit person}}>edit</button>{{/each}}'),\n    edit: function(event) {\n      passedContext = event.context;\n    }\n  });\n\n  appendView();\n\n  view.$('button').trigger('click');\n\n  equal(passedContext, model, \"the action was called with the passed context\");\n});\n\ntest(\"should allow multiple contexts to be specified\", function() {\n  var passedContexts,\n      models = [Ember.Object.create(), Ember.Object.create()];\n\n  view = Ember.View.create({\n    modelA: models[0],\n    modelB: models[1],\n    template: Ember.Handlebars.compile('<button {{action edit view.modelA view.modelB}}>edit</button>'),\n    edit: function(event) {\n      passedContexts = event.contexts;\n    }\n  });\n\n  appendView();\n\n  view.$('button').trigger('click');\n\n  deepEqual(passedContexts, models, \"the action was called with the passed contexts\");\n});\n\nvar namespace = {\n  \"Component\": {\n    toString: function() { return \"Component\"; },\n    find: function() { return { id: 1 }; }\n  }\n};\n\nvar compile = function(string) {\n  return Ember.Handlebars.compile(string);\n};\n\ntest(\"it sets an URL with a context\", function() {\n  var router = Ember.Router.create({\n    location: {\n      formatURL: function(url) {\n        return url;\n      },\n      setURL: Ember.K\n    },\n    namespace: namespace,\n    root: Ember.Route.create({\n      index: Ember.Route.create({\n        route: '/',\n\n        showDashboard: function(router) {\n          router.transitionTo('dashboard');\n        },\n\n        eventTransitions: {\n          showDashboard: 'dashboard'\n        }\n      }),\n\n      dashboard: Ember.Route.create({\n        route: '/dashboard/:component_id'\n      })\n    })\n  });\n\n  Ember.run(function() {\n    router.route(\"/\");\n  });\n\n  equal(router.get('currentState.path'), \"root.index\", \"precond - the current stat is root.index\");\n\n  view = Ember.View.create({\n    template: compile('<a {{action showDashboard controller.component href=true}}>test</a>')\n  });\n\n  var controller = Ember.Controller.create({\n    target: router,\n    component: { id: 1 }\n  });\n\n  Ember.run(function() {\n    view.set('controller', controller);\n    view.appendTo('#qunit-fixture');\n  });\n\n  ok(view.$().html().match(/href=['\"].*\\/dashboard\\/1['\"]/), \"The html (\" + view.$().html() + \") has the href /dashboard/1 in it\");\n});\n\ntest(\"it does not trigger action with special clicks\", function() {\n  var showCalled = false;\n\n  view = Ember.View.create({\n    template: compile(\"<a {{action show href=true}}>Hi</a>\")\n  });\n\n  var controller = Ember.Controller.create({\n    target: {\n      urlForEvent: function(event, context) {\n        return \"/foo/bar\";\n      },\n\n      send: function(event, context) {\n        this[event](context);\n      },\n\n      show: function() {\n        showCalled = true;\n      }\n    }\n  });\n\n  Ember.run(function() {\n    view.set('controller', controller);\n    view.appendTo('#qunit-fixture');\n  });\n\n  function checkClick(prop, value, expected) {\n    var event = Ember.$.Event(\"click\");\n    event[prop] = value;\n    view.$('a').trigger(event);\n    if (expected) {\n      ok(showCalled, \"should call action with \"+prop+\":\"+value);\n      ok(event.isDefaultPrevented(), \"should prevent default\");\n    } else {\n      ok(!showCalled, \"should not call action with \"+prop+\":\"+value);\n      ok(!event.isDefaultPrevented(), \"should not prevent default\");\n    }\n  }\n\n  checkClick('ctrlKey', true, false);\n  checkClick('altKey', true, false);\n  checkClick('metaKey', true, false);\n  checkClick('shiftKey', true, false);\n  checkClick('which', 2, false);\n\n  checkClick('which', 1, true);\n  checkClick('which', undefined, true); // IE <9\n});\n\n\n})();\n//@ sourceURL=ember-old-router/~tests/helpers/action_test");minispade.register('ember-old-router/~tests/helpers/action_url_test', "(function() {// FIXME: Move this to an integration test pacakge with proper requires\ntry {\nminispade.require('ember-handlebars');\n} catch(e) { }\n\nvar view;\n\nmodule(\"the {{action}} helper with href attribute\", {\n  teardown: function() {\n    Ember.run(function() {\n      view.destroy();\n    });\n  }\n});\n\nvar compile = function(string) {\n  return Ember.Handlebars.compile(string);\n};\n\nvar namespace = {\n  \"Component\": {\n    toString: function() { return \"Component\"; },\n    find: function() { return { id: 1 }; }\n  }\n};\n\ntest(\"it generates the URL from the target\", function() {\n  view = Ember.View.create({\n    template: compile(\"<a {{action show href=true}}>Hi</a>\")\n  });\n\n  var controller = Ember.Object.createWithMixins(Ember.ControllerMixin, {\n    target: {\n      urlForEvent: function(event, context) {\n        return \"/foo/bar\";\n      }\n    }\n  });\n\n  Ember.run(function() {\n    view.set('controller', controller);\n    view.appendTo('#qunit-fixture');\n  });\n\n  ok(view.$().html().match(/href=['\"].*\\/foo\\/bar['\"]/), \"The html (\" + view.$().html() + \") does not have the href /foo/bar in it\");\n});\n\ntest(\"it does not generate the URL when href property is not specified\", function() {\n  view = Ember.View.create({\n    template: compile(\"<a {{action show}}>Hi</a>\")\n  });\n\n  var controller = Ember.Object.create(Ember.ControllerMixin, {\n    target: {\n      urlForEvent: function(event, context) {\n        return \"/foo/bar\";\n      }\n    }\n  });\n\n  Ember.run(function() {\n    view.set('controller', controller);\n    view.appendTo('#qunit-fixture');\n  });\n\n  ok(!view.$().html().match(/href=['\"]\\/foo\\/bar['\"]/), \"The html (\" + view.$().html() + \") has the href /foo/bar in it\");\n});\n\n\n})();\n//@ sourceURL=ember-old-router/~tests/helpers/action_url_test");minispade.register('ember-old-router/~tests/helpers/outlet_test', "(function() {var appendView = function(view) {\n  Ember.run(function() { view.appendTo('#qunit-fixture'); });\n};\n\nvar compile = function(template) {\n  return Ember.Handlebars.compile(template);\n};\n\nvar view;\n\nmodule(\"Handlebars {{outlet}} helpers\", {\n  teardown: function() {\n    Ember.run(function () {\n      if (view) {\n        view.destroy();\n      }\n    });\n  }\n});\n\ntest(\"outlet should allow controllers to fill in slots\", function() {\n  var controller = Ember.Object.create();\n\n  var template = \"<h1>HI</h1>{{outlet}}\";\n  view = Ember.View.create({\n    controller: controller,\n    template: Ember.Handlebars.compile(template)\n  });\n\n  appendView(view);\n\n  equal(view.$().text(), 'HI');\n\n  Ember.run(function() {\n    controller.set('view', Ember.View.create({\n      template: compile(\"<p>BYE</p>\")\n    }));\n  });\n\n  // IE likes to add newlines\n  equal(view.$().text().replace(/\\s+/g, ''), 'HIBYE');\n});\n\ntest(\"outlet should allow controllers to fill in slots in prerender state\", function() {\n  var controller = Ember.Object.create({\n    view: Ember.View.create({\n      template: compile(\"<p>BYE</p>\")\n    })\n  });\n\n  var template = \"<h1>HI</h1>{{outlet}}\";\n  view = Ember.View.create({\n    controller: controller,\n    template: Ember.Handlebars.compile(template)\n  });\n\n  appendView(view);\n\n  // IE likes to add newlines\n  equal(view.$().text().replace(/\\s+/g, ''), 'HIBYE');\n});\n\ntest(\"outlet should allow a view's default context to fill in slots\", function() {\n  var template = \"<h1>HI</h1>{{outlet}}\";\n  view = Ember.View.create({\n    context: {},\n    template: Ember.Handlebars.compile(template)\n  });\n\n  appendView(view);\n\n  equal(view.$().text(), 'HI');\n\n  Ember.run(function() {\n    view.set('context.view', Ember.View.create({\n      template: compile(\"<p>BYE</p>\")\n    }));\n  });\n\n  // IE likes to add newlines\n  equal(view.$().text().replace(/\\s+/g, ''), 'HIBYE');\n});\n\ntest(\"outlet should support an optional name\", function() {\n  var controller = Ember.Object.create();\n\n  var template = \"<h1>HI</h1>{{outlet mainView}}\";\n  view = Ember.View.create({\n    controller: controller,\n    template: Ember.Handlebars.compile(template)\n  });\n\n  appendView(view);\n\n  equal(view.$().text(), 'HI');\n\n  Ember.run(function() {\n    controller.set('mainView', Ember.View.create({\n      template: compile(\"<p>BYE</p>\")\n    }));\n  });\n\n  // IE likes to add newlines\n  equal(view.$().text().replace(/\\s+/g, ''), 'HIBYE');\n});\n\n})();\n//@ sourceURL=ember-old-router/~tests/helpers/outlet_test");minispade.register('ember-old-router/~tests/location_test', "(function() {var locationObject;\n\nmodule(\"Ember.Location, hash implementation\", {\n  setup: function() {\n    locationObject = Ember.Location.create({\n      implementation: 'hash'\n    });\n    locationObject.setURL(\"/\");\n\n    // make sure the onhashchange event fires\n    stop();\n    // There are weird issues in FF 3.6 if we pass start itself as the parameter\n    setTimeout(function(){ start(); }, 1);\n  },\n\n  teardown: function() {\n    window.location.hash = \"\";\n    Ember.run(function(){\n      locationObject.destroy();\n    });\n  }\n});\n\ntest(\"it is possible to get the current URL\", function() {\n  equal(locationObject.getURL(), \"/\", \"the initial URL is '/'\");\n  equal(window.location.hash, \"#/\", \"the initial hash is '#/'\");\n});\n\ntest(\"it is possible to set the current URL\", function() {\n  locationObject.setURL(\"/foo\");\n  equal(locationObject.getURL(), \"/foo\", \"the updated URL is '/'\");\n  equal(window.location.hash, \"#/foo\", \"the updated hash is '#/foo'\");\n});\n\ntest(\"if the hash changes, the onUpdateURL callback is invoked\", function() {\n  stop();\n\n  locationObject.onUpdateURL(function(url) {\n    start();\n\n    equal(url, '/foo/bar', \"the callback is invoked with the URL\");\n  });\n\n  window.location.hash = \"#/foo/bar\";\n});\n\ntest(\"if the URL is set, it doesn't trigger the hashchange event\", function() {\n  stop();\n\n  var count = 0;\n\n  setTimeout(function() {\n    start();\n    equal(count, 0, \"The update callback was not called\");\n  }, 100);\n\n  locationObject.onUpdateURL(function(url) {\n    count++;\n  });\n\n  locationObject.setURL('/avoid/triggering');\n});\n\nmodule(\"Ember.Location, history implementation\", {\n  setup: function() {\n\n    var setHistory = function(obj, path) {\n      obj.set('history', { state: { path: path } });\n    };\n\n    Ember.HistoryLocation.reopen({\n      initState: function() {\n        setHistory(this, window.location.pathname);\n      },\n\n      replaceState: function(path) {\n        setHistory(this, path);\n      },\n\n      pushState: function(path) {\n        setHistory(this, path);\n      }\n    });\n\n    locationObject = Ember.Location.create({\n      implementation: 'history'\n    });\n\n    stop();\n    setTimeout(start, 1);\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      locationObject.destroy();\n    });\n  }\n});\n\ntest(\"it sets the initial state\", function() {\n  equal(locationObject.getState().path, window.location.pathname, \"the initial state is set\");\n});\n\ntest(\"it is possible to get the current URL\", function() {\n  equal(locationObject.getURL(), window.location.pathname, \"current URL is set\");\n});\n\ntest(\"it is possible to set the current URL\", function() {\n  var setPath;\n\n  locationObject.pushState = function(path) {\n    setPath = path;\n  };\n\n  locationObject.setURL(\"/foo\");\n  equal(setPath, \"/foo\", \"the updated URL is '/foo'\");\n});\n\ntest(\"if the URL is set, it doesn't trigger the popstate event\", function() {\n  expect(1);\n\n  stop();\n  var count = 0;\n  locationObject.pushState = function(data, title, path) {};\n\n  setTimeout(function() {\n    start();\n    equal(count, 0, \"The update callback was not called\");\n  }, 100);\n\n  locationObject.onUpdateURL(function(url) {\n    count++;\n  });\n\n  locationObject.setURL('/avoid/triggering');\n});\n\ntest(\"if history is used, it triggers the popstate event\", function() {\n  expect(1);\n\n  stop();\n  var count = 0;\n\n  setTimeout(function() {\n    start();\n    equal(count, 1, \"The update callback was not called\");\n  }, 300);\n\n  locationObject.onUpdateURL(function(url) {\n    count++;\n  });\n\n  window.history.back();\n});\n\ntest(\"doesn't push a state if path has not changed\", function() {\n  expect(1);\n  stop();\n\n  var count = 0;\n  locationObject.pushState = function() {\n    count++;\n  };\n\n  setTimeout(function() {\n    start();\n    equal(count, 0, \"pushState should not have been called\");\n  }, 100);\n\n  locationObject.setURL(window.location.pathname);\n});\n\ntest(\"it calls pushState if state.path is different than given path\", function() {\n  expect(1);\n  stop();\n\n  var count = 0;\n\n  locationObject.pushState = function() {\n    count++;\n  };\n\n  setTimeout(function() {\n    start();\n    equal(count, 1, \"pushState should have been called\");\n  }, 100);\n\n  locationObject.setURL('/test');\n});\n\ntest(\"it handles an empty path as root\", function() {\n  equal(locationObject.formatURL(''), '/', \"The formatted url is '/'\");\n});\n\ntest(\"formatURL properly appends to rootURL\", function() {\n  locationObject.set('rootURL', '/test');\n  equal(locationObject.formatURL('/foo'), '/test/foo', \"The formatted url is '/test/foo'\");\n});\n\ntest(\"it prepends rootURL to path\", function() {\n  var setPath;\n\n  locationObject.pushState = function(path) {\n    setPath = path;\n  };\n\n  locationObject.set('rootURL', '/test');\n  locationObject.setURL(\"/foo\");\n\n  equal(setPath, '/test/foo', \"The updated url is '/test/foot'\");\n});\n\n})();\n//@ sourceURL=ember-old-router/~tests/location_test");minispade.register('ember-old-router/~tests/render_test', "(function() {var router;\n\nmodule(\"Rendering in the router\", {\n  teardown: function() {\n    Ember.run(function() {\n      var view = router.get('applicationController.view') ||\n                 router.get('appController.view');\n      if (view) { view.destroy(); }\n      router.destroy();\n    });\n  }\n});\n\ntest(\"By default, `render` renders into the application's outlet\", function() {\n  expect(1);\n\n  router = Ember.Router.extend({\n    applicationController: Ember.Controller.extend({\n      viewDidChange: Ember.observer(function() {\n        equal(this.get('view.templateName'), 'posts');\n      }, 'view')\n    }).create(),\n\n    namespace: {},\n\n    root: Ember.Route.extend({\n      template: 'application',\n\n      posts: Ember.Route.extend({\n        template: 'posts'\n      })\n    })\n  }).create();\n\n  var postsRoute = router.get('states.root.states.posts');\n\n  Ember.run(function() {\n    postsRoute.render();\n  });\n});\n\ntest(\"If a view class for a given template exists, use it and update it with the relevant templateName\", function() {\n  expect(2);\n\n  var PostView = Ember.Object.extend();\n\n  router = Ember.Router.extend({\n    applicationController: Ember.Controller.extend({\n      viewDidChange: Ember.observer(function() {\n        ok(this.get('view') instanceof PostView, \"The view is an instance of PostView\");\n        equal(this.get('view.templateName'), 'post');\n      }, 'view')\n    }).create(),\n\n    namespace: {\n      PostView: PostView\n    },\n\n    root: Ember.Route.extend({\n      template: 'application',\n\n      posts: Ember.Route.extend({\n        template: 'post'\n      })\n    })\n  }).create();\n\n  var postsRoute = router.get('states.root.states.posts');\n\n  Ember.run(function() {\n    postsRoute.render();\n  });\n});\n\ntest(\"The default template to render into is `application`\", function() {\n  expect(1);\n\n  router = Ember.Router.extend({\n    applicationController: Ember.Controller.extend({\n      viewDidChange: Ember.observer(function() {\n        equal(this.get('view.templateName'), 'posts');\n      }, 'view')\n    }).create(),\n\n    namespace: {},\n\n    root: Ember.Route.extend({\n      posts: Ember.Route.extend({\n        template: 'posts'\n      })\n    })\n  }).create();\n\n  var postsRoute = router.get('states.root.states.posts');\n\n  Ember.run(function() {\n    postsRoute.render();\n  });\n});\n\ntest(\"You can override the template to render and the template to render into\", function() {\n  expect(1);\n\n  router = Ember.Router.extend({\n    appController: Ember.Controller.extend({\n      viewDidChange: Ember.observer(function() {\n        equal(this.get('view.templateName'), 'other');\n      }, 'view')\n    }).create(),\n\n    namespace: {},\n\n    root: Ember.Route.extend({\n      posts: Ember.Route.extend({\n        template: 'posts'\n      })\n    })\n  }).create();\n\n  var postsRoute = router.get('states.root.states.posts');\n\n  Ember.run(function() {\n    postsRoute.render({ into: 'app', template: 'other' });\n  });\n});\n\ntest(\"By default, the route's class name is used to infer its template name\", function() {\n  var PostsRoute = Ember.Route.extend();\n  PostsRoute.toString = function() { return \"App.PostsRoute\"; };\n\n  var ApplicationRoute = Ember.Route.extend({\n    posts: PostsRoute\n  });\n  ApplicationRoute.toString = function() { return \"App.ApplicationRoute\"; };\n\n  router = Ember.Router.extend({\n    applicationController: Ember.Controller.extend({\n      viewDidChange: Ember.observer(function() {\n        equal(this.get('view.templateName'), 'posts');\n      }, 'view')\n    }).create(),\n\n    namespace: {},\n\n    root: Ember.Route.extend({\n      posts: PostsRoute\n    })\n  }).create();\n\n  Ember.run(function() {\n    router.get('states.root.states.posts').render();\n  });\n});\n\n})();\n//@ sourceURL=ember-old-router/~tests/render_test");minispade.register('ember-old-router/~tests/routable_test', "(function() {var originalLookup = Ember.lookup, lookup, TestApp;\n\nmodule(\"Ember.Routable\");\n\ntest(\"it should have its updateRoute method called when it is entered\", function() {\n  var locationStub = { };\n\n  expect(2);\n\n  var state = Ember.Route.create({\n    route: 'foo',\n    updateRoute: function(manager, location) {\n      ok(true, \"updateRoute was called\");\n      strictEqual(location, locationStub);\n    }\n  });\n\n  var router = Ember.Router.create({\n    location: locationStub,\n    root: Ember.Route.create({\n      ready: function(manager) {\n        manager.transitionTo('initial');\n      },\n\n      initial: state\n    })\n  });\n\n  router.send('ready');\n});\n\ntest(\"a RouteMatcher matches routes\", function() {\n  var match;\n\n  var matcher = Ember._RouteMatcher.create({\n    route: \"foo\"\n  });\n\n  match = matcher.match('foo');\n  equal(match.remaining, \"\");\n  equal(match.hash, null);\n\n  match = matcher.match('foo/bar');\n  equal(match.remaining, \"/bar\");\n  equal(match.hash, null);\n\n  match = matcher.match('bar');\n  equal(match, undefined);\n});\n\ntest(\"a RouteMatcher matches routes with dynamic segments\", function() {\n  var match;\n\n  var matcher = Ember._RouteMatcher.create({\n    route: \"foo/:id/:name/:ok_tom\"\n  });\n\n  match = matcher.match('foo/bar/baz/sigh');\n  equal(match.remaining, \"\");\n  deepEqual(match.hash, {\"id\": \"bar\", \"name\": \"baz\", \"ok_tom\": \"sigh\"});\n\n  match = matcher.match('foo/bar/baz/common/bro');\n  equal(match.remaining, \"/bro\");\n  deepEqual(match.hash, {\"id\": \"bar\", \"name\": \"baz\", \"ok_tom\": \"common\"});\n\n  match = matcher.match('foo/bar');\n  equal(match, undefined);\n});\n\ntest(\"a RouteMatcher matches routes with dynamic segments (the last being globbed)\", function() {\n  var match;\n\n  var matcher = Ember._RouteMatcher.create({\n    route: \"foo/:id/:name/*ok_tom\"\n  });\n\n  match = matcher.match('foo/bar/baz/common/bro');\n  equal(match.remaining, \"\");\n  deepEqual(match.hash, {\"id\": \"bar\", \"name\": \"baz\", \"ok_tom\": \"common/bro\"});\n\n  match = matcher.match('foo/bar');\n  equal(match, undefined);\n});\n\ntest(\"a RouteMatcher generates routes with dynamic segments\", function() {\n  var url;\n\n  var matcher = Ember._RouteMatcher.create({\n    route: \"foo/:id/:first_name\"\n  });\n\n  url = matcher.generate({ id: 1, first_name: \"Yehuda\" });\n  equal(url, \"foo/1/Yehuda\");\n});\n\ntest(\"a RouteMatcher generates routes with dynamic segments (with glob)\", function() {\n  var url;\n\n  var matcher = Ember._RouteMatcher.create({\n    route: \"foo/:id/*first_name\"\n  });\n\n  url = matcher.generate({ id: 1, first_name: \"Yehuda/test\" });\n  equal(url, \"foo/1/Yehuda/test\");\n});\n\ntest(\"route repeatedly descends into a nested hierarchy\", function() {\n  var state = Ember.Route.create({\n    fooChild: Ember.Route.create({\n      route: 'foo',\n\n      barChild: Ember.Route.create({\n        route: 'bar',\n\n        bazChild: Ember.Route.create({\n          route: 'baz'\n        })\n      })\n    })\n  });\n\n  var router = Ember.Router.create({\n    location: 'none',\n    root: state\n  });\n\n  router.route(\"/foo/bar/baz\");\n\n  equal(router.get('currentState.path'), 'root.fooChild.barChild.bazChild');\n});\n\ntest(\"when you descend into a state, the route is set\", function() {\n  var state = Ember.Route.create({\n    ready: function(manager) {\n      manager.transitionTo('fooChild.barChild.bazChild');\n    },\n\n    fooChild: Ember.Route.create({\n      route: 'foo',\n\n      barChild: Ember.Route.create({\n        route: 'bar',\n\n        bazChild: Ember.Route.create({\n          route: 'baz'\n        })\n      })\n    })\n  });\n\n  var count = 0;\n\n  var router = Ember.Router.create({\n    root: state,\n    location: {\n      setURL: function(url) {\n        if (count === 0) {\n          equal(url, '/foo/bar/baz', \"The current URL should be passed in\");\n          count++;\n        } else {\n          ok(false, \"Should not get here\");\n        }\n      }\n    }\n  });\n\n  router.send('ready');\n});\n\ntest(\"when you descend into a state, the route is set even when child states (not routes) are present\", function() {\n  var state = Ember.Route.create({\n    ready: function(manager) {\n      manager.transitionTo('fooChild.barChild.bazChild');\n    },\n\n    fooChild: Ember.Route.create({\n      route: 'foo',\n\n      barChild: Ember.Route.create({\n        route: 'bar',\n\n        bazChild: Ember.Route.create({\n          route: 'baz',\n\n          basicState: Ember.State.create()\n        })\n      })\n    })\n  });\n\n  var count = 0;\n\n  var router = Ember.Router.create({\n    root: state,\n    location: {\n      setURL: function(url) {\n        if (count === 0) {\n          equal(url, '/foo/bar/baz', \"The current URL should be passed in\");\n          count++;\n        } else {\n          ok(false, \"Should not get here\");\n        }\n      }\n    }\n  });\n\n  router.send('ready');\n});\n\nvar router;\nvar Post = {\n  find: function(id) {\n    return { isPerson: true, id: parseInt(id, 10) };\n  }\n};\n\nvar setURL;\nvar locationMock = {\n  setURL: function(url) {\n    setURL = url;\n  }\n};\n\nmodule(\"Routing Serialization and Deserialization\", {\n  setup: function() {\n    router = Ember.Router.create({\n      location: locationMock,\n      root: Ember.Route.create({\n        ready: function(manager, post) {\n          manager.transitionTo('post.show', { post: post });\n        },\n\n        showIndex: function(manager) {\n          manager.transitionTo('post.index');\n        },\n\n        post: Ember.Route.create({\n          route: '/posts',\n\n          index: Ember.Route.create({\n            route: '/',\n\n            showPost: function(manager, post) {\n              manager.transitionTo('post.show', { post: post });\n            }\n          }),\n\n          show: Ember.Route.create({\n            route: \"/:post_id\",\n\n            connectOutlets: function(manager, context) {\n              equal(context.post.id, 2, \"should be the same value regardless of entry point\");\n            },\n\n            deserialize: function(manager, params) {\n              return { post: Post.find(params['post_id']) };\n            },\n\n            serialize: function(manager, hash) {\n              return { post_id: hash.post.id };\n            },\n\n            showIndex: function(manager) {\n              manager.transitionTo('index');\n            }\n          })\n        })\n      })\n    });\n  }\n});\n\ntest(\"should invoke the deserialize method on a state when it is entered via a URL\", function() {\n  expect(1);\n\n  router.route('/posts/2');\n});\n\ntest(\"should invoke the serialize method on a state when it is entered programmatically (initially deep)\", function() {\n  expect(3);\n\n  router.send('ready', Post.find(2));\n  equal(setURL, '/posts/2', \"The post is serialized\");\n\n  router.send('showIndex');\n  equal(setURL, '/posts');\n});\n\ntest(\"should invoke the serialize method on a state when it is entered programmatically (initially shallow)\", function() {\n  expect(3);\n\n  router.send('showIndex');\n  equal(setURL, '/posts', \"The post is serialized\");\n\n  router.send('showPost', Post.find(2));\n  equal(setURL, '/posts/2');\n});\n\nvar url, firstPost, firstUser;\n\nmodule(\"default serialize and deserialize with modelType\", {\n  setup: function() {\n    Ember.BOOTED = false;\n\n    Ember.lookup = lookup = {};\n\n    lookup.TestApp = TestApp = Ember.Namespace.create();\n    TestApp.Post = Ember.Object.extend();\n    TestApp.Post.find = function(id) {\n      if (id === \"1\") { return firstPost; }\n    };\n    TestApp.Post.toString();\n\n    TestApp.User = Ember.Object.extend();\n    TestApp.User.find = function(id) {\n      if (id === \"1\") { return firstUser; }\n    };\n    TestApp.User.toString();\n\n    firstPost = TestApp.Post.create({ id: 1 });\n    firstUser = TestApp.User.create({ id: 1 });\n\n    router = Ember.Router.create({\n      location: {\n        setURL: function(passedURL) {\n          url = passedURL;\n        }\n      },\n\n      root: Ember.Route.extend({\n        post: Ember.Route.extend({\n          route: '/posts/:post_id',\n          modelType: 'TestApp.Post',\n\n          connectOutlets: function(router, post) {\n            equal(post, firstPost, \"the post should have deserialized correctly\");\n          }\n        }),\n\n        user: Ember.Route.extend({\n          route: '/users/:user_id',\n          modelType: TestApp.User,\n\n          connectOutlets: function(router, user) {\n            equal(user, firstUser, \"the post should have deserialized correctly\");\n          }\n        })\n      })\n    });\n\n    Ember.BOOTED = true;\n  },\n\n  teardown: function() {\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest(\"should use a specified String `modelType` in the default `serialize`\", function() {\n  window.billy = true;\n  router.transitionTo('post', firstPost);\n  window.billy = false;\n  equal(url, \"/posts/1\");\n});\n\ntest(\"should use a specified String `modelType` in the default `deserialize`\", function() {\n  expect(1);\n\n  router.route(\"/posts/1\");\n});\n\ntest(\"should use a specified class `modelType` in the default `serialize`\", function() {\n  router.transitionTo('user', firstUser);\n  equal(url, \"/users/1\");\n});\n\ntest(\"should use a specified class `modelType` in the default `deserialize`\", function() {\n  expect(1);\n\n  router.route(\"/users/1\");\n});\n\nvar postSuccessCallback, postFailureCallback,\n    userSuccessCallback, userFailureCallback,\n    connectedUser, connectedPost, connectedChild, connectedOther,\n    isLoading, userLoaded;\n\nmodule(\"modelType with promise\", {\n  setup: function() {\n    Ember.BOOTED = false;\n    Ember.lookup = lookup = {};\n    lookup.TestApp = TestApp = Ember.Namespace.create();\n\n    TestApp.User = Ember.Object.extend({\n      then: function(success, failure) {\n        userLoaded = true;\n        userSuccessCallback = success;\n        userFailureCallback = failure;\n      }\n    });\n    TestApp.User.find = function(id) {\n      if (id === \"1\") {\n        return firstUser;\n      }\n    };\n    TestApp.User.toString();\n\n    TestApp.Post = Ember.Object.extend({\n      then: function(success, failure) {\n        postSuccessCallback = success;\n        postFailureCallback = failure;\n      }\n    });\n    TestApp.Post.find = function(id) {\n      // Simulate dependency on user\n      if (!userLoaded) { return; }\n      if (id === \"1\") { return firstPost; }\n    };\n    TestApp.Post.toString();\n\n    firstUser = TestApp.User.create({ id: 1 });\n    firstPost = TestApp.Post.create({ id: 1 });\n\n    router = Ember.Router.create({\n      location: {\n        setURL: function(passedURL) {\n          url = passedURL;\n        }\n      },\n\n      root: Ember.Route.extend({\n        users: Ember.Route.extend({\n          route: '/users',\n\n          user: Ember.Route.extend({\n            route: '/:user_id',\n            modelType: 'TestApp.User',\n\n            connectOutlets: function(router, obj) {\n              connectedUser = obj;\n            },\n\n            posts: Ember.Route.extend({\n              route: '/posts',\n\n              post: Ember.Route.extend({\n                route: '/:post_id',\n                modelType: 'TestApp.Post',\n\n                connectOutlets: function(router, obj) {\n                  connectedPost = obj;\n                },\n\n                show: Ember.Route.extend({\n                  route: '/',\n\n                  connectOutlets: function(router) {\n                    connectedChild = true;\n                  }\n                })\n              })\n            })\n          })\n        }),\n\n        other: Ember.Route.extend({\n          route: '/other',\n\n          connectOutlets: function() {\n            connectedOther = true;\n          }\n        }),\n\n        loading: Ember.State.extend({\n          setup: function() {\n            isLoading = true;\n          },\n\n          exit: function() {\n            isLoading = false;\n          }\n        })\n      })\n    });\n  },\n\n  teardown: function() {\n    postSuccessCallback = postFailureCallback = undefined;\n    userSuccessCallback = userFailureCallback = undefined;\n    connectedUser = connectedPost = connectedChild = connectedOther = undefined;\n    isLoading = userLoaded = undefined;\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest(\"should handle promise success\", function() {\n  ok(!isLoading, 'precond - should not start loading');\n\n  Ember.run(function() {\n    router.route('/users/1/posts/1');\n  });\n\n  ok(!connectedUser, 'precond - should not connect user immediately');\n  ok(!connectedPost, 'precond - should not connect post immediately');\n  ok(!connectedChild, 'precond - should not connect child immediately');\n  ok(isLoading, 'should be loading');\n\n  Ember.run(function() {\n    userSuccessCallback('loadedUser');\n  });\n\n  ok(!connectedUser, 'should not connect user until all promises are loaded');\n  ok(!connectedPost, 'should not connect post until all promises are loaded');\n  ok(!connectedChild, 'should not connect child until all promises are loaded');\n  ok(isLoading, 'should still be loading');\n\n  Ember.run(function() {\n    postSuccessCallback('loadedPost');\n  });\n\n  equal(connectedUser, 'loadedUser', 'should connect user after success callback');\n  equal(connectedPost, 'loadedPost', 'should connect post after success callback');\n  ok(connectedChild, \"should connect child's outlets after success callback\");\n  ok(!isLoading, 'should not be loading');\n});\n\ntest(\"should handle early promise failure\", function() {\n  router.route('/users/1/posts/1');\n\n  ok(userFailureCallback, 'precond - has failureCallback');\n\n  raises(function() {\n    userFailureCallback('failedUser');\n  }, \"Unable to load record.\", \"should throw exception on failure\");\n\n  ok(!connectedUser, 'should not connect user after early failure');\n  ok(!connectedPost, 'should not connect post after early failure');\n  ok(!connectedChild, 'should not connect child after early failure');\n});\n\ntest(\"should handle late promise failure\", function() {\n  router.route('/users/1/posts/1');\n\n  userSuccessCallback('loadedUser');\n\n  ok(postFailureCallback, 'precond - has failureCallback');\n\n  raises(function() {\n    postFailureCallback('failedPost');\n  }, \"Unable to load record.\", \"should throw exception on failure\");\n\n  ok(!connectedUser, 'should not connect user after late failure');\n  ok(!connectedPost, 'should not connect post after late failure');\n  ok(!connectedChild, 'should not connect child after late failure');\n});\n\ntest(\"should stop promises if new route is targeted\", function() {\n  router.route('/users/1/posts/1');\n\n  userSuccessCallback('loadedUser');\n\n  ok(!connectedOther, 'precond - has not yet connected other');\n\n  Ember.run(function() {\n    router.route('/other');\n  });\n\n  ok(connectedOther, 'should connect other');\n\n  postSuccessCallback('loadedPost');\n\n  ok(!connectedUser, 'should not connect user after reroute');\n  ok(!connectedPost, 'should not connect post after reroute');\n  ok(!connectedChild, 'should not connect child after reroute');\n});\n\ntest(\"should stop promises if transitionTo is called\", function() {\n  router.route('/users/1/posts/1');\n\n  userSuccessCallback('loadedUser');\n\n  ok(!connectedOther, 'precond - has not yet connected other');\n\n  Ember.run(function() {\n    router.transitionTo('other');\n  });\n\n  ok(connectedOther, 'should connect other');\n\n  postSuccessCallback('loadedPost');\n\n  ok(!connectedUser, 'should not connect user after reroute');\n  ok(!connectedPost, 'should not connect post after reroute');\n  ok(!connectedChild, 'should not connect child after reroute');\n});\n\nmodule(\"default serialize and deserialize without modelType\", {\n  setup: function() {\n    Ember.lookup = lookup = {};\n    lookup.TestApp = TestApp = Ember.Namespace.create();\n    TestApp.Post = Ember.Object.extend();\n    TestApp.Post.find = function(id) {\n      if (id === \"1\") { return firstPost; }\n    };\n\n    firstPost = TestApp.Post.create({ id: 1 });\n\n    router = Ember.Router.create({\n      namespace: TestApp,\n\n      location: {\n        setURL: function(passedURL) {\n          url = passedURL;\n        }\n      },\n\n      root: Ember.Route.extend({\n        post: Ember.Route.extend({\n          route: '/posts/:post_id',\n\n          connectOutlets: function(router, post) {\n            equal(post, firstPost, \"the post should have deserialized correctly\");\n          }\n        })\n      })\n    });\n  },\n\n  teardown: function() {\n    Ember.lookup = originalLookup;\n  }\n});\n\n\n\ntest(\"should use a specified String `modelType` in the default `serialize`\", function() {\n  router.transitionTo('post', firstPost);\n  equal(url, \"/posts/1\");\n});\n\ntest(\"should use a specified String `modelType` in the default `deserialize`\", function() {\n  expect(1);\n\n  router.route(\"/posts/1\");\n});\n\nmodule(\"redirectsTo\");\n\ntest(\"if a leaf state has a redirectsTo, it automatically transitions into that state\", function() {\n   var router = Ember.Router.create({\n     location: 'none',\n     root: Ember.Route.create({\n\n       index: Ember.Route.create({\n         route: '/',\n         redirectsTo: 'someOtherState'\n       }),\n\n       someOtherState: Ember.Route.create({\n         route: '/other'\n       })\n     })\n  });\n\n  Ember.run(function() {\n    router.route(\"/\");\n  });\n\n  equal(router.get('currentState.path'), \"root.someOtherState\");\n});\n\ntest(\"you cannot define connectOutlets AND redirectsTo\", function() {\n  raises(function() {\n    Ember.Router.create({\n      location: 'none',\n      root: Ember.Route.create({\n        index: Ember.Route.create({\n          route: '/',\n          redirectsTo: 'someOtherState',\n          connectOutlets: function() {}\n        })\n      })\n    });\n  });\n});\n\ntest(\"you cannot have a redirectsTo in a non-leaf state\", function () {\n  raises(function() {\n    Ember.Router.create({\n      location: 'none',\n      root: Ember.Route.create({\n        redirectsTo: 'someOtherState',\n\n        index: Ember.Route.create()\n      })\n    });\n  });\n});\n\nmodule(\"urlFor\");\n\nvar formatURLArgument = null;\nvar locationStub = {\n  formatURL: function(url) {\n    formatURLArgument = url;\n    return url;\n  },\n  setURL: Ember.K\n};\nvar expectURL = function(url) {\n  equal(formatURLArgument, url, \"should invoke formatURL with URL \"+url);\n};\n\ntest(\"urlFor returns an absolute route\", function() {\n  expect(2);\n\n  var router = Ember.Router.create({\n    location: locationStub,\n    root: Ember.Route.create({\n      dashboard: Ember.Route.create({\n        route: '/dashboard'\n      })\n    })\n  });\n\n  var url = router.urlFor('root.dashboard');\n  equal(url, '/dashboard');\n  expectURL('/dashboard');\n});\n\ntest(\"urlFor raises an error when route property is not defined\", function() {\n  var router = Ember.Router.create({\n    location: locationStub,\n    root: Ember.Route.create({\n      dashboard: Ember.Route.create({}) // state without route property\n    })\n  });\n\n  raises(function (){\n    router.urlFor('root.dashboard');\n  });\n});\n\ntest(\"urlFor supports dynamic segments\", function() {\n  var router = Ember.Router.create({\n    location: locationStub,\n\n    root: Ember.Route.create({\n      dashboard: Ember.Route.create({\n        route: '/dashboard',\n\n        posts: Ember.Route.create({\n          route: '/posts/:post_id'\n        })\n      })\n    })\n  });\n\n  var url = router.urlFor('root.dashboard.posts', { post_id: 1 });\n  equal(url, \"/dashboard/posts/1\");\n  expectURL('/dashboard/posts/1');\n});\n\ntest(\"urlFor supports using the current information for dynamic segments\", function() {\n  var router = Ember.Router.create({\n    location: locationStub,\n    namespace: {\n      Post: {\n        toString: function() { return \"Post\"; },\n        find: function() { return { id: 1 }; }\n      }\n    },\n\n    root: Ember.Route.create({\n      dashboard: Ember.Route.create({\n        route: '/dashboard',\n\n        posts: Ember.Route.create({\n          route: '/posts/:post_id',\n\n          index: Ember.Route.create({\n            route: '/'\n          }),\n\n          manage: Ember.Route.create({\n            route: '/manage'\n          })\n        })\n      })\n    })\n  });\n\n  Ember.run(function() {\n    router.route('/dashboard/posts/1');\n  });\n\n  var url = router.urlFor('root.dashboard.posts.manage');\n  equal(url, '/dashboard/posts/1/manage');\n  expectURL('/dashboard/posts/1/manage');\n});\n\ntest(\"urlFor supports merging the current information for dynamic segments\", function() {\n  var router = Ember.Router.create({\n    location: locationStub,\n    namespace: {\n      Post: {\n        toString: function() { return \"Post\"; },\n        find: function() { return { id: 1 }; }\n      },\n\n      Widget: {\n        toString: function() { return \"Widget\"; },\n        find: function() { return { id: 2 }; }\n      }\n    },\n\n    root: Ember.Route.create({\n      dashboard: Ember.Route.create({\n        route: '/dashboard',\n\n        posts: Ember.Route.create({\n          route: '/posts/:post_id',\n\n          index: Ember.Route.create({\n            route: '/'\n          }),\n\n          manage: Ember.Route.create({\n            route: '/manage/:widget_id'\n          })\n        })\n      })\n    })\n  });\n\n  Ember.run(function() {\n    router.route('/dashboard/posts/1');\n  });\n\n  var url = router.urlFor('root.dashboard.posts.manage', { widget_id: 2 });\n  equal(url, '/dashboard/posts/1/manage/2');\n  expectURL('/dashboard/posts/1/manage/2');\n});\n\n\ntest(\"urlForEvent supports nested routes that have different contexts but share property names\", function() {\n  var router = Ember.Router.create({\n    location: locationStub,\n\n    root: Ember.Route.create({\n      goToComments: Ember.Route.transitionTo('root.dashboard.posts.comments'),\n\n      dashboard: Ember.Route.create({\n        route: '/dashboard',\n\n        posts: Ember.Route.create({\n          route: '/posts/:id',\n          comments: Ember.Route.create({\n            route: '/comments/:id'\n          })\n        })\n      })\n    })\n  });\n\n  var url = router.urlForEvent('goToComments', { id: 1 }, {id: 5});\n  equal(url, \"/dashboard/posts/1/comments/5\");\n  expectURL('/dashboard/posts/1/comments/5');\n});\n\n\ntest(\"navigateAway is called if the URL changes\", function() {\n  var navigated = 0;\n\n  var router = Ember.Router.create({\n    location: locationStub,\n    root: Ember.Route.create({\n      index: Ember.Route.create({\n        route: '/',\n\n        navigateAway: function(router) {\n          navigated++;\n        }\n      }),\n\n      show: Ember.Route.create({\n        route: '/show'\n      })\n    })\n  });\n\n  Ember.run(function() {\n    router.route('/');\n  });\n\n  equal(router.get('currentState.path'), 'root.index', \"The current state is root.index\");\n\n  Ember.run(function() {\n    router.route('/show');\n  });\n\n  equal(router.get('currentState.path'), 'root.show', \"The current state is root.index\");\n  equal(navigated, 1, \"The navigateAway method was called\");\n});\n\n})();\n//@ sourceURL=ember-old-router/~tests/routable_test");minispade.register('ember-old-router/~tests/router_test', "(function() {module(\"router.urlForEvent\");\n\nvar namespace = {\n  \"Component\": {\n    toString: function() { return \"Component\"; },\n    find: function() { return { id: 1 }; }\n  }\n};\n\nvar location = {\n  formatURL: function(url) {\n    return '#!#' + url;\n  },\n\n  setURL: function(url) {\n    this.url = url;\n  }\n};\n\nvar get = Ember.get;\n\ntest(\"router.urlForEvent looks in the current state's eventTransitions hash\", function() {\n  var router = Ember.Router.create({\n    location: location,\n    namespace: namespace,\n    root: Ember.Route.create({\n      index: Ember.Route.create({\n        route: '/',\n\n        showDashboard: function(router) {\n          router.transitionTo('dashboard');\n        },\n\n        eventTransitions: {\n          showDashboard: 'dashboard'\n        }\n      }),\n\n      dashboard: Ember.Route.create({\n        route: '/dashboard'\n      })\n    })\n  });\n\n  Ember.run(function() {\n    router.route('/');\n  });\n\n  equal(router.get('currentState.path'), \"root.index\", \"precond - the router is in root.index\");\n\n  var url = router.urlForEvent('showDashboard');\n  equal(url, \"#!#/dashboard\");\n});\n\ntest(\"router.urlForEvent looks in the eventTransitions hashes of the current state's ancestors\", function() {\n  var router = Ember.Router.create({\n    location: location,\n    namespace: namespace,\n    root: Ember.Route.create({\n      eventTransitions: {\n        showDashboard: 'dashboard'\n      },\n\n      index: Ember.Route.create({\n        route: '/'\n      }),\n\n      dashboard: Ember.Route.create({\n        route: '/dashboard'\n      })\n    })\n  });\n\n  Ember.run(function() {\n    router.route('/');\n  });\n\n  equal(router.get('currentState.path'), \"root.index\", \"precond - the router is in root.index\");\n\n  var url = router.urlForEvent('showDashboard');\n  equal(url, \"#!#/dashboard\");\n});\n\ntest(\"router.urlForEvent works with a context\", function() {\n  var router = Ember.Router.create({\n    location: location,\n    namespace: namespace,\n    root: Ember.Route.create({\n      index: Ember.Route.create({\n        route: '/',\n\n        showDashboard: function(router) {\n          router.transitionTo('dashboard');\n        },\n\n        eventTransitions: {\n          showDashboard: 'dashboard'\n        }\n      }),\n\n      dashboard: Ember.Route.create({\n        route: '/dashboard/:component_id'\n      })\n    })\n  });\n\n  Ember.run(function() {\n    router.route('/');\n  });\n\n  equal(router.get('currentState.path'), \"root.index\", \"precond - the router is in root.index\");\n\n  var url = router.urlForEvent('showDashboard', { id: 1 });\n  equal(url, \"#!#/dashboard/1\");\n});\n\ntest(\"router.urlForEvent works with multiple contexts\", function() {\n  var router = Ember.Router.create({\n    location: location,\n    namespace: namespace,\n    root: Ember.Route.create({\n      index: Ember.Route.create({\n        route: '/',\n\n        showDashboard: function(router) {\n          router.transitionTo('dashboard');\n        },\n\n        eventTransitions: {\n          showComment: 'post.comment'\n        }\n      }),\n\n      post: Ember.Route.create({\n        route: '/post/:post_id',\n\n        comment: Ember.Route.create({\n          route: '/comment/:comment_id'\n        })\n      })\n    })\n  });\n\n  Ember.run(function() {\n    router.route('/');\n  });\n\n  equal(router.get('currentState.path'), \"root.index\", \"precond - the router is in root.index\");\n\n  var url = router.urlForEvent('showComment', { post_id: 1 }, { comment_id: 2 });\n  equal(url, \"#!#/post/1/comment/2\");\n});\n\ntest(\"router.urlForEvent works with changing context in the current state\", function() {\n  var router = Ember.Router.create({\n    location: location,\n    namespace: namespace,\n    root: Ember.Route.create({\n      index: Ember.Route.create({\n        route: '/'\n      }),\n\n      showDashboard: function(router) {\n        router.transitionTo('dashboard');\n      },\n\n      eventTransitions: {\n        showDashboard: 'dashboard'\n      },\n\n      dashboard: Ember.Route.create({\n        route: '/dashboard/:component_id'\n      })\n    })\n  });\n\n  Ember.run(function() {\n    router.route('/dashboard/1');\n  });\n\n  equal(router.get('currentState.path'), \"root.dashboard\", \"precond - the router is in root.dashboard\");\n\n  var url = router.urlForEvent('showDashboard', { id: 2 });\n  equal(url, \"#!#/dashboard/2\");\n});\n\n\ntest(\"router.urlForEvent works for nested routes with a context\", function() {\n  var router = Ember.Router.create({\n    location: location,\n    namespace: namespace,\n    root: Ember.Route.create({\n      index: Ember.Route.create({\n        route: '/',\n\n        showDashboardActivity: function(router) {\n          router.transitionTo('dashboard.activity');\n        },\n\n        eventTransitions: {\n          showDashboardActivity: 'dashboard.activity'\n        }\n      }),\n\n      dashboard: Ember.Route.create({\n        route: '/dashboard/:component_id',\n\n        activity: Ember.Route.create({\n          route: '/activity'\n        })\n      })\n    })\n  });\n\n  Ember.run(function() {\n    router.route('/');\n  });\n\n  equal(router.get('currentState.path'), \"root.index\", \"precond - the router is in root.index\");\n\n  var url = router.urlForEvent('showDashboardActivity', { id: 1 });\n  equal(url, \"#!#/dashboard/1/activity\");\n});\n\n\ntest(\"router.urlForEvent works with Ember.State.transitionTo\", function() {\n  var router = Ember.Router.create({\n    location: location,\n    namespace: namespace,\n    root: Ember.Route.create({\n      index: Ember.Route.create({\n        route: '/',\n\n        showDashboard: Ember.Route.transitionTo('dashboard')\n      }),\n\n      dashboard: Ember.Route.create({\n        route: '/dashboard/:component_id'\n      })\n    })\n  });\n\n  Ember.run(function() {\n    router.route('/');\n  });\n\n  equal(router.get('currentState.path'), \"root.index\", \"precond - the router is in root.index\");\n\n  var url = router.urlForEvent('showDashboard', { id: 1 });\n  equal(url, \"#!#/dashboard/1\");\n});\n\ntest(\"rerouting doesn't exit all the way out\", function() {\n  var exited = 0;\n\n  var router = Ember.Router.create({\n    location: location,\n    namespace: namespace,\n    root: Ember.Route.create({\n      index: Ember.Route.create({\n        route: '/',\n        showDashboard: Ember.Route.transitionTo('dashboard.index')\n      }),\n\n      dashboard: Ember.Route.create({\n        route: '/dashboard',\n\n        exit: function() {\n          exited++;\n        },\n\n        index: Ember.Route.create({\n          route: '/',\n          showComponent: Ember.Route.transitionTo('component')\n        }),\n\n        component: Ember.Route.create({\n          route: '/:component_id',\n          showIndex: Ember.Route.transitionTo('index')\n        })\n      })\n    })\n  });\n\n  Ember.run(function() {\n    router.route('/');\n  });\n\n  equal(router.get('currentState.path'), \"root.index\", \"precond - the router is in root.index\");\n\n  Ember.run(function() {\n    router.send('showDashboard');\n  });\n\n  equal(router.get('currentState.path'), \"root.dashboard.index\", \"precond - the router is in root.dashboard.index\");\n  equal(exited, 0, \"the dashboard hasn't been exited yet\");\n\n  Ember.run(function() {\n    router.send('showComponent', { id: 1 });\n  });\n\n  equal(router.get('currentState.path'), \"root.dashboard.component\", \"precond - the router is in root.index\");\n  equal(exited, 0, \"moving around shouldn't gratuitously exit states\");\n\n  Ember.run(function() {\n    router.route('/dashboard');\n  });\n\n  equal(router.get('currentState.path'), \"root.dashboard.index\", \"the router is in root.dashboard.index\");\n  equal(exited, 0, \"moving around shouldn't gratuitously exit states\");\n\n  Ember.run(function() {\n    router.route('/');\n  });\n\n  equal(router.get('currentState.path'), \"root.index\", \"the router is in root.dashboard.index\");\n  equal(exited, 1, \"now, the exit was called\");\n\n  Ember.run(function() {\n    router.route('/dashboard/1');\n  });\n\n  exited = 0;\n  equal(router.get('currentState.path'), \"root.dashboard.component\", \"the router is in root.dashboard.index\");\n  equal(exited, 0, \"exit wasn't called now\");\n});\n\ntest(\"should be able to unroute out of a state with context\", function() {\n  var router = Ember.Router.create({\n    location: location,\n    namespace: namespace,\n    root: Ember.Route.create({\n      components: Ember.Route.create({\n        route: '/components',\n\n        show: Ember.Route.create({\n          route: '/:component_id',\n\n          index: Ember.Route.create({\n            route: '/'\n          }),\n\n          edit: Ember.Route.create({\n            route: '/edit'\n          })\n        })\n      })\n    })\n  });\n\n  router.route('/components/1/edit');\n  equal(get(router, 'currentState.path'), 'root.components.show.edit', \"should go to the correct state\");\n\n  router.route('/components/1');\n  equal(get(router, 'currentState.path'), 'root.components.show.index', \"should go to the correct state\");\n});\n\ntest(\"should be able to route with initialState\", function() {\n  var router = Ember.Router.create({\n    location: location,\n    namespace: namespace,\n    root: Ember.Route.create({\n      initialState: 'stateOne',\n\n      stateOne: Ember.Route.create({\n        route: '/state_one'\n      }),\n\n      stateTwo: Ember.Route.create({\n        route: '/state_two'\n      })\n    })\n  });\n\n  equal(get(router, 'currentState.path'), 'root.stateOne', \"should be in stateOne\");\n\n  router.route('/state_two');\n\n  equal(get(router, 'currentState.path'), 'root.stateTwo', \"should be in stateTwo\");\n});\n\ntest(\"should be able to route with rootURL\", function() {\n  var router = Ember.Router.create({\n    location: location,\n    namespace: namespace,\n    rootURL: '/test',\n    root: Ember.Route.create({\n      stateOne: Ember.Route.create({\n        route: '/one'\n      }),\n\n      stateTwo: Ember.Route.create({\n        route: '/two'\n      })\n    })\n  });\n\n  router.route('/test/two');\n\n  equal(get(router, 'currentState.path'), 'root.stateTwo', \"should be in stateTwo\");\n});\n\ntest(\"should update route for redirections\", function() {\n  var router = Ember.Router.create({\n    location: location,\n    namespace: namespace,\n    root: Ember.Route.create({\n      index: Ember.Route.create({\n        route: '/',\n        redirectsTo: 'login'\n      }),\n\n      login: Ember.Route.create({\n        route: '/login'\n      })\n    })\n  });\n\n  Ember.run(function() {\n    router.route('/');\n  });\n\n  equal(location.url, '/login');\n});\n\ntest(\"respects initialState if leafRoute with child states\", function() {\n  var router = Ember.Router.create({\n    location: location,\n    namespace: namespace,\n    root: Ember.Route.create({\n      foo: Ember.Route.create({\n        route: '/foo',\n\n        initialState: 'bar',\n\n        bar: Ember.State.create()\n      })\n    })\n  });\n\n  Ember.run(function() {\n    router.route('/foo');\n  });\n\n  equal(location.url, '/foo');\n  equal(router.get('currentState.name'), 'bar');\n});\n\n})();\n//@ sourceURL=ember-old-router/~tests/router_test");minispade.register('ember-old-router/~tests/view_test', "(function() {var set = Ember.set, get = Ember.get, view;\n\nmodule(\"Ember.View - Old Router Functionality\", {\n  setup: function() {\n    Ember.TEMPLATES = {};\n  },\n  teardown: function() {\n    Ember.run(function() {\n      view.destroy();\n    });\n  }\n});\n\ntest(\"should load named templates from View.templates\", function() {\n\n\n  view = Ember.View.create({\n    templates: {\n      testTemplate: function() {\n        return \"<h1 id='old-router-template-was-called'>template was called</h1>\";\n      }\n    },\n    templateName: 'testTemplate'\n  });\n\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  ok(view.$('#old-router-template-was-called').length, \"the named template was called\");\n});\n\n})();\n//@ sourceURL=ember-old-router/~tests/view_test");minispade.register('ember-routing/~tests/helpers/action_test', "(function() {var dispatcher, view,\n    ActionHelper = Ember.Handlebars.ActionHelper,\n    originalRegisterAction = ActionHelper.registerAction;\n\nvar appendView = function() {\n  Ember.run(function() { view.appendTo('#qunit-fixture'); });\n};\n\nmodule(\"Ember.Handlebars - action helper\", {\n  setup: function() {\n    dispatcher = Ember.EventDispatcher.create();\n    dispatcher.setup();\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      dispatcher.destroy();\n      if (view) { view.destroy(); }\n    });\n  }\n});\n\ntest(\"should output a data attribute with a guid\", function() {\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\"}}>edit</a>')\n  });\n\n  appendView();\n\n  ok(view.$('a').attr('data-ember-action').match(/\\d+/), \"A data-ember-action attribute with a guid was added\");\n});\n\ntest(\"should by default register a click event\", function() {\n  var registeredEventName;\n\n  ActionHelper.registerAction = function(actionName, options) {\n    registeredEventName = options.eventName;\n  };\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\"}}>edit</a>')\n  });\n\n  appendView();\n\n  equal(registeredEventName, 'click', \"The click event was properly registered\");\n\n  ActionHelper.registerAction = originalRegisterAction;\n});\n\ntest(\"should allow alternative events to be handled\", function() {\n  var registeredEventName;\n\n  ActionHelper.registerAction = function(actionName, options) {\n    registeredEventName = options.eventName;\n  };\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\" on=\"mouseUp\"}}>edit</a>')\n  });\n\n  appendView();\n\n  equal(registeredEventName, 'mouseUp', \"The alternative mouseUp event was properly registered\");\n\n  ActionHelper.registerAction = originalRegisterAction;\n});\n\ntest(\"should by default target the view's controller\", function() {\n  var registeredTarget, controller = {};\n\n  ActionHelper.registerAction = function(actionName, options) {\n    registeredTarget = options.target;\n  };\n\n  view = Ember.View.create({\n    controller: controller,\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\"}}>edit</a>')\n  });\n\n  appendView();\n\n  equal(registeredTarget.root, controller, \"The controller was registered as the target\");\n\n  ActionHelper.registerAction = originalRegisterAction;\n});\n\ntest(\"should target the current controller inside an {{each}} loop\", function() {\n  var registeredTarget;\n\n  ActionHelper.registerAction = function(actionName, options) {\n    registeredTarget = options.target;\n  };\n\n  var itemController = Ember.ObjectController.create();\n\n  var ArrayController = Ember.ArrayController.extend({\n    itemController: 'stub',\n    controllerAt: function(idx, object) {\n      return itemController;\n    }\n  });\n\n  var controller = ArrayController.create({\n    model: Ember.A([1])\n  });\n\n  view = Ember.View.create({\n    controller: controller,\n    template: Ember.Handlebars.compile('{{#each controller}}{{action \"editTodo\"}}{{/each}}')\n  });\n\n  appendView();\n\n  equal(registeredTarget.root, itemController, \"the item controller is the target of action\");\n\n  ActionHelper.registerAction = originalRegisterAction;\n});\n\ntest(\"should allow a target to be specified\", function() {\n  var registeredTarget;\n\n  ActionHelper.registerAction = function(actionName, options) {\n    registeredTarget = options.target;\n  };\n\n  var anotherTarget = Ember.View.create();\n\n  view = Ember.View.create({\n    controller: {},\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\" target=\"view.anotherTarget\"}}>edit</a>'),\n    anotherTarget: anotherTarget\n  });\n\n  appendView();\n\n  equal(registeredTarget.options.data.keywords.view, view, \"The specified target was registered\");\n  equal(registeredTarget.target, 'view.anotherTarget', \"The specified target was registered\");\n\n  ActionHelper.registerAction = originalRegisterAction;\n\n  Ember.run(function() {\n    anotherTarget.destroy();\n  });\n});\n\ntest(\"should lazily evaluate the target\", function() {\n  var firstEdit = 0, secondEdit = 0;\n\n  var controller = {};\n  var first = {\n    edit: function() {\n      firstEdit++;\n    }\n  };\n\n  var second = {\n    edit: function() {\n      secondEdit++;\n    }\n  };\n\n  controller.theTarget = first;\n\n  view = Ember.View.create({\n    controller: controller,\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\" target=\"theTarget\"}}>edit</a>')\n  });\n\n  appendView();\n\n  Ember.run(function() {\n    Ember.$('a').trigger('click');\n  });\n\n  equal(firstEdit, 1);\n\n  Ember.set(controller, 'theTarget', second);\n\n  Ember.run(function() {\n    Ember.$('a').trigger('click');\n  });\n\n  equal(firstEdit, 1);\n  equal(secondEdit, 1);\n});\n\ntest(\"should register an event handler\", function() {\n  var eventHandlerWasCalled = false;\n\n  var controller = Ember.Controller.extend({\n    edit: function() { eventHandlerWasCalled = true; }\n  }).create();\n\n  view = Ember.View.create({\n    controller: controller,\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\"}}>click me</a>')\n  });\n\n  appendView();\n\n  var actionId = view.$('a[data-ember-action]').attr('data-ember-action');\n\n  ok(Ember.Handlebars.ActionHelper.registeredActions[actionId], \"The action was registered\");\n\n  view.$('a').trigger('click');\n\n  ok(eventHandlerWasCalled, \"The event handler was called\");\n});\n\ntest(\"handles whitelisted modifier keys\", function() {\n  var eventHandlerWasCalled = false;\n\n  var controller = Ember.Controller.extend({\n    edit: function() { eventHandlerWasCalled = true; }\n  }).create();\n\n  view = Ember.View.create({\n    controller: controller,\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\" allowedKeys=\"alt\"}}>click me</a>')\n  });\n\n  appendView();\n\n  var actionId = view.$('a[data-ember-action]').attr('data-ember-action');\n\n  ok(Ember.Handlebars.ActionHelper.registeredActions[actionId], \"The action was registered\");\n\n  var e = Ember.$.Event('click');\n  e.altKey = true;\n  view.$('a').trigger(e);\n\n  ok(eventHandlerWasCalled, \"The event handler was called\");\n});\n\n\ntest(\"should be able to use action more than once for the same event within a view\", function() {\n  var editWasCalled = false,\n      deleteWasCalled = false,\n      originalEventHandlerWasCalled = false;\n\n  var controller = Ember.Controller.extend({\n    edit: function() { editWasCalled = true; },\n    \"delete\": function() { deleteWasCalled = true; }\n  }).create();\n\n  view = Ember.View.create({\n    controller: controller,\n    template: Ember.Handlebars.compile(\n      '<a id=\"edit\" href=\"#\" {{action \"edit\"}}>edit</a><a id=\"delete\" href=\"#\" {{action \"delete\"}}>delete</a>'\n    ),\n    click: function() { originalEventHandlerWasCalled = true; }\n  });\n\n  appendView();\n\n  view.$('#edit').trigger('click');\n\n  equal(editWasCalled, true, \"The edit action was called\");\n  equal(deleteWasCalled, false, \"The delete action was not called\");\n\n  editWasCalled = deleteWasCalled = originalEventHandlerWasCalled = false;\n\n  view.$('#delete').trigger('click');\n\n  equal(editWasCalled, false, \"The edit action was not called\");\n  equal(deleteWasCalled, true, \"The delete action was called\");\n\n  editWasCalled = deleteWasCalled = originalEventHandlerWasCalled = false;\n\n  view.$().trigger('click');\n\n  equal(editWasCalled, false, \"The edit action was not called\");\n  equal(deleteWasCalled, false, \"The delete action was not called\");\n});\n\ntest(\"the event should not bubble if `bubbles=false` is passed\", function() {\n  var editWasCalled = false,\n      deleteWasCalled = false,\n      originalEventHandlerWasCalled = false;\n\n  var controller = Ember.Controller.extend({\n    edit: function() { editWasCalled = true; },\n    \"delete\": function() { deleteWasCalled = true; }\n  }).create();\n\n  view = Ember.View.create({\n    controller: controller,\n    template: Ember.Handlebars.compile(\n      '<a id=\"edit\" href=\"#\" {{action \"edit\" bubbles=false}}>edit</a><a id=\"delete\" href=\"#\" {{action \"delete\" bubbles=false}}>delete</a>'\n    ),\n    click: function() { originalEventHandlerWasCalled = true; }\n  });\n\n  appendView();\n\n  view.$('#edit').trigger('click');\n\n  equal(editWasCalled, true, \"The edit action was called\");\n  equal(deleteWasCalled, false, \"The delete action was not called\");\n  equal(originalEventHandlerWasCalled, false, \"The original event handler was not called\");\n\n  editWasCalled = deleteWasCalled = originalEventHandlerWasCalled = false;\n\n  view.$('#delete').trigger('click');\n\n  equal(editWasCalled, false, \"The edit action was not called\");\n  equal(deleteWasCalled, true, \"The delete action was called\");\n  equal(originalEventHandlerWasCalled, false, \"The original event handler was not called\");\n\n  editWasCalled = deleteWasCalled = originalEventHandlerWasCalled = false;\n\n  view.$().trigger('click');\n\n  equal(editWasCalled, false, \"The edit action was not called\");\n  equal(deleteWasCalled, false, \"The delete action was not called\");\n  equal(originalEventHandlerWasCalled, true, \"The original event handler was called\");\n});\n\ntest(\"should work properly in an #each block\", function() {\n  var eventHandlerWasCalled = false;\n\n  var controller = Ember.Controller.extend({\n    edit: function() { eventHandlerWasCalled = true; }\n  }).create();\n\n  view = Ember.View.create({\n    controller: controller,\n    items: Ember.A([1, 2, 3, 4]),\n    template: Ember.Handlebars.compile('{{#each view.items}}<a href=\"#\" {{action \"edit\"}}>click me</a>{{/each}}')\n  });\n\n  appendView();\n\n  view.$('a').trigger('click');\n\n  ok(eventHandlerWasCalled, \"The event handler was called\");\n});\n\ntest(\"should work properly in a #with block\", function() {\n  var eventHandlerWasCalled = false;\n\n  var controller = Ember.Controller.extend({\n    edit: function() { eventHandlerWasCalled = true; }\n  }).create();\n\n  view = Ember.View.create({\n    controller: controller,\n    something: {ohai: 'there'},\n    template: Ember.Handlebars.compile('{{#with view.something}}<a href=\"#\" {{action \"edit\"}}>click me</a>{{/with}}')\n  });\n\n  appendView();\n\n  view.$('a').trigger('click');\n\n  ok(eventHandlerWasCalled, \"The event handler was called\");\n});\n\ntest(\"should unregister event handlers on rerender\", function() {\n  var eventHandlerWasCalled = false;\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\"}}>click me</a>'),\n    edit: function() { eventHandlerWasCalled = true; }\n  });\n\n  appendView();\n\n  var previousActionId = view.$('a[data-ember-action]').attr('data-ember-action');\n\n  Ember.run(function(){\n    view.rerender();\n  });\n\n  ok(!Ember.Handlebars.ActionHelper.registeredActions[previousActionId], \"On rerender, the event handler was removed\");\n\n  var newActionId = view.$('a[data-ember-action]').attr('data-ember-action');\n\n  ok(Ember.Handlebars.ActionHelper.registeredActions[newActionId], \"After rerender completes, a new event handler was added\");\n});\n\ntest(\"should unregister event handlers on inside virtual views\", function() {\n  var things = Ember.A([\n    {\n      name: 'Thingy'\n    }\n  ]);\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('{{#each view.things}}<a href=\"#\" {{action \"edit\"}}>click me</a>{{/each}}'),\n    things: things\n  });\n\n  appendView();\n\n  var actionId = view.$('a[data-ember-action]').attr('data-ember-action');\n\n  Ember.run(function() {\n    things.removeAt(0);\n  });\n\n  ok(!Ember.Handlebars.ActionHelper.registeredActions[actionId], \"After the virtual view was destroyed, the action was unregistered\");\n});\n\ntest(\"should properly capture events on child elements of a container with an action\", function() {\n  var eventHandlerWasCalled = false;\n\n  var controller = Ember.Controller.extend({\n    edit: function() { eventHandlerWasCalled = true; }\n  }).create();\n\n  view = Ember.View.create({\n    controller: controller,\n    template: Ember.Handlebars.compile('<div {{action \"edit\"}}><button>click me</button></div>')\n  });\n\n  appendView();\n\n  view.$('button').trigger('click');\n\n  ok(eventHandlerWasCalled, \"Event on a child element triggered the action of it's parent\");\n});\n\ntest(\"should allow bubbling of events from action helper to original parent event\", function() {\n  var eventHandlerWasCalled = false,\n      originalEventHandlerWasCalled = false;\n\n  var controller = Ember.Controller.extend({\n    edit: function() { eventHandlerWasCalled = true; }\n  }).create();\n\n  view = Ember.View.create({\n    controller: controller,\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\"}}>click me</a>'),\n    click: function() { originalEventHandlerWasCalled = true; }\n  });\n\n  appendView();\n\n  view.$('a').trigger('click');\n\n  ok(eventHandlerWasCalled && originalEventHandlerWasCalled, \"Both event handlers were called\");\n});\n\ntest(\"should not bubble an event from action helper to original parent event if `bubbles=false` is passed\", function() {\n  var eventHandlerWasCalled = false,\n      originalEventHandlerWasCalled = false;\n\n  var controller = Ember.Controller.extend({\n    edit: function() { eventHandlerWasCalled = true; }\n  }).create();\n\n  view = Ember.View.create({\n    controller: controller,\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\" bubbles=false}}>click me</a>'),\n    click: function() { originalEventHandlerWasCalled = true; }\n  });\n\n  appendView();\n\n  view.$('a').trigger('click');\n\n  ok(eventHandlerWasCalled, \"The child handler was called\");\n  ok(!originalEventHandlerWasCalled, \"The parent handler was not called\");\n});\n\ntest(\"should allow 'send' as action name (#594)\", function() {\n  var eventHandlerWasCalled = false;\n  var eventObjectSent;\n\n  var controller = Ember.Controller.extend({\n    send: function() { eventHandlerWasCalled = true; }\n  }).create();\n\n  view = Ember.View.create({\n    controller: controller,\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"send\" }}>send</a>')\n  });\n\n  appendView();\n\n  view.$('a').trigger('click');\n\n  ok(eventHandlerWasCalled, \"The view's send method was called\");\n});\n\n\ntest(\"should send the view, event and current Handlebars context to the action\", function() {\n  var passedTarget;\n  var passedContext;\n\n  var aTarget = Ember.Controller.extend({\n    edit: function(context) {\n      passedTarget = this;\n      passedContext = context;\n    }\n  }).create();\n\n  var aContext = { aTarget: aTarget };\n\n  view = Ember.View.create({\n    aContext: aContext,\n    template: Ember.Handlebars.compile('{{#with view.aContext}}<a id=\"edit\" href=\"#\" {{action edit this target=\"aTarget\"}}>edit</a>{{/with}}')\n  });\n\n  appendView();\n\n  view.$('#edit').trigger('click');\n\n  strictEqual(passedTarget, aTarget, \"the action is called with the target as this\");\n  strictEqual(passedContext, aContext, \"the parameter is passed along\");\n});\n\ntest(\"should only trigger actions for the event they were registered on\", function() {\n  var editWasCalled = false;\n\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile('<a href=\"#\" {{action \"edit\"}}>edit</a>'),\n    edit: function() { editWasCalled = true; }\n  });\n\n  appendView();\n\n  view.$('a').trigger('mouseover');\n\n  ok(!editWasCalled, \"The action wasn't called\");\n});\n\ntest(\"should allow a context to be specified\", function() {\n  var passedContext,\n      model = Ember.Object.create();\n\n  var controller = Ember.Controller.extend({\n    edit: function(context) {\n      passedContext = context;\n    }\n  }).create();\n\n  view = Ember.View.create({\n    controller: controller,\n    people: Ember.A([model]),\n    template: Ember.Handlebars.compile('{{#each person in view.people}}<button {{action edit person}}>edit</button>{{/each}}')\n  });\n\n  appendView();\n\n  view.$('button').trigger('click');\n\n  equal(passedContext, model, \"the action was called with the passed context\");\n});\n\ntest(\"should unwrap controllers passed as a context\", function() {\n  var passedContext,\n      model = Ember.Object.create(),\n      controller = Ember.ObjectController.extend({\n        model: model,\n        edit: function(context) {\n          passedContext = context;\n        }\n      }).create();\n\n  view = Ember.View.create({\n    controller: controller,\n    template: Ember.Handlebars.compile('<button {{action \"edit\" this}}>edit</button>')\n  });\n\n  appendView();\n\n  view.$('button').trigger('click');\n\n  equal(passedContext, model, \"the action was passed the unwrapped model\");\n});\n\ntest(\"should allow multiple contexts to be specified\", function() {\n  var passedContexts,\n      models = [Ember.Object.create(), Ember.Object.create()];\n\n  var controller = Ember.Controller.extend({\n    edit: function() {\n      passedContexts = [].slice.call(arguments);\n    }\n  }).create();\n\n  view = Ember.View.create({\n    controller: controller,\n    modelA: models[0],\n    modelB: models[1],\n    template: Ember.Handlebars.compile('<button {{action edit view.modelA view.modelB}}>edit</button>')\n  });\n\n  appendView();\n\n  view.$('button').trigger('click');\n\n  deepEqual(passedContexts, models, \"the action was called with the passed contexts\");\n});\n\ntest(\"should allow multiple contexts to be specified\", function() {\n  var passedParams,\n      model = Ember.Object.create();\n\n  var controller = Ember.Controller.extend({\n    edit: function() {\n      passedParams = [].slice.call(arguments);\n    }\n  }).create();\n\n  view = Ember.View.create({\n    controller: controller,\n    modelA: model,\n    template: Ember.Handlebars.compile('<button {{action edit \"herp\" view.modelA}}>edit</button>')\n  });\n\n  appendView();\n\n  view.$('button').trigger('click');\n\n  deepEqual(passedParams, [\"herp\", model], \"the action was called with the passed contexts\");\n});\n\nvar namespace = {\n  \"Component\": {\n    toString: function() { return \"Component\"; },\n    find: function() { return { id: 1 }; }\n  }\n};\n\nvar compile = function(string) {\n  return Ember.Handlebars.compile(string);\n};\n\ntest(\"it does not trigger action with special clicks\", function() {\n  var showCalled = false;\n\n  view = Ember.View.create({\n    template: compile(\"<a {{action show href=true}}>Hi</a>\")\n  });\n\n  var controller = Ember.Controller.create({\n    target: {\n      urlForEvent: function(event, context) {\n        return \"/foo/bar\";\n      },\n\n      send: function(event, context) {\n        this[event](context);\n      },\n\n      show: function() {\n        showCalled = true;\n      }\n    }\n  });\n\n  Ember.run(function() {\n    view.set('controller', controller);\n    view.appendTo('#qunit-fixture');\n  });\n\n  function checkClick(prop, value, expected) {\n    var event = Ember.$.Event(\"click\");\n    event[prop] = value;\n    view.$('a').trigger(event);\n    if (expected) {\n      ok(showCalled, \"should call action with \"+prop+\":\"+value);\n      ok(event.isDefaultPrevented(), \"should prevent default\");\n    } else {\n      ok(!showCalled, \"should not call action with \"+prop+\":\"+value);\n      ok(!event.isDefaultPrevented(), \"should not prevent default\");\n    }\n  }\n\n  checkClick('ctrlKey', true, false);\n  checkClick('altKey', true, false);\n  checkClick('metaKey', true, false);\n  checkClick('shiftKey', true, false);\n  checkClick('which', 2, false);\n\n  checkClick('which', 1, true);\n  checkClick('which', undefined, true); // IE <9\n});\n\n\n\n})();\n//@ sourceURL=ember-routing/~tests/helpers/action_test");minispade.register('ember-routing/~tests/helpers/control_test', "(function() {/*global QUnit*/\n\nvar container, view;\nvar compile = Ember.Handlebars.compile;\n\nfunction destroy(object) {\n  Ember.run(function() {\n    object.destroy();\n  });\n}\n\nfunction appendView(attrs) {\n  view = Ember.View.create(attrs);\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n}\n\nfunction renderedText(expected, msg) {\n  var actual = view.$().text();\n  QUnit.push(actual === expected, actual, expected, msg);\n}\n\nif (Ember.ENV.EXPERIMENTAL_CONTROL_HELPER) {\n  module(\"Handlebars {{control}} helper\", {\n    setup: function() {\n      container = new Ember.Container();\n      container.options('template', { instantiate: false });\n      container.options('view', { singleton: false });\n      container.register('controller:parent', Ember.Controller.extend());\n      container.register('controller:widget', Ember.Controller.extend());\n      container.register('view:widget', Ember.View.extend());\n    },\n\n    teardown: function() {\n      destroy(view);\n      destroy(container);\n    }\n  });\n\n  test(\"A control raises an error when a view cannot be found\", function() {\n    container = new Ember.Container();\n    container.options('template', { instantiate: false });\n    container.options('view', { singleton: false });\n    container.register('controller:parent', Ember.Controller.extend());\n    container.register('controller:widget', Ember.Controller.extend());\n    container.register('template:widget', compile(\"Hello\"));\n\n    throws(function() {\n      appendView({\n        controller: container.lookup('controller:parent'),\n        template: compile(\"{{control widget}}\")\n      });\n    }, /find view/, \"Must raise an error if no view is defined\");\n  });\n\n  test(\"A control raises an error when a controller cannot be found\", function() {\n    container = new Ember.Container();\n    container.options('template', { instantiate: false });\n    container.options('view', { singleton: false });\n    container.register('controller:parent', Ember.Controller.extend());\n    container.register('view:widget', Ember.View.extend());\n    container.register('template:widget', compile(\"Hello\"));\n\n    throws(function() {\n      appendView({\n        controller: container.lookup('controller:parent'),\n        template: compile(\"{{control widget}}\")\n      });\n    }, /find controller/, \"Must raise an error when no controller is defined\");\n\n    // The assertion causes some views to be left behind\n    Ember.run(function() {\n      for (var viewId in Ember.View.views) {\n        Ember.View.views[viewId].destroy();\n      }\n    });\n  });\n\n  test(\"A control renders a template with a new instance of the named controller and view\", function() {\n    container.register('template:widget', compile(\"Hello\"));\n\n    appendView({\n      controller: container.lookup('controller:parent'),\n      template: compile(\"{{control widget}}\")\n    });\n\n    renderedText(\"Hello\");\n  });\n\n  test(\"A control's controller and view are lookuped up via template name\", function() {\n    container.register('template:widgets/foo', compile(\"Hello\"));\n    container.register('controller:widgets.foo', Ember.Controller.extend());\n    container.register('view:widgets.foo', Ember.View.extend());\n\n    appendView({\n      controller: container.lookup('controller:parent'),\n      template: compile(\"{{control 'widgets/foo'}}\")\n    });\n\n    renderedText(\"Hello\");\n  });\n\n  test(\"A control defaults to the default view\", function() {\n    container.register('template:widgets/foo', compile(\"Hello\"));\n    container.register('controller:widgets.foo', Ember.Controller.extend());\n    container.register('view:default', Ember.View.extend());\n\n    appendView({\n      controller: container.lookup('controller:parent'),\n      template: compile(\"{{control 'widgets/foo'}}\")\n    });\n\n    renderedText(\"Hello\");\n  });\n\n  test(\"A control with a default view survives re-render\", function() {\n    container.register('template:widgets/foo', compile(\"Hello\"));\n    container.register('controller:widgets.foo', Ember.Controller.extend());\n    container.register('view:default', Ember.View.extend());\n\n    appendView({\n      controller: container.lookup('controller:parent'),\n      template: compile(\"{{control 'widgets/foo'}}\")\n    });\n\n    renderedText(\"Hello\");\n\n    Ember.run(function() {\n      view.rerender();\n    });\n\n    renderedText(\"Hello\");\n  });\n\n  test(\"A control can specify a model to use in its template\", function() {\n    container.register('template:widget', compile(\"{{model.name}}\"));\n\n    var controller = container.lookup('controller:parent');\n    controller.set('person', { name: \"Tom Dale\" });\n\n    appendView({\n      controller: controller,\n      template: compile(\"{{control 'widget' person}}\")\n    });\n\n    renderedText(\"Tom Dale\");\n  });\n\n  test(\"A control can be used multiple times\", function() {\n    container.register('template:widget', compile(\"{{model.name}}\"));\n\n    var controller = container.lookup('controller:parent');\n    controller.set('person1', { name: \"Tom Dale\" });\n    controller.set('person2', { name: \"Peter Wagenet\" });\n\n    appendView({\n      controller: controller,\n      template: compile(\"{{control 'widget' person1}}{{control 'widget' person2}}\")\n    });\n\n    renderedText(\"Tom DalePeter Wagenet\");\n  });\n\n  test(\"A control's state is persisted if the view is destroyed and re-rendered\", function() {\n    container.register('template:widget', compile(\"{{randomValue}}{{model.name}}\"));\n\n    var controller = container.lookup('controller:parent');\n    controller.set('person1', { name: \"Tom Dale\" });\n    controller.set('person2', { name: \"Peter Wagenet\" });\n\n    container.register('controller:widget', Ember.Controller.extend({\n      randomValue: Ember.computed(function() {\n        return Math.random() + '' + (+new Date());\n      })\n    }));\n\n    var template = compile(\"{{control 'widget' person1}}{{control 'widget' person2}}\");\n\n    appendView({\n      controller: controller,\n      template: template\n    });\n\n    var text = view.$().text();\n    ok(text.match(/^.*Tom Dale.*Peter Wagenet.*$/), \"The view rendered\");\n\n    destroy(view);\n\n    appendView({\n      controller: controller,\n      template: template\n    });\n\n    equal(view.$().text(), text);\n  });\n\n  test(\"if a controller's model changes, its child controllers are destroyed\", function() {\n    container.register('template:widget', compile(\"{{randomValue}}{{model.name}}\"));\n\n    var controller = container.lookup('controller:parent');\n    controller.set('model', { name: \"Tom Dale\" });\n\n    container.register('controller:widget', Ember.Controller.extend({\n      randomValue: Ember.computed(function() {\n        return Math.random() + '' + (+new Date());\n      })\n    }));\n\n    appendView({\n      controller: controller,\n      template: compile(\"{{control 'widget' model}}\")\n    });\n\n    var childController = view.get('childViews').objectAt(0).get('controller');\n\n    ok(view.$().text().match(/^.*Tom Dale.*$/), \"The view rendered\");\n    deepEqual(childController.get('model'), { name: \"Tom Dale\" });\n\n    Ember.run(function() {\n      controller.set('model', { name: \"Yehuda Katz\" });\n    });\n\n    equal(childController.isDestroying, true);\n    ok(view.$().text().match(/^.*Yehuda Katz.*$/), \"The view rendered\");\n  });\n\n  test(\"A control should correctly remove model observers\", function() {\n    var Controller = Ember.Controller.extend({\n      message: 'bro'\n    });\n\n    container.register('template:widget', compile(\"{{content}}\"));\n    container.register('controller:bro', Controller);\n\n    appendView({\n      controller: container.lookup('controller:bro'),\n      template: compile(\"{{control widget message}}\")\n    });\n\n    renderedText(\"bro\");\n\n    Ember.run(function() {\n      view.destroy();\n    });\n\n    Ember.run(function() {\n      Ember.set(container.lookup('controller:bro'), 'message', 'grammer');\n    });\n  });\n}\n\n})();\n//@ sourceURL=ember-routing/~tests/helpers/control_test");minispade.register('ember-routing/~tests/helpers/outlet_test', "(function() {var appendView = function(view) {\n  Ember.run(function() { view.appendTo('#qunit-fixture'); });\n};\n\nvar compile = function(template) {\n  return Ember.Handlebars.compile(template);\n};\n\nvar view;\n\nmodule(\"Handlebars {{outlet}} helpers\", {\n  teardown: function() {\n    Ember.run(function () {\n      if (view) {\n        view.destroy();\n      }\n    });\n  }\n});\n\ntest(\"view should support connectOutlet for the main outlet\", function() {\n  var template = \"<h1>HI</h1>{{outlet}}\";\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile(template)\n  });\n\n  appendView(view);\n\n  equal(view.$().text(), 'HI');\n\n  Ember.run(function() {\n    view.connectOutlet('main', Ember.View.create({\n      template: compile(\"<p>BYE</p>\")\n    }));\n  });\n\n  // Replace whitespace for older IE\n  equal(view.$().text().replace(/\\s+/,''), 'HIBYE');\n});\n\ntest(\"outlet should support connectOutlet in slots in prerender state\", function() {\n  var template = \"<h1>HI</h1>{{outlet}}\";\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile(template)\n  });\n\n  view.connectOutlet('main', Ember.View.create({\n    template: compile(\"<p>BYE</p>\")\n  }));\n\n  appendView(view);\n\n  equal(view.$().text(), 'HIBYE');\n});\n\ntest(\"outlet should support an optional name\", function() {\n  var template = \"<h1>HI</h1>{{outlet mainView}}\";\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile(template)\n  });\n\n  appendView(view);\n\n  equal(view.$().text(), 'HI');\n\n  Ember.run(function() {\n    view.connectOutlet('mainView', Ember.View.create({\n      template: compile(\"<p>BYE</p>\")\n    }));\n  });\n\n  // Replace whitespace for older IE\n  equal(view.$().text().replace(/\\s+/,''), 'HIBYE');\n});\n\ntest(\"Outlets bind to the current view, not the current concrete view\", function() {\n  var parentTemplate = \"<h1>HI</h1>{{outlet}}\";\n  var middleTemplate = \"<h2>MIDDLE</h2>{{outlet}}\";\n  var bottomTemplate = \"<h3>BOTTOM</h3>\";\n\n  view = Ember.View.create({\n    template: compile(parentTemplate)\n  });\n\n  var middleView = Ember._MetamorphView.create({\n    template: compile(middleTemplate)\n  });\n\n  var bottomView = Ember._MetamorphView.create({\n    template: compile(bottomTemplate)\n  });\n\n  appendView(view);\n\n  Ember.run(function() {\n    view.connectOutlet('main', middleView);\n  });\n\n  Ember.run(function() {\n    middleView.connectOutlet('main', bottomView);\n  });\n\n  var output = Ember.$('#qunit-fixture h1 ~ h2 ~ h3').text();\n  equal(output, \"BOTTOM\", \"all templates were rendered\");\n});\n\ntest(\"view should support disconnectOutlet for the main outlet\", function() {\n  var template = \"<h1>HI</h1>{{outlet}}\";\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile(template)\n  });\n\n  appendView(view);\n\n  equal(view.$().text(), 'HI');\n\n  Ember.run(function() {\n    view.connectOutlet('main', Ember.View.create({\n      template: compile(\"<p>BYE</p>\")\n    }));\n  });\n\n  // Replace whitespace for older IE\n  equal(view.$().text().replace(/\\s+/,''), 'HIBYE');\n\n  Ember.run(function() {\n    view.disconnectOutlet('main');\n  });\n\n  // Replace whitespace for older IE\n  equal(view.$().text().replace(/\\s+/,''), 'HI');\n});\n\ntest(\"Outlets bind to the current template's view, not inner contexts\", function() {\n  var parentTemplate = \"<h1>HI</h1>{{#if view.alwaysTrue}}{{#with this}}{{outlet}}{{/with}}{{/if}}\";\n  var bottomTemplate = \"<h3>BOTTOM</h3>\";\n\n  view = Ember.View.create({\n    alwaysTrue: true,\n    template: compile(parentTemplate)\n  });\n\n  var bottomView = Ember._MetamorphView.create({\n    template: compile(bottomTemplate)\n  });\n\n  appendView(view);\n\n  Ember.run(function() {\n    view.connectOutlet('main', bottomView);\n  });\n\n  var output = Ember.$('#qunit-fixture h1 ~ h3').text();\n  equal(output, \"BOTTOM\", \"all templates were rendered\");\n});\n\n})();\n//@ sourceURL=ember-routing/~tests/helpers/outlet_test");minispade.register('ember-routing/~tests/helpers/render_test', "(function() {var appendView = function(view) {\n  Ember.run(function() { view.appendTo('#qunit-fixture'); });\n};\n\nvar set = function(object, key, value) {\n  Ember.run(function() { Ember.set(object, key, value); });\n};\n\nvar compile = function(template) {\n  return Ember.Handlebars.compile(template);\n};\n\nvar buildContainer = function(namespace) {\n  var container = new Ember.Container();\n\n  container.set = Ember.set;\n  container.resolver = resolverFor(namespace);\n  container.optionsForType('view', { singleton: false });\n  container.optionsForType('template', { instantiate: false });\n  container.register('application:main', namespace, { instantiate: false });\n  container.injection('router:main', 'namespace', 'application:main');\n\n  container.register('controller:basic', Ember.Controller, { instantiate: false });\n  container.register('controller:object', Ember.ObjectController, { instantiate: false });\n  container.register('controller:array', Ember.ArrayController, { instantiate: false });\n\n  container.typeInjection('route', 'router', 'router:main');\n\n  return container;\n};\n\nfunction resolverFor(namespace) {\n  return function(fullName) {\n    var nameParts = fullName.split(\":\"),\n        type = nameParts[0], name = nameParts[1];\n\n    if (type === 'template') {\n      var templateName = Ember.String.decamelize(name);\n      if (Ember.TEMPLATES[templateName]) {\n        return Ember.TEMPLATES[templateName];\n      }\n    }\n\n    var className = Ember.String.classify(name) + Ember.String.classify(type);\n    var factory = Ember.get(namespace, className);\n\n    if (factory) { return factory; }\n  };\n}\n\nvar view, container;\n\nmodule(\"Handlebars {{render}} helper\", {\n  setup: function() {\n    var namespace = Ember.Namespace.create();\n    container = buildContainer(namespace);\n    container.register('view:default', Ember.View.extend());\n    container.register('router:main', Ember.Router.extend());\n  },\n  teardown: function() {\n    Ember.run(function () {\n      if (container) {\n        container.destroy();\n      }\n      if (view) {\n        view.destroy();\n      }\n    });\n  }\n});\n\ntest(\"{{render}} helper should render given template\", function() {\n  var template = \"<h1>HI</h1>{{render home}}\";\n  var controller = Ember.Controller.extend({container: container});\n  view = Ember.View.create({\n    controller: controller.create(),\n    template: Ember.Handlebars.compile(template)\n  });\n\n  Ember.TEMPLATES['home'] = compile(\"<p>BYE</p>\");\n\n  appendView(view);\n\n  equal(view.$().text(), 'HIBYE');\n  ok(container.lookup('router:main')._lookupActiveView('home'), 'should register home as active view');\n});\n\ntest(\"{{render}} helper should render given template with a supplied model\", function() {\n  var template = \"<h1>HI</h1>{{render 'post' post}}\";\n  var post = {\n    title: \"Rails is omakase\"\n  };\n\n  var Controller = Ember.Controller.extend({\n    container: container,\n    post: post\n  });\n\n  var controller = Controller.create();\n\n  view = Ember.View.create({\n    controller: controller,\n    template: Ember.Handlebars.compile(template)\n  });\n\n  var PostController = Ember.ObjectController.extend();\n  container.register('controller:post', PostController);\n\n  Ember.TEMPLATES['post'] = compile(\"<p>{{title}}</p>\");\n\n  appendView(view);\n\n  var postController = view.get('_childViews')[0].get('controller');\n\n  equal(view.$().text(), 'HIRails is omakase');\n  equal(postController.get('model'), post);\n\n  set(controller, 'post', { title: \"Rails is unagi\" });\n\n  equal(view.$().text(), 'HIRails is unagi');\n  deepEqual(postController.get('model'), { title: \"Rails is unagi\" });\n});\n\ntest(\"{{render}} helper should render with given controller\", function() {\n  var template = '<h1>HI</h1>{{render home controller=\"posts\"}}';\n  var controller = Ember.Controller.extend({container: container});\n  container.register('controller:posts', Ember.ArrayController.extend());\n  view = Ember.View.create({\n    controller: controller.create(),\n    template: Ember.Handlebars.compile(template)\n  });\n\n  Ember.TEMPLATES['home'] = compile(\"<p>BYE</p>\");\n\n  appendView(view);\n\n  var renderedView = container.lookup('router:main')._lookupActiveView('home');\n  equal(container.lookup('controller:posts'), renderedView.get('controller'), 'rendered with correct controller');\n});\n\ntest(\"{{render}} helper should render a template without a model only once\", function() {\n  var template = \"<h1>HI</h1>{{render home}}<hr/>{{render home}}\";\n  var controller = Ember.Controller.extend({container: container});\n  view = Ember.View.create({\n    controller: controller.create(),\n    template: Ember.Handlebars.compile(template)\n  });\n\n  Ember.TEMPLATES['home'] = compile(\"<p>BYE</p>\");\n\n  raises(function() {\n    appendView(view);\n  }, 'should raise an exception');\n});\n\ntest(\"{{render}} helper should render templates with models multiple times\", function() {\n  var template = \"<h1>HI</h1> {{render 'post' post1}} {{render 'post' post2}}\";\n  var post1 = {\n    title: \"Me first\"\n  };\n  var post2 = {\n    title: \"Then me\"\n  };\n\n  var Controller = Ember.Controller.extend({\n    container: container,\n    post1: post1,\n    post2: post2\n  });\n\n  var controller = Controller.create();\n\n  view = Ember.View.create({\n    controller: controller,\n    template: Ember.Handlebars.compile(template)\n  });\n\n  var PostController = Ember.ObjectController.extend();\n  container.register('controller:post', PostController, {singleton: false});\n\n  Ember.TEMPLATES['post'] = compile(\"<p>{{title}}</p>\");\n\n  appendView(view);\n\n  var postController1 = view.get('_childViews')[0].get('controller');\n  var postController2 = view.get('_childViews')[1].get('controller');\n\n  equal(view.$().text(), 'HI Me first Then me');\n  equal(postController1.get('model'), post1);\n  equal(postController2.get('model'), post2);\n\n  set(controller, 'post1', { title: \"I am new\" });\n\n  equal(view.$().text(), 'HI I am new Then me');\n  deepEqual(postController1.get('model'), { title: \"I am new\" });\n});\n\ntest(\"{{render}} helper should render templates both with and without models\", function() {\n  var template = \"<h1>HI</h1> {{render 'post'}} {{render 'post' post}}\";\n  var post = {\n    title: \"Rails is omakase\"\n  };\n\n  var Controller = Ember.Controller.extend({\n    container: container,\n    post: post\n  });\n\n  var controller = Controller.create();\n\n  view = Ember.View.create({\n    controller: controller,\n    template: Ember.Handlebars.compile(template)\n  });\n\n  var PostController = Ember.ObjectController.extend();\n  container.register('controller:post', PostController, {singleton: false});\n\n  Ember.TEMPLATES['post'] = compile(\"<p>Title:{{title}}</p>\");\n\n  appendView(view);\n\n  var postController1 = view.get('_childViews')[0].get('controller');\n  var postController2 = view.get('_childViews')[1].get('controller');\n\n  equal(view.$().text(), 'HI Title: Title:Rails is omakase');\n  equal(postController1.get('model'), null);\n  equal(postController2.get('model'), post);\n\n  set(controller, 'post', { title: \"Rails is unagi\" });\n\n  equal(view.$().text(), 'HI Title: Title:Rails is unagi');\n  deepEqual(postController2.get('model'), { title: \"Rails is unagi\" });\n});\n\ntest(\"{{render}} helper should link child controllers to the parent controller\", function() {\n  var parentTriggered = 0;\n\n  var template = '<h1>HI</h1>{{render \"posts\"}}';\n  var controller = Ember.Controller.extend({\n    container: container,\n\n    parentPlease: function() {\n      parentTriggered++;\n    }\n  });\n\n  container.register('controller:posts', Ember.ArrayController.extend());\n\n  view = Ember.View.create({\n    controller: controller.create(),\n    template: Ember.Handlebars.compile(template)\n  });\n\n  Ember.TEMPLATES['posts'] = compile('<button id=\"parent-action\" {{action \"parentPlease\"}}>Go to Parent</button>');\n\n  appendView(view);\n\n  var actionId = Ember.$(\"#parent-action\").data('ember-action'),\n      action = Ember.Handlebars.ActionHelper.registeredActions[actionId],\n      handler = action.handler;\n\n  Ember.run(null, handler, new Ember.$.Event(\"click\"));\n\n  equal(parentTriggered, 1, \"The event bubbled to the parent\");\n});\n\ntest(\"{{render}} helper should be able to render a template again when it was removed\", function() {\n  var template = \"<h1>HI</h1>{{outlet}}\";\n  var controller = Ember.Controller.extend({container: container});\n  view = Ember.View.create({\n    template: Ember.Handlebars.compile(template)\n  });\n\n  Ember.TEMPLATES['home'] = compile(\"<p>BYE</p>\");\n\n  appendView(view);\n\n  Ember.run(function() {\n    view.connectOutlet('main', Ember.View.create({\n      controller: controller.create(),\n      template: compile(\"<p>1{{render home}}</p>\")\n    }));\n  });\n\n  equal(view.$().text(), 'HI1BYE');\n\n  Ember.run(function() {\n    view.connectOutlet('main', Ember.View.create({\n      controller: controller.create(),\n      template: compile(\"<p>2{{render home}}</p>\")\n    }));\n  });\n\n  equal(view.$().text(), 'HI2BYE');\n});\n\ntest(\"{{render}} works with dot notation\", function() {\n  var template = '<h1>BLOG</h1>{{render blog.post}}';\n\n  var controller = Ember.Controller.extend({container: container});\n  container.register('controller:blog.post', Ember.ObjectController.extend());\n\n  view = Ember.View.create({\n    controller: controller.create(),\n    template: Ember.Handlebars.compile(template)\n  });\n\n  Ember.TEMPLATES['blog/post'] = compile(\"<p>POST</p>\");\n\n  appendView(view);\n\n  var renderedView = container.lookup('router:main')._lookupActiveView('blog.post');\n  equal(renderedView.get('viewName'), 'blogPost', 'camelizes the view name');\n  equal(container.lookup('controller:blog.post'), renderedView.get('controller'), 'rendered with correct controller');\n});\n\ntest(\"{{render}} works with slash notation\", function() {\n  var template = '<h1>BLOG</h1>{{render \"blog/post\"}}';\n\n  var controller = Ember.Controller.extend({container: container});\n  container.register('controller:blog.post', Ember.ObjectController.extend());\n\n  view = Ember.View.create({\n    controller: controller.create(),\n    template: Ember.Handlebars.compile(template)\n  });\n\n  Ember.TEMPLATES['blog/post'] = compile(\"<p>POST</p>\");\n\n  appendView(view);\n\n  var renderedView = container.lookup('router:main')._lookupActiveView('blog.post');\n  equal(renderedView.get('viewName'), 'blogPost', 'camelizes the view name');\n  equal(container.lookup('controller:blog.post'), renderedView.get('controller'), 'rendered with correct controller');\n});\n\n})();\n//@ sourceURL=ember-routing/~tests/helpers/render_test");minispade.register('ember-routing/~tests/system/controller_for_test', "(function() {var buildContainer = function(namespace) {\n  var container = new Ember.Container();\n\n  container.set = Ember.set;\n  container.resolver = resolverFor(namespace);\n  container.optionsForType('view', { singleton: false });\n\n  container.register('application:main', namespace, { instantiate: false });\n\n  container.register('controller:basic', Ember.Controller, { instantiate: false });\n  container.register('controller:object', Ember.ObjectController, { instantiate: false });\n  container.register('controller:array', Ember.ArrayController, { instantiate: false });\n\n  return container;\n};\n\nfunction resolverFor(namespace) {\n  return function(fullName) {\n    var nameParts = fullName.split(\":\"),\n        type = nameParts[0], name = nameParts[1];\n\n    if (name === 'basic') {\n      name = '';\n    }\n    var className = Ember.String.classify(name) + Ember.String.classify(type);\n    var factory = Ember.get(namespace, className);\n\n\n\n    if (factory) { return factory; }\n  };\n}\n\nvar container, appController, namespace;\n\nmodule(\"Ember.controllerFor\", {\n  setup: function() {\n    namespace = Ember.Namespace.create();\n    container = buildContainer(namespace);\n    container.register('controller:app', Ember.Controller.extend());\n    appController = container.lookup('controller:app');\n  },\n  teardown: function() {\n    Ember.run(function () {\n      if (container) {\n        container.destroy();\n      }\n    });\n  }\n});\n\ntest(\"controllerFor should lookup for registered controllers\", function() {\n  var controller = Ember.controllerFor(container, 'app');\n\n  equal(appController, controller, 'should find app controller');\n});\n\ntest(\"controllerFor should create Ember.Controller\", function() {\n  var controller = Ember.controllerFor(container, 'home');\n\n  ok(controller instanceof Ember.Controller, 'should create controller');\n});\n\ntest(\"controllerFor should create Ember.ObjectController\", function() {\n  var context = {};\n  var controller = Ember.controllerFor(container, 'home', context);\n\n  ok(controller instanceof Ember.ObjectController, 'should create controller');\n  equal(controller.get('content'), context, 'should set content');\n});\n\ntest(\"controllerFor should create Ember.ArrayController\", function() {\n  var context = Ember.A();\n  var controller = Ember.controllerFor(container, 'home', context);\n\n  ok(controller instanceof Ember.ArrayController, 'should create controller');\n  equal(controller.get('content'), context, 'should set content');\n});\n\ntest(\"controllerFor should create App.Controller if provided\", function() {\n  var controller;\n  namespace.Controller = Ember.Controller.extend();\n\n  controller = Ember.controllerFor(container, 'home');\n\n  ok(controller instanceof namespace.Controller, 'should create controller');\n});\n\ntest(\"controllerFor should create App.ObjectController if provided\", function() {\n  var context = {}, controller;\n  namespace.ObjectController = Ember.ObjectController.extend();\n\n  controller = Ember.controllerFor(container, 'home', context);\n\n  ok(controller instanceof namespace.ObjectController, 'should create controller');\n  equal(controller.get('content'), context, 'should set content');\n\n});\n\ntest(\"controllerFor should create App.ArrayController if provided\", function() {\n  var context = Ember.A(), controller;\n  namespace.ArrayController = Ember.ArrayController.extend();\n\n  controller = Ember.controllerFor(container, 'home', context);\n\n  ok(controller instanceof namespace.ArrayController, 'should create controller');\n  equal(controller.get('content'), context, 'should set content');\n\n});\n\n})();\n//@ sourceURL=ember-routing/~tests/system/controller_for_test");minispade.register('ember-runtime/~tests/controllers/array_controller_test', "(function() {minispade.require('ember-runtime/~tests/suites/mutable_array');\n\nmodule(\"ember-runtime/controllers/array_controller_test\");\n\nEmber.MutableArrayTests.extend({\n\n  name: 'Ember.ArrayController',\n\n  newObject: function(ary) {\n    var ret = ary ? ary.slice() : this.newFixture(3);\n    return Ember.ArrayController.create({\n      content: Ember.A(ret)\n    });\n  },\n\n  mutate: function(obj) {\n    obj.pushObject(Ember.get(obj, 'length')+1);\n  },\n\n  toArray: function(obj) {\n    return obj.toArray ? obj.toArray() : obj.slice();\n  }\n}).run();\n\ntest(\"defaults it's `content` to an empty array\", function () {\n  var Controller = Ember.ArrayController.extend();\n  deepEqual(Controller.create().get(\"content\"), [], \"`ArrayController` defaults it's content to an empty array\");\n  equal(Controller.create().get('firstObject'), undefined, 'can fetch firstObject');\n  equal(Controller.create().get('lastObject'), undefined, 'can fetch lastObject');\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/controllers/array_controller_test");minispade.register('ember-runtime/~tests/controllers/item_controller_class_test', "(function() {var lannisters, arrayController, controllerClass, otherControllerClass, container, itemControllerCount,\n    tywin, jaime, cersei, tyrion,\n    get = Ember.get;\n\nmodule(\"Ember.ArrayController - itemController\", {\n  setup: function() {\n    container = new Ember.Container();\n\n    tywin = Ember.Object.create({ name: 'Tywin' });\n    jaime = Ember.Object.create({ name: 'Jaime' });\n    cersei = Ember.Object.create({ name: 'Cersei' });\n    tyrion = Ember.Object.create({ name: 'Tyrion' });\n    lannisters = Ember.A([ tywin, jaime, cersei ]);\n\n    itemControllerCount = 0;\n    controllerClass = Ember.ObjectController.extend({\n      init: function() {\n        ++itemControllerCount;\n        this._super();\n      },\n\n      toString: function() {\n        return \"itemController for \" + this.get('name');\n      }\n    });\n\n    otherControllerClass = Ember.ObjectController.extend({\n      toString: function() {\n        return \"otherItemController for \" + this.get('name');\n      }\n    });\n\n    container.register(\"controller:Item\", controllerClass);\n    container.register(\"controller:OtherItem\", otherControllerClass);\n  },\n  teardown: function() {\n    Ember.run(function() {\n      container.destroy();\n    });\n  }\n});\n\nfunction createUnwrappedArrayController() {\n  arrayController = Ember.ArrayController.create({\n    container: container,\n    content: lannisters\n  });\n}\n\nfunction createArrayController() {\n  arrayController = Ember.ArrayController.create({\n    container: container,\n    itemController: 'Item',\n    content: lannisters\n  });\n}\n\nfunction createDynamicArrayController() {\n  arrayController = Ember.ArrayController.create({\n    container: container,\n    lookupItemController: function(object) {\n      if (\"Tywin\" === object.get(\"name\")) {\n        return \"Item\";\n      } else {\n        return \"OtherItem\";\n      }\n    },\n    content: lannisters\n  });\n}\n\ntest(\"when no `itemController` is set, `objectAtContent` returns objects directly\", function() {\n  createUnwrappedArrayController();\n\n  strictEqual(arrayController.objectAtContent(1), jaime, \"No controller is returned when itemController is not set\");\n});\n\ntest(\"when `itemController` is set, `objectAtContent` returns an instance of the controller\", function() {\n  createArrayController();\n\n  var jaimeController = arrayController.objectAtContent(1);\n\n  ok(controllerClass.detectInstance(jaimeController), \"A controller is returned when itemController is set\");\n});\n\n\ntest(\"when `idx` is out of range, `objectAtContent` does not create a controller\", function() {\n  controllerClass.reopen({\n    init: function() {\n      ok(false, \"Controllers should not be created when `idx` is out of range\");\n    }\n  });\n\n  createArrayController();\n  strictEqual(arrayController.objectAtContent(50), undefined, \"no controllers are created for out of range indexes\");\n});\n\ntest(\"when the underlying object is null, a controller is still returned\", function() {\n  createArrayController();\n  arrayController.unshiftObject(null);\n  var firstController = arrayController.objectAtContent(0);\n  ok(controllerClass.detectInstance(firstController), \"A controller is still created for null objects\");\n});\n\ntest(\"the target of item controllers is the parent controller\", function() {\n  createArrayController();\n\n  var jaimeController = arrayController.objectAtContent(1);\n\n  equal(jaimeController.get('target'), arrayController, \"Item controllers' targets are their parent controller\");\n});\n\ntest(\"when the underlying object has not changed, `objectAtContent` always returns the same instance\", function() {\n  createArrayController();\n\n  strictEqual(arrayController.objectAtContent(1), arrayController.objectAtContent(1), \"Controller instances are reused\");\n});\n\ntest(\"when the index changes, `objectAtContent` still returns the same instance\", function() {\n  createArrayController();\n  var jaimeController = arrayController.objectAtContent(1);\n  arrayController.unshiftObject(tyrion);\n\n  strictEqual(arrayController.objectAtContent(2), jaimeController, \"Controller instances are reused\");\n});\n\ntest(\"when the underlying array changes, old subcontainers are destroyed\", function() {\n  createArrayController();\n  // cause some controllers to be instantiated\n  arrayController.objectAtContent(1);\n  arrayController.objectAtContent(2);\n\n  // Not a public API; just checking for cleanup\n  var subControllers = get(arrayController, '_subControllers'),\n      jaimeController = subControllers[1],\n      cerseiController = subControllers[2];\n\n  equal(!!jaimeController.isDestroying, false, \"precond - nobody is destroyed yet\");\n  equal(!!!!cerseiController.isDestroying, false, \"precond - nobody is destroyed yet\");\n\n  Ember.run(function() {\n    arrayController.set('content', Ember.A());\n  });\n\n  equal(!!jaimeController.isDestroying, true, \"old subcontainers are destroyed\");\n  equal(!!cerseiController.isDestroying, true, \"old subcontainers are destroyed\");\n});\n\n\ntest(\"item controllers are created lazily\", function() {\n  createArrayController();\n\n  equal(itemControllerCount, 0, \"precond - no item controllers yet\");\n\n  arrayController.objectAtContent(1);\n\n  equal(itemControllerCount, 1, \"item controllers are created lazily\");\n});\n\ntest(\"when items are removed from the arrayController, their respective subcontainers are destroyed\", function() {\n  createArrayController();\n  var jaimeController = arrayController.objectAtContent(1),\n      cerseiController = arrayController.objectAtContent(2),\n      subControllers = get(arrayController, '_subControllers');\n\n  equal(!!jaimeController.isDestroyed, false, \"precond - nobody is destroyed yet\");\n  equal(!!cerseiController.isDestroyed, false, \"precond - nobody is destroyed yet\");\n\n  Ember.run(function() {\n    arrayController.removeObject(cerseiController);\n  });\n\n  equal(!!cerseiController.isDestroying, true, \"Removed objects' containers are cleaned up\");\n  equal(!!jaimeController.isDestroying, false, \"Retained objects' containers are not cleaned up\");\n});\n\ntest(\"one cannot remove wrapped content directly when specifying `itemController`\", function() {\n  createArrayController();\n  var jaimeController = arrayController.objectAtContent(1),\n      cerseiController = arrayController.objectAtContent(2);\n\n  equal(arrayController.get('length'), 3, \"precondition - array is in initial state\");\n  arrayController.removeObject(cersei);\n\n  equal(arrayController.get('length'), 3, \"cannot remove wrapped objects directly\");\n\n  Ember.run(function() {\n    arrayController.removeObject(cerseiController);\n  });\n  equal(arrayController.get('length'), 2, \"can remove wrapper objects\");\n});\n\ntest(\"when items are removed from the underlying array, their respective subcontainers are destroyed\", function() {\n  createArrayController();\n  var jaimeController = arrayController.objectAtContent(1),\n      cerseiController = arrayController.objectAtContent(2),\n      subContainers = get(arrayController, 'subContainers');\n\n  equal(!!jaimeController.isDestroying, false, \"precond - nobody is destroyed yet\");\n  equal(!!cerseiController.isDestroying, false, \"precond - nobody is destroyed yet\");\n\n  Ember.run(function() {\n    lannisters.removeObject(cersei); // if only it were that easy\n  });\n\n  equal(!!jaimeController.isDestroyed, false, \"Retained objects' containers are not cleaned up\");\n  equal(!!cerseiController.isDestroyed, true, \"Removed objects' containers are cleaned up\");\n});\n\ntest(\"`itemController` can be dynamic by overwriting `lookupItemController`\", function() {\n  createDynamicArrayController();\n\n  var tywinController = arrayController.objectAtContent(0),\n      jaimeController = arrayController.objectAtContent(1);\n\n  ok(controllerClass.detectInstance(tywinController), \"lookupItemController can return different classes for different objects\");\n  ok(otherControllerClass.detectInstance(jaimeController), \"lookupItemController can return different classes for different objects\");\n});\n\ntest(\"when `idx` is out of range, `lookupItemController` is not called\", function() {\n  arrayController = Ember.ArrayController.create({\n    container: container,\n    lookupItemController: function(object) {\n      ok(false, \"`lookupItemController` should not be called when `idx` is out of range\");\n    },\n    content: lannisters\n  });\n\n  strictEqual(arrayController.objectAtContent(50), undefined, \"no controllers are created for indexes that are superior to the length\");\n  strictEqual(arrayController.objectAtContent(-1), undefined, \"no controllers are created for indexes less than zero\");\n});\n\ntest(\"if `lookupItemController` returns a string, it must be resolvable by the container\", function() {\n  arrayController = Ember.ArrayController.create({\n    container: container,\n    lookupItemController: function(object) {\n      return \"NonExistant\";\n    },\n    content: lannisters\n  });\n\n  throws(function() {\n      arrayController.objectAtContent(1);\n    },\n    /NonExistant/,\n    \"`lookupItemController` must return either null or a valid controller name\");\n});\n\ntest(\"array observers can invoke `objectAt` without overwriting existing item controllers\", function() {\n  createArrayController();\n\n  var tywinController = arrayController.objectAtContent(0),\n      arrayObserverCalled = false;\n\n  arrayController.reopen({\n    lannistersWillChange: Ember.K,\n    lannistersDidChange: function(_, idx, removedAmt, addedAmt) {\n      arrayObserverCalled = true;\n      equal(this.objectAt(idx).get('name'), \"Tyrion\", \"Array observers get the right object via `objectAt`\");\n    }\n  });\n  arrayController.addArrayObserver(arrayController, {\n    willChange: 'lannistersWillChange',\n    didChange: 'lannistersDidChange'\n  });\n\n  Ember.run(function() {\n    lannisters.unshiftObject(tyrion);\n  });\n\n  equal(arrayObserverCalled, true, \"Array observers are called normally\");\n  equal(tywinController.get('name'), \"Tywin\", \"Array observers calling `objectAt` does not overwrite existing controllers' content\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/controllers/item_controller_class_test");minispade.register('ember-runtime/~tests/controllers/object_controller_tests', "(function() {module(\"Ember.ObjectController\");\n\n\ntest(\"should be able to set the target property of an ObjectController\", function() {\n  var controller = Ember.ObjectController.create();\n  var target = {};\n\n  controller.set('target', target);\n  equal(controller.get('target'), target, \"able to set the target property\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/controllers/object_controller_tests");minispade.register('ember-runtime/~tests/core/compare_test', "(function() {/*globals module ok equals same test MyApp */\n\n// test parsing of query string\nvar v = [];\nmodule(\"Ember.compare()\", {\n  setup: function() {\n    // setup dummy data\n    v[0]  = null;\n    v[1]  = false;\n    v[2]  = true;\n    v[3]  = -12;\n    v[4]  = 3.5;\n    v[5]  = 'a string';\n    v[6]  = 'another string';\n    v[7]  = 'last string';\n    v[8]  = [1,2];\n    v[9]  = [1,2,3];\n    v[10] = [1,3];\n    v[11] = {a: 'hash'};\n    v[12] = Ember.Object.create();\n    v[13] = function (a) {return a;};\n    v[14] = new Date('2012/01/01');\n    v[15] = new Date('2012/06/06');\n  }\n});\n\n\n// ..........................................................\n// TESTS\n//\n\ntest(\"ordering should work\", function() {\n  for (var j=0; j < v.length; j++) {\n    equal(Ember.compare(v[j],v[j]), 0, j +' should equal itself');\n    for (var i=j+1; i < v.length; i++) {\n      equal(Ember.compare(v[j],v[i]), -1, 'v[' + j + '] (' + Ember.typeOf(v[j]) + ') should be smaller than v[' + i + '] (' + Ember.typeOf(v[i]) + ')' );\n    }\n\n  }\n});\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/core/compare_test");minispade.register('ember-runtime/~tests/core/copy_test', "(function() {module(\"Ember Copy Method\");\n\ntest(\"Ember.copy null\", function() {\n  var obj = {field: null};\n  equal(Ember.copy(obj, true).field, null, \"null should still be null\");\n});\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/core/copy_test");minispade.register('ember-runtime/~tests/core/error_test', "(function() {module(\"Ember Error Throwing\");\n\ntest(\"new Ember.Error displays provided message\", function() {\n  raises( function(){\n    throw new Ember.Error('A Message');\n  }, function(e){\n    return e.message === 'A Message';\n  }, 'the assigned message was displayed' );\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/core/error_test");minispade.register('ember-runtime/~tests/core/inspect_test', "(function() {module(\"Ember.inspect\");\n\nvar inspect = Ember.inspect;\n\ntest(\"strings\", function() {\n  equal(inspect(\"foo\"), \"foo\");\n});\n\ntest(\"numbers\", function() {\n  equal(inspect(2.6), \"2.6\");\n});\n\ntest(\"null\", function() {\n  equal(inspect(null), \"null\");\n});\n\ntest(\"undefined\", function() {\n  equal(inspect(undefined), \"undefined\");\n});\n\ntest(\"true\", function() {\n  equal(inspect(true), \"true\");\n});\n\ntest(\"false\", function() {\n  equal(inspect(false), \"false\");\n});\n\ntest(\"object\", function() {\n  equal(inspect({}), \"{}\");\n  equal(inspect({ foo: 'bar' }), \"{foo: bar}\");\n  equal(inspect({ foo: Ember.K }), \"{foo: function() { ... }}\");\n});\n\ntest(\"array\", function() {\n  // this could be better, but let's not let this method get\n  // out of control unless we want to go all the way, a la\n  // JSDump\n  equal(inspect([1,2,3]), \"{0: 1, 1: 2, 2: 3}\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/core/inspect_test");minispade.register('ember-runtime/~tests/core/isEqual_test', "(function() {// ========================================================================\n// Ember.isEqual Tests\n// ========================================================================\n/*globals module test */\n\nmodule(\"isEqual\");\n\ntest(\"undefined and null\", function() {\n  ok(  Ember.isEqual(undefined, undefined), \"undefined is equal to undefined\" );\n  ok( !Ember.isEqual(undefined, null),      \"undefined is not equal to null\" );\n  ok(  Ember.isEqual(null, null),           \"null is equal to null\" );\n  ok( !Ember.isEqual(null, undefined),      \"null is not equal to undefined\" );\n});\n\ntest(\"strings should be equal\",function(){\n\tok( !Ember.isEqual(\"Hello\", \"Hi\"),    \"different Strings are unequal\" );\n\tok(  Ember.isEqual(\"Hello\", \"Hello\"), \"same Strings are equal\" );\n});\n\ntest(\"numericals should be equal\",function(){\n  ok(  Ember.isEqual(24, 24), \"same numbers are equal\" );\n\tok( !Ember.isEqual(24, 21), \"different numbers are inequal\" );\n});\n\ntest(\"array should be equal\",function(){\n\t// NOTE: We don't test for array contents -- that would be too expensive.\n\tok( !Ember.isEqual( [1,2], [1,2] ), 'two array instances with the same values should not be equal' );\n\tok( !Ember.isEqual( [1,2], [1] ),   'two array instances with different values should not be equal' );\n});\n\ntest(\"first object implements isEqual should use it\", function() {\n  ok(Ember.isEqual({ isEqual: function() { return true; } }, null), 'should return true always');\n\n  var obj = { isEqual: function() { return false; } };\n  equal(Ember.isEqual(obj, obj), false, 'should return false because isEqual returns false');\n});\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/core/isEqual_test");minispade.register('ember-runtime/~tests/core/is_array_test', "(function() {module(\"Ember Type Checking\");\n\ntest(\"Ember.isArray\" ,function(){\n  var arrayProxy = Ember.ArrayProxy.create({ content: Ember.A([]) });\n\n  equal(Ember.isArray(arrayProxy), true, \"[]\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/core/is_array_test");minispade.register('ember-runtime/~tests/core/is_empty_test', "(function() {module(\"Ember.isEmpty\");\n\ntest(\"Ember.isEmpty\", function() {\n  var arrayProxy = Ember.ArrayProxy.create({ content: Ember.A([]) });\n\n  equal(true,  Ember.isEmpty(arrayProxy), \"for an ArrayProxy that has empty content\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/core/is_empty_test");minispade.register('ember-runtime/~tests/core/keys_test', "(function() {// ========================================================================\n// Ember.keys Tests\n// ========================================================================\n/*globals module test */\n\nmodule(\"Fetch Keys \");\n\ntest(\"should get a key array for a specified object \",function(){\n\tvar object1 = {};\n\n\tobject1.names = \"Rahul\";\n\tobject1.age = \"23\";\n\tobject1.place = \"Mangalore\";\n\n\tvar object2 = [];\n\tobject2 = Ember.keys(object1);\n\tdeepEqual(object2,['names','age','place']);\n});\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/core/keys_test");minispade.register('ember-runtime/~tests/core/type_test', "(function() {module(\"Ember Type Checking\");\n\ntest(\"Ember.typeOf\", function() {\n\tvar a = null,\n      arr = [1,2,3],\n      obj = {},\n      object = Ember.Object.create({ method: function() {} });\n\n  equal(Ember.typeOf(undefined),     'undefined', \"item of type undefined\");\n  equal(Ember.typeOf(a),             'null',      \"item of type null\");\n\tequal(Ember.typeOf(arr),           'array',     \"item of type array\");\n\tequal(Ember.typeOf(obj),           'object',    \"item of type object\");\n\tequal(Ember.typeOf(object),        'instance',  \"item of type instance\");\n\tequal(Ember.typeOf(object.method), 'function',  \"item of type function\") ;\n\tequal(Ember.typeOf(Ember.Object),     'class',     \"item of type class\");\n  equal(Ember.typeOf(new Error()),   'error',     \"item of type error\");\n});\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/core/type_test");minispade.register('ember-runtime/~tests/ext/function_test', "(function() {/*globals testBoth */\nminispade.require('ember-runtime/~tests/props_helper');\n\nmodule('Function.prototype.observes() helper');\n\ntestBoth('global observer helper takes multiple params', function(get, set) {\n\n  if (Ember.EXTEND_PROTOTYPES === false) {\n    ok('Function.prototype helper disabled');\n    return ;\n  }\n\n  var MyMixin = Ember.Mixin.create({\n\n    count: 0,\n\n    foo: function() {\n      set(this, 'count', get(this, 'count')+1);\n    }.observes('bar', 'baz')\n\n  });\n\n  var obj = Ember.mixin({}, MyMixin);\n  equal(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj, 'bar', \"BAZ\");\n  set(obj, 'baz', \"BAZ\");\n  equal(get(obj, 'count'), 2, 'should invoke observer after change');\n});\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/ext/function_test");minispade.register('ember-runtime/~tests/ext/mixin_test', "(function() {module('system/mixin/binding_test');\n\ntest('Defining a property ending in Binding should setup binding when applied', function() {\n\n  var MyMixin = Ember.Mixin.create({\n    fooBinding: 'bar.baz'\n  });\n\n  var obj = { bar: { baz: 'BIFF' } };\n\n  Ember.run(function(){\n    MyMixin.apply(obj);\n  });\n\n  ok(Ember.get(obj, 'fooBinding') instanceof Ember.Binding, 'should be a binding object');\n  equal(Ember.get(obj, 'foo'), 'BIFF', 'binding should be created and synced');\n\n});\n\ntest('Defining a property ending in Binding should apply to prototype children', function() {\n  var MyMixin, obj, obj2;\n\n  Ember.run(function(){\n    MyMixin = Ember.Mixin.create({\n      fooBinding: 'bar.baz'\n    });\n  });\n\n  obj = { bar: { baz: 'BIFF' } };\n\n  Ember.run(function(){\n    MyMixin.apply(obj);\n  });\n\n\n  obj2 = Ember.create(obj);\n  Ember.run(function(){\n    Ember.set(Ember.get(obj2, 'bar'), 'baz', 'BARG');\n  });\n\n\n  ok(Ember.get(obj2, 'fooBinding') instanceof Ember.Binding, 'should be a binding object');\n  equal(Ember.get(obj2, 'foo'), 'BARG', 'binding should be created and synced');\n\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/ext/mixin_test");minispade.register('ember-runtime/~tests/legacy_1x/mixins/observable/chained_test', "(function() {/*\n  NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n  are the same except for places where we intend to break the API we instead\n  validate that we warn the developer appropriately.\n\n  CHANGES FROM 1.6:\n\n  * changed obj.set() and obj.get() to Ember.set() and Ember.get()\n  * changed obj.addObserver() to Ember.addObserver()\n*/\n\nvar get = Ember.get, set = Ember.set;\n\nmodule(\"Ember.Observable - Observing with @each\");\n\ntest(\"chained observers on enumerable properties are triggered when the observed property of any item changes\", function() {\n  var family = Ember.Object.create({ momma: null });\n  var momma = Ember.Object.create({ children: [] });\n\n  var child1 = Ember.Object.create({ name: \"Bartholomew\" });\n  var child2 = Ember.Object.create({ name: \"Agnes\" });\n  var child3 = Ember.Object.create({ name: \"Dan\" });\n  var child4 = Ember.Object.create({ name: \"Nancy\" });\n\n  set(family, 'momma', momma);\n  set(momma, 'children', Ember.A([child1, child2, child3]));\n\n  var observerFiredCount = 0;\n  Ember.addObserver(family, 'momma.children.@each.name', this, function() {\n    observerFiredCount++;\n  });\n\n  observerFiredCount = 0;\n  Ember.run(function() { get(momma, 'children').setEach('name', 'Juan'); });\n  equal(observerFiredCount, 3, \"observer fired after changing child names\");\n\n  observerFiredCount = 0;\n  Ember.run(function() { get(momma, 'children').pushObject(child4); });\n  equal(observerFiredCount, 1, \"observer fired after adding a new item\");\n\n  observerFiredCount = 0;\n  Ember.run(function() { set(child4, 'name', \"Herbert\"); });\n  equal(observerFiredCount, 1, \"observer fired after changing property on new object\");\n\n  set(momma, 'children', []);\n\n  observerFiredCount = 0;\n  Ember.run(function() { set(child1, 'name', \"Hanna\"); });\n  equal(observerFiredCount, 0, \"observer did not fire after removing changing property on a removed object\");\n});\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/legacy_1x/mixins/observable/chained_test");minispade.register('ember-runtime/~tests/legacy_1x/mixins/observable/observable_test', "(function() {/*global Namespace:true DepObj:true*/\n\nvar get = Ember.get, set = Ember.set;\nvar forEach = Ember.EnumerableUtils.forEach;\n\n/*\n  NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n  are the same except for places where we intend to break the API we instead\n  validate that we warn the developer appropriately.\n\n  CHANGES FROM 1.6:\n\n  * Added ObservableObject which applies the Ember.Observable mixin.\n  * Changed reference to Ember.T_FUNCTION to 'function'\n  * Changed all references to sc_super to this._super()\n  * Changed Ember.objectForPropertyPath() to Ember.getPath()\n  * Removed allPropertiesDidChange test - no longer supported\n  * Changed test that uses 'ObjectE' as path to 'objectE' to reflect new\n    rule on using capital letters for property paths.\n  * Removed test passing context to addObserver.  context param is no longer\n    supported.\n  * Changed calls to Ember.Binding.flushPendingChanges() -> Ember.run.sync()\n  * removed test in observer around line 862 that expected key/value to be\n    the last item in the chained path.  Should be root and chained path\n\n*/\n\n// ========================================================================\n// Ember.Observable Tests\n// ========================================================================\n\nvar object, ObjectC, ObjectD, objectA, objectB ;\n\nvar ObservableObject = Ember.Object.extend(Ember.Observable);\nvar originalLookup = Ember.lookup, lookup;\n\n// ..........................................................\n// GET()\n//\n\nmodule(\"object.get()\", {\n\n  setup: function() {\n    object = ObservableObject.createWithMixins(Ember.Observable, {\n\n      normal: 'value',\n      numberVal: 24,\n      toggleVal: true,\n\n      computed: Ember.computed(function() { return 'value'; }).volatile(),\n\n      method: function() { return \"value\"; },\n\n      nullProperty: null,\n\n      unknownProperty: function(key, value) {\n        this.lastUnknownProperty = key ;\n        return \"unknown\" ;\n      }\n\n    });\n  }\n\n});\n\ntest(\"should get normal properties\", function() {\n  equal(object.get('normal'), 'value') ;\n});\n\ntest(\"should call computed properties and return their result\", function() {\n  equal(object.get(\"computed\"), \"value\") ;\n});\n\ntest(\"should return the function for a non-computed property\", function() {\n  var value = object.get(\"method\") ;\n  equal(Ember.typeOf(value), 'function') ;\n});\n\ntest(\"should return null when property value is null\", function() {\n  equal(object.get(\"nullProperty\"), null) ;\n});\n\ntest(\"should call unknownProperty when value is undefined\", function() {\n  equal(object.get(\"unknown\"), \"unknown\") ;\n  equal(object.lastUnknownProperty, \"unknown\") ;\n});\n\n// ..........................................................\n// Ember.GET()\n//\nmodule(\"Ember.get()\", {\n  setup: function() {\n    objectA = ObservableObject.createWithMixins({\n\n      normal: 'value',\n      numberVal: 24,\n      toggleVal: true,\n\n      computed: Ember.computed(function() { return 'value'; }).volatile(),\n\n      method: function() { return \"value\"; },\n\n      nullProperty: null,\n\n      unknownProperty: function(key, value) {\n        this.lastUnknownProperty = key ;\n        return \"unknown\" ;\n      }\n\n    });\n\n    objectB = {\n      normal: 'value',\n\n      nullProperty: null\n    };\n  }\n});\n\ntest(\"should get normal properties on Ember.Observable\", function() {\n  equal(Ember.get(objectA, 'normal'), 'value') ;\n});\n\ntest(\"should call computed properties on Ember.Observable and return their result\", function() {\n  equal(Ember.get(objectA, \"computed\"), \"value\") ;\n});\n\ntest(\"should return the function for a non-computed property on Ember.Observable\", function() {\n  var value = Ember.get(objectA, \"method\") ;\n  equal(Ember.typeOf(value), 'function') ;\n});\n\ntest(\"should return null when property value is null on Ember.Observable\", function() {\n  equal(Ember.get(objectA, \"nullProperty\"), null) ;\n});\n\ntest(\"should call unknownProperty when value is undefined on Ember.Observable\", function() {\n  equal(Ember.get(object, \"unknown\"), \"unknown\") ;\n  equal(object.lastUnknownProperty, \"unknown\") ;\n});\n\ntest(\"should get normal properties on standard objects\", function() {\n  equal(Ember.get(objectB, 'normal'), 'value');\n});\n\ntest(\"should return null when property is null on standard objects\", function() {\n  equal(Ember.get(objectB, 'nullProperty'), null);\n});\n\n/*\ntest(\"raise if the provided object is null\", function() {\n  raises(function() {\n    Ember.get(null, 'key');\n  });\n});\n*/\n\ntest(\"raise if the provided object is undefined\", function() {\n  raises(function() {\n    Ember.get(undefined, 'key');\n  });\n});\n\ntest(\"should work when object is Ember (used in Ember.get)\", function() {\n  equal(Ember.get('Ember.RunLoop'), Ember.RunLoop, 'Ember.get');\n  equal(Ember.get(Ember, 'RunLoop'), Ember.RunLoop, 'Ember.get(Ember, RunLoop)');\n});\n\nmodule(\"Ember.get() with paths\", {\n  setup: function() {\n    lookup = Ember.lookup = {};\n  },\n\n  teardown: function() {\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest(\"should return a property at a given path relative to the lookup\", function() {\n  lookup.Foo = ObservableObject.create({\n    Bar: ObservableObject.createWithMixins({\n      Baz: Ember.computed(function() { return \"blargh\"; }).volatile()\n    })\n  });\n\n  equal(Ember.get('Foo.Bar.Baz'), \"blargh\");\n});\n\ntest(\"should return a property at a given path relative to the passed object\", function() {\n  var foo = ObservableObject.create({\n    bar: ObservableObject.createWithMixins({\n      baz: Ember.computed(function() { return \"blargh\"; }).volatile()\n    })\n  });\n\n  equal(Ember.get(foo, 'bar.baz'), \"blargh\");\n});\n\ntest(\"should return a property at a given path relative to the lookup - JavaScript hash\", function() {\n  lookup.Foo = {\n    Bar: {\n      Baz: \"blargh\"\n    }\n  };\n\n  equal(Ember.get('Foo.Bar.Baz'), \"blargh\");\n});\n\ntest(\"should return a property at a given path relative to the passed object - JavaScript hash\", function() {\n  var foo = {\n    bar: {\n      baz: \"blargh\"\n    }\n  };\n\n  equal(Ember.get(foo, 'bar.baz'), \"blargh\");\n});\n\n// ..........................................................\n// SET()\n//\n\nmodule(\"object.set()\", {\n\n  setup: function() {\n    object = ObservableObject.createWithMixins({\n\n      // normal property\n      normal: 'value',\n\n      // computed property\n      _computed: \"computed\",\n      computed: Ember.computed(function(key, value) {\n        if (value !== undefined) {\n          this._computed = value ;\n        }\n        return this._computed ;\n      }).volatile(),\n\n      // method, but not a property\n      _method: \"method\",\n      method: function(key, value) {\n        if (value !== undefined) {\n          this._method = value ;\n        }\n        return this._method ;\n      },\n\n      // null property\n      nullProperty: null,\n\n      // unknown property\n      _unknown: 'unknown',\n      unknownProperty: function(key) {\n        return this._unknown ;\n      },\n\n      setUnknownProperty: function(key, value) {\n        this._unknown = value ;\n        return this._unknown ;\n      }\n    });\n  }\n\n});\n\ntest(\"should change normal properties and return this\", function() {\n  var ret = object.set(\"normal\", \"changed\") ;\n  equal(object.normal, \"changed\") ;\n  equal(ret, object) ;\n});\n\ntest(\"should call computed properties passing value and return this\", function() {\n  var ret = object.set(\"computed\", \"changed\") ;\n  equal(object._computed, \"changed\") ;\n\n  // DISABLED: this is no longer true with accessors\n  //equal(Ember.typeOf(object.computed), 'function') ;\n\n  equal(ret, object) ;\n});\n\ntest(\"should change normal properties when passing undefined\", function() {\n  var ret = object.set('normal', undefined);\n  equal(object.normal, undefined);\n  equal(ret, object);\n});\n\ntest(\"should replace the function for a non-computed property and return this\", function() {\n  var ret = object.set(\"method\", \"changed\") ;\n  equal(object._method, \"method\") ; // make sure this was NOT run\n  ok(Ember.typeOf(object.method) !== 'function') ;\n  equal(ret, object) ;\n});\n\ntest(\"should replace prover when property value is null\", function() {\n  var ret = object.set(\"nullProperty\", \"changed\") ;\n  equal(object.nullProperty, \"changed\") ;\n  equal(ret, object) ;\n});\n\ntest(\"should call unknownProperty with value when property is undefined\", function() {\n  var ret = object.set(\"unknown\", \"changed\") ;\n  equal(object._unknown, \"changed\") ;\n  equal(ret, object) ;\n});\n\n// ..........................................................\n// COMPUTED PROPERTIES\n//\n\nmodule(\"Computed properties\", {\n  setup: function() {\n    lookup = Ember.lookup = {};\n\n    object = ObservableObject.createWithMixins({\n\n      // REGULAR\n\n      computedCalls: [],\n      computed: Ember.computed(function(key, value) {\n        this.computedCalls.push(value);\n        return 'computed';\n      }).volatile(),\n\n      computedCachedCalls: [],\n      computedCached: Ember.computed(function(key, value) {\n        this.computedCachedCalls.push(value);\n        return 'computedCached';\n      }),\n\n\n      // DEPENDENT KEYS\n\n      changer: 'foo',\n\n      dependentCalls: [],\n      dependent: Ember.computed(function(key, value) {\n        this.dependentCalls.push(value);\n        return 'dependent';\n      }).property('changer').volatile(),\n\n      dependentFrontCalls: [],\n      dependentFront: Ember.computed('changer', function(key, value) {\n        this.dependentFrontCalls.push(value);\n        return 'dependentFront';\n      }).volatile(),\n\n      dependentCachedCalls: [],\n      dependentCached: Ember.computed(function(key, value) {\n        this.dependentCachedCalls.push(value);\n        return 'dependentCached';\n      }).property('changer'),\n\n      // everytime it is recomputed, increments call\n      incCallCount: 0,\n      inc: Ember.computed(function() {\n        return this.incCallCount++;\n      }).property('changer'),\n\n      // depends on cached property which depends on another property...\n      nestedIncCallCount: 0,\n      nestedInc: Ember.computed(function(key, value) {\n        return this.nestedIncCallCount++;\n      }).property('inc'),\n\n      // two computed properties that depend on a third property\n      state: 'on',\n      isOn: Ember.computed(function(key, value) {\n        if (value !== undefined) this.set('state', 'on');\n        return this.get('state') === 'on';\n      }).property('state').volatile(),\n\n      isOff: Ember.computed(function(key, value) {\n        if (value !== undefined) this.set('state', 'off');\n        return this.get('state') === 'off';\n      }).property('state').volatile()\n\n    }) ;\n  },\n  teardown: function() {\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest(\"getting values should call function return value\", function() {\n\n  // get each property twice. Verify return.\n  var keys = Ember.String.w('computed computedCached dependent dependentFront dependentCached');\n\n  forEach(keys, function(key) {\n    equal(object.get(key), key, Ember.String.fmt('Try #1: object.get(%@) should run function', [key]));\n    equal(object.get(key), key, Ember.String.fmt('Try #2: object.get(%@) should run function', [key]));\n  });\n\n  // verify each call count.  cached should only be called once\n  forEach(Ember.String.w('computedCalls dependentFrontCalls dependentCalls'), function(key) {\n    equal(object[key].length, 2, Ember.String.fmt('non-cached property %@ should be called 2x', [key]));\n  });\n\n  forEach(Ember.String.w('computedCachedCalls dependentCachedCalls'), function(key) {\n    equal(object[key].length, 1, Ember.String.fmt('non-cached property %@ should be called 1x', [key]));\n  });\n\n});\n\ntest(\"setting values should call function return value\", function() {\n\n  // get each property twice. Verify return.\n  var keys = Ember.String.w('computed dependent dependentFront computedCached dependentCached');\n  var values = Ember.String.w('value1 value2');\n\n  forEach(keys, function(key) {\n\n    equal(object.set(key, values[0]), object, Ember.String.fmt('Try #1: object.set(%@, %@) should run function', [key, values[0]]));\n\n    equal(object.set(key, values[1]), object, Ember.String.fmt('Try #2: object.set(%@, %@) should run function', [key, values[1]]));\n\n    equal(object.set(key, values[1]), object, Ember.String.fmt('Try #3: object.set(%@, %@) should not run function since it is setting same value as before', [key, values[1]]));\n\n  });\n\n\n  // verify each call count.  cached should only be called once\n  forEach(keys, function(key) {\n    var calls = object[key + 'Calls'], idx;\n    var expectedLength;\n\n    // Cached properties first check their cached value before setting the\n    // property. Other properties blindly call set.\n    expectedLength = 3;\n    equal(calls.length, expectedLength, Ember.String.fmt('set(%@) should be called the right amount of times', [key]));\n    for(idx=0;idx<2;idx++) {\n      equal(calls[idx], values[idx], Ember.String.fmt('call #%@ to set(%@) should have passed value %@', [idx+1, key, values[idx]]));\n    }\n  });\n\n});\n\ntest(\"notify change should clear cache\", function() {\n\n  // call get several times to collect call count\n  object.get('computedCached'); // should run func\n  object.get('computedCached'); // should not run func\n\n  object.propertyWillChange('computedCached')\n    .propertyDidChange('computedCached');\n\n  object.get('computedCached'); // should run again\n  equal(object.computedCachedCalls.length, 2, 'should have invoked method 2x');\n});\n\ntest(\"change dependent should clear cache\", function() {\n\n  // call get several times to collect call count\n  var ret1 = object.get('inc'); // should run func\n  equal(object.get('inc'), ret1, 'multiple calls should not run cached prop');\n\n  object.set('changer', 'bar');\n\n  equal(object.get('inc'), ret1+1, 'should increment after dependent key changes'); // should run again\n});\n\ntest(\"just notifying change of dependent should clear cache\", function() {\n\n  // call get several times to collect call count\n  var ret1 = object.get('inc'); // should run func\n  equal(object.get('inc'), ret1, 'multiple calls should not run cached prop');\n\n  object.notifyPropertyChange('changer');\n\n  equal(object.get('inc'), ret1+1, 'should increment after dependent key changes'); // should run again\n});\n\ntest(\"changing dependent should clear nested cache\", function() {\n\n  // call get several times to collect call count\n  var ret1 = object.get('nestedInc'); // should run func\n  equal(object.get('nestedInc'), ret1, 'multiple calls should not run cached prop');\n\n  object.set('changer', 'bar');\n\n  equal(object.get('nestedInc'), ret1+1, 'should increment after dependent key changes'); // should run again\n\n});\n\ntest(\"just notifying change of dependent should clear nested cache\", function() {\n\n  // call get several times to collect call count\n  var ret1 = object.get('nestedInc'); // should run func\n  equal(object.get('nestedInc'), ret1, 'multiple calls should not run cached prop');\n\n  object.notifyPropertyChange('changer');\n\n  equal(object.get('nestedInc'), ret1+1, 'should increment after dependent key changes'); // should run again\n\n});\n\n\n// This verifies a specific bug encountered where observers for computed\n// properties would fire before their prop caches were cleared.\ntest(\"change dependent should clear cache when observers of dependent are called\", function() {\n\n  // call get several times to collect call count\n  var ret1 = object.get('inc'); // should run func\n  equal(object.get('inc'), ret1, 'multiple calls should not run cached prop');\n\n  // add observer to verify change...\n  object.addObserver('inc', this, function() {\n    equal(object.get('inc'), ret1+1, 'should increment after dependent key changes'); // should run again\n  });\n\n  // now run\n  object.set('changer', 'bar');\n\n});\n\ntest('setting one of two computed properties that depend on a third property should clear the kvo cache', function() {\n  // we have to call set twice to fill up the cache\n  object.set('isOff', true);\n  object.set('isOn', true);\n\n  // setting isOff to true should clear the kvo cache\n  object.set('isOff', true);\n  equal(object.get('isOff'), true, 'object.isOff should be true');\n  equal(object.get('isOn'), false, 'object.isOn should be false');\n});\n\ntest(\"dependent keys should be able to be specified as property paths\", function() {\n  var depObj = ObservableObject.createWithMixins({\n    menu: ObservableObject.create({\n      price: 5\n    }),\n\n    menuPrice: Ember.computed(function() {\n      return this.get('menu.price');\n    }).property('menu.price')\n  });\n\n  equal(depObj.get('menuPrice'), 5, \"precond - initial value returns 5\");\n\n  depObj.set('menu.price', 6);\n\n  equal(depObj.get('menuPrice'), 6, \"cache is properly invalidated after nested property changes\");\n});\n\ntest(\"nested dependent keys should propagate after they update\", function() {\n  var bindObj;\n  Ember.run(function () {\n    lookup.DepObj = ObservableObject.createWithMixins({\n      restaurant: ObservableObject.create({\n        menu: ObservableObject.create({\n          price: 5\n        })\n      }),\n\n      price: Ember.computed(function() {\n        return this.get('restaurant.menu.price');\n      }).property('restaurant.menu.price')\n    });\n\n    bindObj = ObservableObject.createWithMixins({\n      priceBinding: \"DepObj.price\"\n    });\n  });\n\n  equal(bindObj.get('price'), 5, \"precond - binding propagates\");\n\n  Ember.run(function () {\n    lookup.DepObj.set('restaurant.menu.price', 10);\n  });\n\n  equal(bindObj.get('price'), 10, \"binding propagates after a nested dependent keys updates\");\n\n  Ember.run(function () {\n    lookup.DepObj.set('restaurant.menu', ObservableObject.create({\n      price: 15\n    }));\n  });\n\n  equal(bindObj.get('price'), 15, \"binding propagates after a middle dependent keys updates\");\n});\n\ntest(\"cacheable nested dependent keys should clear after their dependencies update\", function() {\n  ok(true);\n\n  var DepObj;\n\n  Ember.run(function(){\n    lookup.DepObj = DepObj = ObservableObject.createWithMixins({\n      restaurant: ObservableObject.create({\n        menu: ObservableObject.create({\n          price: 5\n        })\n      }),\n\n      price: Ember.computed(function() {\n        return this.get('restaurant.menu.price');\n      }).property('restaurant.menu.price')\n    });\n  });\n\n  equal(DepObj.get('price'), 5, \"precond - computed property is correct\");\n\n  Ember.run(function(){\n    DepObj.set('restaurant.menu.price', 10);\n  });\n  equal(DepObj.get('price'), 10, \"cacheable computed properties are invalidated even if no run loop occurred\");\n\n  Ember.run(function(){\n    DepObj.set('restaurant.menu.price', 20);\n  });\n  equal(DepObj.get('price'), 20, \"cacheable computed properties are invalidated after a second get before a run loop\");\n  equal(DepObj.get('price'), 20, \"precond - computed properties remain correct after a run loop\");\n\n  Ember.run(function(){\n    DepObj.set('restaurant.menu', ObservableObject.create({\n      price: 15\n    }));\n  });\n\n\n  equal(DepObj.get('price'), 15, \"cacheable computed properties are invalidated after a middle property changes\");\n\n  Ember.run(function(){\n    DepObj.set('restaurant.menu', ObservableObject.create({\n      price: 25\n    }));\n  });\n\n  equal(DepObj.get('price'), 25, \"cacheable computed properties are invalidated after a middle property changes again, before a run loop\");\n});\n\n\n\n// ..........................................................\n// OBSERVABLE OBJECTS\n//\n\nmodule(\"Observable objects & object properties \", {\n\n  setup: function() {\n    object = ObservableObject.createWithMixins({\n\n      normal: 'value',\n      abnormal: 'zeroValue',\n      numberVal: 24,\n      toggleVal: true,\n      observedProperty: 'beingWatched',\n      testRemove: 'observerToBeRemoved',\n      normalArray: Ember.A([1,2,3,4,5]),\n\n      getEach: function() {\n        var keys = ['normal','abnormal'];\n        var ret = [];\n        for(var idx=0; idx<keys.length;idx++) {\n          ret[ret.length] = this.get(keys[idx]);\n        }\n        return ret ;\n      },\n\n      newObserver:function(){\n        this.abnormal = 'changedValueObserved';\n      },\n\n      testObserver: Ember.observer(function(){\n        this.abnormal = 'removedObserver';\n      }, 'normal'),\n\n      testArrayObserver: Ember.observer(function(){\n        this.abnormal = 'notifiedObserver';\n      }, 'normalArray.[]')\n\n    });\n  }\n\n});\n\ntest('incrementProperty and decrementProperty',function(){\n  var newValue = object.incrementProperty('numberVal');\n  equal(25,newValue,'numerical value incremented');\n  object.numberVal = 24;\n  newValue = object.decrementProperty('numberVal');\n  equal(23,newValue,'numerical value decremented');\n  object.numberVal = 25;\n  newValue = object.incrementProperty('numberVal', 5);\n  equal(30,newValue,'numerical value incremented by specified increment');\n  object.numberVal = 25;\n  newValue = object.decrementProperty('numberVal',5);\n  equal(20,newValue,'numerical value decremented by specified increment');\n});\n\ntest('toggle function, should be boolean',function(){\n  equal(object.toggleProperty('toggleVal',true,false),object.get('toggleVal'));\n  equal(object.toggleProperty('toggleVal',true,false),object.get('toggleVal'));\n  equal(object.toggleProperty('toggleVal',undefined,undefined),object.get('toggleVal'));\n});\n\ntest('should notify array observer when array changes',function(){\n  get(object, 'normalArray').replace(0,0,6);\n  equal(object.abnormal, 'notifiedObserver', 'observer should be notified');\n});\n\nmodule(\"object.addObserver()\", {\n  setup: function() {\n\n    ObjectC = ObservableObject.create({\n\n      objectE:ObservableObject.create({\n        propertyVal:\"chainedProperty\"\n      }),\n\n      normal: 'value',\n      normal1: 'zeroValue',\n      normal2: 'dependentValue',\n      incrementor: 10,\n\n      action: function() {\n        this.normal1= 'newZeroValue';\n      },\n\n      observeOnceAction: function() {\n        this.incrementor= this.incrementor+1;\n      },\n\n      chainedObserver:function(){\n        this.normal2 = 'chainedPropertyObserved' ;\n      }\n\n    });\n  }\n});\n\ntest(\"should register an observer for a property\", function() {\n  ObjectC.addObserver('normal', ObjectC, 'action');\n  ObjectC.set('normal','newValue');\n  equal(ObjectC.normal1, 'newZeroValue');\n});\n\ntest(\"should register an observer for a property - Special case of chained property\", function() {\n  ObjectC.addObserver('objectE.propertyVal',ObjectC,'chainedObserver');\n  ObjectC.objectE.set('propertyVal',\"chainedPropertyValue\");\n  equal('chainedPropertyObserved',ObjectC.normal2);\n  ObjectC.normal2 = 'dependentValue';\n  ObjectC.set('objectE','');\n  equal('chainedPropertyObserved',ObjectC.normal2);\n});\n\nmodule(\"object.removeObserver()\", {\n  setup: function() {\n    ObjectD = ObservableObject.create({\n\n      objectF:ObservableObject.create({\n        propertyVal:\"chainedProperty\"\n      }),\n\n      normal: 'value',\n      normal1: 'zeroValue',\n      normal2: 'dependentValue',\n      ArrayKeys: ['normal','normal1'],\n\n      addAction: function() {\n        this.normal1 = 'newZeroValue';\n      },\n      removeAction: function() {\n        this.normal2 = 'newDependentValue';\n      },\n      removeChainedObserver:function(){\n        this.normal2 = 'chainedPropertyObserved' ;\n      },\n\n      observableValue: \"hello world\",\n\n      observer1: function() {\n        // Just an observer\n      },\n      observer2: function() {\n        this.removeObserver('observableValue', null, 'observer1');\n        this.removeObserver('observableValue', null, 'observer2');\n        this.hasObserverFor('observableValue');   // Tickle 'getMembers()'\n        this.removeObserver('observableValue', null, 'observer3');\n      },\n      observer3: function() {\n        // Just an observer\n      }\n    });\n\n  }\n});\n\ntest(\"should unregister an observer for a property\", function() {\n  ObjectD.addObserver('normal', ObjectD, 'addAction');\n  ObjectD.set('normal','newValue');\n  equal(ObjectD.normal1, 'newZeroValue');\n\n  ObjectD.set('normal1','zeroValue');\n\n  ObjectD.removeObserver('normal', ObjectD, 'addAction');\n  ObjectD.set('normal','newValue');\n  equal(ObjectD.normal1, 'zeroValue');\n});\n\n\ntest(\"should unregister an observer for a property - special case when key has a '.' in it.\", function() {\n  ObjectD.addObserver('objectF.propertyVal',ObjectD,'removeChainedObserver');\n  ObjectD.objectF.set('propertyVal',\"chainedPropertyValue\");\n  ObjectD.removeObserver('objectF.propertyVal',ObjectD,'removeChainedObserver');\n  ObjectD.normal2 = 'dependentValue';\n  ObjectD.objectF.set('propertyVal',\"removedPropertyValue\");\n  equal('dependentValue',ObjectD.normal2);\n  ObjectD.set('objectF','');\n  equal('dependentValue',ObjectD.normal2);\n});\n\n\ntest(\"removing an observer inside of an observer shouldnt cause any problems\", function() {\n  // The observable system should be protected against clients removing\n  // observers in the middle of observer notification.\n  var encounteredError = false;\n  try {\n    ObjectD.addObserver('observableValue', null, 'observer1');\n    ObjectD.addObserver('observableValue', null, 'observer2');\n    ObjectD.addObserver('observableValue', null, 'observer3');\n    Ember.run(function() { ObjectD.set('observableValue', \"hi world\"); });\n  }\n  catch(e) {\n    encounteredError = true;\n  }\n  equal(encounteredError, false);\n});\n\n\n\nmodule(\"Bind function \", {\n\n  setup: function() {\n    objectA = ObservableObject.create({\n      name: \"Sproutcore\",\n      location: \"Timbaktu\"\n    });\n\n    objectB = ObservableObject.create({\n      normal: \"value\",\n      computed:function() {\n        this.normal = 'newValue';\n      }\n    }) ;\n\n    Namespace = {\n      objectA: objectA,\n      objectB: objectB\n    } ;\n  }\n});\n\ntest(\"should bind property with method parameter as undefined\", function() {\n  // creating binding\n  Ember.run(function(){\n    objectA.bind(\"name\", \"Namespace.objectB.normal\",undefined) ;\n  });\n\n  // now make a change to see if the binding triggers.\n  Ember.run(function(){\n    objectB.set(\"normal\", \"changedValue\") ;\n  });\n\n  // support new-style bindings if available\n  equal(\"changedValue\", objectA.get(\"name\"), \"objectA.name is binded\");\n});\n\n// ..........................................................\n// SPECIAL CASES\n//\n\ntest(\"changing chained observer object to null should not raise exception\", function() {\n\n  var obj = ObservableObject.create({\n    foo: ObservableObject.create({\n      bar: ObservableObject.create({ bat: \"BAT\" })\n    })\n  });\n\n  var callCount = 0;\n  obj.foo.addObserver('bar.bat', obj, function(target, key, value) {\n    callCount++;\n  });\n\n  Ember.run(function() {\n    obj.foo.set('bar', null);\n  });\n\n  equal(callCount, 1, 'changing bar should trigger observer');\n  expect(1);\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/legacy_1x/mixins/observable/observable_test");minispade.register('ember-runtime/~tests/legacy_1x/mixins/observable/observersForKey_test', "(function() {/*\n  NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n  are the same except for places where we intend to break the API we instead\n  validate that we warn the developer appropriately.\n\n  CHANGES FROM 1.6:\n\n  * Create ObservableObject which includes Ember.Observable\n*/\n\n// ========================================================================\n// Ember.Observable Tests\n// ========================================================================\n/*globals module test ok isObj equals expects Namespace */\n\nvar ObservableObject = Ember.Object.extend(Ember.Observable);\n\n// ..........................................................\n// GET()\n//\n\nmodule(\"object.observesForKey()\");\n\ntest(\"should get observers\", function() {\n  var o1 = ObservableObject.create({ foo: 100 }),\n      o2 = ObservableObject.create({ func: function() {} }),\n      o3 = ObservableObject.create({ func: function() {} }),\n      observers = null;\n\n  equal(Ember.get(o1.observersForKey('foo'), 'length'), 0, \"o1.observersForKey should return empty array\");\n\n  o1.addObserver('foo', o2, o2.func);\n  o1.addObserver('foo', o3, o3.func);\n\n  observers = o1.observersForKey('foo');\n\n  equal(Ember.get(observers, 'length'), 2, \"o2.observersForKey should return an array with length 2\");\n  equal(observers[0][0], o2, \"first item in observers array should be o2\");\n  equal(observers[1][0], o3, \"second item in observers array should be o3\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/legacy_1x/mixins/observable/observersForKey_test");minispade.register('ember-runtime/~tests/legacy_1x/mixins/observable/propertyChanges_test', "(function() {/*\n  NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n  are the same except for places where we intend to break the API we instead\n  validate that we warn the developer appropriately.\n\n  CHANGES FROM 1.6:\n\n  * Create ObservableObject which includes Ember.Observable\n  * Remove test that tests internal _kvo_changeLevel property.  This is an\n    implementation detail.\n  * Remove test for allPropertiesDidChange\n  * Removed star observer test.  no longer supported\n  * Removed property revision test.  no longer supported\n*/\n\n// ========================================================================\n// Ember.Observable Tests\n// ========================================================================\n/*globals module test ok isObj equals expects */\n\nvar ObservableObject = Ember.Object.extend(Ember.Observable);\n\nvar revMatches = false , ObjectA;\n\nmodule(\"object.propertyChanges\", {\n  setup: function() {\n    ObjectA = ObservableObject.createWithMixins({\n      foo  : 'fooValue',\n      prop : 'propValue',\n\n      action: Ember.observer(function() {\n        this.set('prop', 'changedPropValue');\n      }, 'foo'),\n\n      newFoo : 'newFooValue',\n      newProp: 'newPropValue',\n\n      notifyAction: Ember.observer(function() {\n        this.set('newProp', 'changedNewPropValue');\n      }, 'newFoo'),\n\n      notifyAllAction: Ember.observer(function() {\n        this.set('newFoo', 'changedNewFooValue');\n      }, 'prop'),\n\n      starProp: null,\n      starObserver: function(target, key, value, rev) {\n        revMatches = (rev === target.propertyRevision) ;\n        this.starProp = key;\n      }\n\n    });\n    }\n});\n\n\ntest(\"should observe the changes within the nested begin / end property changes\", function() {\n\n  //start the outer nest\n  ObjectA.beginPropertyChanges();\n    // Inner nest\n    ObjectA.beginPropertyChanges();\n        ObjectA.set('foo', 'changeFooValue');\n      equal(ObjectA.prop, \"propValue\") ;\n      ObjectA.endPropertyChanges();\n\n    //end inner nest\n    ObjectA.set('prop', 'changePropValue');\n    equal(ObjectA.newFoo, \"newFooValue\") ;\n  //close the outer nest\n  ObjectA.endPropertyChanges();\n\n  equal(ObjectA.prop, \"changedPropValue\") ;\n  equal(ObjectA.newFoo, \"changedNewFooValue\") ;\n\n});\n\ntest(\"should observe the changes within the begin and end property changes\", function() {\n\n  ObjectA.beginPropertyChanges();\n    ObjectA.set('foo', 'changeFooValue');\n\n  equal(ObjectA.prop, \"propValue\") ;\n    ObjectA.endPropertyChanges();\n\n  equal(ObjectA.prop, \"changedPropValue\") ;\n});\n\ntest(\"should indicate that the property of an object has just changed\", function() {\n  // inidicate that proprty of foo will change to its subscribers\n  ObjectA.propertyWillChange('foo') ;\n\n  //Value of the prop is unchanged yet as this will be changed when foo changes\n  equal(ObjectA.prop, 'propValue' ) ;\n\n  //change the value of foo.\n  ObjectA.set('foo', 'changeFooValue');\n\n  // Indicate the subscribers of foo that the value has just changed\n  ObjectA.propertyDidChange('foo', null) ;\n\n  // Values of prop has just changed\n  equal(ObjectA.prop,'changedPropValue') ;\n});\n\ntest(\"should notify that the property of an object has changed\", function() {\n  // Notify to its subscriber that the values of 'newFoo' will be changed. In this\n  // case the observer is \"newProp\". Therefore this will call the notifyAction function\n  // and value of \"newProp\" will be changed.\n  ObjectA.notifyPropertyChange('newFoo','fooValue');\n\n  //value of newProp changed.\n  equal(ObjectA.newProp,'changedNewPropValue') ;\n});\n\ntest(\"should invalidate function property cache when notifyPropertyChange is called\", function() {\n\n  var a = ObservableObject.createWithMixins({\n    _b: null,\n    b: Ember.computed(function(key, value) {\n      if (value !== undefined) {\n        this._b = value;\n        return this;\n      }\n      return this._b;\n    }).volatile()\n  });\n\n  a.set('b', 'foo');\n  equal(a.get('b'), 'foo', 'should have set the correct value for property b');\n\n  a._b = 'bar';\n  a.notifyPropertyChange('b');\n  a.set('b', 'foo');\n  equal(a.get('b'), 'foo', 'should have invalidated the cache so that the newly set value is actually set');\n\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/legacy_1x/mixins/observable/propertyChanges_test");minispade.register('ember-runtime/~tests/legacy_1x/system/binding_test', "(function() {/*global TestNamespace:true*/\n\n/*\n  NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n  are the same except for places where we intend to break the API we instead\n  validate that we warn the developer appropriately.\n\n  CHANGES FROM 1.6:\n\n  * All calls to Ember.run.sync() were changed to\n    Ember.run.sync()\n\n  * Bindings no longer accept a root object as their second param.  Instead\n    our test binding objects were put under a single object they could\n    originate from.\n\n  * tests that inspected internal properties were removed.\n\n  * converted foo.get/foo.set to use Ember.get/Ember.set\n\n  * Removed tests for Ember.Binding.isConnected.  Since binding instances are now\n    shared this property no longer makes sense.\n\n  * Changed call calls for obj.bind(...) to Ember.bind(obj, ...);\n\n  * Changed all calls to sc_super() to this._super()\n\n  * Changed all calls to disconnect() to pass the root object.\n\n  * removed calls to Ember.Binding.destroy() as that method is no longer useful\n    (or defined)\n\n  * changed use of T_STRING to 'string'\n*/\n\nvar get = Ember.get, set = Ember.set;\n\n// ========================================================================\n// Ember.Binding Tests\n// ========================================================================\n\nvar fromObject, toObject, binding, Bon1, bon2, root; // global variables\n\nmodule(\"basic object binding\", {\n  setup: function() {\n    fromObject = Ember.Object.create({ value: 'start' }) ;\n    toObject = Ember.Object.create({ value: 'end' }) ;\n    root = { fromObject: fromObject, toObject: toObject };\n    Ember.run(function () {\n      binding = Ember.bind(root, 'toObject.value', 'fromObject.value');\n    });\n  }\n});\n\ntest(\"binding should have synced on connect\", function() {\n  equal(get(toObject, \"value\"), \"start\", \"toObject.value should match fromObject.value\");\n});\n\ntest(\"fromObject change should propagate to toObject only after flush\", function() {\n  Ember.run(function () {\n    set(fromObject, \"value\", \"change\") ;\n    equal(get(toObject, \"value\"), \"start\") ;\n  });\n  equal(get(toObject, \"value\"), \"change\") ;\n});\n\ntest(\"toObject change should propagate to fromObject only after flush\", function() {\n  Ember.run(function () {\n    set(toObject, \"value\", \"change\") ;\n    equal(get(fromObject, \"value\"), \"start\") ;\n  });\n  equal(get(fromObject, \"value\"), \"change\") ;\n});\n\ntest(\"deferred observing during bindings\", function() {\n\n  // setup special binding\n  fromObject = Ember.Object.create({\n    value1: 'value1',\n    value2: 'value2'\n  });\n\n  toObject = Ember.Object.createWithMixins({\n    value1: 'value1',\n    value2: 'value2',\n\n    callCount: 0,\n\n    observer: Ember.observer(function() {\n      equal(get(this, 'value1'), 'CHANGED', 'value1 when observer fires');\n      equal(get(this, 'value2'), 'CHANGED', 'value2 when observer fires');\n      this.callCount++;\n    }, 'value1', 'value2')\n  });\n\n  var root = { fromObject: fromObject, toObject: toObject };\n  Ember.run(function () {\n    Ember.bind(root, 'toObject.value1', 'fromObject.value1');\n    Ember.bind(root, 'toObject.value2', 'fromObject.value2');\n\n    // change both value1 + value2, then  flush bindings.  observer should only\n    // fire after bindings are done flushing.\n    set(fromObject, 'value1', 'CHANGED');\n    set(fromObject, 'value2', 'CHANGED');\n  });\n\n  equal(toObject.callCount, 2, 'should call observer twice');\n});\n\ntest(\"binding disconnection actually works\", function() {\n  binding.disconnect(root);\n  Ember.run(function () {\n    set(fromObject, 'value', 'change');\n  });\n  equal(get(toObject, 'value'), 'start');\n});\n\n// ..........................................................\n// one way binding\n//\n\nmodule(\"one way binding\", {\n\n  setup: function() {\n    Ember.run(function() {\n      fromObject = Ember.Object.create({ value: 'start' }) ;\n      toObject = Ember.Object.create({ value: 'end' }) ;\n      root = { fromObject: fromObject, toObject: toObject };\n      binding = Ember.oneWay(root, 'toObject.value', 'fromObject.value');\n    });\n  },\n  teardown: function(){\n    Ember.run.cancelTimers();\n  }\n});\n\ntest(\"fromObject change should propagate after flush\", function() {\n  Ember.run(function() {\n    set(fromObject, \"value\", \"change\") ;\n    equal(get(toObject, \"value\"), \"start\") ;\n    Ember.run.sync() ;\n    equal(get(toObject, \"value\"), \"change\") ;\n  });\n});\n\ntest(\"toObject change should NOT propagate\", function() {\n  Ember.run(function() {\n    set(toObject, \"value\", \"change\") ;\n    equal(get(fromObject, \"value\"), \"start\") ;\n    Ember.run.sync() ;\n    equal(get(fromObject, \"value\"), \"start\") ;\n  });\n});\n\nvar first, second, third, binding1, binding2; // global variables\n\n// ..........................................................\n// chained binding\n//\n\nmodule(\"chained binding\", {\n\n  setup: function() {\n    Ember.run(function() {\n      first = Ember.Object.create({ output: 'first' }) ;\n\n      second = Ember.Object.createWithMixins({\n        input: 'second',\n        output: 'second',\n\n        inputDidChange: Ember.observer(function() {\n          set(this, \"output\", get(this, \"input\")) ;\n        }, \"input\")\n      }) ;\n\n      third = Ember.Object.create({ input: \"third\" }) ;\n\n      root = { first: first, second: second, third: third };\n      binding1 = Ember.bind(root, 'second.input', 'first.output');\n      binding2 = Ember.bind(root, 'second.output', 'third.input');\n    });\n  },\n  teardown: function(){\n    Ember.run.cancelTimers();\n  }\n});\n\ntest(\"changing first output should propograte to third after flush\", function() {\n  Ember.run(function() {\n    set(first, \"output\", \"change\") ;\n    equal(\"change\", get(first, \"output\"), \"first.output\") ;\n    ok(\"change\" !== get(third, \"input\"), \"third.input\") ;\n\n    var didChange = true;\n    while(didChange) didChange = Ember.run.sync() ;\n\n    equal(\"change\", get(first, \"output\"), \"first.output\") ;\n    equal(\"change\", get(second, \"input\"), \"second.input\") ;\n    equal(\"change\", get(second, \"output\"), \"second.output\") ;\n    equal(\"change\", get(third,\"input\"), \"third.input\") ;\n  });\n});\n\n// ..........................................................\n// Custom Binding\n//\n\nmodule(\"Custom Binding\", {\n  setup: function() {\n    Bon1 = Ember.Object.extend({\n      value1: \"hi\",\n      value2: 83,\n      array1: []\n    });\n\n    bon2 = Ember.Object.create({\n      val1: \"hello\",\n      val2: 25,\n      arr: [1,2,3,4]\n    });\n\n    TestNamespace = {\n      bon2: bon2,\n      Bon1: Bon1\n    };\n  },\n  teardown: function() {\n    Bon1 = bon2 = TestNamespace  = null;\n    Ember.run.cancelTimers();\n  }\n});\n\ntest(\"two bindings to the same value should sync in the order they are initialized\", function() {\n\n  Ember.run.begin();\n\n  var a = Ember.Object.create({\n    foo: \"bar\"\n  });\n\n  var b = Ember.Object.createWithMixins({\n    foo: \"baz\",\n    fooBinding: \"a.foo\",\n\n    a: a,\n\n    C: Ember.Object.extend({\n      foo: \"bee\",\n      fooBinding: \"owner.foo\"\n    }),\n\n    init: function() {\n      this._super();\n      set(this, 'c', this.C.create({ owner: this }));\n    }\n\n  });\n\n  Ember.run.end();\n\n  equal(get(a, 'foo'), \"bar\", 'a.foo should not change');\n  equal(get(b, 'foo'), \"bar\", 'a.foo should propagate up to b.foo');\n  equal(get(b.c, 'foo'), \"bar\", 'a.foo should propagate up to b.c.foo');\n});\n\n// ..........................................................\n// propertyNameBinding with longhand\n//\n\nmodule(\"propertyNameBinding with longhand\", {\n  setup: function(){\n    TestNamespace = {};\n    Ember.run(function () {\n      TestNamespace.fromObject = Ember.Object.create({\n        value: \"originalValue\"\n      });\n\n      TestNamespace.toObject = Ember.Object.createWithMixins({\n          valueBinding: Ember.Binding.from('TestNamespace.fromObject.value'),\n          localValue: \"originalLocal\",\n          relativeBinding: Ember.Binding.from('localValue')\n      });\n    });\n  },\n  teardown: function(){\n    TestNamespace = undefined;\n  }\n});\n\ntest(\"works with full path\", function(){\n  Ember.run(function () {\n    set(TestNamespace.fromObject, 'value', \"updatedValue\");\n  });\n\n  equal(get(TestNamespace.toObject, 'value'), \"updatedValue\");\n\n  Ember.run(function () {\n    set(TestNamespace.fromObject, 'value', \"newerValue\");\n  });\n\n  equal(get(TestNamespace.toObject, 'value'), \"newerValue\");\n});\n\ntest(\"works with local path\", function(){\n  Ember.run(function () {\n    set(TestNamespace.toObject, 'localValue', \"updatedValue\");\n  });\n\n  equal(get(TestNamespace.toObject, 'relative'), \"updatedValue\");\n\n  Ember.run(function () {\n    set(TestNamespace.toObject, 'localValue', \"newerValue\");\n  });\n\n  equal(get(TestNamespace.toObject, 'relative'), \"newerValue\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/legacy_1x/system/binding_test");minispade.register('ember-runtime/~tests/legacy_1x/system/object/base_test', "(function() {/*globals TestNamespace:true*/\n\n/*\n  NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n  are the same except for places where we intend to break the API we instead\n  validate that we warn the developer appropriately.\n\n  CHANGES FROM 1.6:\n\n  * Changed get(obj, ) and set(obj, ) to Ember.get() and Ember.set()\n  * Removed obj.instanceOf() and obj.kindOf() tests.  use obj instanceof Foo\n    instead\n  * Removed respondsTo() and tryToPerform() tests.  Can be brought back in a\n    utils package.\n  * Removed destroy() test.  You can impl yourself but not built in\n  * Changed Class.subclassOf() test to Class.detect()\n  * Remove broken test for 'superclass' property.\n  * Removed obj.didChangeFor()\n*/\n\n// ========================================================================\n// Ember.Object Base Tests\n// ========================================================================\n\nvar obj, obj1, don, don1 ; // global variables\n\nvar get = Ember.get, set = Ember.set;\n\nmodule(\"A new Ember.Object instance\", {\n\n  setup: function() {\n    obj = Ember.Object.create({\n      foo: \"bar\",\n      total: 12345,\n      aMethodThatExists: function() {},\n      aMethodThatReturnsTrue: function() { return true; },\n      aMethodThatReturnsFoobar: function() { return \"Foobar\"; },\n      aMethodThatReturnsFalse: function() { return false; }\n    });\n  },\n\n  teardown: function() {\n    obj = undefined ;\n  }\n\n});\n\ntest(\"Should return it's properties when requested using Ember.Object#get\", function() {\n  equal(get(obj, 'foo'), 'bar') ;\n  equal(get(obj, 'total'), 12345) ;\n});\n\ntest(\"Should allow changing of those properties by calling Ember.Object#set\", function() {\n  equal(get(obj,'foo'), 'bar') ;\n  equal(get(obj, 'total'), 12345) ;\n\n  set(obj,  'foo', 'Chunky Bacon' ) ;\n  set(obj,  'total', 12 ) ;\n\n  equal(get(obj, 'foo'), 'Chunky Bacon') ;\n  equal(get(obj, 'total'), 12) ;\n});\n\n\nmodule(\"Ember.Object observers\", {\n  setup: function() {\n    // create a namespace\n    TestNamespace = {\n      obj: Ember.Object.create({\n        value: \"test\"\n      })\n    };\n\n    // create an object\n    obj = Ember.Object.createWithMixins({\n      prop1: null,\n\n      // normal observer\n      observer: Ember.observer(function(){\n        this._normal = true;\n      }, \"prop1\"),\n\n      globalObserver: Ember.observer(function() {\n        this._global = true;\n      }, \"TestNamespace.obj.value\"),\n\n      bothObserver: Ember.observer(function() {\n        this._both = true;\n      }, \"prop1\", \"TestNamespace.obj.value\")\n    });\n\n  }\n});\n\ntest(\"Local observers work\", function() {\n  obj._normal = false;\n  set(obj, \"prop1\", false);\n  equal(obj._normal, true, \"Normal observer did change.\");\n});\n\ntest(\"Global observers work\", function() {\n  obj._global = false;\n  set(TestNamespace.obj, \"value\", \"test2\");\n  equal(obj._global, true, \"Global observer did change.\");\n});\n\ntest(\"Global+Local observer works\", function() {\n  obj._both = false;\n  set(obj, \"prop1\", false);\n  equal(obj._both, true, \"Both observer did change.\");\n});\n\n\n\nmodule(\"Ember.Object superclass and subclasses\", {\n  setup: function() {\n    obj = Ember.Object.extend ({\n    method1: function() {\n      return \"hello\";\n    }\n\t});\n\tobj1 = obj.extend();\n\tdon = obj1.create ({\n    method2: function() {\n      return this.superclass();\n    }\n\t});\n  },\n\n  teardown: function() {\n\tobj = undefined ;\n    obj1 = undefined ;\n    don = undefined ;\n  }\n});\n\ntest(\"Checking the detect() function on an object and its subclass\", function(){\n\tequal(obj.detect(obj1), true);\n\tequal(obj1.detect(obj), false);\n});\n\ntest(\"Checking the detectInstance() function on an object and its subclass\", function() {\n  ok(Ember.Object.detectInstance(obj.create()));\n  ok(obj.detectInstance(obj.create()));\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/legacy_1x/system/object/base_test");minispade.register('ember-runtime/~tests/legacy_1x/system/object/bindings_test', "(function() {/*globals TestNamespace:true*/\n\n/*\n  NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n  are the same except for places where we intend to break the API we instead\n  validate that we warn the developer appropriately.\n\n  CHANGES FROM 1.6:\n\n  * changed Ember.Bending.flushPendingChanges() -> Ember.run.sync();\n  * changes obj.set() and obj.get() to Ember.set() and Ember.get()\n  * Fixed an actual bug in unit tests around line 133\n  * fixed 'bindings should disconnect on destroy' test to use Ember.destroy.\n*/\n\n// ========================================================================\n// Ember.Object bindings Tests\n// ========================================================================\n\nvar testObject, fromObject, extraObject, TestObject;\n\nvar set = Ember.set, get = Ember.get;\n\nvar bindModuleOpts = {\n\n  setup: function() {\n    testObject = Ember.Object.create({\n      foo: \"bar\",\n      bar: \"foo\",\n      extraObject: null\n    });\n\n    fromObject = Ember.Object.create({\n      bar: \"foo\",\n      extraObject: null\n    }) ;\n\n    extraObject = Ember.Object.create({\n      foo: \"extraObjectValue\"\n    }) ;\n\n    TestNamespace = {\n      fromObject: fromObject,\n      testObject: testObject\n    } ;\n  },\n\n  teardown: function() {\n    testObject = fromObject = extraObject = null ;\n  }\n\n};\n\nmodule(\"bind() method\", bindModuleOpts);\n\ntest(\"bind(TestNamespace.fromObject.bar) should follow absolute path\", function() {\n  Ember.run(function(){\n    // create binding\n    testObject.bind(\"foo\", \"TestNamespace.fromObject.bar\");\n\n    // now make a change to see if the binding triggers.\n    set(fromObject, \"bar\", \"changedValue\");\n  });\n\n  equal(\"changedValue\", get(testObject, \"foo\"), \"testObject.foo\");\n});\n\ntest(\"bind(.bar) should bind to relative path\", function() {\n  Ember.run(function(){\n    // create binding\n    testObject.bind(\"foo\", \"bar\") ;\n\n    // now make a change to see if the binding triggers.\n    set(testObject, \"bar\", \"changedValue\") ;\n  });\n\n  equal(\"changedValue\", get(testObject, \"foo\"), \"testObject.foo\");\n});\n\nvar fooBindingModuleOpts = {\n\n  setup: function() {\n    TestObject = Ember.Object.extend({\n      foo: \"bar\",\n      bar: \"foo\",\n      extraObject: null\n    });\n\n    fromObject = Ember.Object.create({\n      bar: \"foo\",\n      extraObject: null\n    }) ;\n\n    extraObject = Ember.Object.create({\n      foo: \"extraObjectValue\"\n    }) ;\n\n    TestNamespace = {\n      fromObject: fromObject,\n      testObject: TestObject\n    } ;\n  },\n\n  teardown: function() {\n    TestObject = fromObject = extraObject = null ;\n  //  delete TestNamespace ;\n  }\n\n};\n\nmodule(\"fooBinding method\", fooBindingModuleOpts);\n\n\ntest(\"fooBinding: TestNamespace.fromObject.bar should follow absolute path\", function() {\n  // create binding\n  Ember.run(function(){\n    testObject = TestObject.createWithMixins({\n      fooBinding: \"TestNamespace.fromObject.bar\"\n    }) ;\n\n    // now make a change to see if the binding triggers.\n    set(fromObject, \"bar\", \"changedValue\") ;\n  });\n\n\n  equal(\"changedValue\", get(testObject, \"foo\"), \"testObject.foo\");\n});\n\ntest(\"fooBinding: .bar should bind to relative path\", function() {\n  Ember.run(function(){\n    testObject = TestObject.createWithMixins({\n      fooBinding: \"bar\"\n    });\n    // now make a change to see if the binding triggers.\n    set(testObject, \"bar\", \"changedValue\");\n  });\n\n  equal(\"changedValue\", get(testObject, \"foo\"), \"testObject.foo\");\n});\n\ntest('fooBinding: should disconnect bindings when destroyed', function () {\n  Ember.run(function(){\n    testObject = TestObject.createWithMixins({\n      fooBinding: \"TestNamespace.fromObject.bar\"\n    });\n\n    set(TestNamespace.fromObject, 'bar', 'BAZ');\n  });\n\n  equal(get(testObject, 'foo'), 'BAZ', 'binding should have synced');\n\n  Ember.destroy(testObject);\n\n  Ember.run(function(){\n    set(TestNamespace.fromObject, 'bar', 'BIFF');\n  });\n\n  ok(get(testObject, 'foo') !== 'bar', 'binding should not have synced');\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/legacy_1x/system/object/bindings_test");minispade.register('ember-runtime/~tests/legacy_1x/system/object/concatenated_test', "(function() {/*\n  NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n  are the same except for places where we intend to break the API we instead\n  validate that we warn the developer appropriately.\n\n  CHANGES FROM 1.6:\n\n  * changed get(obj, ) and set(obj, ) to Ember.get() and Ember.set()\n  * converted uses of obj.isEqual() to use deepEqual() test since isEqual is not\n    always defined\n*/\n\n\n\n  var klass, get = Ember.get, set = Ember.set;\n\n  module(\"Ember.Object Concatenated Properties\", {\n    setup: function(){\n      klass = Ember.Object.extend({\n        concatenatedProperties: ['values'],\n        values: ['a', 'b', 'c']\n      });\n    }\n  });\n\n  test(\"concatenates instances\", function() {\n    var obj = klass.create({\n      values: ['d', 'e', 'f']\n    });\n\n    var values = get(obj, 'values'),\n        expected = ['a', 'b', 'c', 'd', 'e', 'f'];\n    deepEqual(values, expected, Ember.String.fmt(\"should concatenate values property (expected: %@, got: %@)\", [expected, values]));\n  });\n\n  test(\"concatenates subclasses\", function() {\n    var subKlass = klass.extend({\n      values: ['d', 'e', 'f']\n    });\n    var obj = subKlass.create();\n\n    var values = get(obj, 'values'),\n        expected = ['a', 'b', 'c', 'd', 'e', 'f'];\n    deepEqual(values, expected, Ember.String.fmt(\"should concatenate values property (expected: %@, got: %@)\", [expected, values]));\n  });\n\n  test(\"concatenates reopen\", function() {\n    klass.reopen({\n      values: ['d', 'e', 'f']\n    });\n    var obj = klass.create();\n\n    var values = get(obj, 'values'),\n        expected = ['a', 'b', 'c', 'd', 'e', 'f'];\n    deepEqual(values, expected, Ember.String.fmt(\"should concatenate values property (expected: %@, got: %@)\", [expected, values]));\n  });\n\n  test(\"concatenates mixin\", function() {\n    var mixin = {\n      values: ['d', 'e']\n    };\n    var subKlass = klass.extend(mixin, {\n      values: ['f']\n    });\n    var obj = subKlass.create();\n\n    var values = get(obj, 'values'),\n        expected = ['a', 'b', 'c', 'd', 'e', 'f'];\n    deepEqual(values, expected, Ember.String.fmt(\"should concatenate values property (expected: %@, got: %@)\", [expected, values]));\n  });\n\n  test(\"concatenates reopen, subclass, and instance\", function() {\n    klass.reopen({ values: ['d'] });\n    var subKlass = klass.extend({ values: ['e'] });\n    var obj = subKlass.create({ values: ['f'] });\n\n    var values = get(obj, 'values'),\n        expected = ['a', 'b', 'c', 'd', 'e', 'f'];\n    deepEqual(values, expected, Ember.String.fmt(\"should concatenate values property (expected: %@, got: %@)\", [expected, values]));\n  });\n\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/legacy_1x/system/object/concatenated_test");minispade.register('ember-runtime/~tests/legacy_1x/system/run_loop_test', "(function() {/*\n  NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n  are the same except for places where we intend to break the API we instead\n  validate that we warn the developer appropriately.\n\n  CHANGES FROM 1.6:\n\n  * Updated the API usage for setting up and syncing Ember.Binding since these\n    are not the APIs this file is testing.\n\n  * Disabled a call to invokeOnce() around line 127 because it appeared to be\n    broken anyway.  I don't think it ever even worked.\n*/\n\nvar MyApp, binding1, binding2, previousPreventRunloop;\n\nmodule(\"System:run_loop() - chained binding\", {\n  setup: function() {\n    MyApp = {};\n    MyApp.first = Ember.Object.create(Ember.Observable, {\n      output: 'MyApp.first'\n    }) ;\n\n    MyApp.second = Ember.Object.createWithMixins(Ember.Observable, {\n      input: 'MyApp.second',\n      output: 'MyApp.second',\n\n      inputDidChange: Ember.observer(function() {\n        this.set(\"output\", this.get(\"input\")) ;\n      }, \"input\")\n\n    }) ;\n\n    MyApp.third = Ember.Object.create(Ember.Observable, {\n      input: \"MyApp.third\"\n    }) ;\n  }\n});\n\ntest(\"Should propagate bindings after the RunLoop completes (using Ember.RunLoop)\", function() {\n  Ember.TESTING_DEPRECATION = true;\n\n  Ember.run(function () {\n\n    //Binding of output of MyApp.first object to input of MyApp.second object\n      binding1 = Ember.Binding.from(\"first.output\")\n        .to(\"second.input\").connect(MyApp) ;\n\n    //Binding of output of MyApp.second object to input of MyApp.third object\n    binding2 = Ember.Binding.from(\"second.output\")\n      .to(\"third.input\").connect(MyApp) ;\n\n    Ember.run.sync();\n\n    // Based on the above binding if you change the output of MyApp.first\n    // object it should change the all the variable of\n    //  MyApp.first,MyApp.second and MyApp.third object\n    MyApp.first.set(\"output\", \"change\") ;\n\n    //Changes the output of the MyApp.first object\n    equal(MyApp.first.get(\"output\"), \"change\") ;\n\n    //since binding has not taken into effect the value still remains as change.\n    equal(MyApp.second.get(\"output\"), \"MyApp.first\") ;\n\n  }); // allows bindings to trigger...\n\n  //Value of the output variable changed to 'change'\n  equal(MyApp.first.get(\"output\"), \"change\") ;\n\n  //Since binding triggered after the end loop the value changed to 'change'.\n  equal(MyApp.second.get(\"output\"), \"change\") ;\n\n  Ember.TESTING_DEPRECATION = false;\n\n});\n\ntest(\"Should propagate bindings after the RunLoop completes\", function() {\n  Ember.TESTING_DEPRECATION = false;\n\n  Ember.run(function () {\n    //Binding of output of MyApp.first object to input of MyApp.second object\n    binding1 = Ember.Binding.from(\"first.output\")\n      .to(\"second.input\").connect(MyApp) ;\n\n    //Binding of output of MyApp.second object to input of MyApp.third object\n    binding2 = Ember.Binding.from(\"second.output\")\n        .to(\"third.input\").connect(MyApp) ;\n  });\n\n  Ember.run(function () {\n    //Based on the above binding if you change the output of MyApp.first object it should\n    //change the all the variable of MyApp.first,MyApp.second and MyApp.third object\n    MyApp.first.set(\"output\", \"change\") ;\n\n    //Changes the output of the MyApp.first object\n    equal(MyApp.first.get(\"output\"), \"change\") ;\n\n    //since binding has not taken into effect the value still remains as change.\n    equal(MyApp.second.get(\"output\"), \"MyApp.first\") ;\n  });\n\n  //Value of the output variable changed to 'change'\n  equal(MyApp.first.get(\"output\"), \"change\") ;\n\n  //Since binding triggered after the end loop the value changed to 'change'.\n  equal(MyApp.second.get(\"output\"), \"change\") ;\n\n  Ember.TESTING_DEPRECATION = false;\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/legacy_1x/system/run_loop_test");minispade.register('ember-runtime/~tests/legacy_1x/system/set_test', "(function() {// NOTE: This test is adapted from the 1.x series of unit tests.  The tests\n// are the same except for places where we intend to break the API we instead\n// validate that we warn the developer appropriately.\n//\n//  * Changed Ember.Set.clone() call to Ember.Set.copy()\n\n// ========================================================================\n// Ember.Set Tests\n// ========================================================================\n\nvar a, b, c ; // global variables\n\nmodule(\"creating Ember.Set instances\", {\n\n  setup: function() {\n    // create objects...\n    a = { name: \"a\" } ;\n    b = { name: \"b\" } ;\n    c = { name: \"c\" } ;\n  },\n\n  teardown: function() {\n    a = undefined ;\n    b = undefined ;\n    c = undefined ;\n  }\n\n});\n\ntest(\"new Ember.Set() should create empty set\", function() {\n  var set = new Ember.Set() ;\n  equal(set.length, 0) ;\n});\n\ntest(\"new Ember.Set([1,2,3]) should create set with three items in them\", function() {\n  var set = new Ember.Set(Ember.A([a,b,c])) ;\n  equal(set.length, 3) ;\n  equal(set.contains(a), true) ;\n  equal(set.contains(b), true) ;\n  equal(set.contains(c), true) ;\n});\n\ntest(\"new Ember.Set() should accept anything that implements Ember.Array\", function() {\n  var arrayLikeObject = Ember.Object.createWithMixins(Ember.Array, {\n    _content: [a,b,c],\n    length: 3,\n    objectAt: function(idx) { return this._content[idx]; }\n  }) ;\n\n  var set = new Ember.Set(arrayLikeObject) ;\n  equal(set.length, 3) ;\n  equal(set.contains(a), true) ;\n  equal(set.contains(b), true) ;\n  equal(set.contains(c), true) ;\n});\n\nvar set ; // global variables\n\n// The tests below also end up testing the contains() method pretty\n// exhaustively.\nmodule(\"Ember.Set.add + Ember.Set.contains\", {\n\n  setup: function() {\n    set = new Ember.Set() ;\n  },\n\n  teardown: function() {\n    set = undefined ;\n  }\n\n});\n\ntest(\"should add an Ember.Object\", function() {\n  var obj = Ember.Object.create() ;\n\n  var oldLength = set.length ;\n  set.add(obj) ;\n  equal(set.contains(obj), true, \"contains()\") ;\n  equal(set.length, oldLength+1, \"new set length\") ;\n});\n\ntest(\"should add a regular hash\", function() {\n  var obj = {} ;\n\n  var oldLength = set.length ;\n  set.add(obj) ;\n  equal(set.contains(obj), true, \"contains()\") ;\n  equal(set.length, oldLength+1, \"new set length\") ;\n});\n\ntest(\"should add a string\", function() {\n  var obj = \"String!\" ;\n\n  var oldLength = set.length ;\n  set.add(obj) ;\n  equal(set.contains(obj), true, \"contains()\") ;\n  equal(set.length, oldLength+1, \"new set length\") ;\n});\n\ntest(\"should add a number\", function() {\n  var obj = 23 ;\n\n  var oldLength = set.length ;\n  set.add(obj) ;\n  equal(set.contains(obj), true, \"contains()\") ;\n  equal(set.length, oldLength+1, \"new set length\") ;\n});\n\ntest(\"should add bools\", function() {\n  var oldLength = set.length ;\n\n  set.add(true) ;\n  equal(set.contains(true), true, \"contains(true)\");\n  equal(set.length, oldLength+1, \"new set length\");\n\n  set.add(false);\n  equal(set.contains(false), true, \"contains(false)\");\n  equal(set.length, oldLength+2, \"new set length\");\n});\n\ntest(\"should add 0\", function() {\n  var oldLength = set.length ;\n\n  set.add(0) ;\n  equal(set.contains(0), true, \"contains(0)\");\n  equal(set.length, oldLength+1, \"new set length\");\n});\n\ntest(\"should add a function\", function() {\n  var obj = function() { return \"Test function\"; } ;\n\n  var oldLength = set.length ;\n  set.add(obj) ;\n  equal(set.contains(obj), true, \"contains()\") ;\n  equal(set.length, oldLength+1, \"new set length\") ;\n});\n\ntest(\"should NOT add a null\", function() {\n  set.add(null) ;\n  equal(set.length, 0) ;\n  equal(set.contains(null), false) ;\n});\n\ntest(\"should NOT add an undefined\", function() {\n  set.add(undefined) ;\n  equal(set.length, 0) ;\n  equal(set.contains(undefined), false) ;\n});\n\ntest(\"adding an item, removing it, adding another item\", function() {\n  var item1 = \"item1\" ;\n  var item2 = \"item2\" ;\n\n  set.add(item1) ; // add to set\n  set.remove(item1) ; //remove from set\n  set.add(item2) ;\n\n  equal(set.contains(item1), false, \"set.contains(item1)\") ;\n\n  set.add(item1) ; // re-add to set\n  equal(set.length, 2, \"set.length\") ;\n});\n\nmodule(\"Ember.Set.remove + Ember.Set.contains\", {\n\n  // generate a set with every type of object, but none of the specific\n  // ones we add in the tests below...\n  setup: function() {\n    set = new Ember.Set(Ember.A([\n      Ember.Object.create({ dummy: true }),\n      { isHash: true },\n      \"Not the String\",\n      16, true, false, 0])) ;\n  },\n\n  teardown: function() {\n    set = undefined ;\n  }\n\n});\n\ntest(\"should remove an Ember.Object and reduce length\", function() {\n  var obj = Ember.Object.create() ;\n  set.add(obj) ;\n  equal(set.contains(obj), true) ;\n  var oldLength = set.length ;\n\n  set.remove(obj) ;\n  equal(set.contains(obj), false, \"should be removed\") ;\n  equal(set.length, oldLength-1, \"should be 1 shorter\") ;\n});\n\ntest(\"should remove a regular hash and reduce length\", function() {\n  var obj = {} ;\n  set.add(obj) ;\n  equal(set.contains(obj), true) ;\n  var oldLength = set.length ;\n\n  set.remove(obj) ;\n  equal(set.contains(obj), false, \"should be removed\") ;\n  equal(set.length, oldLength-1, \"should be 1 shorter\") ;\n});\n\ntest(\"should remove a string and reduce length\", function() {\n  var obj = \"String!\" ;\n  set.add(obj) ;\n  equal(set.contains(obj), true) ;\n  var oldLength = set.length ;\n\n  set.remove(obj) ;\n  equal(set.contains(obj), false, \"should be removed\") ;\n  equal(set.length, oldLength-1, \"should be 1 shorter\") ;\n});\n\ntest(\"should remove a number and reduce length\", function() {\n  var obj = 23 ;\n  set.add(obj) ;\n  equal(set.contains(obj), true) ;\n  var oldLength = set.length ;\n\n  set.remove(obj) ;\n  equal(set.contains(obj), false, \"should be removed\") ;\n  equal(set.length, oldLength-1, \"should be 1 shorter\") ;\n});\n\ntest(\"should remove a bools and reduce length\", function() {\n  var oldLength = set.length ;\n  set.remove(true) ;\n  equal(set.contains(true), false, \"should be removed\") ;\n  equal(set.length, oldLength-1, \"should be 1 shorter\") ;\n\n  set.remove(false);\n  equal(set.contains(false), false, \"should be removed\") ;\n  equal(set.length, oldLength-2, \"should be 2 shorter\") ;\n});\n\ntest(\"should remove 0 and reduce length\", function(){\n  var oldLength = set.length;\n  set.remove(0) ;\n  equal(set.contains(0), false, \"should be removed\") ;\n  equal(set.length, oldLength-1, \"should be 1 shorter\") ;\n});\n\ntest(\"should remove a function and reduce length\", function() {\n  var obj = function() { return \"Test function\"; } ;\n  set.add(obj) ;\n  equal(set.contains(obj), true) ;\n  var oldLength = set.length ;\n\n  set.remove(obj) ;\n  equal(set.contains(obj), false, \"should be removed\") ;\n  equal(set.length, oldLength-1, \"should be 1 shorter\") ;\n});\n\ntest(\"should NOT remove a null\", function() {\n  var oldLength = set.length ;\n  set.remove(null) ;\n  equal(set.length, oldLength) ;\n});\n\ntest(\"should NOT remove an undefined\", function() {\n  var oldLength = set.length ;\n  set.remove(undefined) ;\n  equal(set.length, oldLength) ;\n});\n\ntest(\"should ignore removing an object not in the set\", function() {\n  var obj = Ember.Object.create() ;\n  var oldLength = set.length ;\n  set.remove(obj) ;\n  equal(set.length, oldLength) ;\n});\n\nmodule(\"Ember.Set.pop + Ember.Set.copy\", {\n// generate a set with every type of object, but none of the specific\n// ones we add in the tests below...\n  setup: function() {\n    set = new Ember.Set(Ember.A([\n      Ember.Object.create({ dummy: true }),\n      { isHash: true },\n      \"Not the String\",\n      16, false])) ;\n    },\n\n    teardown: function() {\n      set = undefined ;\n    }\n});\n\ntest(\"the pop() should remove an arbitrary object from the set\", function() {\n  var oldLength = set.length ;\n  var obj = set.pop();\n  ok(!Ember.isNone(obj), 'pops up an item');\n  equal(set.length, oldLength-1, 'length shorter by 1');\n});\n\ntest(\"should pop false and 0\", function(){\n  set = new Ember.Set(Ember.A([false]));\n  ok(set.pop() === false, \"should pop false\");\n\n  set = new Ember.Set(Ember.A([0]));\n  ok(set.pop() === 0, \"should pop 0\");\n});\n\ntest(\"the copy() should return an indentical set\", function() {\n  var oldLength = set.length ;\n  var obj = set.copy();\n  equal(oldLength,obj.length,'length of the clone should be same');\n  equal(obj.contains(set[0]), true);\n  equal(obj.contains(set[1]), true);\n  equal(obj.contains(set[2]), true);\n  equal(obj.contains(set[3]), true);\n  equal(obj.contains(set[4]), true);\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/legacy_1x/system/set_test");minispade.register('ember-runtime/~tests/mixins/array_test', "(function() {/*globals testBoth */\nminispade.require('ember-runtime/~tests/props_helper');\nminispade.require('ember-runtime/~tests/suites/array');\n\n/*\n  Implement a basic fake mutable array.  This validates that any non-native\n  enumerable can impl this API.\n*/\nvar TestArray = Ember.Object.extend(Ember.Array, {\n\n  _content: null,\n\n  init: function(ary) {\n    this._content = ary || [];\n  },\n\n  // some methods to modify the array so we can test changes.  Note that\n  // arrays can be modified even if they don't implement MutableArray.  The\n  // MutableArray is just a standard API for mutation but not required.\n  addObject: function(obj) {\n    var idx = this._content.length;\n    this.arrayContentWillChange(idx, 0, 1);\n    this._content.push(obj);\n    this.arrayContentDidChange(idx, 0, 1);\n  },\n\n  removeFirst: function(idx) {\n    this.arrayContentWillChange(0, 1, 0);\n    this._content.shift();\n    this.arrayContentDidChange(0, 1, 0);\n  },\n\n  objectAt: function(idx) {\n    return this._content[idx];\n  },\n\n  length: Ember.computed(function() {\n    return this._content.length;\n  })\n});\n\n\nEmber.ArrayTests.extend({\n\n  name: 'Basic Mutable Array',\n\n  newObject: function(ary) {\n    ary = ary ? ary.slice() : this.newFixture(3);\n    return new TestArray(ary);\n  },\n\n  // allows for testing of the basic enumerable after an internal mutation\n  mutate: function(obj) {\n    obj.addObject(this.getFixture(1)[0]);\n  },\n\n  toArray: function(obj) {\n    return obj.slice();\n  }\n\n}).run();\n\ntest(\"the return value of slice has Ember.Array applied\", function(){\n  var x = Ember.Object.createWithMixins(Ember.Array, {\n    length: 0\n  });\n  var y = x.slice(1);\n  equal(Ember.Array.detect(y), true, \"mixin should be applied\");\n});\n\ntest(\"slice supports negative index arguments\", function(){\n  var testArray = new TestArray([1,2,3,4]);\n\n  deepEqual(testArray.slice(-2),      [3, 4],     'slice(-2)');\n  deepEqual(testArray.slice(-2, -1),  [3],        'slice(-2, -1');\n  deepEqual(testArray.slice(-2, -2),  [],         'slice(-2, -2)');\n  deepEqual(testArray.slice(-1, -2),  [],         'slice(-1, -2)');\n\n  deepEqual(testArray.slice(-4, 1),   [1],        'slice(-4, 1)');\n  deepEqual(testArray.slice(-4, 5),   [1,2,3,4],  'slice(-4, 5)');\n  deepEqual(testArray.slice(-4),      [1,2,3,4],  'slice(-4)');\n\n  deepEqual(testArray.slice(0, -1),   [1,2,3],    'slice(0, -1)');\n  deepEqual(testArray.slice(0, -4),   [],         'slice(0, -4)');\n  deepEqual(testArray.slice(0, -3),   [1],        'slice(0, -3)');\n\n});\n\n// ..........................................................\n// CONTENT DID CHANGE\n//\n\nvar DummyArray = Ember.Object.extend(Ember.Array, {\n  nextObject: function() {},\n  length: 0,\n  objectAt: function(idx) { return 'ITEM-'+idx; }\n});\n\nvar obj, observer;\n\n\n// ..........................................................\n// NOTIFY ARRAY OBSERVERS\n//\n\nmodule('mixins/array/arrayContent[Will|Did]Change');\n\ntest('should notify observers of []', function() {\n\n  obj = DummyArray.createWithMixins({\n    _count: 0,\n    enumerablePropertyDidChange: Ember.observer(function() {\n      this._count++;\n    }, '[]')\n  });\n\n  equal(obj._count, 0, 'should not have invoked yet');\n\n  obj.arrayContentWillChange(0, 1, 1);\n  obj.arrayContentDidChange(0, 1, 1);\n\n  equal(obj._count, 1, 'should have invoked');\n\n});\n\n// ..........................................................\n// NOTIFY CHANGES TO LENGTH\n//\n\nmodule('notify observers of length', {\n  setup: function() {\n    obj = DummyArray.createWithMixins({\n      _after: 0,\n      lengthDidChange: Ember.observer(function() {\n        this._after++;\n      }, 'length')\n\n    });\n\n    equal(obj._after, 0, 'should not have fired yet');\n  },\n\n  teardown: function() {\n    obj = null;\n  }\n});\n\ntest('should notify observers when call with no params', function() {\n  obj.arrayContentWillChange();\n  equal(obj._after, 0);\n\n  obj.arrayContentDidChange();\n  equal(obj._after, 1);\n});\n\n// API variation that included items only\ntest('should not notify when passed lengths are same', function() {\n  obj.arrayContentWillChange(0, 1, 1);\n  equal(obj._after, 0);\n\n  obj.arrayContentDidChange(0, 1, 1);\n  equal(obj._after, 0);\n});\n\ntest('should notify when passed lengths are different', function() {\n  obj.arrayContentWillChange(0, 1, 2);\n  equal(obj._after, 0);\n\n  obj.arrayContentDidChange(0, 1, 2);\n  equal(obj._after, 1);\n});\n\n\n// ..........................................................\n// NOTIFY ARRAY OBSERVER\n//\n\nmodule('notify array observers', {\n  setup: function() {\n    obj = DummyArray.create();\n\n    observer = Ember.Object.createWithMixins({\n      _before: null,\n      _after: null,\n\n      arrayWillChange: function() {\n        equal(this._before, null); // should only call once\n        this._before = Array.prototype.slice.call(arguments);\n      },\n\n      arrayDidChange: function() {\n        equal(this._after, null); // should only call once\n        this._after = Array.prototype.slice.call(arguments);\n      }\n    });\n\n    obj.addArrayObserver(observer);\n  },\n\n  teardown: function() {\n    obj = observer = null;\n  }\n});\n\ntest('should notify enumerable observers when called with no params', function() {\n  obj.arrayContentWillChange();\n  deepEqual(observer._before, [obj, 0, -1, -1]);\n\n  obj.arrayContentDidChange();\n  deepEqual(observer._after, [obj, 0, -1, -1]);\n});\n\n// API variation that included items only\ntest('should notify when called with same length items', function() {\n  obj.arrayContentWillChange(0, 1, 1);\n  deepEqual(observer._before, [obj, 0, 1, 1]);\n\n  obj.arrayContentDidChange(0, 1, 1);\n  deepEqual(observer._after, [obj, 0, 1, 1]);\n});\n\ntest('should notify when called with diff length items', function() {\n  obj.arrayContentWillChange(0, 2, 1);\n  deepEqual(observer._before, [obj, 0, 2, 1]);\n\n  obj.arrayContentDidChange(0, 2, 1);\n  deepEqual(observer._after, [obj, 0, 2, 1]);\n});\n\ntest('removing enumerable observer should disable', function() {\n  obj.removeArrayObserver(observer);\n  obj.arrayContentWillChange();\n  deepEqual(observer._before, null);\n\n  obj.arrayContentDidChange();\n  deepEqual(observer._after, null);\n});\n\n// ..........................................................\n// NOTIFY ENUMERABLE OBSERVER\n//\n\nmodule('notify enumerable observers as well', {\n  setup: function() {\n    obj = DummyArray.create();\n\n    observer = Ember.Object.createWithMixins({\n      _before: null,\n      _after: null,\n\n      enumerableWillChange: function() {\n        equal(this._before, null); // should only call once\n        this._before = Array.prototype.slice.call(arguments);\n      },\n\n      enumerableDidChange: function() {\n        equal(this._after, null); // should only call once\n        this._after = Array.prototype.slice.call(arguments);\n      }\n    });\n\n    obj.addEnumerableObserver(observer);\n  },\n\n  teardown: function() {\n    obj = observer = null;\n  }\n});\n\ntest('should notify enumerable observers when called with no params', function() {\n  obj.arrayContentWillChange();\n  deepEqual(observer._before, [obj, null, null], 'before');\n\n  obj.arrayContentDidChange();\n  deepEqual(observer._after, [obj, null, null], 'after');\n});\n\n// API variation that included items only\ntest('should notify when called with same length items', function() {\n  obj.arrayContentWillChange(0, 1, 1);\n  deepEqual(observer._before, [obj, ['ITEM-0'], 1], 'before');\n\n  obj.arrayContentDidChange(0, 1, 1);\n  deepEqual(observer._after, [obj, 1, ['ITEM-0']], 'after');\n});\n\ntest('should notify when called with diff length items', function() {\n  obj.arrayContentWillChange(0, 2, 1);\n  deepEqual(observer._before, [obj, ['ITEM-0', 'ITEM-1'], 1], 'before');\n\n  obj.arrayContentDidChange(0, 2, 1);\n  deepEqual(observer._after, [obj, 2, ['ITEM-0']], 'after');\n});\n\ntest('removing enumerable observer should disable', function() {\n  obj.removeEnumerableObserver(observer);\n  obj.arrayContentWillChange();\n  deepEqual(observer._before, null, 'before');\n\n  obj.arrayContentDidChange();\n  deepEqual(observer._after, null, 'after');\n});\n\n// ..........................................................\n// @each\n//\n\nvar ary;\n\nmodule('Ember.Array.@each support', {\n  setup: function() {\n    ary = new TestArray([\n      { isDone: true,  desc: 'Todo 1' },\n      { isDone: false, desc: 'Todo 2' },\n      { isDone: true,  desc: 'Todo 3' },\n      { isDone: false, desc: 'Todo 4' }\n    ]);\n  },\n\n  teardown: function() {\n    ary = null;\n  }\n});\n\ntest('adding an object should notify (@each)', function() {\n\n  var get = Ember.get, set = Ember.set;\n  var called = 0;\n\n  var observerObject = Ember.Object.create({\n    wasCalled: function() {\n      called++;\n    }\n  });\n\n  // Ember.get(ary, '@each');\n  Ember.addObserver(ary, '@each', observerObject, 'wasCalled');\n\n  ary.addObject(Ember.Object.create({\n    desc: \"foo\",\n    isDone: false\n  }));\n\n  equal(called, 1, \"calls observer when object is pushed\");\n\n});\n\ntest('adding an object should notify (@each.isDone)', function() {\n\n  var get = Ember.get, set = Ember.set;\n  var called = 0;\n\n  var observerObject = Ember.Object.create({\n    wasCalled: function() {\n      called++;\n    }\n  });\n\n  Ember.addObserver(ary, '@each.isDone', observerObject, 'wasCalled');\n\n  ary.addObject(Ember.Object.create({\n    desc: \"foo\",\n    isDone: false\n  }));\n\n  equal(called, 1, \"calls observer when object is pushed\");\n\n});\n\ntest('modifying the array should also indicate the isDone prop itself has changed', function() {\n  // NOTE: we never actually get the '@each.isDone' property here.  This is\n  // important because it tests the case where we don't have an isDone\n  // EachArray materialized but just want to know when the property has\n  // changed.\n\n  var get = Ember.get, set = Ember.set;\n  var each = get(ary, '@each');\n  var count = 0;\n\n  Ember.addObserver(each, 'isDone', function() { count++; });\n\n  count = 0;\n  var item = ary.objectAt(2);\n  set(item, 'isDone', !get(item, 'isDone'));\n  equal(count, 1, '@each.isDone should have notified');\n});\n\n\ntestBoth(\"should be clear caches for computed properties that have dependent keys on arrays that are changed after object initialization\", function(get, set) {\n  var obj = Ember.Object.createWithMixins({\n    init: function() {\n      set(this, 'resources', Ember.A());\n    },\n\n    common: Ember.computed(function() {\n      return get(get(this, 'resources').objectAt(0), 'common');\n    }).property('resources.@each.common')\n  });\n\n  get(obj, 'resources').pushObject(Ember.Object.create({ common: \"HI!\" }));\n  equal(\"HI!\", get(obj, 'common'));\n\n  set(get(obj, 'resources').objectAt(0), 'common', \"BYE!\");\n  equal(\"BYE!\", get(obj, 'common'));\n});\n\ntestBoth(\"observers that contain @each in the path should fire only once the first time they are accessed\", function(get, set) {\n  var count = 0;\n\n  var obj = Ember.Object.createWithMixins({\n    init: function() {\n      // Observer fires once when resources changes\n      set(this, 'resources', Ember.A());\n    },\n\n    commonDidChange: Ember.observer(function() {\n      count++;\n    }, 'resources.@each.common')\n  });\n\n  // Observer fires second time when new object is added\n  get(obj, 'resources').pushObject(Ember.Object.create({ common: \"HI!\" }));\n  // Observer fires third time when property on an object is changed\n  set(get(obj, 'resources').objectAt(0), 'common', \"BYE!\");\n\n  equal(count, 3, \"observers should only be called once\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/mixins/array_test");minispade.register('ember-runtime/~tests/mixins/comparable_test', "(function() {/*globals module test ok isObj equals expects */\n\nvar Rectangle = Ember.Object.extend(Ember.Comparable, {\n  length: 0,\n  width: 0,\n\n  area: function() {\n    return Ember.get(this,'length') * Ember.get(this, 'width');\n  },\n\n  compare: function(a, b) {\n    return Ember.compare(a.area(), b.area());\n  }\n\n});\n\nvar r1, r2;\n\nmodule(\"Comparable\", {\n\n  setup: function() {\n    r1 = Rectangle.create({length: 6, width: 12});\n    r2 = Rectangle.create({length: 6, width: 13});\n  },\n\n  teardown: function() {\n  }\n\n});\n\ntest(\"should be comparable and return the correct result\", function() {\n  equal(Ember.Comparable.detect(r1), true);\n  equal(Ember.compare(r1, r1), 0);\n  equal(Ember.compare(r1, r2), -1);\n  equal(Ember.compare(r2, r1), 1);\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/mixins/comparable_test");minispade.register('ember-runtime/~tests/mixins/copyable_test', "(function() {minispade.require('ember-runtime/~tests/suites/copyable');\n\n// NOTE: See debug/suites/copyable.js for mosts tests\n\nvar CopyableObject = Ember.Object.extend(Ember.Copyable, {\n\n  id: null,\n\n  init: function() {\n    this._super();\n    Ember.set(this, 'id', Ember.generateGuid());\n  },\n\n  copy: function() {\n    var ret = new CopyableObject();\n    Ember.set(ret, 'id', Ember.get(this, 'id'));\n    return ret;\n  }\n});\n\nEmber.CopyableTests.extend({\n\n  name: 'Ember.Copyable Basic Test',\n\n  newObject: function() {\n    return new CopyableObject();\n  },\n\n  isEqual: function(a, b) {\n    if (!(a instanceof CopyableObject) || !(b instanceof CopyableObject)) return false;\n    return Ember.get(a, 'id') === Ember.get(b,'id');\n  }\n}).run();\n\n})();\n//@ sourceURL=ember-runtime/~tests/mixins/copyable_test");minispade.register('ember-runtime/~tests/mixins/deferred_test', "(function() {module(\"Ember.DeferredMixin\");\n\ntest(\"can resolve deferred\", function() {\n\n  var deferred, count = 0;\n\n  Ember.run(function() {\n    deferred = Ember.Object.createWithMixins(Ember.DeferredMixin);\n  });\n\n  deferred.then(function() {\n    count++;\n  });\n\n  stop();\n  Ember.run(function() {\n    deferred.resolve();\n  });\n\n  setTimeout(function() {\n    start();\n    equal(count, 1, \"done callback was called\");\n  }, 20);\n});\n\ntest(\"can reject deferred\", function() {\n\n  var deferred, count = 0;\n\n  Ember.run(function() {\n    deferred = Ember.Object.createWithMixins(Ember.DeferredMixin);\n  });\n\n  deferred.then(function() {}, function() {\n    count++;\n  });\n\n  stop();\n  Ember.run(function() {\n    deferred.reject();\n  });\n\n  setTimeout(function() {\n    start();\n    equal(count, 1, \"fail callback was called\");\n  }, 20);\n});\n\ntest(\"can resolve with then\", function() {\n\n  var deferred, count1 = 0 ,count2 = 0;\n\n  Ember.run(function() {\n    deferred = Ember.Object.createWithMixins(Ember.DeferredMixin);\n  });\n\n  deferred.then(function() {\n    count1++;\n  }, function() {\n    count2++;\n  });\n\n  stop();\n  Ember.run(function() {\n    deferred.resolve();\n  });\n\n  setTimeout(function() {\n    start();\n    equal(count1, 1, \"then were resolved\");\n    equal(count2, 0, \"then was not rejected\");\n  }, 20);\n});\n\ntest(\"can reject with then\", function() {\n\n  var deferred, count1 = 0 ,count2 = 0;\n\n  Ember.run(function() {\n    deferred = Ember.Object.createWithMixins(Ember.DeferredMixin);\n  });\n\n  deferred.then(function() {\n    count1++;\n  }, function() {\n    count2++;\n  });\n\n  stop();\n  Ember.run(function() {\n    deferred.reject();\n  });\n\n  setTimeout(function() {\n    start();\n    equal(count1, 0, \"then was not resolved\");\n    equal(count2, 1, \"then were rejected\");\n  }, 20);\n});\n\ntest(\"can call resolve multiple times\", function() {\n\n  var deferred, count = 0;\n\n  Ember.run(function() {\n    deferred = Ember.Object.createWithMixins(Ember.DeferredMixin);\n  });\n\n  deferred.then(function() {\n    count++;\n  });\n\n  stop();\n  Ember.run(function() {\n    deferred.resolve();\n    deferred.resolve();\n    deferred.resolve();\n  });\n\n  setTimeout(function() {\n    start();\n    equal(count, 1, \"calling resolve multiple times has no effect\");\n  }, 20);\n});\n\ntest(\"resolve prevent reject\", function() {\n  var deferred, resolved = false, rejected = false, progress = 0;\n\n  Ember.run(function() {\n    deferred = Ember.Object.createWithMixins(Ember.DeferredMixin);\n  });\n\n  deferred.then(function() {\n    resolved = true;\n  }, function() {\n    rejected = true;\n  });\n\n  stop();\n  Ember.run(function() {\n    deferred.resolve();\n  });\n  Ember.run(function() {\n    deferred.reject();\n  });\n\n  setTimeout(function() {\n    start();\n    equal(resolved, true, \"is resolved\");\n    equal(rejected, false, \"is not rejected\");\n  }, 20);\n});\n\ntest(\"reject prevent resolve\", function() {\n  var deferred, resolved = false, rejected = false, progress = 0;\n\n  Ember.run(function() {\n    deferred = Ember.Object.createWithMixins(Ember.DeferredMixin);\n  });\n\n  deferred.then(function() {\n    resolved = true;\n  }, function() {\n    rejected = true;\n  });\n\n  stop();\n  Ember.run(function() {\n    deferred.reject();\n  });\n  Ember.run(function() {\n    deferred.resolve();\n  });\n\n  setTimeout(function() {\n    start();\n    equal(resolved, false, \"is not resolved\");\n    equal(rejected, true, \"is rejected\");\n  }, 20);\n});\n\ntest(\"will call callbacks if they are added after resolution\", function() {\n\n  var deferred, count1 = 0;\n\n  Ember.run(function() {\n    deferred = Ember.Object.createWithMixins(Ember.DeferredMixin);\n  });\n\n  stop();\n  Ember.run(function() {\n    deferred.resolve('toto');\n  });\n\n  Ember.run(function() {\n    deferred.then(function(context) {\n      if (context === 'toto') {\n        count1++;\n      }\n    });\n\n    deferred.then(function(context) {\n      if (context === 'toto') {\n        count1++;\n      }\n    });\n  });\n\n  setTimeout(function() {\n    start();\n    equal(count1, 2, \"callbacks called after resolution\");\n  }, 20);\n});\n\ntest(\"then is chainable\", function() {\n  var deferred, count = 0;\n\n  Ember.run(function() {\n    deferred = Ember.Object.createWithMixins(Ember.DeferredMixin);\n  });\n\n  deferred.then(function() {\n    eval('error'); // Use eval to pass JSHint\n  }).then(null, function() {\n    count++;\n  });\n\n  stop();\n  Ember.run(function() {\n    deferred.resolve();\n  });\n\n  setTimeout(function() {\n    start();\n    equal(count, 1, \"chained callback was called\");\n  }, 20);\n\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/mixins/deferred_test");minispade.register('ember-runtime/~tests/mixins/enumerable_test', "(function() {minispade.require('ember-runtime/~tests/suites/enumerable');\n\nvar indexOf = Ember.EnumerableUtils.indexOf;\n\n/*\n  Implement a basic fake enumerable.  This validates that any non-native\n  enumerable can impl this API.\n*/\nvar TestEnumerable = Ember.Object.extend(Ember.Enumerable, {\n\n  _content: null,\n\n  init: function(ary) {\n    this._content = ary || [];\n  },\n\n  addObject: function(obj) {\n    if (indexOf(this._content, obj)>=0) return this;\n    this._content.push(obj);\n    this.enumerableContentDidChange();\n  },\n\n  nextObject: function(idx) {\n    return idx >= Ember.get(this, 'length') ? undefined : this._content[idx];\n  },\n\n  length: Ember.computed(function() {\n    return this._content.length;\n  }),\n\n  slice: function() {\n    return this._content.slice();\n  }\n\n});\n\n\nEmber.EnumerableTests.extend({\n\n  name: 'Basic Enumerable',\n\n  newObject: function(ary) {\n    ary = ary ? ary.slice() : this.newFixture(3);\n    return new TestEnumerable(ary);\n  },\n\n  // allows for testing of the basic enumerable after an internal mutation\n  mutate: function(obj) {\n    obj.addObject(obj._content.length+1);\n  },\n\n  toArray: function(obj) {\n    return obj.slice();\n  }\n\n}).run();\n\ntest(\"should apply Ember.Array to return value of map\", function(){\n  var x = Ember.Object.createWithMixins(Ember.Enumerable);\n  var y = x.map(Ember.K);\n  equal(Ember.Array.detect(y), true, \"should have mixin applied\");\n});\n\ntest(\"should apply Ember.Array to return value of filter\", function(){\n  var x = Ember.Object.createWithMixins(Ember.Enumerable);\n  var y = x.filter(Ember.K);\n  equal(Ember.Array.detect(y), true, \"should have mixin applied\");\n});\n\ntest(\"should apply Ember.Array to return value of invoke\", function(){\n  var x = Ember.Object.createWithMixins(Ember.Enumerable);\n  var y = x.invoke(Ember.K);\n  equal(Ember.Array.detect(y), true, \"should have mixin applied\");\n});\n\ntest(\"should apply Ember.Array to return value of toArray\", function(){\n  var x = Ember.Object.createWithMixins(Ember.Enumerable);\n  var y = x.toArray(Ember.K);\n  equal(Ember.Array.detect(y), true, \"should have mixin applied\");\n});\n\ntest(\"should apply Ember.Array to return value of without\", function(){\n  var x = Ember.Object.createWithMixins(Ember.Enumerable, {\n    contains: function(){\n      return true;\n    }\n  });\n  var y = x.without(Ember.K);\n  equal(Ember.Array.detect(y), true, \"should have mixin applied\");\n});\n\ntest(\"should apply Ember.Array to return value of uniq\", function(){\n  var x = Ember.Object.createWithMixins(Ember.Enumerable);\n  var y = x.uniq(Ember.K);\n  equal(Ember.Array.detect(y), true, \"should have mixin applied\");\n});\n\n\n\n// ..........................................................\n// CONTENT DID CHANGE\n//\n\nvar DummyEnum = Ember.Object.extend(Ember.Enumerable, {\n  nextObject: function() {},\n  length: 0\n});\n\nvar obj, observer;\n\n// ..........................................................\n// NOTIFY ENUMERABLE PROPERTY\n//\n\nmodule('mixins/enumerable/enumerableContentDidChange');\n\ntest('should notify observers of []', function() {\n\n  var obj = Ember.Object.createWithMixins(Ember.Enumerable, {\n    nextObject: function() {}, // avoid exceptions\n\n    _count: 0,\n    enumerablePropertyDidChange: Ember.observer(function() {\n      this._count++;\n    }, '[]')\n  });\n\n  equal(obj._count, 0, 'should not have invoked yet');\n  obj.enumerableContentWillChange();\n  obj.enumerableContentDidChange();\n  equal(obj._count, 1, 'should have invoked');\n\n});\n\n// ..........................................................\n// NOTIFY CHANGES TO LENGTH\n//\n\nmodule('notify observers of length', {\n  setup: function() {\n    obj = DummyEnum.createWithMixins({\n      _after: 0,\n      lengthDidChange: Ember.observer(function() {\n        this._after++;\n      }, 'length')\n\n    });\n\n    equal(obj._after, 0, 'should not have fired yet');\n  },\n\n  teardown: function() {\n    obj = null;\n  }\n});\n\ntest('should notify observers when call with no params', function() {\n  obj.enumerableContentWillChange();\n  equal(obj._after, 0);\n\n  obj.enumerableContentDidChange();\n  equal(obj._after, 1);\n});\n\n// API variation that included items only\ntest('should not notify when passed arrays of same length', function() {\n  var added = ['foo'], removed = ['bar'];\n  obj.enumerableContentWillChange(removed, added);\n  equal(obj._after, 0);\n\n  obj.enumerableContentDidChange(removed, added);\n  equal(obj._after, 0);\n});\n\ntest('should notify when passed arrays of different length', function() {\n  var added = ['foo'], removed = ['bar', 'baz'];\n  obj.enumerableContentWillChange(removed, added);\n  equal(obj._after, 0);\n\n  obj.enumerableContentDidChange(removed, added);\n  equal(obj._after, 1);\n});\n\n// API variation passes indexes only\ntest('should not notify when passed with indexes', function() {\n  obj.enumerableContentWillChange(1, 1);\n  equal(obj._after, 0);\n\n  obj.enumerableContentDidChange(1, 1);\n  equal(obj._after, 0);\n});\n\ntest('should notify when passed old index API with delta', function() {\n  obj.enumerableContentWillChange(1, 2);\n  equal(obj._after, 0);\n\n  obj.enumerableContentDidChange(1, 2);\n  equal(obj._after, 1);\n});\n\n\n// ..........................................................\n// NOTIFY ENUMERABLE OBSERVER\n//\n\nmodule('notify enumerable observers', {\n  setup: function() {\n    obj = DummyEnum.create();\n\n    observer = Ember.Object.createWithMixins({\n      _before: null,\n      _after: null,\n\n      enumerableWillChange: function() {\n        equal(this._before, null); // should only call once\n        this._before = Array.prototype.slice.call(arguments);\n      },\n\n      enumerableDidChange: function() {\n        equal(this._after, null); // should only call once\n        this._after = Array.prototype.slice.call(arguments);\n      }\n    });\n\n    obj.addEnumerableObserver(observer);\n  },\n\n  teardown: function() {\n    obj = observer = null;\n  }\n});\n\ntest('should notify enumerable observers when called with no params', function() {\n  obj.enumerableContentWillChange();\n  deepEqual(observer._before, [obj, null, null]);\n\n  obj.enumerableContentDidChange();\n  deepEqual(observer._after, [obj, null, null]);\n});\n\n// API variation that included items only\ntest('should notify when called with same length items', function() {\n  var added = ['foo'], removed = ['bar'];\n  obj.enumerableContentWillChange(removed, added);\n  deepEqual(observer._before, [obj, removed, added]);\n\n  obj.enumerableContentDidChange(removed, added);\n  deepEqual(observer._after, [obj, removed, added]);\n});\n\ntest('should notify when called with diff length items', function() {\n  var added = ['foo', 'baz'], removed = ['bar'];\n  obj.enumerableContentWillChange(removed, added);\n  deepEqual(observer._before, [obj, removed, added]);\n\n  obj.enumerableContentDidChange(removed, added);\n  deepEqual(observer._after, [obj, removed, added]);\n});\n\ntest('should not notify when passed with indexes only', function() {\n  obj.enumerableContentWillChange(1, 2);\n  deepEqual(observer._before, [obj, 1, 2]);\n\n  obj.enumerableContentDidChange(1, 2);\n  deepEqual(observer._after, [obj, 1, 2]);\n});\n\ntest('removing enumerable observer should disable', function() {\n  obj.removeEnumerableObserver(observer);\n  obj.enumerableContentWillChange();\n  deepEqual(observer._before, null);\n\n  obj.enumerableContentDidChange();\n  deepEqual(observer._after, null);\n});\n\n\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/mixins/enumerable_test");minispade.register('ember-runtime/~tests/mixins/mutable_array_test', "(function() {minispade.require('ember-runtime/~tests/suites/mutable_array');\n\n/*\n  Implement a basic fake mutable array.  This validates that any non-native\n  enumerable can impl this API.\n*/\nvar TestMutableArray = Ember.Object.extend(Ember.MutableArray, {\n\n  _content: null,\n\n  init: function(ary) {\n    this._content = Ember.A(ary || []);\n  },\n\n  replace: function(idx, amt, objects) {\n\n    var args = objects ? objects.slice() : [],\n        removeAmt = amt,\n        addAmt    = args.length;\n\n    this.arrayContentWillChange(idx, removeAmt, addAmt);\n\n    args.unshift(amt);\n    args.unshift(idx);\n    this._content.splice.apply(this._content, args);\n    this.arrayContentDidChange(idx, removeAmt, addAmt);\n    return this;\n  },\n\n  objectAt: function(idx) {\n    return this._content[idx];\n  },\n\n  length: Ember.computed(function() {\n    return this._content.length;\n  }),\n\n  slice: function() {\n    return this._content.slice();\n  }\n\n});\n\n\nEmber.MutableArrayTests.extend({\n\n  name: 'Basic Mutable Array',\n\n  newObject: function(ary) {\n    ary = ary ? ary.slice() : this.newFixture(3);\n    return new TestMutableArray(ary);\n  },\n\n  // allows for testing of the basic enumerable after an internal mutation\n  mutate: function(obj) {\n    obj.addObject(this.getFixture(1)[0]);\n  },\n\n  toArray: function(obj) {\n    return obj.slice();\n  }\n\n}).run();\n\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/mixins/mutable_array_test");minispade.register('ember-runtime/~tests/mixins/mutable_enumerable_test', "(function() {minispade.require('ember-runtime/~tests/suites/mutable_enumerable');\n\nvar indexOf = Ember.EnumerableUtils.indexOf;\n\n/*\n  Implement a basic fake mutable array.  This validates that any non-native\n  enumerable can impl this API.\n*/\nvar TestMutableEnumerable = Ember.Object.extend(Ember.MutableEnumerable, {\n\n  _content: null,\n\n  addObject: function(obj) {\n    if (indexOf(this._content, obj)>=0) return this;\n    this.enumerableContentWillChange(null, [obj]);\n    this._content.push(obj);\n    this.enumerableContentDidChange(null, [obj]);\n  },\n\n  removeObject: function(obj) {\n    var idx = indexOf(this._content, obj);\n    if (idx<0) return this;\n\n    this.enumerableContentWillChange([obj], null);\n    this._content.splice(idx, 1);\n    this.enumerableContentDidChange([obj], null);\n    return this;\n  },\n\n  init: function(ary) {\n    this._content = ary || [];\n  },\n\n  nextObject: function(idx) {\n    return idx>=Ember.get(this, 'length') ? undefined : this._content[idx];\n  },\n\n  length: Ember.computed(function() {\n    return this._content.length;\n  }),\n\n  slice: function() {\n    return this._content.slice();\n  }\n});\n\n\nEmber.MutableEnumerableTests.extend({\n\n  name: 'Basic Mutable Array',\n\n  newObject: function(ary) {\n    ary = ary ? ary.slice() : this.newFixture(3);\n    return new TestMutableEnumerable(ary);\n  },\n\n  // allows for testing of the basic enumerable after an internal mutation\n  mutate: function(obj) {\n    obj.addObject(this.getFixture(1)[0]);\n  },\n\n  toArray: function(obj) {\n    return obj.slice();\n  }\n\n}).run();\n\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/mixins/mutable_enumerable_test");minispade.register('ember-runtime/~tests/mixins/observable_test', "(function() {module('mixins/observable');\n\ntest('should be able to use getProperties to get a POJO of provided keys', function() {\n  var obj = Ember.Object.create({\n    firstName: \"Steve\",\n    lastName: \"Jobs\",\n    companyName: \"Apple, Inc.\"\n  });\n\n  var pojo = obj.getProperties(\"firstName\", \"lastName\");\n  equal(\"Steve\", pojo.firstName);\n  equal(\"Jobs\", pojo.lastName);\n});\n\ntest('should be able to use getProperties with array parameter to get a POJO of provided keys', function() {\n  var obj = Ember.Object.create({\n    firstName: \"Steve\",\n    lastName: \"Jobs\",\n    companyName: \"Apple, Inc.\"\n  });\n\n  var pojo = obj.getProperties([\"firstName\", \"lastName\"]);\n  equal(\"Steve\", pojo.firstName);\n  equal(\"Jobs\", pojo.lastName);\n});\n\ntest('should be able to use setProperties to set multiple properties at once', function() {\n  var obj = Ember.Object.create({\n    firstName: \"Steve\",\n    lastName: \"Jobs\",\n    companyName: \"Apple, Inc.\"\n  });\n\n  obj.setProperties({firstName: \"Tim\", lastName: \"Cook\"});\n  equal(\"Tim\", obj.get(\"firstName\"));\n  equal(\"Cook\", obj.get(\"lastName\"));\n});\n\ntestBoth('calling setProperties completes safely despite exceptions', function(get,set) {\n  var exc = new Error(\"Something unexpected happened!\");\n  var obj = Ember.Object.createWithMixins({\n    firstName: \"Steve\",\n    lastName: \"Jobs\",\n    companyName: Ember.computed(function(key, value) {\n      if (value !== undefined) {\n        throw exc;\n      }\n      return \"Apple, Inc.\";\n    })\n  });\n\n  var firstNameChangedCount = 0;\n\n  Ember.addObserver(obj, 'firstName', function() { firstNameChangedCount++; });\n\n  try {\n    obj.setProperties({\n      firstName: 'Tim',\n      lastName: 'Cook',\n      companyName: 'Fruit Co., Inc.'\n    });\n  } catch(err) {\n    if (err !== exc) {\n      throw err;\n    }\n  }\n\n  equal(firstNameChangedCount, 1, 'firstName should have fired once');\n});\n\ntestBoth(\"should be able to retrieve cached values of computed properties without invoking the computed property\", function(get) {\n  var obj = Ember.Object.createWithMixins({\n    foo: Ember.computed(function() {\n      return \"foo\";\n    }),\n\n    bar: \"bar\"\n  });\n\n  equal(obj.cacheFor('foo'), undefined, \"should return undefined if no value has been cached\");\n  get(obj, 'foo');\n\n  equal(get(obj, 'foo'), \"foo\", \"precond - should cache the value\");\n  equal(obj.cacheFor('foo'), \"foo\", \"should return the cached value after it is invoked\");\n\n  equal(obj.cacheFor('bar'), undefined, \"returns undefined if the value is not a computed property\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/mixins/observable_test");minispade.register('ember-runtime/~tests/mixins/sortable_test', "(function() {var get = Ember.get, set = Ember.set;\n\nvar unsortedArray, sortedArrayController;\n\nmodule(\"Ember.Sortable\");\n\nmodule(\"Ember.Sortable with content\", {\n  setup: function() {\n    Ember.run(function() {\n      var array = [{ id: 1, name: \"Scumbag Dale\" }, { id: 2, name: \"Scumbag Katz\" }, { id: 3, name: \"Scumbag Bryn\" }];\n\n      unsortedArray = Ember.A(Ember.A(array).copy());\n\n      sortedArrayController = Ember.ArrayProxy.createWithMixins(Ember.SortableMixin, {\n        content: unsortedArray\n      });\n    });\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      sortedArrayController.set('content', null);\n      sortedArrayController.destroy();\n    });\n  }\n});\n\ntest(\"if you do not specify `sortProperties` sortable have no effect\", function() {\n  equal(sortedArrayController.get('length'), 3, 'array has 3 items');\n  equal(sortedArrayController.objectAt(0).name, 'Scumbag Dale', 'array is in it natural order');\n\n  unsortedArray.pushObject({id: 4, name: 'Scumbag Chavard'});\n\n  equal(sortedArrayController.get('length'), 4, 'array has 4 items');\n  equal(sortedArrayController.objectAt(3).name, 'Scumbag Chavard', 'a new object was inserted in the natural order');\n});\n\ntest(\"you can change sorted properties\", function() {\n  sortedArrayController.set('sortProperties', ['id']);\n\n  equal(sortedArrayController.objectAt(0).name, 'Scumbag Dale', 'array is sorted by id');\n  equal(sortedArrayController.get('length'), 3, 'array has 3 items');\n\n  sortedArrayController.set('sortAscending', false);\n\n  equal(sortedArrayController.objectAt(0).name, 'Scumbag Bryn', 'array is sorted by id in DESC order');\n  equal(sortedArrayController.objectAt(2).name, 'Scumbag Dale', 'array is sorted by id in DESC order');\n  equal(sortedArrayController.get('length'), 3, 'array has 3 items');\n\n  sortedArrayController.set('sortProperties', ['name']);\n\n  equal(sortedArrayController.objectAt(0).name, 'Scumbag Katz', 'array is sorted by name in DESC order');\n  equal(sortedArrayController.get('length'), 3, 'array has 3 items');\n});\n\ntest(\"changing sort order triggers observers\", function() {\n  var observer, changeCount = 0;\n  observer = Ember.Object.createWithMixins({\n    array: sortedArrayController,\n    arrangedDidChange: Ember.observer(function() {\n      changeCount++;\n    }, 'array.[]')\n  });\n\n  equal(changeCount, 0, 'precond - changeCount starts at 0');\n\n  sortedArrayController.set('sortProperties', ['id']);\n\n  equal(changeCount, 1, 'setting sortProperties increments changeCount');\n\n  sortedArrayController.set('sortAscending', false);\n\n  equal(changeCount, 2, 'changing sortAscending increments changeCount');\n\n  sortedArrayController.set('sortAscending', true);\n\n  equal(changeCount, 3, 'changing sortAscending again increments changeCount');\n\n  Ember.run(function() { observer.destroy(); });\n});\n\nmodule(\"Ember.Sortable with content and sortProperties\", {\n  setup: function() {\n    Ember.run(function() {\n      var array = [{ id: 1, name: \"Scumbag Dale\" }, { id: 2, name: \"Scumbag Katz\" }, { id: 3, name: \"Scumbag Bryn\" }];\n\n      unsortedArray = Ember.A(Ember.A(array).copy());\n\n      sortedArrayController = Ember.ArrayController.create({\n        content: unsortedArray,\n        sortProperties: ['name']\n      });\n    });\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      sortedArrayController.destroy();\n    });\n  }\n});\n\ntest(\"sortable object will expose associated content in the right order\", function() {\n  equal(sortedArrayController.get('length'), 3, 'array has 3 items');\n  equal(sortedArrayController.objectAt(0).name, 'Scumbag Bryn', 'array is sorted by name');\n});\n\ntest(\"you can add objects in sorted order\", function() {\n  equal(sortedArrayController.get('length'), 3, 'array has 3 items');\n\n  unsortedArray.pushObject({id: 4, name: 'Scumbag Chavard'});\n\n  equal(sortedArrayController.get('length'), 4, 'array has 4 items');\n  equal(sortedArrayController.objectAt(1).name, 'Scumbag Chavard', 'a new object added to content was inserted according to given constraint');\n\n  sortedArrayController.addObject({id: 5, name: 'Scumbag Fucs'});\n\n  equal(sortedArrayController.get('length'), 5, 'array has 5 items');\n  equal(sortedArrayController.objectAt(3).name, 'Scumbag Fucs', 'a new object added to controller was inserted according to given constraint');\n});\n\ntest(\"you can push objects in sorted order\", function() {\n  equal(sortedArrayController.get('length'), 3, 'array has 3 items');\n\n  unsortedArray.pushObject({id: 4, name: 'Scumbag Chavard'});\n\n  equal(sortedArrayController.get('length'), 4, 'array has 4 items');\n  equal(sortedArrayController.objectAt(1).name, 'Scumbag Chavard', 'a new object added to content was inserted according to given constraint');\n\n  sortedArrayController.pushObject({id: 5, name: 'Scumbag Fucs'});\n\n  equal(sortedArrayController.get('length'), 5, 'array has 5 items');\n  equal(sortedArrayController.objectAt(3).name, 'Scumbag Fucs', 'a new object added to controller was inserted according to given constraint');\n});\n\ntest(\"you can unshift objects in sorted order\", function() {\n  equal(sortedArrayController.get('length'), 3, 'array has 3 items');\n\n  unsortedArray.unshiftObject({id: 4, name: 'Scumbag Chavard'});\n\n  equal(sortedArrayController.get('length'), 4, 'array has 4 items');\n  equal(sortedArrayController.objectAt(1).name, 'Scumbag Chavard', 'a new object added to content was inserted according to given constraint');\n\n  sortedArrayController.addObject({id: 5, name: 'Scumbag Fucs'});\n\n  equal(sortedArrayController.get('length'), 5, 'array has 5 items');\n  equal(sortedArrayController.objectAt(3).name, 'Scumbag Fucs', 'a new object added to controller was inserted according to given constraint');\n});\n\ntest(\"addObject does not insert duplicates\", function() {\n  var sortedArrayProxy, obj = {};\n  sortedArrayProxy = Ember.ArrayProxy.createWithMixins(Ember.SortableMixin, {\n    content: Ember.A([obj])\n  });\n\n  equal(sortedArrayProxy.get('length'), 1, 'array has 1 item');\n\n  sortedArrayProxy.addObject(obj);\n\n  equal(sortedArrayProxy.get('length'), 1, 'array still has 1 item');\n});\n\ntest(\"you can change a sort property and the content will rearrenge\", function() {\n  equal(sortedArrayController.get('length'), 3, 'array has 3 items');\n  equal(sortedArrayController.objectAt(0).name, 'Scumbag Bryn', 'bryn is first');\n\n  set(sortedArrayController.objectAt(0), 'name', 'Scumbag Fucs');\n  equal(sortedArrayController.objectAt(0).name, 'Scumbag Dale', 'dale is first now');\n  equal(sortedArrayController.objectAt(1).name, 'Scumbag Fucs', 'foucs is second');\n});\n\ntest(\"you can change the position of the middle item\", function() {\n  equal(sortedArrayController.get('length'), 3, 'array has 3 items');\n\n  equal(sortedArrayController.objectAt(1).name, 'Scumbag Dale', 'Dale is second');\n  set(sortedArrayController.objectAt(1), 'name', 'Alice'); // Change Dale to Alice\n\n  equal(sortedArrayController.objectAt(0).name, 'Alice', 'Alice (previously Dale) is first now');\n});\n\ntest(\"don't remove and insert if position didn't change\", function() {\n  var insertItemSortedCalled = false;\n\n  sortedArrayController.reopen({\n    insertItemSorted: function(item) {\n      insertItemSortedCalled = true;\n      this._super(item);\n    }\n  });\n\n  sortedArrayController.set('sortProperties', ['name']);\n\n  Ember.set(sortedArrayController.objectAt(0), 'name', 'Scumbag Brynjolfsson');\n\n  ok(!insertItemSortedCalled, \"insertItemSorted should not have been called\");\n});\n\ntest(\"sortProperties observers removed on content removal\", function() {\n  var removedObject = unsortedArray.objectAt(2);\n  equal(Ember.listenersFor(removedObject, 'name:change').length, 1,\n    \"Before removal, there should be one listener for sortProperty change.\");\n  unsortedArray.replace(2, 1, []);\n  equal(Ember.listenersFor(removedObject, 'name:change').length, 0,\n    \"After removal, there should be no listeners for sortProperty change.\");\n});\n\nmodule(\"Ember.Sortable with sortProperties\", {\n  setup: function() {\n    Ember.run(function() {\n      sortedArrayController = Ember.ArrayController.create({\n        sortProperties: ['name']\n      });\n      var array = [{ id: 1, name: \"Scumbag Dale\" }, { id: 2, name: \"Scumbag Katz\" }, { id: 3, name: \"Scumbag Bryn\" }];\n      unsortedArray = Ember.A(Ember.A(array).copy());\n    });\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      sortedArrayController.destroy();\n    });\n  }\n});\n\ntest(\"you can set content later and it will be sorted\", function() {\n  equal(sortedArrayController.get('length'), 0, 'array has 0 items');\n\n  Ember.run(function() {\n    sortedArrayController.set('content', unsortedArray);\n  });\n\n  equal(sortedArrayController.get('length'), 3, 'array has 3 items');\n  equal(sortedArrayController.objectAt(0).name, 'Scumbag Bryn', 'array is sorted by name');\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/mixins/sortable_test");minispade.register('ember-runtime/~tests/mixins/target_action_support_test', "(function() {/*global Test:true*/\n\nvar originalLookup;\n\nmodule(\"Ember.TargetActionSupport\", {\n  setup: function() {\n    originalLookup = Ember.lookup;\n  },\n  teardown: function() {\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest(\"it should return false if no target or action are specified\", function() {\n  expect(1);\n\n  var obj = Ember.Object.createWithMixins(Ember.TargetActionSupport);\n\n  ok(false === obj.triggerAction(), \"no target or action was specified\");\n});\n\ntest(\"it should support actions specified as strings\", function() {\n  expect(2);\n\n  var obj = Ember.Object.createWithMixins(Ember.TargetActionSupport, {\n    target: Ember.Object.create({\n      anEvent: function() {\n        ok(true, \"anEvent method was called\");\n      }\n    }),\n\n    action: 'anEvent'\n  });\n\n  ok(true === obj.triggerAction(), \"a valid target and action were specified\");\n});\n\ntest(\"it should invoke the send() method on objects that implement it\", function() {\n  expect(2);\n\n  var obj = Ember.Object.createWithMixins(Ember.TargetActionSupport, {\n    target: Ember.Object.create({\n      send: function(evt) {\n        equal(evt, 'anEvent', \"send() method was invoked with correct event name\");\n      }\n    }),\n\n    action: 'anEvent'\n  });\n\n  ok(true === obj.triggerAction(), \"a valid target and action were specified\");\n});\n\ntest(\"it should find targets specified using a property path\", function() {\n  expect(2);\n\n  var Test = {};\n  Ember.lookup = { Test: Test };\n\n  Test.targetObj = Ember.Object.create({\n    anEvent: function() {\n      ok(true, \"anEvent method was called on global object\");\n    }\n  });\n\n  var myObj = Ember.Object.createWithMixins(Ember.TargetActionSupport, {\n    target: 'Test.targetObj',\n    action: 'anEvent'\n  });\n\n  ok(true === myObj.triggerAction(), \"a valid target and action were specified\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/mixins/target_action_support_test");minispade.register('ember-runtime/~tests/props_helper', "(function() {// used by unit tests to test both accessor mode and non-accessor mode\ntestBoth = function(testname, callback) {\n\n  function emberget(x,y) { return Ember.get(x,y); }\n  function emberset(x,y,z) { return Ember.set(x,y,z); }\n  function aget(x,y) { return x[y]; }\n  function aset(x,y,z) { return (x[y] = z); }\n\n  test(testname+' using Ember.get()/Ember.set()', function() {\n    callback(emberget, emberset);\n  });\n\n  test(testname+' using accessors', function() {\n    if (Ember.USES_ACCESSORS) callback(aget, aset);\n    else ok('SKIPPING ACCESSORS');\n  });\n};\n\ntestWithDefault = function(testname, callback) {\n  function get(x,y) { return x.get(y); }\n  function emberget(x,y) { return Ember.get(x,y); }\n  function embergetwithdefault(x,y,z) { return Ember.getWithDefault(x,y,z); }\n  function getwithdefault(x,y,z) { return x.getWithDefault(y,z); }\n  function emberset(x,y,z) { return Ember.set(x,y,z); }\n  function aget(x,y) { return x[y]; }\n  function aset(x,y,z) { return (x[y] = z); }\n\n  test(testname+' using obj.get()', function() {\n    callback(emberget, emberset);\n  });\n\n  test(testname+' using obj.getWithDefault()', function() {\n    callback(getwithdefault, emberset);\n  });\n\n  test(testname+' using Ember.get()', function() {\n    callback(emberget, emberset);\n  });\n\n  test(testname+' using Ember.getWithDefault()', function() {\n    callback(embergetwithdefault, emberset);\n  });\n\n  test(testname+' using accessors', function() {\n    if (Ember.USES_ACCESSORS) callback(aget, aset);\n    else ok('SKIPPING ACCESSORS');\n  });\n};\n\n})();\n//@ sourceURL=ember-runtime/~tests/props_helper");minispade.register('ember-runtime/~tests/suites/array', "(function() {minispade.require('ember-runtime/~tests/suites/enumerable');\n\n\n\nvar ObserverClass =   Ember.EnumerableTests.ObserverClass.extend({\n\n   observeArray: function(obj) {\n    obj.addArrayObserver(this);\n    return this;\n  },\n\n  stopObserveArray: function(obj) {\n    obj.removeArrayObserver(this);\n    return this;\n  },\n\n  arrayWillChange: function() {\n    equal(this._before, null, 'should only call once');\n    this._before = Array.prototype.slice.call(arguments);\n  },\n\n  arrayDidChange: function() {\n    equal(this._after, null, 'should only call once');\n    this._after = Array.prototype.slice.call(arguments);\n  }\n\n});\n\nEmber.ArrayTests = Ember.EnumerableTests.extend({\n\n  observerClass: ObserverClass\n\n});\n\nEmber.ArrayTests.ObserverClass = ObserverClass;\nminispade.require('ember-runtime/~tests/suites/array/indexOf');\nminispade.require('ember-runtime/~tests/suites/array/lastIndexOf');\nminispade.require('ember-runtime/~tests/suites/array/objectAt');\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/array");minispade.register('ember-runtime/~tests/suites/array/indexOf', "(function() {minispade.require('ember-runtime/~tests/suites/array');\n\nvar suite = Ember.ArrayTests;\n\nsuite.module('indexOf');\n\nsuite.test(\"should return index of object\", function() {\n  var expected = this.newFixture(3),\n      obj      = this.newObject(expected),\n      len      = 3,\n      idx;\n\n  for(idx=0;idx<len;idx++) {\n    equal(obj.indexOf(expected[idx]), idx, Ember.String.fmt('obj.indexOf(%@) should match idx', [expected[idx]]));\n  }\n\n});\n\nsuite.test(\"should return -1 when requesting object not in index\", function() {\n  var obj = this.newObject(this.newFixture(3)), foo = {};\n  equal(obj.indexOf(foo), -1, 'obj.indexOf(foo) should be < 0');\n});\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/array/indexOf");minispade.register('ember-runtime/~tests/suites/array/lastIndexOf', "(function() {minispade.require('ember-runtime/~tests/suites/array');\n\nvar suite = Ember.ArrayTests;\n\nsuite.module('lastIndexOf');\n\nsuite.test(\"should return index of object's last occurrence\", function() {\n  var expected = this.newFixture(3),\n      obj      = this.newObject(expected),\n      len      = 3,\n      idx;\n\n  for(idx=0;idx<len;idx++) {\n    equal(obj.lastIndexOf(expected[idx]), idx,\n      Ember.String.fmt('obj.lastIndexOf(%@) should match idx', [expected[idx]]));\n  }\n\n});\n\nsuite.test(\"should return index of object's last occurrence even startAt search location is equal to length\", function() {\n  var expected = this.newFixture(3),\n      obj      = this.newObject(expected),\n      len      = 3,\n      idx;\n\n  for(idx=0;idx<len;idx++) {\n    equal(obj.lastIndexOf(expected[idx], len), idx,\n      Ember.String.fmt('obj.lastIndexOfs(%@) should match idx', [expected[idx]]));\n  }\n\n});\n\nsuite.test(\"should return index of object's last occurrence even startAt search location is greater than length\", function() {\n  var expected = this.newFixture(3),\n      obj      = this.newObject(expected),\n      len      = 3,\n      idx;\n\n  for(idx=0;idx<len;idx++) {\n    equal(obj.lastIndexOf(expected[idx], len + 1), idx,\n      Ember.String.fmt('obj.lastIndexOf(%@) should match idx', [expected[idx]]));\n  }\n\n});\n\nsuite.test(\"should return -1 when no match is found\", function() {\n  var obj = this.newObject(this.newFixture(3)), foo = {};\n  equal(obj.lastIndexOf(foo), -1, 'obj.lastIndexOf(foo) should be -1');\n});\n\nsuite.test(\"should return -1 when no match is found even startAt search location is equal to length\", function() {\n  var obj = this.newObject(this.newFixture(3)), foo = {};\n  equal(obj.lastIndexOf(foo, obj.length), -1, 'obj.lastIndexOf(foo) should be -1');\n});\n\nsuite.test(\"should return -1 when no match is found even startAt search location is greater than length\", function() {\n  var obj = this.newObject(this.newFixture(3)), foo = {};\n  equal(obj.lastIndexOf(foo, obj.length + 1), -1, 'obj.lastIndexOf(foo) should be -1');\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/array/lastIndexOf");minispade.register('ember-runtime/~tests/suites/array/objectAt', "(function() {minispade.require('ember-runtime/~tests/suites/array');\n\nvar suite = Ember.ArrayTests;\n\nsuite.module('objectAt');\n\nsuite.test(\"should return object at specified index\", function() {\n  var expected = this.newFixture(3),\n      obj      = this.newObject(expected),\n      len      = expected.length,\n      idx;\n\n  for(idx=0;idx<len;idx++) {\n    equal(obj.objectAt(idx), expected[idx], Ember.String.fmt('obj.objectAt(%@) should match', [idx]));\n  }\n\n});\n\nsuite.test(\"should return undefined when requesting objects beyond index\", function() {\n  var obj;\n\n  obj = this.newObject(this.newFixture(3));\n  equal(obj.objectAt(5), undefined, 'should return undefined for obj.objectAt(5) when len = 3');\n\n  obj = this.newObject([]);\n  equal(obj.objectAt(0), undefined, 'should return undefined for obj.objectAt(0) when len = 0');\n});\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/array/objectAt");minispade.register('ember-runtime/~tests/suites/copyable', "(function() {minispade.require('ember-runtime/~tests/suites/suite');\n\nEmber.CopyableTests = Ember.Suite.extend({\n\n  /**\n    Must be able to create a new object for testing.\n\n    @returns {Object} object\n  */\n  newObject: Ember.required(Function),\n\n  /**\n    Compares the two passed in objects.  Returns true if the two objects\n    are logically equivalent.\n\n    @param {Object} a\n      First object\n\n    @param {Object} b\n      Second object\n\n    @returns {Boolean}\n  */\n  isEqual: Ember.required(Function),\n\n  /**\n    Set this to true if you expect the objects you test to be freezable.\n    The suite will verify that your objects actually match this.  (i.e. if\n    you say you can't test freezable it will verify that your objects really\n    aren't freezable.)\n\n    @type Boolean\n  */\n  shouldBeFreezable: false\n\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/copyable");minispade.register('ember-runtime/~tests/suites/copyable/copy', "(function() {minispade.require('ember-runtime/~tests/suites/copyable');\n\nvar suite = Ember.CopyableTests;\n\nsuite.module('copy');\n\nsuite.test(\"should return an equivalent copy\", function() {\n  var obj = this.newObject();\n  var copy = obj.copy();\n  ok(this.isEqual(obj, copy), 'old object and new object should be equivalent');\n});\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/copyable/copy");minispade.register('ember-runtime/~tests/suites/copyable/frozenCopy', "(function() {minispade.require('ember-runtime/~tests/suites/copyable');\n\nvar suite = Ember.CopyableTests;\n\nsuite.module('frozenCopy');\n\nsuite.test(\"frozen objects should return same instance\", function() {\n  var obj, copy;\n\n  obj = this.newObject();\n  if (Ember.get(this, 'shouldBeFreezable')) {\n    ok(!Ember.Freezable || Ember.Freezable.detect(obj), 'object should be freezable');\n\n    copy = obj.frozenCopy();\n    ok(this.isEqual(obj, copy), 'new copy should be equal');\n    ok(Ember.get(copy, 'isFrozen'), 'returned value should be frozen');\n\n    copy = obj.freeze().frozenCopy();\n    equal(copy, obj, 'returns frozen object should be same');\n    ok(Ember.get(copy, 'isFrozen'), 'returned object should be frozen');\n\n  } else {\n    ok(!Ember.Freezable || !Ember.Freezable.detect(obj), 'object should not be freezable');\n  }\n});\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/copyable/frozenCopy");minispade.register('ember-runtime/~tests/suites/enumerable', "(function() {var ObserverClass = Ember.Object.extend({\n\n  _keysBefore: null,\n  _keys: null,\n  _values: null,\n  _before : null,\n  _after: null,\n\n  isEnabled: true,\n\n  init: function() {\n    this._super();\n    this.reset();\n  },\n\n\n  propertyWillChange: function(target, key) {\n    if (this._keysBefore[key] === undefined) { this._keysBefore[key] = 0; }\n    this._keysBefore[key]++;\n  },\n\n  /**\n    Invoked when the property changes.  Just records the parameters for\n    later analysis.\n  */\n  propertyDidChange: function(target, key, value) {\n    if (this._keys[key] === undefined) { this._keys[key] = 0; }\n    this._keys[key]++;\n    this._values[key] = value;\n  },\n\n  /**\n    Resets the recorded results for another run.\n\n    @returns {Object} receiver\n  */\n  reset: function() {\n    this._keysBefore = {};\n    this._keys = {};\n    this._values = {};\n    this._before = null;\n    this._after = null;\n    return this;\n  },\n\n\n  observeBefore: function(obj) {\n    if (obj.addBeforeObserver) {\n      var keys = Array.prototype.slice.call(arguments, 1),\n          loc  = keys.length;\n      while(--loc>=0) obj.addBeforeObserver(keys[loc], this, 'propertyWillChange');\n    }\n    return this;\n  },\n\n  /**\n    Begins observing the passed key names on the passed object.  Any changes\n    on the named properties will be recorded.\n\n    @param {Ember.Enumerable} obj\n      The enumerable to observe.\n\n    @returns {Object} receiver\n  */\n  observe: function(obj) {\n    if (obj.addObserver) {\n      var keys = Array.prototype.slice.call(arguments, 1),\n          loc  = keys.length;\n      while(--loc>=0) obj.addObserver(keys[loc], this, 'propertyDidChange');\n    } else {\n      this.isEnabled = false;\n    }\n    return this;\n  },\n\n  /**\n    Returns true if the passed key was invoked.  If you pass a value as\n    well then validates that the values match.\n\n    @param {String} key\n      Key to validate\n\n    @param {Object} value\n      (Optional) value\n\n    @returns {Boolean}\n  */\n  validate: function(key, value) {\n    if (!this.isEnabled) return true;\n    if (!this._keys[key]) return false;\n    if (arguments.length>1) return this._values[key] === value;\n    else return true;\n  },\n\n  /**\n    Returns times the before observer as invoked.\n\n    @param {String} key\n      Key to check\n  */\n  timesCalledBefore: function(key) {\n    return this._keysBefore[key] || 0;\n  },\n\n  /**\n    Returns times the observer as invoked.\n\n    @param {String} key\n      Key to check\n  */\n  timesCalled: function(key) {\n    return this._keys[key] || 0;\n  },\n\n  /**\n    begins acting as an enumerable observer.\n  */\n  observeEnumerable: function(obj) {\n    obj.addEnumerableObserver(this);\n    return this;\n  },\n\n  stopObserveEnumerable: function(obj) {\n    obj.removeEnumerableObserver(this);\n    return this;\n  },\n\n  enumerableWillChange: function() {\n    equal(this._before, null, 'should only call once');\n    this._before = Array.prototype.slice.call(arguments);\n  },\n\n  enumerableDidChange: function() {\n    equal(this._after, null, 'should only call once');\n    this._after = Array.prototype.slice.call(arguments);\n  }\n\n});\n\n\n/**\n  Defines a test suite that can be used to test any object for compliance\n  with any enumerable.  To use, extend this object and define the required\n  methods to generate new object instances for testing, etc.\n\n  You can also add your own tests by defining new methods beginning with the\n  word 'test'\n*/\nvar EnumerableTests = Ember.Object.extend({\n\n  /**\n    Define a name for these tests - all modules are prefixed w/ it.\n\n    @type String\n  */\n  name: Ember.required(String),\n\n  /**\n    Implement to return a new enumerable object for testing.  Should accept\n    either no parameters, a single number (indicating the desired length of\n    the collection) or an array of objects.\n\n    @param {Array} content\n      An array of items to include in the enumerable optionally.\n\n    @returns {Ember.Enumerable} a new enumerable\n  */\n  newObject: Ember.required(Function),\n\n  /**\n    Implement to return a set of new fixture objects that can be applied to\n    the enumerable.  This may be passed into the newObject method.\n\n    @param {Number} count\n      The number of items required.\n\n    @returns {Array} array of items\n  */\n  newFixture: function(cnt) {\n    var ret = [];\n    while(--cnt>=0) ret.push(Ember.generateGuid());\n    return ret;\n  },\n\n  /**\n    Implement accept an instance of the enumerable and return an array\n    containing the objects in the enumerable.  This is used only for testing\n    so performance is not important.\n\n    @param {Ember.Enumerable} enumerable\n      The enumerable to convert.\n\n    @returns {Array} array of items\n  */\n  toArray: Ember.required(Function),\n\n  /**\n    Implement this method if your object can mutate internally (even if it\n    does not support the MutableEnumerable API).  The method should accept\n    an object of your desired type and modify it somehow.  Suite tests will\n    use this to ensure that all appropriate caches, etc. clear when the\n    mutation occurs.\n\n    If you do not define this optional method, then mutation-related tests\n    will be skipped.\n\n    @param {Ember.Enumerable} enumerable\n      The enumerable to mutate\n\n    @returns {void}\n  */\n  mutate: function(){},\n\n  /**\n    Becomes true when you define a new mutate() method, indicating that\n    mutation tests should run.  This is calculated automatically.\n\n    @type Boolean\n  */\n  canTestMutation: Ember.computed(function() {\n    return this.mutate !== EnumerableTests.prototype.mutate;\n  }),\n\n  /**\n    Invoked to actually run the test - overridden by mixins\n  */\n  run: function() {},\n\n\n  /**\n    Creates a new observer object for testing.  You can add this object as an\n    observer on an array and it will record results anytime it is invoked.\n    After running the test, call the validate() method on the observer to\n    validate the results.\n  */\n  newObserver: function(obj) {\n    var ret = Ember.get(this, 'observerClass').create();\n    if (arguments.length>0) ret.observeBefore.apply(ret, arguments);\n    if (arguments.length>0) ret.observe.apply(ret, arguments);\n    return ret;\n  },\n\n  observerClass: ObserverClass\n\n});\n\nEnumerableTests.reopenClass({\n\n  plan: null,\n\n  run: function() {\n    var C = this;\n    return new C().run();\n  },\n\n  module: function(desc, opts) {\n    if (!opts) opts = {};\n    var setup = opts.setup, teardown = opts.teardown;\n    this.reopen({\n      run: function() {\n        this._super();\n        var title = Ember.get(this,'name')+': '+desc, ctx = this;\n        module(title, {\n          setup: function() {\n            if (setup) setup.call(ctx);\n          },\n\n          teardown: function() {\n            if (teardown) teardown.call(ctx);\n          }\n        });\n      }\n    });\n  },\n\n  test: function(name, func) {\n    this.reopen({\n      run: function() {\n        this._super();\n        var ctx = this;\n        if (!func) test(name); // output warning\n        else test(name, function() { func.call(ctx); });\n      }\n    });\n  },\n\n  // convert to guids to minimize logging.\n  same: function(actual, exp, message) {\n    actual = (actual && actual.map) ? actual.map(function(x) { return Ember.guidFor(x); }) : actual;\n    exp = (exp && exp.map) ? exp.map(function(x) { return Ember.guidFor(x); }) : exp;\n    return deepEqual(actual, exp, message);\n  },\n\n  // easy way to disable tests\n  notest: function() {}\n\n});\n\nEmber.EnumerableTests = EnumerableTests;\nEmber.EnumerableTests.ObserverClass = ObserverClass;\nminispade.require('ember-runtime/~tests/suites/enumerable/compact');\nminispade.require('ember-runtime/~tests/suites/enumerable/contains');\nminispade.require('ember-runtime/~tests/suites/enumerable/every');\nminispade.require('ember-runtime/~tests/suites/enumerable/filter');\nminispade.require('ember-runtime/~tests/suites/enumerable/find');\nminispade.require('ember-runtime/~tests/suites/enumerable/firstObject');\nminispade.require('ember-runtime/~tests/suites/enumerable/forEach');\nminispade.require('ember-runtime/~tests/suites/enumerable/mapProperty');\nminispade.require('ember-runtime/~tests/suites/enumerable/invoke');\nminispade.require('ember-runtime/~tests/suites/enumerable/lastObject');\nminispade.require('ember-runtime/~tests/suites/enumerable/map');\nminispade.require('ember-runtime/~tests/suites/enumerable/reduce');\nminispade.require('ember-runtime/~tests/suites/enumerable/reject');\nminispade.require('ember-runtime/~tests/suites/enumerable/some');\nminispade.require('ember-runtime/~tests/suites/enumerable/toArray');\nminispade.require('ember-runtime/~tests/suites/enumerable/uniq');\nminispade.require('ember-runtime/~tests/suites/enumerable/without');\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/enumerable");minispade.register('ember-runtime/~tests/suites/enumerable/compact', "(function() {minispade.require('ember-runtime/~tests/suites/enumerable');\n\nvar suite = Ember.EnumerableTests;\n\nsuite.module('compact');\n\nsuite.test('removes null and undefined values from enumerable', function() {\n  var obj = this.newObject([null, 1, false, '', undefined, 0, null]);\n  var ary = obj.compact();\n  deepEqual(ary, [1, false, '', 0]);\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/enumerable/compact");minispade.register('ember-runtime/~tests/suites/enumerable/contains', "(function() {minispade.require('ember-runtime/~tests/suites/enumerable');\n\nvar suite = Ember.EnumerableTests;\n\nsuite.module('contains');\n\nsuite.test('contains returns true if items is in enumerable', function() {\n  var data = this.newFixture(3);\n  var obj  = this.newObject(data);\n  equal(obj.contains(data[1]), true, 'should return true if contained');\n});\n\nsuite.test('contains returns false if item is not in enumerable', function() {\n  var data = this.newFixture(1);\n  var obj  = this.newObject(this.newFixture(3));\n  equal(obj.contains(data[0]), false, 'should return false if not contained');\n});\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/enumerable/contains");minispade.register('ember-runtime/~tests/suites/enumerable/every', "(function() {minispade.require('ember-runtime/~tests/suites/enumerable');\n\nvar suite = Ember.EnumerableTests;\n\n// ..........................................................\n// every()\n//\n\nsuite.module('every');\n\nsuite.test('every should should invoke callback on each item as long as you return true', function() {\n  var obj = this.newObject(),\n      ary = this.toArray(obj),\n      found = [], result;\n\n  result = obj.every(function(i) { found.push(i); return true; });\n  equal(result, true, 'return value of obj.every');\n  deepEqual(found, ary, 'items passed during every() should match');\n});\n\nsuite.test('every should stop invoking when you return false', function() {\n  var obj = this.newObject(),\n      ary = this.toArray(obj),\n      cnt = ary.length - 2,\n      exp = cnt,\n      found = [], result;\n\n  result = obj.every(function(i) { found.push(i); return --cnt>0; });\n  equal(result, false, 'return value of obj.every');\n  equal(found.length, exp, 'should invoke proper number of times');\n  deepEqual(found, ary.slice(0,-2), 'items passed during every() should match');\n});\n\n// ..........................................................\n// everyProperty()\n//\n\nsuite.module('everyProperty');\n\nsuite.test('should return true of every property matches', function() {\n  var obj = this.newObject([\n    { foo: 'foo', bar: 'BAZ' },\n    Ember.Object.create({ foo: 'foo', bar: 'bar' })\n  ]);\n\n  equal(obj.everyProperty('foo', 'foo'), true, 'everyProperty(foo)');\n  equal(obj.everyProperty('bar', 'bar'), false, 'everyProperty(bar)');\n});\n\nsuite.test('should return true of every property is true', function() {\n  var obj = this.newObject([\n    { foo: 'foo', bar: true },\n    Ember.Object.create({ foo: 'bar', bar: false })\n  ]);\n\n  // different values - all eval to true\n  equal(obj.everyProperty('foo'), true, 'everyProperty(foo)');\n  equal(obj.everyProperty('bar'), false, 'everyProperty(bar)');\n});\n\nsuite.test('should return true if every property matches null', function() {\n  var obj = this.newObject([\n    { foo: null, bar: 'BAZ' },\n    Ember.Object.create({ foo: null, bar: null })\n  ]);\n\n  equal(obj.everyProperty('foo', null), true, \"everyProperty('foo', null)\");\n  equal(obj.everyProperty('bar', null), false, \"everyProperty('bar', null)\");\n});\n\nsuite.test('should return true if every property is undefined', function() {\n  var obj = this.newObject([\n    { foo: undefined, bar: 'BAZ' },\n    Ember.Object.create({ bar: undefined })\n  ]);\n\n  equal(obj.everyProperty('foo', undefined), true, \"everyProperty('foo', undefined)\");\n  equal(obj.everyProperty('bar', undefined), false, \"everyProperty('bar', undefined)\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/enumerable/every");minispade.register('ember-runtime/~tests/suites/enumerable/filter', "(function() {minispade.require('ember-runtime/~tests/suites/enumerable');\n\nvar suite = Ember.EnumerableTests;\n\n// ..........................................................\n// filter()\n//\n\nsuite.module('filter');\n\nsuite.test('filter should invoke on each item', function() {\n  var obj = this.newObject(),\n      ary = this.toArray(obj),\n      cnt = ary.length - 2,\n      found = [], result;\n\n  // return true on all but the last two\n  result = obj.filter(function(i) { found.push(i); return --cnt>=0; });\n  deepEqual(found, ary, 'should have invoked on each item');\n  deepEqual(result, ary.slice(0,-2), 'filtered array should exclude items');\n});\n\n// ..........................................................\n// filterProperty()\n//\n\nsuite.module('filterProperty');\n\nsuite.test('should filter based on object', function() {\n  var obj, ary;\n\n  ary = [\n    { foo: 'foo', bar: 'BAZ' },\n    Ember.Object.create({ foo: 'foo', bar: 'bar' })\n  ];\n\n  obj = this.newObject(ary);\n\n  deepEqual(obj.filterProperty('foo', 'foo'), ary, 'filterProperty(foo)');\n  deepEqual(obj.filterProperty('bar', 'bar'), [ary[1]], 'filterProperty(bar)');\n});\n\nsuite.test('should include in result if property is true', function() {\n  var obj, ary;\n\n  ary = [\n    { foo: 'foo', bar: true },\n    Ember.Object.create({ foo: 'bar', bar: false })\n  ];\n\n  obj = this.newObject(ary);\n\n  // different values - all eval to true\n  deepEqual(obj.filterProperty('foo'), ary, 'filterProperty(foo)');\n  deepEqual(obj.filterProperty('bar'), [ary[0]], 'filterProperty(bar)');\n});\n\nsuite.test('should filter on second argument if provided', function() {\n  var obj, ary;\n\n  ary = [\n    { name: 'obj1', foo: 3},\n    Ember.Object.create({ name: 'obj2', foo: 2}),\n    { name: 'obj3', foo: 2},\n    Ember.Object.create({ name: 'obj4', foo: 3})\n  ];\n\n  obj = this.newObject(ary);\n\n  deepEqual(obj.filterProperty('foo', 3), [ary[0], ary[3]], \"filterProperty('foo', 3)')\");\n});\n\nsuite.test('should correctly filter null second argument', function() {\n  var obj, ary;\n\n  ary = [\n    { name: 'obj1', foo: 3},\n    Ember.Object.create({ name: 'obj2', foo: null}),\n    { name: 'obj3', foo: null},\n    Ember.Object.create({ name: 'obj4', foo: 3})\n  ];\n\n  obj = this.newObject(ary);\n\n  deepEqual(obj.filterProperty('foo', null), [ary[1], ary[2]], \"filterProperty('foo', 3)')\");\n});\n\nsuite.test('should not return all objects on undefined second argument', function() {\n  var obj, ary;\n\n  ary = [\n    { name: 'obj1', foo: 3},\n    Ember.Object.create({ name: 'obj2', foo: 2})\n  ];\n\n  obj = this.newObject(ary);\n\n  deepEqual(obj.filterProperty('foo', undefined), [], \"filterProperty('foo', 3)')\");\n});\n\nsuite.test('should correctly filter explicit undefined second argument', function() {\n  var obj, ary;\n\n  ary = [\n    { name: 'obj1', foo: 3},\n    Ember.Object.create({ name: 'obj2', foo: 3}),\n    { name: 'obj3', foo: undefined},\n    Ember.Object.create({ name: 'obj4', foo: undefined}),\n    { name: 'obj5'},\n    Ember.Object.create({ name: 'obj6'})\n  ];\n\n  obj = this.newObject(ary);\n\n  deepEqual(obj.filterProperty('foo', undefined), ary.slice(2), \"filterProperty('foo', 3)')\");\n});\n\nsuite.test('should not match undefined properties without second argument', function() {\n  var obj, ary;\n\n  ary = [\n    { name: 'obj1', foo: 3},\n    Ember.Object.create({ name: 'obj2', foo: 3}),\n    { name: 'obj3', foo: undefined},\n    Ember.Object.create({ name: 'obj4', foo: undefined}),\n    { name: 'obj5'},\n    Ember.Object.create({ name: 'obj6'})\n  ];\n\n  obj = this.newObject(ary);\n\n  deepEqual(obj.filterProperty('foo'), ary.slice(0, 2), \"filterProperty('foo', 3)')\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/enumerable/filter");minispade.register('ember-runtime/~tests/suites/enumerable/find', "(function() {minispade.require('ember-runtime/~tests/suites/enumerable');\n\nvar suite = Ember.EnumerableTests;\n\n// ..........................................................\n// find()\n//\n\nsuite.module('find');\n\nsuite.test('find should invoke callback on each item as long as you return false', function() {\n  var obj = this.newObject(),\n      ary = this.toArray(obj),\n      found = [], result;\n\n  result = obj.find(function(i) { found.push(i); return false; });\n  equal(result, undefined, 'return value of obj.find');\n  deepEqual(found, ary, 'items passed during find() should match');\n});\n\nsuite.test('every should stop invoking when you return true', function() {\n  var obj = this.newObject(),\n      ary = this.toArray(obj),\n      cnt = ary.length - 2,\n      exp = cnt,\n      found = [], result;\n\n  result = obj.find(function(i) { found.push(i); return --cnt >= 0; });\n  equal(result, ary[exp-1], 'return value of obj.find');\n  equal(found.length, exp, 'should invoke proper number of times');\n  deepEqual(found, ary.slice(0,-2), 'items passed during find() should match');\n});\n\n// ..........................................................\n// findProperty()\n//\n\nsuite.module('findProperty');\n\nsuite.test('should return first object of property matches', function() {\n  var ary, obj;\n\n  ary = [\n    { foo: 'foo', bar: 'BAZ' },\n    Ember.Object.create({ foo: 'foo', bar: 'bar' })\n  ];\n\n  obj = this.newObject(ary);\n\n  equal(obj.findProperty('foo', 'foo'), ary[0], 'findProperty(foo)');\n  equal(obj.findProperty('bar', 'bar'), ary[1], 'findProperty(bar)');\n});\n\nsuite.test('should return first object with truthy prop', function() {\n  var ary, obj ;\n\n  ary = [\n    { foo: 'foo', bar: false },\n    Ember.Object.create({ foo: 'bar', bar: true })\n  ];\n\n  obj = this.newObject(ary);\n\n  // different values - all eval to true\n  equal(obj.findProperty('foo'), ary[0], 'findProperty(foo)');\n  equal(obj.findProperty('bar'), ary[1], 'findProperty(bar)');\n});\n\nsuite.test('should return first null property match', function() {\n  var ary, obj;\n\n  ary = [\n    { foo: null, bar: 'BAZ' },\n    Ember.Object.create({ foo: null, bar: null })\n  ];\n\n  obj = this.newObject(ary);\n\n  equal(obj.findProperty('foo', null), ary[0], \"findProperty('foo', null)\");\n  equal(obj.findProperty('bar', null), ary[1], \"findProperty('bar', null)\");\n});\n\nsuite.test('should return first undefined property match', function() {\n  var ary, obj;\n\n  ary = [\n    { foo: undefined, bar: 'BAZ' },\n    Ember.Object.create({ })\n  ];\n\n  obj = this.newObject(ary);\n\n  equal(obj.findProperty('foo', undefined), ary[0], \"findProperty('foo', undefined)\");\n  equal(obj.findProperty('bar', undefined), ary[1], \"findProperty('bar', undefined)\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/enumerable/find");minispade.register('ember-runtime/~tests/suites/enumerable/firstObject', "(function() {minispade.require('ember-runtime/~tests/suites/enumerable');\n\nvar suite = Ember.EnumerableTests;\n\nsuite.module('firstObject');\n\nsuite.test('returns first item in enumerable', function() {\n  var obj = this.newObject();\n  equal(Ember.get(obj, 'firstObject'), this.toArray(obj)[0]);\n});\n\nsuite.test('returns undefined if enumerable is empty', function() {\n  var obj = this.newObject([]);\n  equal(Ember.get(obj, 'firstObject'), undefined);\n});\n})();\n//@ sourceURL=ember-runtime/~tests/suites/enumerable/firstObject");minispade.register('ember-runtime/~tests/suites/enumerable/forEach', "(function() {minispade.require('ember-runtime/~tests/suites/enumerable');\n\nvar suite = Ember.EnumerableTests, global = this;\n\nsuite.module('forEach');\n\nsuite.test('forEach should iterate over list', function() {\n  var obj = this.newObject(),\n      ary = this.toArray(obj),\n      found = [];\n\n  obj.forEach(function(i) { found.push(i); });\n  deepEqual(found, ary, 'items passed during forEach should match');\n});\n\n\nsuite.test('forEach should iterate over list after mutation', function() {\n  if (Ember.get(this, 'canTestMutation')) {\n    expect(0);\n    return ;\n  }\n\n  var obj = this.newObject(),\n      ary = this.toArray(obj),\n      found = [];\n\n  obj.forEach(function(i) { found.push(i); });\n  deepEqual(found, ary, 'items passed during forEach should match');\n\n  this.mutate(obj);\n  ary = this.toArray(obj);\n  found = [];\n\n  obj.forEach(function(i) { found.push(i); });\n  deepEqual(found, ary, 'items passed during forEach should match');\n});\n\nsuite.test('2nd target parameter', function() {\n  var obj = this.newObject(), target = this;\n\n  obj.forEach(function() {\n    equal(Ember.guidFor(this), Ember.guidFor(global), 'should pass the global object as this if no context');\n  });\n\n  obj.forEach(function() {\n    equal(Ember.guidFor(this), Ember.guidFor(target), 'should pass target as this if context');\n  }, target);\n\n});\n\n\nsuite.test('callback params', function() {\n  var obj = this.newObject(),\n      ary = this.toArray(obj),\n      loc = 0;\n\n\n  obj.forEach(function(item, idx, enumerable) {\n    equal(item, ary[loc], 'item param');\n    equal(idx, loc, 'idx param');\n    equal(Ember.guidFor(enumerable), Ember.guidFor(obj), 'enumerable param');\n    loc++;\n  });\n\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/enumerable/forEach");minispade.register('ember-runtime/~tests/suites/enumerable/invoke', "(function() {minispade.require('ember-runtime/~tests/suites/enumerable');\n\nvar suite = Ember.EnumerableTests;\n\nsuite.module('invoke');\n\nsuite.test('invoke should call on each object that implements', function() {\n  var cnt, ary, obj;\n\n  function F(amt) {\n    cnt += amt===undefined ? 1 : amt;\n  }\n  cnt = 0;\n  ary = [\n    { foo: F },\n    Ember.Object.create({ foo: F }),\n\n    // NOTE: does not impl foo - invoke should just skip\n    Ember.Object.create({ bar: F }),\n\n    { foo: F }\n  ];\n\n  obj = this.newObject(ary);\n  obj.invoke('foo');\n  equal(cnt, 3, 'should have invoked 3 times');\n\n  cnt = 0;\n  obj.invoke('foo', 2);\n  equal(cnt, 6, 'should have invoked 3 times, passing param');\n});\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/enumerable/invoke");minispade.register('ember-runtime/~tests/suites/enumerable/lastObject', "(function() {minispade.require('ember-runtime/~tests/suites/enumerable');\n\nvar suite = Ember.EnumerableTests;\n\nsuite.module('lastObject');\n\nsuite.test('returns last item in enumerable', function() {\n  var obj = this.newObject(),\n      ary = this.toArray(obj);\n  equal(Ember.get(obj, 'lastObject'), ary[ary.length-1]);\n});\n\nsuite.test('returns undefined if enumerable is empty', function() {\n  var obj = this.newObject([]);\n  equal(Ember.get(obj, 'lastObject'), undefined);\n});\n})();\n//@ sourceURL=ember-runtime/~tests/suites/enumerable/lastObject");minispade.register('ember-runtime/~tests/suites/enumerable/map', "(function() {minispade.require('ember-runtime/~tests/suites/enumerable');\n\nvar suite = Ember.EnumerableTests, global = this;\n\nsuite.module('map');\n\nfunction mapFunc(item) { return item ? item.toString() : null; }\n\nsuite.test('map should iterate over list', function() {\n  var obj = this.newObject(),\n      ary = Ember.EnumerableUtils.map(this.toArray(obj), mapFunc),\n      found = [];\n\n  found = obj.map(mapFunc);\n  deepEqual(found, ary, 'mapped arrays should match');\n});\n\n\nsuite.test('map should iterate over list after mutation', function() {\n  if (Ember.get(this, 'canTestMutation')) {\n    expect(0);\n    return ;\n  }\n\n  var obj = this.newObject(),\n      ary = this.toArray(obj).map(mapFunc),\n      found;\n\n  found = obj.map(mapFunc);\n  deepEqual(found, ary, 'items passed during forEach should match');\n\n  this.mutate(obj);\n  ary = this.toArray(obj).map(mapFunc);\n  found = obj.map(mapFunc);\n  deepEqual(found, ary, 'items passed during forEach should match');\n});\n\nsuite.test('2nd target parameter', function() {\n  var obj = this.newObject(), target = this;\n\n\n  obj.map(function() {\n    equal(Ember.guidFor(this), Ember.guidFor(global), 'should pass the global object as this if no context');\n  });\n\n  obj.map(function() {\n    equal(Ember.guidFor(this), Ember.guidFor(target), 'should pass target as this if context');\n  }, target);\n\n});\n\n\nsuite.test('callback params', function() {\n  var obj = this.newObject(),\n      ary = this.toArray(obj),\n      loc = 0;\n\n\n  obj.map(function(item, idx, enumerable) {\n    equal(item, ary[loc], 'item param');\n    equal(idx, loc, 'idx param');\n    equal(Ember.guidFor(enumerable), Ember.guidFor(obj), 'enumerable param');\n    loc++;\n  });\n\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/enumerable/map");minispade.register('ember-runtime/~tests/suites/enumerable/mapProperty', "(function() {minispade.require('ember-runtime/~tests/suites/enumerable');\n\nvar suite = Ember.EnumerableTests;\n\nsuite.module('mapProperty');\n\nsuite.test('get value of each property', function() {\n  var obj = this.newObject([{a: 1},{a: 2}]);\n  equal(obj.mapProperty('a').join(''), '12');\n});\n\nsuite.test('should work also through getEach alias', function() {\n  var obj = this.newObject([{a: 1},{a: 2}]);\n  equal(obj.getEach('a').join(''), '12');\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/enumerable/mapProperty");minispade.register('ember-runtime/~tests/suites/enumerable/reduce', "(function() {minispade.require('ember-runtime/~tests/suites/enumerable');\n\nvar suite = Ember.EnumerableTests;\n\nsuite.module('reduce');\n\nsuite.test('collectes a summary value from an enumeration', function() {\n  var obj = this.newObject([1, 2, 3]);\n  var res = obj.reduce(function(previousValue, item, index, enumerable) { return previousValue + item; }, 0);\n  equal(res, 6);\n});\n\nsuite.test('passes index of item to callback', function() {\n  var obj = this.newObject([1, 2, 3]);\n  var res = obj.reduce(function(previousValue, item, index, enumerable) { return previousValue + index; }, 0);\n  equal(res, 3);\n});\n\nsuite.test('passes enumerable object to callback', function() {\n  var obj = this.newObject([1, 2, 3]);\n  var res = obj.reduce(function(previousValue, item, index, enumerable) { return enumerable; }, 0);\n  equal(res, obj);\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/enumerable/reduce");minispade.register('ember-runtime/~tests/suites/enumerable/reject', "(function() {minispade.require('ember-runtime/~tests/suites/enumerable');\n\nvar suite = Ember.EnumerableTests;\n\n// ..........................................................\n// reject()\n//\n\nsuite.module('reject');\n\nsuite.test('should reject any item that does not meet the condition', function() {\n  var obj = this.newObject([1,2,3,4]),\n      result;\n\n  result = obj.reject(function(i) { return i < 3; });\n  deepEqual(result, [3,4], 'reject the correct items');\n});\n\nsuite.test('should be the inverse of filter', function() {\n  var obj = this.newObject([1,2,3,4]),\n      isEven = function(i) { return i % 2 === 0; },\n      filtered, rejected;\n\n  filtered = obj.filter(isEven);\n  rejected = obj.reject(isEven);\n\n  deepEqual(filtered, [2,4], 'filtered evens');\n  deepEqual(rejected, [1,3], 'rejected evens');\n});\n\n// ..........................................................\n// rejectProperty()\n//\n\nsuite.module('rejectProperty');\n\nsuite.test('should reject based on object', function() {\n  var obj, ary;\n\n  ary = [\n    { foo: 'foo', bar: 'BAZ' },\n    Ember.Object.create({ foo: 'foo', bar: 'bar' })\n  ];\n\n  obj = this.newObject(ary);\n\n  deepEqual(obj.rejectProperty('foo', 'foo'), [], 'rejectProperty(foo)');\n  deepEqual(obj.rejectProperty('bar', 'bar'), [ary[0]], 'rejectProperty(bar)');\n});\n\nsuite.test('should include in result if property is false', function() {\n  var obj, ary;\n\n  ary = [\n    { foo: false, bar: true },\n    Ember.Object.create({ foo: false, bar: false })\n  ];\n\n  obj = this.newObject(ary);\n\n  deepEqual(obj.rejectProperty('foo'), ary, 'rejectProperty(foo)');\n  deepEqual(obj.rejectProperty('bar'), [ary[1]], 'rejectProperty(bar)');\n});\n\nsuite.test('should reject on second argument if provided', function() {\n  var obj, ary;\n\n  ary = [\n    { name: 'obj1', foo: 3},\n    Ember.Object.create({ name: 'obj2', foo: 2}),\n    { name: 'obj3', foo: 2},\n    Ember.Object.create({ name: 'obj4', foo: 3})\n  ];\n\n  obj = this.newObject(ary);\n\n  deepEqual(obj.rejectProperty('foo', 3), [ary[1], ary[2]], \"rejectProperty('foo', 3)')\");\n});\n\nsuite.test('should correctly reject null second argument', function() {\n  var obj, ary;\n\n  ary = [\n    { name: 'obj1', foo: 3},\n    Ember.Object.create({ name: 'obj2', foo: null}),\n    { name: 'obj3', foo: null},\n    Ember.Object.create({ name: 'obj4', foo: 3})\n  ];\n\n  obj = this.newObject(ary);\n\n  deepEqual(obj.rejectProperty('foo', null), [ary[0], ary[3]], \"rejectProperty('foo', null)')\");\n});\n\nsuite.test('should correctly reject undefined second argument', function() {\n  var obj, ary;\n\n  ary = [\n    { name: 'obj1', foo: 3},\n    Ember.Object.create({ name: 'obj2', foo: 2})\n  ];\n\n  obj = this.newObject(ary);\n\n  deepEqual(obj.rejectProperty('bar', undefined), [], \"rejectProperty('bar', undefined)')\");\n});\n\nsuite.test('should correctly reject explicit undefined second argument', function() {\n  var obj, ary;\n\n  ary = [\n    { name: 'obj1', foo: 3},\n    Ember.Object.create({ name: 'obj2', foo: 3}),\n    { name: 'obj3', foo: undefined},\n    Ember.Object.create({ name: 'obj4', foo: undefined}),\n    { name: 'obj5'},\n    Ember.Object.create({ name: 'obj6'})\n  ];\n\n  obj = this.newObject(ary);\n\n  deepEqual(obj.rejectProperty('foo', undefined), ary.slice(0, 2), \"rejectProperty('foo', undefined)')\");\n});\n\nsuite.test('should match undefined, null, or false properties without second argument', function() {\n  var obj, ary;\n\n  ary = [\n    { name: 'obj1', foo: 3},\n    Ember.Object.create({ name: 'obj2', foo: 3}),\n    { name: 'obj3', foo: undefined},\n    Ember.Object.create({ name: 'obj4', foo: undefined}),\n    { name: 'obj5'},\n    Ember.Object.create({ name: 'obj6'}),\n    { name: 'obj7', foo: null },\n    Ember.Object.create({ name: 'obj8', foo: null }),\n    { name: 'obj9', foo: false },\n    Ember.Object.create({ name: 'obj10', foo: false })\n  ];\n\n  obj = this.newObject(ary);\n\n  deepEqual(obj.rejectProperty('foo'), ary.slice(2), \"rejectProperty('foo')')\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/enumerable/reject");minispade.register('ember-runtime/~tests/suites/enumerable/some', "(function() {minispade.require('ember-runtime/~tests/suites/enumerable');\n\nvar suite = Ember.EnumerableTests;\n\n// ..........................................................\n// some()\n//\n\nsuite.module('some');\n\nsuite.test('some should should invoke callback on each item as long as you return false', function() {\n  var obj = this.newObject(),\n      ary = this.toArray(obj),\n      found = [], result;\n\n  result = obj.some(function(i) { found.push(i); return false; });\n  equal(result, false, 'return value of obj.some');\n  deepEqual(found, ary, 'items passed during some() should match');\n});\n\nsuite.test('every should stop invoking when you return true', function() {\n  var obj = this.newObject(),\n      ary = this.toArray(obj),\n      cnt = ary.length - 2,\n      exp = cnt,\n      found = [], result;\n\n  result = obj.some(function(i) { found.push(i); return --cnt <= 0; });\n  equal(result, true, 'return value of obj.some');\n  equal(found.length, exp, 'should invoke proper number of times');\n  deepEqual(found, ary.slice(0,-2), 'items passed during some() should match');\n});\n\n// ..........................................................\n// someProperty()\n//\n\nsuite.module('someProperty');\n\nsuite.test('should return true of any property matches', function() {\n  var obj = this.newObject([\n    { foo: 'foo', bar: 'BAZ' },\n    Ember.Object.create({ foo: 'foo', bar: 'bar' })\n  ]);\n\n  equal(obj.someProperty('foo', 'foo'), true, 'someProperty(foo)');\n  equal(obj.someProperty('bar', 'bar'), true, 'someProperty(bar)');\n  equal(obj.someProperty('bar', 'BIFF'), false, 'someProperty(BIFF)');\n});\n\nsuite.test('should return true of any property is true', function() {\n  var obj = this.newObject([\n    { foo: 'foo', bar: true },\n    Ember.Object.create({ foo: 'bar', bar: false })\n  ]);\n\n  // different values - all eval to true\n  equal(obj.someProperty('foo'), true, 'someProperty(foo)');\n  equal(obj.someProperty('bar'), true, 'someProperty(bar)');\n  equal(obj.someProperty('BIFF'), false, 'someProperty(biff)');\n});\n\nsuite.test('should return true if any property matches null', function() {\n  var obj = this.newObject([\n    { foo: null, bar: 'bar' },\n    Ember.Object.create({ foo: 'foo', bar: null })\n  ]);\n\n  equal(obj.someProperty('foo', null), true, \"someProperty('foo', null)\");\n  equal(obj.someProperty('bar', null), true, \"someProperty('bar', null)\");\n});\n\nsuite.test('should return true if any property is undefined', function() {\n  var obj = this.newObject([\n    { foo: undefined, bar: 'bar' },\n    Ember.Object.create({ foo: 'foo' })\n  ]);\n\n  equal(obj.someProperty('foo', undefined), true, \"someProperty('foo', undefined)\");\n  equal(obj.someProperty('bar', undefined), true, \"someProperty('bar', undefined)\");\n});\n\nsuite.test('should not match undefined properties without second argument', function() {\n  var obj = this.newObject([\n    { foo: undefined },\n    Ember.Object.create({ })\n  ]);\n\n  equal(obj.someProperty('foo'), false, \"someProperty('foo', undefined)\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/enumerable/some");minispade.register('ember-runtime/~tests/suites/enumerable/toArray', "(function() {minispade.require('ember-runtime/~tests/suites/enumerable');\n\nvar suite = Ember.EnumerableTests;\n\nsuite.module('toArray');\n\nsuite.test('toArray should convert to an array', function() {\n  var obj = this.newObject();\n  deepEqual(obj.toArray(), this.toArray(obj));\n});\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/enumerable/toArray");minispade.register('ember-runtime/~tests/suites/enumerable/uniq', "(function() {minispade.require('ember-runtime/~tests/suites/enumerable');\n\nvar suite = Ember.EnumerableTests;\n\nsuite.module('uniq');\n\nsuite.test('should return new instance with duplicates removed', function() {\n  var before, after, obj, ret;\n\n  after  = this.newFixture(3);\n  before = [after[0], after[1], after[2], after[1], after[0]];\n  obj    = this.newObject(before);\n  before = obj.toArray(); // in case of set before will be different...\n\n  ret = obj.uniq();\n  deepEqual(this.toArray(ret), after, 'should have removed item');\n  deepEqual(this.toArray(obj), before, 'should not have changed original');\n});\n\nsuite.test('should return duplicate of same content if no duplicates found', function() {\n  var item, obj, ret;\n  obj = this.newObject(this.newFixture(3));\n  ret = obj.uniq(item);\n  ok(ret !== obj, 'should not be same object');\n  deepEqual(this.toArray(ret), this.toArray(obj), 'should be the same content');\n});\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/enumerable/uniq");minispade.register('ember-runtime/~tests/suites/enumerable/without', "(function() {minispade.require('ember-runtime/~tests/suites/enumerable');\n\nvar suite = Ember.EnumerableTests;\n\nsuite.module('without');\n\nsuite.test('should return new instance with item removed', function() {\n  var before, after, obj, ret;\n\n  before = this.newFixture(3);\n  after  = [before[0], before[2]];\n  obj    = this.newObject(before);\n\n  ret = obj.without(before[1]);\n  deepEqual(this.toArray(ret), after, 'should have removed item');\n  deepEqual(this.toArray(obj), before, 'should not have changed original');\n});\n\nsuite.test('should return same instance if object not found', function() {\n  var item, obj, ret;\n\n  item   = this.newFixture(1)[0];\n  obj    = this.newObject(this.newFixture(3));\n\n  ret = obj.without(item);\n  equal(ret, obj, 'should be same instance');\n});\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/enumerable/without");minispade.register('ember-runtime/~tests/suites/mutable_array', "(function() {minispade.require('ember-runtime/~tests/suites/array');\n\nEmber.MutableArrayTests = Ember.ArrayTests.extend();\nminispade.require('ember-runtime/~tests/suites/mutable_array/insertAt');\nminispade.require('ember-runtime/~tests/suites/mutable_array/popObject');\nminispade.require('ember-runtime/~tests/suites/mutable_array/pushObject');\nminispade.require('ember-runtime/~tests/suites/mutable_array/removeAt');\nminispade.require('ember-runtime/~tests/suites/mutable_array/replace');\nminispade.require('ember-runtime/~tests/suites/mutable_array/shiftObject');\nminispade.require('ember-runtime/~tests/suites/mutable_array/unshiftObject');\nminispade.require('ember-runtime/~tests/suites/mutable_array/reverseObjects');\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/mutable_array");minispade.register('ember-runtime/~tests/suites/mutable_array/addObject', "(function() {minispade.require('ember-runtime/~tests/suites/mutable_array');\n\nvar suite = Ember.MutableArrayTests;\n\nsuite.module('addObject');\n\nsuite.test(\"should return receiver\", function() {\n  var before, obj;\n  before = this.newFixture(3);\n  obj    = this.newObject(before);\n  equal(obj.addObject(before[1]), obj, 'should return receiver');\n});\n\nsuite.test(\"[A,B].addObject(C) => [A,B,C] + notify\", function() {\n  var obj, before, after, observer, item;\n\n  before = this.newFixture(2);\n  item   = this.newFixture(1)[0];\n  after  = [before[0], before[1], item];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.addObject(item);\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n    equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n    equal(observer.timesCalled('length'), 1, 'should have notified length once');\n    equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');\n\n    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');\n  }\n});\n\nsuite.test(\"[A,B,C].addObject(A) => [A,B,C] + NO notify\", function() {\n  var obj, before, after, observer, item;\n\n  before = this.newFixture(3);\n  after  = before;\n  item   = before[0];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.addObject(item); // note: item in set\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equal(observer.validate('[]'), false, 'should NOT have notified []');\n    equal(observer.validate('@each'), false, 'should NOT have notified @each');\n    equal(observer.validate('length'), false, 'should NOT have notified length');\n    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');\n    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');\n  }\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/mutable_array/addObject");minispade.register('ember-runtime/~tests/suites/mutable_array/clear', "(function() {/*globals raises */\nminispade.require('ember-runtime/~tests/suites/mutable_array');\n\nvar suite = Ember.MutableArrayTests;\n\nsuite.module('clear');\n\nsuite.test(\"[].clear() => [] + notify\", function () {\n  var obj, before, after, observer;\n\n  before = [];\n  after  = [];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  equal(obj.clear(), obj, 'return self');\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.validate('[]'), false, 'should NOT have notified [] once');\n  equal(observer.validate('@each'), false, 'should NOT have notified @each once');\n  equal(observer.validate('length'), false, 'should NOT have notified length once');\n  equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');\n  equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');\n});\n\nsuite.test(\"[X].clear() => [] + notify\", function () {\n  var obj, before, after, observer;\n\n  before = this.newFixture(1);\n  after  = [];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  equal(obj.clear(), obj, 'return self');\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');\n  equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/mutable_array/clear");minispade.register('ember-runtime/~tests/suites/mutable_array/insertAt', "(function() {/*globals raises */\nminispade.require('ember-runtime/~tests/suites/mutable_array');\n\nvar suite = Ember.MutableArrayTests;\n\nsuite.module('insertAt');\n\nsuite.test(\"[].insertAt(0, X) => [X] + notify\", function() {\n  var obj, after, observer;\n\n  after = this.newFixture(1);\n  obj = this.newObject([]);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.insertAt(0, after[0]);\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n\n  equal(observer.timesCalledBefore('[]'), 1, 'should have notified [] will change once');\n  equal(observer.timesCalledBefore('@each'), 1, 'should have notified @each will change once');\n  equal(observer.timesCalledBefore('length'), 1, 'should have notified length will change once');\n  equal(observer.timesCalledBefore('firstObject'), 1, 'should have notified firstObject will change once');\n  equal(observer.timesCalledBefore('lastObject'), 1, 'should have notified lastObject will change once');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] did change once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each did change once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length did change once');\n  equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject did change once');\n  equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject did change once');\n});\n\nsuite.test(\"[].insertAt(200,X) => OUT_OF_RANGE_EXCEPTION exception\", function() {\n  var obj = this.newObject([]), that = this;\n  raises(function() {\n    obj.insertAt(200, that.newFixture(1)[0]);\n  }, Error);\n});\n\nsuite.test(\"[A].insertAt(0, X) => [X,A] + notify\", function() {\n  var obj, item, after, before, observer;\n\n  item = this.newFixture(1)[0];\n  before = this.newFixture(1);\n  after  = [item, before[0]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.insertAt(0, item);\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalledBefore('[]'), 1, 'should have notified [] will change once');\n  equal(observer.timesCalledBefore('@each'), 1, 'should have notified @each will change once');\n  equal(observer.timesCalledBefore('length'), 1, 'should have notified length will change once');\n  equal(observer.timesCalledBefore('firstObject'), 1, 'should have notified firstObject will change once');\n  equal(observer.timesCalledBefore('lastObject'), 0, 'should NOT have notified lastObject will change once');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');\n\n  equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');\n});\n\nsuite.test(\"[A].insertAt(1, X) => [A,X] + notify\", function() {\n  var obj, item, after, before, observer;\n\n  item = this.newFixture(1)[0];\n  before = this.newFixture(1);\n  after  = [before[0], item];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.insertAt(1, item);\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalledBefore('[]'), 1, 'should have notified [] will change once');\n  equal(observer.timesCalledBefore('@each'), 1, 'should have notified @each will change once');\n  equal(observer.timesCalledBefore('length'), 1, 'should have notified length will change once');\n  equal(observer.timesCalledBefore('firstObject'), 0, 'should NOT have notified firstObject will change once');\n  equal(observer.timesCalledBefore('lastObject'), 1, 'should have notified lastObject will change once');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');\n\n  equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');\n});\n\nsuite.test(\"[A].insertAt(200,X) => OUT_OF_RANGE exception\", function() {\n  var obj = this.newObject(this.newFixture(1)), that = this;\n  raises(function() {\n    obj.insertAt(200, that.newFixture(1)[0]);\n  }, Error);\n});\n\nsuite.test(\"[A,B,C].insertAt(0,X) => [X,A,B,C] + notify\", function() {\n  var obj, item, after, before, observer;\n\n  item = this.newFixture(1)[0];\n  before = this.newFixture(3);\n  after  = [item, before[0], before[1], before[2]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.insertAt(0, item);\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalledBefore('[]'), 1, 'should have notified [] will change once');\n  equal(observer.timesCalledBefore('@each'), 1, 'should have notified @each will change once');\n  equal(observer.timesCalledBefore('length'), 1, 'should have notified length will change once');\n  equal(observer.timesCalledBefore('firstObject'), 1, 'should have notified firstObject will change once');\n  equal(observer.timesCalledBefore('lastObject'), 0, 'should NOT have notified lastObject will change once');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');\n\n  equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');\n});\n\nsuite.test(\"[A,B,C].insertAt(1,X) => [A,X,B,C] + notify\", function() {\n  var obj, item, after, before, observer;\n\n  item = this.newFixture(1)[0];\n  before = this.newFixture(3);\n  after  = [before[0], item, before[1], before[2]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.insertAt(1, item);\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalledBefore('[]'), 1, 'should have notified [] will change once');\n  equal(observer.timesCalledBefore('@each'), 1, 'should have notified @each will change once');\n  equal(observer.timesCalledBefore('length'), 1, 'should have notified length will change once');\n  equal(observer.timesCalledBefore('firstObject'), 0, 'should NOT have notified firstObject will change once');\n  equal(observer.timesCalledBefore('lastObject'), 0, 'should NOT have notified lastObject will change once');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n\n  equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');\n  equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');\n});\n\nsuite.test(\"[A,B,C].insertAt(3,X) => [A,B,C,X] + notify\", function() {\n  var obj, item, after, before, observer;\n\n  item = this.newFixture(1)[0];\n  before = this.newFixture(3);\n  after  = [before[0], before[1], before[2], item];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.insertAt(3, item);\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalledBefore('[]'), 1, 'should have notified [] will change once');\n  equal(observer.timesCalledBefore('@each'), 1, 'should have notified @each will change once');\n  equal(observer.timesCalledBefore('length'), 1, 'should have notified length will change once');\n  equal(observer.timesCalledBefore('firstObject'), 0, 'should NOT have notified firstObject will change once');\n  equal(observer.timesCalledBefore('lastObject'), 1, 'should have notified lastObject will change once');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');\n\n  equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/mutable_array/insertAt");minispade.register('ember-runtime/~tests/suites/mutable_array/popObject', "(function() {minispade.require('ember-runtime/~tests/suites/mutable_array');\n\nvar suite = Ember.MutableArrayTests;\n\nsuite.module('popObject');\n\nsuite.test(\"[].popObject() => [] + returns undefined + NO notify\", function() {\n  var obj, observer;\n\n  obj = this.newObject([]);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  equal(obj.popObject(), undefined, 'popObject results');\n\n  deepEqual(this.toArray(obj), [], 'post item results');\n\n  equal(observer.validate('[]'), false, 'should NOT have notified []');\n  equal(observer.validate('@each'), false, 'should NOT have notified @each');\n  equal(observer.validate('length'), false, 'should NOT have notified length');\n  equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');\n  equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');\n});\n\nsuite.test(\"[X].popObject() => [] + notify\", function() {\n  var obj, before, after, observer, ret;\n\n  before = this.newFixture(1);\n  after  = [];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  ret = obj.popObject();\n\n  equal(ret, before[0], 'return object');\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');\n  equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');\n});\n\nsuite.test(\"[A,B,C].popObject() => [A,B] + notify\", function() {\n  var obj, before, after, observer, ret;\n\n  before = this.newFixture(3);\n  after  = [before[0], before[1]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  ret = obj.popObject();\n\n  equal(ret, before[2], 'return object');\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');\n\n  equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/mutable_array/popObject");minispade.register('ember-runtime/~tests/suites/mutable_array/pushObject', "(function() {minispade.require('ember-runtime/~tests/suites/mutable_array');\n\nvar suite = Ember.MutableArrayTests;\n\nsuite.module('pushObject');\n\nsuite.test(\"returns pushed object\", function() {\n  var exp = this.newFixture(1)[0];\n  var obj = this.newObject([]);\n  equal(obj.pushObject(exp), exp, 'should return pushed object');\n});\n\nsuite.test(\"[].pushObject(X) => [X] + notify\", function() {\n  var obj, before, after, observer;\n\n  before = [];\n  after  = this.newFixture(1);\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.pushObject(after[0]);\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');\n  equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');\n});\n\nsuite.test(\"[A,B,C].pushObject(X) => [A,B,C,X] + notify\", function() {\n  var obj, before, after, item, observer;\n\n  before = this.newFixture(3);\n  item   = this.newFixture(1)[0];\n  after  = [before[0], before[1], before[2], item];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.pushObject(item);\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');\n\n  equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/mutable_array/pushObject");minispade.register('ember-runtime/~tests/suites/mutable_array/removeAt', "(function() {/*globals raises */\nminispade.require('ember-runtime/~tests/suites/mutable_array');\n\nvar suite = Ember.MutableArrayTests;\n\nsuite.module('removeAt');\n\nsuite.test(\"[X].removeAt(0) => [] + notify\", function() {\n  var obj, before, after, observer;\n\n  before = this.newFixture(1);\n  after  = [];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  equal(obj.removeAt(0), obj, 'return self');\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');\n  equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');\n});\n\nsuite.test(\"[].removeAt(200) => OUT_OF_RANGE_EXCEPTION exception\", function() {\n  var obj = this.newObject([]);\n  raises(function() {\n    obj.removeAt(200);\n  }, Error);\n});\n\nsuite.test(\"[A,B].removeAt(0) => [B] + notify\", function() {\n  var obj, before, after, observer;\n\n  before = this.newFixture(2);\n  after  = [before[1]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  equal(obj.removeAt(0), obj, 'return self');\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');\n\n  equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');\n});\n\nsuite.test(\"[A,B].removeAt(1) => [A] + notify\", function() {\n  var obj, before, after, observer;\n\n  before = this.newFixture(2);\n  after  = [before[0]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  equal(obj.removeAt(1), obj, 'return self');\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');\n\n  equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');\n});\n\nsuite.test(\"[A,B,C].removeAt(1) => [A,C] + notify\", function() {\n  var obj, before, after, observer;\n\n  before = this.newFixture(3);\n  after  = [before[0], before[2]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  equal(obj.removeAt(1), obj, 'return self');\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n\n  equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');\n  equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');\n});\n\nsuite.test(\"[A,B,C,D].removeAt(1,2) => [A,D] + notify\", function() {\n  var obj, before, after, observer;\n\n  before = this.newFixture(4);\n  after  = [before[0], before[3]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  equal(obj.removeAt(1,2), obj, 'return self');\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n\n  equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');\n  equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/mutable_array/removeAt");minispade.register('ember-runtime/~tests/suites/mutable_array/removeObject', "(function() {minispade.require('ember-runtime/~tests/suites/mutable_array');\n\nvar suite = Ember.MutableArrayTests;\n\nsuite.module('removeObject');\n\nsuite.test(\"should return receiver\", function() {\n  var before, obj;\n  before = this.newFixture(3);\n  obj    = this.newObject(before);\n  equal(obj.removeObject(before[1]), obj, 'should return receiver');\n});\n\nsuite.test(\"[A,B,C].removeObject(B) => [A,C] + notify\", function() {\n  var obj, before, after, observer;\n\n  before = this.newFixture(3);\n  after  = [before[0], before[2]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.removeObject(before[1]);\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n    equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n    equal(observer.timesCalled('length'), 1, 'should have notified length once');\n\n    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');\n    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');\n  }\n});\n\nsuite.test(\"[A,B,C].removeObject(D) => [A,B,C]\", function() {\n  var obj, before, after, observer, item;\n\n  before = this.newFixture(3);\n  after  = before;\n  item   = this.newFixture(1)[0];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.removeObject(item); // note: item not in set\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equal(observer.validate('[]'), false, 'should NOT have notified []');\n    equal(observer.validate('@each'), false, 'should NOT have notified @each');\n    equal(observer.validate('length'), false, 'should NOT have notified length');\n\n    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');\n    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');\n  }\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/mutable_array/removeObject");minispade.register('ember-runtime/~tests/suites/mutable_array/replace', "(function() {minispade.require('ember-runtime/~tests/suites/mutable_array');\n\nvar suite = Ember.MutableArrayTests;\n\nsuite.module('replace');\n\nsuite.test(\"[].replace(0,0,'X') => ['X'] + notify\", function() {\n\n  var obj, exp, observer;\n  exp = this.newFixture(1);\n  obj = this.newObject([]);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.replace(0,0,exp) ;\n\n  deepEqual(this.toArray(obj), exp, 'post item results');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');\n  equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');\n});\n\nsuite.test(\"[A,B,C,D].replace(1,2,X) => [A,X,D] + notify\", function() {\n  var obj, observer, before, replace, after;\n\n  before  = this.newFixture(4);\n  replace = this.newFixture(1);\n  after   = [before[0], replace[0], before[3]];\n\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.replace(1,2,replace) ;\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n\n  equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');\n  equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');\n});\n\nsuite.test(\"[A,B,C,D].replace(1,2,[X,Y]) => [A,X,Y,D] + notify\", function() {\n  var obj, observer, before, replace, after;\n\n  before  = this.newFixture(4);\n  replace = this.newFixture(2);\n  after   = [before[0], replace[0], replace[1], before[3]];\n\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.replace(1,2,replace) ;\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.validate('length'), false, 'should NOT have notified length');\n\n  equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');\n  equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');\n});\n\nsuite.test(\"[A,B].replace(1,0,[X,Y]) => [A,X,Y,B] + notify\", function() {\n  var obj, observer, before, replace, after;\n\n  before  = this.newFixture(2);\n  replace = this.newFixture(2);\n  after   = [before[0], replace[0], replace[1], before[1]];\n\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.replace(1,0,replace) ;\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n\n  equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');\n  equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');\n});\n\nsuite.test(\"[A,B,C,D].replace(2,2) => [A,B] + notify\", function() {\n  var obj, observer, before, replace, after;\n\n  before  = this.newFixture(4);\n  after   = [before[0], before[1]];\n\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.replace(2,2);\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');\n\n  equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');\n});\n\nsuite.test('Adding object should notify enumerable observer', function() {\n\n  var fixtures = this.newFixture(4);\n  var obj = this.newObject(fixtures);\n  var observer = this.newObserver(obj).observeEnumerable(obj);\n  var item = this.newFixture(1)[0];\n\n  obj.replace(2, 2, [item]);\n\n  deepEqual(observer._before, [obj, [fixtures[2], fixtures[3]], 1], 'before');\n  deepEqual(observer._after, [obj, 2, [item]], 'after');\n});\n\nsuite.test('Adding object should notify array observer', function() {\n\n  var fixtures = this.newFixture(4);\n  var obj = this.newObject(fixtures);\n  var observer = this.newObserver(obj).observeArray(obj);\n  var item = this.newFixture(1)[0];\n\n  obj.replace(2, 2, [item]);\n\n  deepEqual(observer._before, [obj, 2, 2, 1], 'before');\n  deepEqual(observer._after, [obj, 2, 2, 1], 'after');\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/mutable_array/replace");minispade.register('ember-runtime/~tests/suites/mutable_array/reverseObjects', "(function() {/*globals raises */\nminispade.require('ember-runtime/~tests/suites/mutable_array');\n\nvar suite = Ember.MutableArrayTests;\n\nsuite.module('reverseObjects');\n\nsuite.test(\"[A,B,C].reverseObjects() => [] + notify\", function () {\n  var obj, before, after, observer;\n\n  before = this.newFixture(3);\n  after  = [before[2], before[1], before[0]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  equal(obj.reverseObjects(), obj, 'return self');\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 0, 'should have notified length once');\n  equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');\n  equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/mutable_array/reverseObjects");minispade.register('ember-runtime/~tests/suites/mutable_array/setObjects', "(function() {minispade.require('ember-runtime/~tests/suites/mutable_array');\n\nvar suite = Ember.MutableArrayTests;\n\nsuite.module('setObjects');\n\nsuite.test(\"[A,B,C].setObjects([]) = > [] + notify\", function() {\n  var obj, before, after, observer;\n\n  before = this.newFixture(3);\n  after  = [];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  equal(obj.setObjects(after), obj, 'return self');\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');\n  equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');\n});\n\nsuite.test(\"[A,B,C].setObjects([D, E, F, G]) = > [D, E, F, G] + notify\", function() {\n  var obj, before, after, observer;\n\n  before = this.newFixture(3);\n  after  = this.newFixture(4);\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  equal(obj.setObjects(after), obj, 'return self');\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');\n  equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');\n});\n})();\n//@ sourceURL=ember-runtime/~tests/suites/mutable_array/setObjects");minispade.register('ember-runtime/~tests/suites/mutable_array/shiftObject', "(function() {minispade.require('ember-runtime/~tests/suites/mutable_array');\n\nvar suite = Ember.MutableArrayTests;\n\nsuite.module('shiftObject');\n\nsuite.test(\"[].shiftObject() => [] + returns undefined + NO notify\", function() {\n  var obj, before, after, observer;\n\n  before = [];\n  after  = [];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  equal(obj.shiftObject(), undefined);\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.validate('[]', undefined, 1), false, 'should NOT have notified [] once');\n  equal(observer.validate('@each', undefined, 1), false, 'should NOT have notified @each once');\n  equal(observer.validate('length', undefined, 1), false, 'should NOT have notified length once');\n\n  equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');\n  equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');\n});\n\nsuite.test(\"[X].shiftObject() => [] + notify\", function() {\n  var obj, before, after, observer;\n\n  before = this.newFixture(1);\n  after  = [];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  equal(obj.shiftObject(), before[0], 'should return object');\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');\n  equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');\n});\n\nsuite.test(\"[A,B,C].shiftObject() => [B,C] + notify\", function() {\n  var obj, before, after, observer;\n\n  before = this.newFixture(3);\n  after  = [before[1], before[2]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  equal(obj.shiftObject(), before[0], 'should return object');\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');\n\n  equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/mutable_array/shiftObject");minispade.register('ember-runtime/~tests/suites/mutable_array/unshiftObject', "(function() {minispade.require('ember-runtime/~tests/suites/mutable_array');\n\nvar suite = Ember.MutableArrayTests;\n\nsuite.module('unshiftObject');\n\nsuite.test(\"returns unshifted object\", function() {\n  var obj = this.newObject([]);\n  var item = this.newFixture(1)[0];\n  equal(obj.unshiftObject(item), item, 'should return unshifted object');\n});\n\n\nsuite.test(\"[].unshiftObject(X) => [X] + notify\", function() {\n  var obj, before, after, item, observer;\n\n  before = [];\n  item = this.newFixture(1)[0];\n  after  = [item];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.unshiftObject(item);\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');\n  equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');\n});\n\nsuite.test(\"[A,B,C].unshiftObject(X) => [X,A,B,C] + notify\", function() {\n  var obj, before, after, item, observer;\n\n  before = this.newFixture(3);\n  item = this.newFixture(1)[0];\n  after  = [item, before[0], before[1], before[2]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.unshiftObject(item);\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');\n\n  equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');\n});\n\nsuite.test(\"[A,B,C].unshiftObject(A) => [A,A,B,C] + notify\", function() {\n  var obj, before, after, item, observer;\n\n  before = this.newFixture(3);\n  item = before[0]; // note same object as current head. should end up twice\n  after  = [item, before[0], before[1], before[2]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.unshiftObject(item);\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n\n  equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');\n  equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/mutable_array/unshiftObject");minispade.register('ember-runtime/~tests/suites/mutable_array/unshiftObjects', "(function() {minispade.require('ember-runtime/~tests/suites/mutable_array');\n\nvar suite = Ember.MutableArrayTests;\n\nsuite.module('unshiftObjects');\n\nsuite.test(\"returns receiver\", function() {\n  var obj = this.newObject([]);\n  var items = this.newFixture(3);\n  equal(obj.unshiftObjects(items), obj, 'should return receiver');\n});\n\nsuite.test(\"[].unshiftObjects([A,B,C]) => [A,B,C] + notify\", function() {\n  var obj, before, items, observer;\n\n  before = [];\n  items = this.newFixture(3);\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.unshiftObjects(items);\n\n  deepEqual(this.toArray(obj), items, 'post item results');\n  equal(Ember.get(obj, 'length'), items.length, 'length');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');\n  equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');\n});\n\nsuite.test(\"[A,B,C].unshiftObjects([X,Y]) => [X,Y,A,B,C] + notify\", function() {\n  var obj, before, items, after, observer;\n\n  before = this.newFixture(3);\n  items  = this.newFixture(2);\n  after  = items.concat(before);\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.unshiftObjects(items);\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n  equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');\n\n  equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');\n});\n\nsuite.test(\"[A,B,C].unshiftObjects([A,B]) => [A,B,A,B,C] + notify\", function() {\n  var obj, before, after, items, observer;\n\n  before = this.newFixture(3);\n  items = [before[0], before[1]]; // note same object as current head. should end up twice\n  after  = items.concat(before);\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');\n  obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */\n\n  obj.unshiftObjects(items);\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n  equal(observer.timesCalled('@each'), 1, 'should have notified @each once');\n  equal(observer.timesCalled('length'), 1, 'should have notified length once');\n\n  equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');\n  equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/mutable_array/unshiftObjects");minispade.register('ember-runtime/~tests/suites/mutable_enumerable', "(function() {minispade.require('ember-runtime/~tests/suites/enumerable');\n\nEmber.MutableEnumerableTests = Ember.EnumerableTests.extend();\nminispade.require('ember-runtime/~tests/suites/mutable_enumerable/addObject');\nminispade.require('ember-runtime/~tests/suites/mutable_enumerable/removeObject');\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/mutable_enumerable");minispade.register('ember-runtime/~tests/suites/mutable_enumerable/addObject', "(function() {minispade.require('ember-runtime/~tests/suites/mutable_enumerable');\n\nvar suite = Ember.MutableEnumerableTests;\n\nsuite.module('addObject');\n\nsuite.test(\"should return receiver\", function() {\n  var before, obj;\n  before = this.newFixture(3);\n  obj    = this.newObject(before);\n  equal(obj.addObject(before[1]), obj, 'should return receiver');\n});\n\nsuite.test(\"[A,B].addObject(C) => [A,B,C] + notify\", function() {\n  var obj, before, after, observer, item;\n\n  before = this.newFixture(2);\n  item   = this.newFixture(1)[0];\n  after  = [before[0], before[1], item];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');\n\n  obj.addObject(item);\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n    equal(observer.timesCalled('length'), 1, 'should have notified length once');\n    equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');\n    // This gets called since MutableEnumerable is naive about changes\n    equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');\n  }\n});\n\nsuite.test(\"[A,B,C].addObject(A) => [A,B,C] + NO notify\", function() {\n  var obj, before, after, observer, item;\n\n  before = this.newFixture(3);\n  after  = before;\n  item   = before[0];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');\n\n  obj.addObject(item); // note: item in set\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equal(observer.validate('[]'), false, 'should NOT have notified []');\n    equal(observer.validate('length'), false, 'should NOT have notified length');\n    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');\n    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');\n  }\n});\n\nsuite.test('Adding object should notify enumerable observer', function() {\n  var obj = this.newObject(this.newFixture(3));\n  var observer = this.newObserver(obj).observeEnumerable(obj);\n  var item = this.newFixture(1)[0];\n\n  obj.addObject(item);\n\n  deepEqual(observer._before, [obj, null, [item]]);\n  deepEqual(observer._after, [obj, null, [item]]);\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/mutable_enumerable/addObject");minispade.register('ember-runtime/~tests/suites/mutable_enumerable/removeObject', "(function() {minispade.require('ember-runtime/~tests/suites/mutable_enumerable');\n\nvar suite = Ember.MutableEnumerableTests;\n\nsuite.module('removeObject');\n\nsuite.test(\"should return receiver\", function() {\n  var before, obj;\n  before = this.newFixture(3);\n  obj    = this.newObject(before);\n  equal(obj.removeObject(before[1]), obj, 'should return receiver');\n});\n\nsuite.test(\"[A,B,C].removeObject(B) => [A,C] + notify\", function() {\n  var obj, before, after, observer;\n\n  before = this.newFixture(3);\n  after  = [before[0], before[2]];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.removeObject(before[1]);\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');\n    equal(observer.timesCalled('length'), 1, 'should have notified length once');\n\n    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');\n    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');\n  }\n});\n\nsuite.test(\"[A,B,C].removeObject(D) => [A,B,C]\", function() {\n  var obj, before, after, observer, item;\n\n  before = this.newFixture(3);\n  after  = before;\n  item   = this.newFixture(1)[0];\n  obj = this.newObject(before);\n  observer = this.newObserver(obj, '[]', 'length');\n\n  obj.removeObject(item); // note: item not in set\n\n  deepEqual(this.toArray(obj), after, 'post item results');\n  equal(Ember.get(obj, 'length'), after.length, 'length');\n\n  if (observer.isEnabled) {\n    equal(observer.validate('[]'), false, 'should NOT have notified []');\n    equal(observer.validate('length'), false, 'should NOT have notified length');\n    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');\n    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');\n  }\n});\n\nsuite.test('Removing object should notify enumerable observer', function() {\n\n  var fixtures = this.newFixture(3);\n  var obj = this.newObject(fixtures);\n  var observer = this.newObserver(obj).observeEnumerable(obj);\n  var item = fixtures[1];\n\n  obj.removeObject(item);\n\n  deepEqual(observer._before, [obj, [item], null]);\n  deepEqual(observer._after, [obj, [item], null]);\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/mutable_enumerable/removeObject");minispade.register('ember-runtime/~tests/suites/suite', "(function() {/**\n  @class\n  A Suite can be used to define a reusable set of unit tests that can be\n  applied to any object.  Suites are most useful for defining tests that\n  work against a mixin or plugin API.  Developers implementing objects that\n  use the mixin or support the API can then run these tests against their\n  own code to verify compliance.\n\n  To define a suite, you need to define the tests themselves as well as a\n  callback API implementors can use to tie your tests to thier specific class.\n\n  ## Defining a Callback API\n\n  To define the callback API, just extend this class and add your properties\n  or methods that must be provided.  Use Ember.required() placeholders for\n  any properties that implementors must define themselves.\n\n  ## Defining Unit Tests\n\n  To add unit tests, use the suite.module() or suite.test() methods instead\n  of a regular module() or test() method when defining your tests.  This will\n  add the tests to the suite.\n\n  ## Using a Suite\n\n  To use a Suite to test your own objects, extend the suite subclass and\n  define any required methods.  Then call run() on the new subclass.  This\n  will create an instance of your class and then defining the unit tests.\n\n  @extends Ember.Object\n  @private\n*/\nEmber.Suite = Ember.Object.extend(\n  /** @scope Ember.Suite.prototype */ {\n\n  /**\n    Define a name for these tests - all modules are prefixed w/ it.\n\n    @type String\n  */\n  name: Ember.required(String),\n\n  /**\n    Invoked to actually run the test - overridden by mixins\n  */\n  run: function() {}\n\n});\n\nEmber.Suite.reopenClass({\n\n  plan: null,\n\n  run: function() {\n    var C = this;\n    return new C().run();\n  },\n\n  module: function(desc, opts) {\n    if (!opts) opts = {};\n    var setup = opts.setup, teardown = opts.teardown;\n    this.reopen({\n      run: function() {\n        this._super();\n        var title = Ember.get(this, 'name')+': '+desc, ctx = this;\n        module(title, {\n          setup: function() {\n            if (setup) setup.call(ctx);\n          },\n\n          teardown: function() {\n            if (teardown) teardown.call(ctx);\n          }\n        });\n      }\n    });\n  },\n\n  test: function(name, func) {\n    this.reopen({\n      run: function() {\n        this._super();\n        var ctx = this;\n        if (!func) test(name); // output warning\n        else test(name, function() { func.call(ctx); });\n      }\n    });\n  },\n\n  // convert to guids to minimize logging.\n  same: function(actual, exp, message) {\n    actual = (actual && actual.map) ? actual.map(function(x) { return Ember.guidFor(x); }) : actual;\n    exp = (exp && exp.map) ? exp.map(function(x) { return Ember.guidFor(x); }) : exp;\n    return deepEqual(actual, exp, message);\n  },\n\n  // easy way to disable tests\n  notest: function() {}\n\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/suites/suite");minispade.register('ember-runtime/~tests/system/application/base_test', "(function() {module('Ember.Application');\n\ntest('Ember.Application should be a subclass of Ember.Namespace', function() {\n\n  ok(Ember.Namespace.detect(Ember.Application), 'Ember.Application subclass of Ember.Namespace');\n\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/application/base_test");minispade.register('ember-runtime/~tests/system/array_proxy/arranged_content_test', "(function() {var array;\n\nmodule(\"Ember.ArrayProxy - arrangedContent\", {\n  setup: function() {\n    Ember.run(function() {\n      array = Ember.ArrayProxy.createWithMixins({\n        content: Ember.A([1,2,4,5]),\n        arrangedContent: Ember.computed(function() {\n          var content = this.get('content');\n          return content && Ember.A(content.slice().sort(function(a,b) {\n            if (a == null) { a = -1; }\n            if (b == null) { b = -1; }\n            return b - a;\n          }));\n        }).property('content.[]')\n      });\n    });\n  },\n  teardown: function() {\n    Ember.run(function() {\n      array.destroy();\n    });\n  }\n});\n\ntest(\"addObject - adds to end of 'content' if not present\", function() {\n  Ember.run(function() { array.addObject(3); });\n  deepEqual(array.get('content'), [1,2,4,5,3], 'adds to end of content');\n  deepEqual(array.get('arrangedContent'), [5,4,3,2,1], 'arrangedContent stays sorted');\n\n  Ember.run(function() { array.addObject(1); });\n  deepEqual(array.get('content'), [1,2,4,5,3], 'does not add existing number to content');\n});\n\ntest(\"addObjects - adds to end of 'content' if not present\", function() {\n  Ember.run(function() { array.addObjects([1,3,6]); });\n  deepEqual(array.get('content'), [1,2,4,5,3,6], 'adds to end of content');\n  deepEqual(array.get('arrangedContent'), [6,5,4,3,2,1], 'arrangedContent stays sorted');\n});\n\ntest(\"compact - returns arrangedContent without nulls and undefined\", function() {\n  Ember.run(function() { array.set('content', Ember.A([1,3,null,2,undefined])); });\n  deepEqual(array.compact(), [3,2,1]);\n});\n\ntest(\"indexOf - returns index of object in arrangedContent\", function() {\n  equal(array.indexOf(4), 1, 'returns arranged index');\n});\n\ntest(\"insertAt - raises, indeterminate behavior\", function() {\n  raises(function() {\n    Ember.run(function() { array.insertAt(2,3); });\n  });\n});\n\ntest(\"lastIndexOf - returns last index of object in arrangedContent\", function() {\n  Ember.run(function() { array.pushObject(4); });\n  equal(array.lastIndexOf(4), 2, 'returns last arranged index');\n});\n\ntest(\"nextObject - returns object at index in arrangedContent\", function() {\n  equal(array.nextObject(1), 4, 'returns object at index');\n});\n\ntest(\"objectAt - returns object at index in arrangedContent\", function() {\n  equal(array.objectAt(1), 4, 'returns object at index');\n});\n\n// Not sure if we need a specific test for it, since it's internal\ntest(\"objectAtContent - returns object at index in arrangedContent\", function() {\n  equal(array.objectAtContent(1), 4, 'returns object at index');\n});\n\ntest(\"objectsAt - returns objects at indices in arrangedContent\", function() {\n  deepEqual(array.objectsAt([0,2,4]), [5,2,undefined], 'returns objects at indices');\n});\n\ntest(\"popObject - removes last object in arrangedContent\", function() {\n  var popped;\n  Ember.run(function() { popped = array.popObject(); });\n  equal(popped, 1, 'returns last object');\n  deepEqual(array.get('content'), [2,4,5], 'removes from content');\n});\n\ntest(\"pushObject - adds to end of content even if it already exists\", function() {\n  Ember.run(function() { array.pushObject(1); });\n  deepEqual(array.get('content'), [1,2,4,5,1], 'adds to end of content');\n});\n\ntest(\"pushObjects - adds multiple to end of content even if it already exists\", function() {\n  Ember.run(function() { array.pushObjects([1,2,4]); });\n  deepEqual(array.get('content'), [1,2,4,5,1,2,4], 'adds to end of content');\n});\n\ntest(\"removeAt - removes from index in arrangedContent\", function() {\n  Ember.run(function() { array.removeAt(1,2); });\n  deepEqual(array.get('content'), [1,5]);\n});\n\ntest(\"removeObject - removes object from content\", function() {\n  Ember.run(function() { array.removeObject(2); });\n  deepEqual(array.get('content'), [1,4,5]);\n});\n\ntest(\"removeObjects - removes objects from content\", function() {\n  Ember.run(function() { array.removeObjects([2,4,6]); });\n  deepEqual(array.get('content'), [1,5]);\n});\n\ntest(\"replace - raises, indeterminate behavior\", function() {\n  raises(function() {\n    Ember.run(function() { array.replace(1, 2, [3]); });\n  });\n});\n\ntest(\"replaceContent - does a standard array replace on content\", function() {\n  Ember.run(function() { array.replaceContent(1, 2, [3]); });\n  deepEqual(array.get('content'), [1,3,5]);\n});\n\ntest(\"reverseObjects - raises, use Sortable#sortAscending\", function() {\n  raises(function() {\n    Ember.run(function() { array.reverseObjects(); });\n  });\n});\n\ntest(\"setObjects - replaces entire content\", function() {\n  Ember.run(function() { array.setObjects([6,7,8]); });\n  deepEqual(array.get('content'), [6,7,8], 'replaces content');\n});\n\ntest(\"shiftObject - removes from start of arrangedContent\", function() {\n  var shifted;\n  Ember.run(function() { shifted = array.shiftObject(); });\n  equal(shifted, 5, 'returns first object');\n  deepEqual(array.get('content'), [1,2,4], 'removes object from content');\n});\n\ntest(\"slice - returns a slice of the arrangedContent\", function() {\n  deepEqual(array.slice(1,3), [4,2], 'returns sliced arrangedContent');\n});\n\ntest(\"toArray - returns copy of arrangedContent\", function() {\n  deepEqual(array.toArray(), [5,4,2,1]);\n});\n\ntest(\"unshiftObject - adds to start of content\", function() {\n  Ember.run(function(){ array.unshiftObject(6); });\n  deepEqual(array.get('content'), [6,1,2,4,5], 'adds to start of content');\n});\n\ntest(\"unshiftObjects - adds to start of content\", function() {\n  Ember.run(function(){ array.unshiftObjects([6,7]); });\n  deepEqual(array.get('content'), [6,7,1,2,4,5], 'adds to start of content');\n});\n\ntest(\"without - returns arrangedContent without object\", function() {\n  deepEqual(array.without(2), [5,4,1], 'returns arranged without object');\n});\n\ntest(\"lastObject - returns last arranged object\", function() {\n  equal(array.get('lastObject'), 1, 'returns last arranged object');\n});\n\ntest(\"firstObject - returns first arranged object\", function() {\n  equal(array.get('firstObject'), 5, 'returns first arranged object');\n});\n\n\nmodule(\"Ember.ArrayProxy - arrangedContent matching content\", {\n  setup: function() {\n    Ember.run(function() {\n      array = Ember.ArrayProxy.createWithMixins({\n        content: Ember.A([1,2,4,5])\n      });\n    });\n  },\n  teardown: function() {\n    Ember.run(function() {\n      array.destroy();\n    });\n  }\n});\n\ntest(\"insertAt - inserts object at specified index\", function() {\n  Ember.run(function() { array.insertAt(2, 3); });\n  deepEqual(array.get('content'), [1,2,3,4,5]);\n});\n\ntest(\"replace - does a standard array replace\", function() {\n  Ember.run(function() { array.replace(1, 2, [3]); });\n  deepEqual(array.get('content'), [1,3,5]);\n});\n\ntest(\"reverseObjects - reverses content\", function() {\n  Ember.run(function() { array.reverseObjects(); });\n  deepEqual(array.get('content'), [5,4,2,1]);\n});\n\nmodule(\"Ember.ArrayProxy - arrangedContent with transforms\", {\n  setup: function() {\n    Ember.run(function() {\n      array = Ember.ArrayProxy.createWithMixins({\n        content: Ember.A([1,2,4,5]),\n\n        arrangedContent: Ember.computed(function() {\n          var content = this.get('content');\n          return content && Ember.A(content.slice().sort(function(a,b) {\n            if (a == null) { a = -1; }\n            if (b == null) { b = -1; }\n            return b - a;\n          }));\n        }).property('content.[]'),\n\n        objectAtContent: function(idx) {\n          var obj = this.get('arrangedContent').objectAt(idx);\n          return obj && obj.toString();\n        }\n      });\n    });\n  },\n  teardown: function() {\n    Ember.run(function() {\n      array.destroy();\n    });\n  }\n});\n\ntest(\"indexOf - returns index of object in arrangedContent\", function() {\n  equal(array.indexOf('4'), 1, 'returns arranged index');\n});\n\ntest(\"lastIndexOf - returns last index of object in arrangedContent\", function() {\n  Ember.run(function() { array.pushObject(4); });\n  equal(array.lastIndexOf('4'), 2, 'returns last arranged index');\n});\n\ntest(\"nextObject - returns object at index in arrangedContent\", function() {\n  equal(array.nextObject(1), '4', 'returns object at index');\n});\n\ntest(\"objectAt - returns object at index in arrangedContent\", function() {\n  equal(array.objectAt(1), '4', 'returns object at index');\n});\n\n// Not sure if we need a specific test for it, since it's internal\ntest(\"objectAtContent - returns object at index in arrangedContent\", function() {\n  equal(array.objectAtContent(1), '4', 'returns object at index');\n});\n\ntest(\"objectsAt - returns objects at indices in arrangedContent\", function() {\n  deepEqual(array.objectsAt([0,2,4]), ['5','2',undefined], 'returns objects at indices');\n});\n\ntest(\"popObject - removes last object in arrangedContent\", function() {\n  var popped;\n  Ember.run(function() { popped = array.popObject(); });\n  equal(popped, '1', 'returns last object');\n  deepEqual(array.get('content'), [2,4,5], 'removes from content');\n});\n\ntest(\"removeObject - removes object from content\", function() {\n  Ember.run(function() { array.removeObject('2'); });\n  deepEqual(array.get('content'), [1,4,5]);\n});\n\ntest(\"removeObjects - removes objects from content\", function() {\n  Ember.run(function() { array.removeObjects(['2','4','6']); });\n  deepEqual(array.get('content'), [1,5]);\n});\n\ntest(\"shiftObject - removes from start of arrangedContent\", function() {\n  var shifted;\n  Ember.run(function() { shifted = array.shiftObject(); });\n  equal(shifted, '5', 'returns first object');\n  deepEqual(array.get('content'), [1,2,4], 'removes object from content');\n});\n\ntest(\"slice - returns a slice of the arrangedContent\", function() {\n  deepEqual(array.slice(1,3), ['4','2'], 'returns sliced arrangedContent');\n});\n\ntest(\"toArray - returns copy of arrangedContent\", function() {\n  deepEqual(array.toArray(), ['5','4','2','1']);\n});\n\ntest(\"without - returns arrangedContent without object\", function() {\n  deepEqual(array.without('2'), ['5','4','1'], 'returns arranged without object');\n});\n\ntest(\"lastObject - returns last arranged object\", function() {\n  equal(array.get('lastObject'), '1', 'returns last arranged object');\n});\n\ntest(\"firstObject - returns first arranged object\", function() {\n  equal(array.get('firstObject'), '5', 'returns first arranged object');\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/array_proxy/arranged_content_test");minispade.register('ember-runtime/~tests/system/array_proxy/content_change_test', "(function() {module(\"Ember.ArrayProxy - content change\");\n\ntest(\"should update length for null content\", function() {\n  var proxy = Ember.ArrayProxy.create({\n        content: Ember.A([1,2,3])\n      });\n\n  equal(proxy.get('length'), 3, \"precond - length is 3\");\n\n  proxy.set('content', null);\n\n  equal(proxy.get('length'), 0, \"length updates\");\n});\n\ntest(\"The `arrangedContentWillChange` method is invoked before `content` is changed.\", function() {\n  var callCount = 0,\n      expectedLength;\n\n  var proxy = Ember.ArrayProxy.extend({\n    content: Ember.A([1, 2, 3]),\n\n    arrangedContentWillChange: function() {\n      equal(this.get('arrangedContent.length'), expectedLength, \"hook should be invoked before array has changed\");\n      callCount++;\n    }\n  }).create();\n\n  proxy.pushObject(4);\n  equal(callCount, 0, \"pushing content onto the array doesn't trigger it\");\n\n  proxy.get('content').pushObject(5);\n  equal(callCount, 0, \"pushing content onto the content array doesn't trigger it\");\n\n  expectedLength = 5;\n  proxy.set('content', Ember.A(['a', 'b']));\n  equal(callCount, 1, \"replacing the content array triggers the hook\");\n});\n\ntest(\"The `arrangedContentDidChange` method is invoked after `content` is changed.\", function() {\n  var callCount = 0,\n      expectedLength;\n\n  var proxy = Ember.ArrayProxy.extend({\n    content: Ember.A([1, 2, 3]),\n\n    arrangedContentDidChange: function() {\n      equal(this.get('arrangedContent.length'), expectedLength, \"hook should be invoked after array has changed\");\n      callCount++;\n    }\n  }).create();\n\n  equal(callCount, 0, \"hook is not called after creating the object\");\n\n  proxy.pushObject(4);\n  equal(callCount, 0, \"pushing content onto the array doesn't trigger it\");\n\n  proxy.get('content').pushObject(5);\n  equal(callCount, 0, \"pushing content onto the content array doesn't trigger it\");\n\n  expectedLength = 2;\n  proxy.set('content', Ember.A(['a', 'b']));\n  equal(callCount, 1, \"replacing the content array triggers the hook\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/array_proxy/content_change_test");minispade.register('ember-runtime/~tests/system/array_proxy/content_update_test', "(function() {// ==========================================================================\n// Project:  Ember Runtime\n// Copyright: 2011 Strobe Inc. and contributors.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule(\"Ember.ArrayProxy - content update\");\n\ntest(\"The `contentArrayDidChange` method is invoked after `content` is updated.\", function() {\n\n  var proxy, observerCalled = false;\n\n  proxy = Ember.ArrayProxy.createWithMixins({\n    content: Ember.A([]),\n\n    arrangedContent: Ember.computed('content', function(key, value) {\n      // setup arrangedContent as a different object than content,\n      // which is the default\n      return Ember.A(this.get('content').slice());\n    }).cacheable(),\n\n    contentArrayDidChange: function(array, idx, removedCount, addedCount) {\n      observerCalled = true;\n      return this._super(array, idx, removedCount, addedCount);\n    }\n  });\n\n  proxy.pushObject(1);\n\n  ok(observerCalled, \"contentArrayDidChange is invoked\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/array_proxy/content_update_test");minispade.register('ember-runtime/~tests/system/array_proxy/suite_test', "(function() {Ember.MutableArrayTests.extend({\n\n  name: 'Ember.ArrayProxy',\n\n  newObject: function(ary) {\n    var ret = ary ? ary.slice() : this.newFixture(3);\n    return Ember.ArrayProxy.create({ content: Ember.A(ret) });\n  },\n\n  mutate: function(obj) {\n    obj.pushObject(Ember.get(obj, 'length')+1);\n  },\n\n  toArray: function(obj) {\n    return obj.toArray ? obj.toArray() : obj.slice();\n  }\n\n}).run();\n\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/array_proxy/suite_test");minispade.register('ember-runtime/~tests/system/deferred_test', "(function() {module(\"Ember.Deferred all-in-one\");\n\nasyncTest(\"Can resolve a promise\", function() {\n  var value = { value: true };\n\n  var promise = Ember.Deferred.promise(function(deferred) {\n    setTimeout(function() {\n      Ember.run(function() { deferred.resolve(value); });\n    });\n  });\n\n  promise.then(function(resolveValue) {\n    start();\n    equal(resolveValue, value, \"The resolved value should be correct\");\n  });\n});\n\nasyncTest(\"Can reject a promise\", function() {\n  var rejected = { rejected: true };\n\n  var promise = Ember.Deferred.promise(function(deferred) {\n    setTimeout(function() {\n      Ember.run(function() { deferred.reject(rejected); });\n    });\n  });\n\n  promise.then(null, function(rejectedValue) {\n    start();\n    equal(rejectedValue, rejected, \"The resolved value should be correct\");\n  });\n});\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/deferred_test");minispade.register('ember-runtime/~tests/system/lazy_load_test', "(function() {module(\"Lazy Loading\");\n\ntest(\"if a load hook is registered, it is executed when runLoadHooks are exected\", function() {\n  var count = 0;\n\n  Ember.run(function() {\n    Ember.onLoad(\"__test_hook__\", function(object) {\n      count += object;\n    });\n  });\n\n  Ember.run(function() {\n    Ember.runLoadHooks(\"__test_hook__\", 1);\n  });\n\n  equal(count, 1, \"the object was passed into the load hook\");\n});\n\ntest(\"if runLoadHooks was already run, it executes newly added hooks immediately\", function() {\n  var count = 0;\n  Ember.run(function() {\n    Ember.onLoad(\"__test_hook__\", function(object) {\n      count += object;\n    });\n  });\n\n  Ember.run(function() {\n    Ember.runLoadHooks(\"__test_hook__\", 1);\n  });\n\n  count = 0;\n  Ember.run(function() {\n    Ember.onLoad(\"__test_hook__\", function(object) {\n      count += object;\n    });\n  });\n\n  equal(count, 1, \"the original object was passed into the load hook\");\n});\n\ntest(\"hooks in ENV.EMBER_LOAD_HOOKS['hookName'] get executed\", function() {\n\n  // Note that the necessary code to perform this test is run before\n  // the Ember lib is loaded in tests/index.html\n\n  Ember.run(function() {\n    Ember.runLoadHooks(\"__before_ember_test_hook__\", 1);\n  });\n\n  equal(window.ENV.__test_hook_count__, 1, \"the object was passed into the load hook\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/lazy_load_test");minispade.register('ember-runtime/~tests/system/namespace/base_test', "(function() {// ==========================================================================\n// Project:  Ember Runtime\n// ==========================================================================\n\nvar get = Ember.get, originalLookup = Ember.lookup, lookup;\n\nmodule('Ember.Namespace', {\n  setup: function() {\n    Ember.BOOTED = false;\n\n    lookup = Ember.lookup = {};\n  },\n  teardown: function() {\n    Ember.BOOTED = false;\n\n    if (lookup.NamespaceA) { Ember.run(function(){ lookup.NamespaceA.destroy(); }); }\n    if (lookup.NamespaceB) { Ember.run(function(){ lookup.NamespaceB.destroy(); }); }\n    if (lookup.namespaceC) {\n      try {\n        Ember.TESTING_DEPRECATION = true;\n        Ember.run(function(){\n          lookup.namespaceC.destroy();\n        });\n      } finally {\n        Ember.TESTING_DEPRECATION = false;\n      }\n    }\n\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest('Ember.Namespace should be a subclass of Ember.Object', function() {\n  ok(Ember.Object.detect(Ember.Namespace));\n});\n\ntest(\"Ember.Namespace should be duck typed\", function() {\n  ok(get(Ember.Namespace.create(), 'isNamespace'), \"isNamespace property is true\");\n});\n\ntest('Ember.Namespace is found and named', function() {\n  var nsA = lookup.NamespaceA = Ember.Namespace.create();\n  equal(nsA.toString(), \"NamespaceA\", \"namespaces should have a name if they are on lookup\");\n\n  var nsB = lookup.NamespaceB = Ember.Namespace.create();\n  equal(nsB.toString(), \"NamespaceB\", \"namespaces work if created after the first namespace processing pass\");\n});\n\ntest(\"Classes under an Ember.Namespace are properly named\", function() {\n  var nsA = lookup.NamespaceA = Ember.Namespace.create();\n  nsA.Foo = Ember.Object.extend();\n  equal(nsA.Foo.toString(), \"NamespaceA.Foo\", \"Classes pick up their parent namespace\");\n\n  nsA.Bar = Ember.Object.extend();\n  equal(nsA.Bar.toString(), \"NamespaceA.Bar\", \"New Classes get the naming treatment too\");\n\n  var nsB = lookup.NamespaceB = Ember.Namespace.create();\n  nsB.Foo = Ember.Object.extend();\n  equal(nsB.Foo.toString(), \"NamespaceB.Foo\", \"Classes in new namespaces get the naming treatment\");\n});\n\ntest(\"Classes under Ember are properly named\", function() {\n  equal(Ember.Array.toString(), \"Ember.Array\", \"precond - existing classes are processed\");\n\n  Ember.TestObject = Ember.Object.extend({});\n  equal(Ember.TestObject.toString(), \"Ember.TestObject\", \"class under Ember is given a string representation\");\n});\n\ntest(\"Lowercase namespaces should be deprecated\", function() {\n  lookup.namespaceC = Ember.Namespace.create();\n\n  var originalWarn = Ember.Logger.warn,\n      loggerWarning;\n\n  Ember.Logger.warn = function(msg) { loggerWarning = msg; };\n\n  try {\n    lookup.namespaceC.toString();\n  } finally {\n    Ember.Logger.warn = originalWarn;\n  }\n\n  // Ignore backtrace\n  equal(loggerWarning.split(\"\\n\")[0], \"DEPRECATION: Namespaces should not begin with lowercase.\");\n});\n\ntest(\"A namespace can be assigned a custom name\", function() {\n  var nsA = Ember.Namespace.create({\n    name: \"NamespaceA\"\n  });\n\n  var nsB = lookup.NamespaceB = Ember.Namespace.create({\n    name: \"CustomNamespaceB\"\n  });\n\n  nsA.Foo = Ember.Object.extend();\n  nsB.Foo = Ember.Object.extend();\n\n  equal(nsA.Foo.toString(), \"NamespaceA.Foo\", \"The namespace's name is used when the namespace is not in the lookup object\");\n  equal(nsB.Foo.toString(), \"CustomNamespaceB.Foo\", \"The namespace's name is used when the namespace is in the lookup object\");\n});\n\ntest(\"Calling namespace.nameClasses() eagerly names all classes\", function() {\n  Ember.BOOTED = true;\n\n  var namespace = lookup.NS = Ember.Namespace.create();\n\n  namespace.ClassA = Ember.Object.extend();\n  namespace.ClassB = Ember.Object.extend();\n\n  Ember.Namespace.processAll();\n\n  equal(namespace.ClassA.toString(), \"NS.ClassA\");\n  equal(namespace.ClassB.toString(), \"NS.ClassB\");\n});\n\ntest(\"A namespace can be looked up by its name\", function() {\n  var NS = lookup.NS = Ember.Namespace.create();\n  var UI = lookup.UI = Ember.Namespace.create();\n  var CF = lookup.CF = Ember.Namespace.create();\n\n  equal(Ember.Namespace.byName('NS'), NS);\n  equal(Ember.Namespace.byName('UI'), UI);\n  equal(Ember.Namespace.byName('CF'), CF);\n});\n\ntest(\"A nested namespace can be looked up by its name\", function() {\n  var UI = lookup.UI = Ember.Namespace.create();\n  UI.Nav = Ember.Namespace.create();\n\n  equal(Ember.Namespace.byName('UI.Nav'), UI.Nav);\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/namespace/base_test");minispade.register('ember-runtime/~tests/system/native_array/copyable_suite_test', "(function() {// ..........................................................\n// COPYABLE TESTS\n//\nEmber.CopyableTests.extend({\n  name: 'NativeArray Copyable',\n\n  newObject: function() {\n    return Ember.A([Ember.generateGuid()]);\n  },\n\n  isEqual: function(a,b) {\n    if (!(a instanceof Array)) return false;\n    if (!(b instanceof Array)) return false;\n    if (a.length !== b.length) return false;\n    return a[0]===b[0];\n  },\n\n  shouldBeFreezable: false\n}).run();\n\nmodule(\"NativeArray Copyable\");\n\ntest(\"deep copy is respected\", function() {\n  var array = Ember.A([ { id: 1 }, { id: 2 }, { id: 3 } ]);\n\n  var copiedArray = array.copy(true);\n\n  deepEqual(copiedArray, array, \"copied array is equivalent\");\n  ok(copiedArray[0] !== array[0], \"objects inside should be unique\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/native_array/copyable_suite_test");minispade.register('ember-runtime/~tests/system/native_array/suite_test', "(function() {Ember.MutableArrayTests.extend({\n\n  name: 'Native Array',\n\n  newObject: function(ary) {\n    return Ember.A(ary ? ary.slice() : this.newFixture(3));\n  },\n\n  mutate: function(obj) {\n    obj.pushObject(obj.length+1);\n  },\n\n  toArray: function(obj) {\n    return obj.slice(); // make a copy.\n  }\n\n}).run();\n\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/native_array/suite_test");minispade.register('ember-runtime/~tests/system/object/computed_test', "(function() {minispade.require('ember-runtime/~tests/props_helper');\n\nmodule('Ember.Object computed property');\n\ntestWithDefault('computed property on instance', function(get, set) {\n\n  var MyClass = Ember.Object.extend({\n    foo: Ember.computed(function() { return 'FOO'; })\n  });\n\n  equal(get(new MyClass(), 'foo'), 'FOO');\n\n});\n\n\ntestWithDefault('computed property on subclass', function(get, set) {\n\n  var MyClass = Ember.Object.extend({\n    foo: Ember.computed(function() { return 'FOO'; })\n  });\n\n  var Subclass = MyClass.extend({\n    foo: Ember.computed(function() { return 'BAR'; })\n  });\n\n  equal(get(new Subclass(), 'foo'), 'BAR');\n\n});\n\n\ntestWithDefault('replacing computed property with regular val', function(get, set) {\n\n  var MyClass = Ember.Object.extend({\n    foo: Ember.computed(function() { return 'FOO'; })\n  });\n\n  var Subclass = MyClass.extend({\n    foo: 'BAR'\n  });\n\n  equal(get(new Subclass(), 'foo'), 'BAR');\n\n});\n\ntestWithDefault('complex depndent keys', function(get, set) {\n\n  var MyClass = Ember.Object.extend({\n\n    init: function() {\n      this._super();\n      set(this, 'bar', { baz: 'BIFF' });\n    },\n\n    count: 0,\n\n    foo: Ember.computed(function() {\n      set(this, 'count', get(this, 'count')+1);\n      return Ember.get(get(this, 'bar'), 'baz') + ' ' + get(this, 'count');\n    }).property('bar.baz')\n\n  });\n\n  var Subclass = MyClass.extend({\n    count: 20\n  });\n\n  var obj1 = new MyClass(),\n      obj2 = new Subclass();\n\n  equal(get(obj1, 'foo'), 'BIFF 1');\n  equal(get(obj2, 'foo'), 'BIFF 21');\n\n  set(get(obj1, 'bar'), 'baz', 'BLARG');\n\n  equal(get(obj1, 'foo'), 'BLARG 2');\n  equal(get(obj2, 'foo'), 'BIFF 21');\n\n  set(get(obj2, 'bar'), 'baz', 'BOOM');\n\n  equal(get(obj1, 'foo'), 'BLARG 2');\n  equal(get(obj2, 'foo'), 'BOOM 22');\n});\n\ntestWithDefault('complex depndent keys changing complex dependent keys', function(get, set) {\n\n  var MyClass = Ember.Object.extend({\n\n    init: function() {\n      this._super();\n      set(this, 'bar', { baz: 'BIFF' });\n    },\n\n    count: 0,\n\n    foo: Ember.computed(function() {\n      set(this, 'count', get(this, 'count')+1);\n      return Ember.get(get(this, 'bar'), 'baz') + ' ' + get(this, 'count');\n    }).property('bar.baz')\n\n  });\n\n  var Subclass = MyClass.extend({\n\n    init: function() {\n      this._super();\n      set(this, 'bar2', { baz: 'BIFF2' });\n    },\n\n    count: 0,\n\n    foo: Ember.computed(function() {\n      set(this, 'count', get(this, 'count')+1);\n      return Ember.get(get(this, 'bar2'), 'baz') + ' ' + get(this, 'count');\n    }).property('bar2.baz')\n  });\n\n  var obj2 = new Subclass();\n\n  equal(get(obj2, 'foo'), 'BIFF2 1');\n\n  set(get(obj2, 'bar'), 'baz', 'BLARG');\n  equal(get(obj2, 'foo'), 'BIFF2 1', 'should not invalidate property');\n\n  set(get(obj2, 'bar2'), 'baz', 'BLARG');\n  equal(get(obj2, 'foo'), 'BLARG 2', 'should invalidate property');\n});\n\ntest(\"can retrieve metadata for a computed property\", function() {\n  var get = Ember.get;\n\n  var MyClass = Ember.Object.extend({\n    computedProperty: Ember.computed(function() {\n    }).meta({ key: 'keyValue' })\n  });\n\n  equal(get(MyClass.metaForProperty('computedProperty'), 'key'), 'keyValue', \"metadata saved on the computed property can be retrieved\");\n\n  var ClassWithNoMetadata = Ember.Object.extend({\n    computedProperty: Ember.computed(function() {\n    }).volatile(),\n\n    staticProperty: 12\n  });\n\n  equal(typeof ClassWithNoMetadata.metaForProperty('computedProperty'), \"object\", \"returns empty hash if no metadata has been saved\");\n\n  raises(function() {\n    ClassWithNoMetadata.metaForProperty('nonexistentProperty');\n  }, Error, \"throws an error if metadata for a non-existent property is requested\");\n\n  raises(function() {\n    ClassWithNoMetadata.metaForProperty('staticProperty');\n  }, Error, \"throws an error if metadata for a non-computed property is requested\");\n});\n\ntestBoth(\"can iterate over a list of computed properties for a class\", function(get, set) {\n  var MyClass = Ember.Object.extend({\n    foo: Ember.computed(function() {\n\n    }),\n\n    fooDidChange: Ember.observer(function() {\n\n    }, 'foo'),\n\n    bar: Ember.computed(function() {\n\n    })\n  });\n\n  var SubClass = MyClass.extend({\n    baz: Ember.computed(function() {\n\n    })\n  });\n\n  SubClass.reopen({\n    bat: Ember.computed(function() {\n\n    }).meta({ iAmBat: true })\n  });\n\n  var list = [];\n\n  MyClass.eachComputedProperty(function(name) {\n    list.push(name);\n  });\n\n  deepEqual(list.sort(), ['bar', 'foo'], \"watched and unwatched computed properties are iterated\");\n\n  list = [];\n\n  SubClass.eachComputedProperty(function(name, meta) {\n    list.push(name);\n\n    if (name === 'bat') {\n      deepEqual(meta, { iAmBat: true });\n    } else {\n      deepEqual(meta, {});\n    }\n  });\n\n  deepEqual(list.sort(), ['bar', 'bat', 'baz', 'foo'], \"all inherited properties are included\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/object/computed_test");minispade.register('ember-runtime/~tests/system/object/create_test', "(function() {/*globals TestObject:true */\n\nmodule('Ember.Object.create');\n\ntest(\"simple properties are set\", function() {\n  var o = Ember.Object.create({ohai: 'there'});\n  equal(o.get('ohai'), 'there');\n});\n\ntest(\"calls computed property setters\", function() {\n  var MyClass = Ember.Object.extend({\n    foo: Ember.computed(function(key, val) {\n      if (arguments.length === 2) { return val; }\n      return \"this is not the value you're looking for\";\n    })\n  });\n\n  var o = MyClass.create({foo: 'bar'});\n  equal(o.get('foo'), 'bar');\n});\n\ntest(\"sets up mandatory setters for watched simple properties\", function() {\n  var MyClass = Ember.Object.extend({\n    foo: null,\n    bar: null,\n    fooDidChange: Ember.observer(function() {}, 'foo')\n  });\n\n  var o = MyClass.create({foo: 'bar', bar: 'baz'});\n  equal(o.get('foo'), 'bar');\n\n  var descriptor = Object.getOwnPropertyDescriptor(o, 'foo');\n  ok(descriptor.set, 'Mandatory setter was setup');\n\n  descriptor = Object.getOwnPropertyDescriptor(o, 'bar');\n  ok(!descriptor.set, 'Mandatory setter was not setup');\n});\n\ntest(\"allows bindings to be defined\", function() {\n  var obj = Ember.Object.create({\n    foo: 'foo',\n    barBinding: 'foo'\n  });\n\n  equal(obj.get('bar'), 'foo', 'The binding value is correct');\n});\n\ntest(\"calls setUnknownProperty if defined\", function() {\n  var setUnknownPropertyCalled = false;\n\n  var MyClass = Ember.Object.extend({\n    setUnknownProperty: function(key, value) {\n      setUnknownPropertyCalled = true;\n    }\n  });\n\n  var o = MyClass.create({foo: 'bar'});\n  ok(setUnknownPropertyCalled, 'setUnknownProperty was called');\n});\n\ntest(\"throws if you try to define a computed property\", function() {\n  raises(function() {\n    var obj = Ember.Object.create({\n      foo: Ember.computed(function(){})\n    });\n  }, 'should warn that a computed property was passed to create');\n});\n\ntest(\"throws if you try to call _super in a method\", function() {\n  raises(function() {\n    var obj = Ember.Object.create({\n      foo: function() {\n        this._super();\n      }\n    });\n  }, 'should warn that a method that calls _super was passed to create');\n});\n\nmodule('Ember.Object.createWithMixins');\n\ntest(\"Creates a new object that contains passed properties\", function() {\n\n  var called = false;\n  var obj = Ember.Object.createWithMixins({\n    prop: 'FOO',\n    method: function() { called=true; }\n  });\n\n  equal(Ember.get(obj, 'prop'), 'FOO', 'obj.prop');\n  obj.method();\n  ok(called, 'method executed');\n\n});\n\n// ..........................................................\n// WORKING WITH MIXINS\n//\n\ntest(\"Creates a new object that includes mixins and properties\", function() {\n\n  var MixinA = Ember.Mixin.create({ mixinA: 'A' });\n  var obj = Ember.Object.createWithMixins(MixinA, { prop: 'FOO' });\n\n  equal(Ember.get(obj, 'mixinA'), 'A', 'obj.mixinA');\n  equal(Ember.get(obj, 'prop'), 'FOO', 'obj.prop');\n});\n\n// ..........................................................\n// LIFECYCLE\n//\n\ntest(\"Configures _super() on methods with override\", function() {\n  var completed = false;\n  var MixinA = Ember.Mixin.create({ method: function() {} });\n  var obj = Ember.Object.createWithMixins(MixinA, {\n    method: function() {\n      this._super();\n      completed = true;\n    }\n  });\n\n  obj.method();\n  ok(completed, 'should have run method without error');\n});\n\ntest(\"Calls init if defined\", function() {\n  var completed = false;\n  var obj = Ember.Object.createWithMixins({\n    init: function() {\n      this._super();\n      completed = true;\n    }\n  });\n\n  ok(completed, 'should have run init without error');\n});\n\ntest(\"Calls all mixin inits if defined\", function() {\n  var completed = 0;\n  var Mixin1 = Ember.Mixin.create({\n    init: function() { this._super(); completed++; }\n  });\n\n  var Mixin2 = Ember.Mixin.create({\n    init: function() { this._super(); completed++; }\n  });\n\n  Ember.Object.createWithMixins(Mixin1, Mixin2);\n  equal(completed, 2, 'should have called init for both mixins.');\n});\n\ntest('creating an object with required properties', function() {\n  var ClassA = Ember.Object.extend({\n    foo: Ember.required()\n  });\n\n  var obj = ClassA.createWithMixins({ foo: 'FOO' }); // should not throw\n  equal(Ember.get(obj,'foo'), 'FOO');\n});\n\n\n// ..........................................................\n// BUGS\n//\n\ntest('create should not break observed values', function() {\n\n  var CountObject = Ember.Object.extend({\n    value: null,\n\n    _count: 0,\n\n    reset: function() {\n      this._count = 0;\n      return this;\n    },\n\n    valueDidChange: Ember.observer(function() {\n      this._count++;\n    }, 'value')\n  });\n\n  var obj = CountObject.createWithMixins({ value: 'foo' });\n  equal(obj._count, 0, 'should not fire yet');\n\n  Ember.set(obj, 'value', 'BAR');\n  equal(obj._count, 1, 'should fire');\n});\n\ntest('bindings on a class should only sync on instances', function() {\n  TestObject = Ember.Object.createWithMixins({\n    foo: 'FOO'\n  });\n\n  var Class, inst;\n\n  Ember.run(function() {\n    Class = Ember.Object.extend({\n      fooBinding: 'TestObject.foo'\n    });\n\n    inst = Class.createWithMixins();\n  });\n\n  equal(Ember.get(Class.prototype, 'foo'), undefined, 'should not sync binding');\n  equal(Ember.get(inst, 'foo'), 'FOO', 'should sync binding');\n\n});\n\n\ntest('inherited bindings should only sync on instances', function() {\n  TestObject = Ember.Object.createWithMixins({\n    foo: 'FOO'\n  });\n\n  var Class, Subclass, inst;\n\n  Ember.run(function() {\n    Class = Ember.Object.extend({\n      fooBinding: 'TestObject.foo'\n    });\n  });\n\n  Ember.run(function() {\n    Subclass = Class.extend();\n    inst = Subclass.createWithMixins();\n  });\n\n  equal(Ember.get(Class.prototype, 'foo'), undefined, 'should not sync binding on Class');\n  equal(Ember.get(Subclass.prototype, 'foo'), undefined, 'should not sync binding on Subclass');\n  equal(Ember.get(inst, 'foo'), 'FOO', 'should sync binding on inst');\n\n  Ember.run(function() {\n    Ember.set(TestObject, 'foo', 'BAR');\n  });\n\n  equal(Ember.get(Class.prototype, 'foo'), undefined, 'should not sync binding on Class');\n  equal(Ember.get(Subclass.prototype, 'foo'), undefined, 'should not sync binding on Subclass');\n  equal(Ember.get(inst, 'foo'), 'BAR', 'should sync binding on inst');\n\n});\n\ntest(\"created objects should not share a guid with their superclass\", function() {\n  ok(Ember.guidFor(Ember.Object), \"Ember.Object has a guid\");\n\n  var objA = Ember.Object.createWithMixins(),\n      objB = Ember.Object.createWithMixins();\n\n  ok(Ember.guidFor(objA) !== Ember.guidFor(objB), \"two instances do not share a guid\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/object/create_test");minispade.register('ember-runtime/~tests/system/object/destroy_test', "(function() {/*globals raises TestObject */\n\nmodule('ember-runtime/system/object/destroy_test');\n\ntest(\"should schedule objects to be destroyed at the end of the run loop\", function() {\n  var obj = Ember.Object.create(), meta;\n\n  Ember.run(function() {\n    obj.destroy();\n    meta = obj[Ember.META_KEY];\n    ok(meta, \"meta is not destroyed immediately\");\n    ok(!obj.get('isDestroyed'), \"object is not destroyed immediately\");\n  });\n\n  meta = obj[Ember.META_KEY];\n  ok(!meta, \"meta is destroyed after run loop finishes\");\n  ok(obj.get('isDestroyed'), \"object is destroyed after run loop finishes\");\n});\n\ntest(\"should raise an exception when modifying watched properties on a destroyed object\", function() {\n  if (Ember.platform.hasAccessors) {\n    var obj = Ember.Object.createWithMixins({\n      foo: \"bar\",\n      fooDidChange: Ember.observer(function() { }, 'foo')\n    });\n\n    Ember.run(function() {\n      obj.destroy();\n    });\n\n    raises(function() {\n      Ember.set(obj, 'foo', 'baz');\n    }, Error, \"raises an exception\");\n  } else {\n    expect(0);\n  }\n});\n\ntest(\"observers should not fire after an object has been destroyed\", function() {\n  var count = 0;\n  var obj = Ember.Object.createWithMixins({\n    fooDidChange: Ember.observer(function() {\n      count++;\n    }, 'foo')\n  });\n\n  obj.set('foo', 'bar');\n\n  equal(count, 1, \"observer was fired once\");\n\n  Ember.run(function() {\n    Ember.beginPropertyChanges();\n    obj.set('foo', 'quux');\n    obj.destroy();\n    Ember.endPropertyChanges();\n  });\n\n  equal(count, 1, \"observer was not called after object was destroyed\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/object/destroy_test");minispade.register('ember-runtime/~tests/system/object/detectInstance_test', "(function() {module('system/object/detectInstance');\n\ntest('detectInstance detects instances correctly', function() {\n\n  var A = Ember.Object.extend();\n  var B = A.extend();\n  var C = A.extend();\n\n  var o = Ember.Object.create(),\n      a = A.create(),\n      b = B.create(),\n      c = C.create();\n\n  ok( Ember.Object.detectInstance(o), 'o is an instance of Ember.Object' );\n  ok( Ember.Object.detectInstance(a), 'a is an instance of Ember.Object' );\n  ok( Ember.Object.detectInstance(b), 'b is an instance of Ember.Object' );\n  ok( Ember.Object.detectInstance(c), 'c is an instance of Ember.Object' );\n\n  ok( !A.detectInstance(o), 'o is not an instance of A');\n  ok( A.detectInstance(a), 'a is an instance of A' );\n  ok( A.detectInstance(b), 'b is an instance of A' );\n  ok( A.detectInstance(c), 'c is an instance of A' );\n\n  ok( !B.detectInstance(o), 'o is not an instance of B' );\n  ok( !B.detectInstance(a), 'a is not an instance of B' );\n  ok( B.detectInstance(b), 'b is an instance of B' );\n  ok( !B.detectInstance(c), 'c is not an instance of B' );\n\n  ok( !C.detectInstance(o), 'o is not an instance of C' );\n  ok( !C.detectInstance(a), 'a is not an instance of C' );\n  ok( !C.detectInstance(b), 'b is not an instance of C' );\n  ok( C.detectInstance(c), 'c is an instance of C' );\n\n});\n})();\n//@ sourceURL=ember-runtime/~tests/system/object/detectInstance_test");minispade.register('ember-runtime/~tests/system/object/detect_test', "(function() {module('system/object/detect');\n\ntest('detect detects classes correctly', function() {\n\n  var A = Ember.Object.extend();\n  var B = A.extend();\n  var C = A.extend();\n\n  ok( Ember.Object.detect(Ember.Object), 'Ember.Object is an Ember.Object class' );\n  ok( Ember.Object.detect(A), 'A is an Ember.Object class' );\n  ok( Ember.Object.detect(B), 'B is an Ember.Object class' );\n  ok( Ember.Object.detect(C), 'C is an Ember.Object class' );\n\n  ok( !A.detect(Ember.Object), 'Ember.Object is not an A class' );\n  ok( A.detect(A), 'A is an A class' );\n  ok( A.detect(B), 'B is an A class' );\n  ok( A.detect(C), 'C is an A class' );\n\n  ok( !B.detect(Ember.Object), 'Ember.Object is not a B class' );\n  ok( !B.detect(A), 'A is not a B class' );\n  ok( B.detect(B), 'B is a B class' );\n  ok( !B.detect(C), 'C is not a B class' );\n\n  ok( !C.detect(Ember.Object), 'Ember.Object is not a C class' );\n  ok( !C.detect(A), 'A is not a C class' );\n  ok( !C.detect(B), 'B is not a C class' );\n  ok( C.detect(C), 'C is a C class' );\n\n});\n})();\n//@ sourceURL=ember-runtime/~tests/system/object/detect_test");minispade.register('ember-runtime/~tests/system/object/events_test', "(function() {module(\"Object events\");\n\ntest(\"a listener can be added to an object\", function() {\n  var count = 0;\n  var F = function() { count++; };\n\n  var obj = Ember.Object.createWithMixins(Ember.Evented);\n\n  obj.on('event!', F);\n  obj.trigger('event!');\n\n  equal(count, 1, \"the event was triggered\");\n\n  obj.trigger('event!');\n\n  equal(count, 2, \"the event was triggered\");\n});\n\ntest(\"a listener can be added and removed automatically the first time it is triggered\", function() {\n  var count = 0;\n  var F = function() { count++; };\n\n  var obj = Ember.Object.createWithMixins(Ember.Evented);\n\n  obj.one('event!', F);\n  obj.trigger('event!');\n\n  equal(count, 1, \"the event was triggered\");\n\n  obj.trigger('event!');\n\n  equal(count, 1, \"the event was not triggered again\");\n});\n\ntest(\"triggering an event can have arguments\", function() {\n  var self, args;\n\n  var obj = Ember.Object.createWithMixins(Ember.Evented);\n\n  obj.on('event!', function() {\n    args = [].slice.call(arguments);\n    self = this;\n  });\n\n  obj.trigger('event!', \"foo\", \"bar\");\n\n  deepEqual(args, [ \"foo\", \"bar\" ]);\n  equal(self, obj);\n});\n\ntest(\"a listener can be added and removed automatically and have arguments\", function() {\n  var self, args, count = 0;\n\n  var obj = Ember.Object.createWithMixins(Ember.Evented);\n\n  obj.one('event!', function() {\n    args = [].slice.call(arguments);\n    self = this;\n    count++;\n  });\n\n  obj.trigger('event!', \"foo\", \"bar\");\n\n  deepEqual(args, [ \"foo\", \"bar\" ]);\n  equal(self, obj);\n  equal(count, 1, \"the event is triggered once\");\n\n  obj.trigger('event!', \"baz\", \"bat\");\n\n  deepEqual(args, [ \"foo\", \"bar\" ]);\n  equal(count, 1, \"the event was not triggered again\");\n  equal(self, obj);\n});\n\ntest(\"binding an event can specify a different target\", function() {\n  var self, args;\n\n  var obj = Ember.Object.createWithMixins(Ember.Evented);\n  var target = {};\n\n  obj.on('event!', target, function() {\n    args = [].slice.call(arguments);\n    self = this;\n  });\n\n  obj.trigger('event!', \"foo\", \"bar\");\n\n  deepEqual(args, [ \"foo\", \"bar\" ]);\n  equal(self, target);\n});\n\ntest(\"a listener registered with one can take method as string and can be added with different target\", function() {\n  var count = 0;\n  var target = {};\n  target.fn = function() { count++; };\n\n  var obj = Ember.Object.createWithMixins(Ember.Evented);\n\n  obj.one('event!', target, 'fn');\n  obj.trigger('event!');\n\n  equal(count, 1, \"the event was triggered\");\n\n  obj.trigger('event!');\n\n  equal(count, 1, \"the event was not triggered again\");\n});\n\ntest(\"a listener registered with one can be removed with off\", function() {\n  var obj = Ember.Object.createWithMixins(Ember.Evented, {\n    F: function() {}\n  });\n  var F = function() {};\n\n  obj.one('event!', F);\n  obj.one('event!', obj, 'F');\n\n  equal(obj.has('event!'), true, 'has events');\n\n  obj.off('event!', F);\n  obj.off('event!', obj, 'F');\n\n  equal(obj.has('event!'), false, 'has no more events');\n});\n\ntest(\"adding and removing listeners should be chainable\", function() {\n  var obj = Ember.Object.createWithMixins(Ember.Evented);\n  var F = function() {};\n\n  var ret = obj.on('event!', F);\n  equal(ret, obj, '#on returns self');\n\n  ret = obj.off('event!', F);\n  equal(ret, obj, '#off returns self');\n\n  ret = obj.one('event!', F);\n  equal(ret, obj, '#one returns self');\n});\n})();\n//@ sourceURL=ember-runtime/~tests/system/object/events_test");minispade.register('ember-runtime/~tests/system/object/extend_test', "(function() {module('Ember.Object.extend');\n\ntest('Basic extend', function() {\n  var SomeClass = Ember.Object.extend({ foo: 'BAR' });\n  ok(SomeClass.isClass, \"A class has isClass of true\");\n  var obj = new SomeClass();\n  equal(obj.foo, 'BAR');\n  ok(obj.isInstance, \"An instance of a class has isInstance of true\");\n});\n\ntest('Sub-subclass', function() {\n  var SomeClass = Ember.Object.extend({ foo: 'BAR' });\n  var AnotherClass = SomeClass.extend({ bar: 'FOO' });\n  var obj = new AnotherClass();\n  equal(obj.foo, 'BAR');\n  equal(obj.bar, 'FOO');\n});\n\ntest('Overriding a method several layers deep', function() {\n  var SomeClass = Ember.Object.extend({\n    fooCnt: 0,\n    foo: function() { this.fooCnt++; },\n\n    barCnt: 0,\n    bar: function() { this.barCnt++; }\n  });\n\n  var AnotherClass = SomeClass.extend({\n    barCnt: 0,\n    bar: function() { this.barCnt++; this._super(); }\n  });\n\n  var FinalClass = AnotherClass.extend({\n    fooCnt: 0,\n    foo: function() { this.fooCnt++; this._super(); }\n  });\n\n  var obj = new FinalClass();\n  obj.foo();\n  obj.bar();\n  equal(obj.fooCnt, 2, 'should invoke both');\n  equal(obj.barCnt, 2, 'should invoke both');\n\n  // Try overriding on create also\n  obj = FinalClass.createWithMixins({\n    foo: function() { this.fooCnt++; this._super(); }\n  });\n\n  obj.foo();\n  obj.bar();\n  equal(obj.fooCnt, 3, 'should invoke final as well');\n  equal(obj.barCnt, 2, 'should invoke both');\n});\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/object/extend_test");minispade.register('ember-runtime/~tests/system/object/observer_test', "(function() {/*globals testBoth */\nminispade.require('ember-runtime/~tests/props_helper');\n\nmodule('Ember.Object observer');\n\ntestBoth('observer on class', function(get, set) {\n\n  var MyClass = Ember.Object.extend({\n\n    count: 0,\n\n    foo: Ember.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar')\n\n  });\n\n  var obj = new MyClass();\n  equal(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj, 'bar', \"BAZ\");\n  equal(get(obj, 'count'), 1, 'should invoke observer after change');\n\n});\n\ntestBoth('observer on subclass', function(get, set) {\n\n  var MyClass = Ember.Object.extend({\n\n    count: 0,\n\n    foo: Ember.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar')\n\n  });\n\n  var Subclass = MyClass.extend({\n    foo: Ember.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'baz')\n  });\n\n  var obj = new Subclass();\n  equal(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj, 'bar', \"BAZ\");\n  equal(get(obj, 'count'), 0, 'should not invoke observer after change');\n\n  set(obj, 'baz', \"BAZ\");\n  equal(get(obj, 'count'), 1, 'should not invoke observer after change');\n\n});\n\ntestBoth('observer on instance', function(get, set) {\n\n  var obj = Ember.Object.createWithMixins({\n\n    count: 0,\n\n    foo: Ember.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar')\n\n  });\n\n  equal(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj, 'bar', \"BAZ\");\n  equal(get(obj, 'count'), 1, 'should invoke observer after change');\n\n});\n\ntestBoth('observer on instance overridding class', function(get, set) {\n\n  var MyClass = Ember.Object.extend({\n\n    count: 0,\n\n    foo: Ember.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar')\n\n  });\n\n  var obj = MyClass.createWithMixins({\n    foo: Ember.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'baz') // <-- change property we observe\n  });\n\n  equal(get(obj, 'count'), 0, 'should not invoke observer immediately');\n\n  set(obj, 'bar', \"BAZ\");\n  equal(get(obj, 'count'), 0, 'should not invoke observer after change');\n\n  set(obj, 'baz', \"BAZ\");\n  equal(get(obj, 'count'), 1, 'should not invoke observer after change');\n\n});\n\ntestBoth('observer should not fire after being destroyed', function(get, set) {\n\n  var obj = Ember.Object.createWithMixins({\n    count: 0,\n    foo: Ember.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar')\n  });\n\n  equal(get(obj, 'count'), 0, 'precond - should not invoke observer immediately');\n\n  Ember.run(function() { obj.destroy(); });\n\n  if (Ember.assert) {\n    raises(function() {\n      set(obj, 'bar', \"BAZ\");\n    }, Error, \"raises error when setting a property\");\n  } else {\n    set(obj, 'bar', \"BAZ\");\n  }\n\n  equal(get(obj, 'count'), 0, 'should not invoke observer after change');\n});\n// ..........................................................\n// COMPLEX PROPERTIES\n//\n\n\ntestBoth('chain observer on class', function(get, set) {\n\n  var MyClass = Ember.Object.extend({\n    count: 0,\n\n    foo: Ember.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar.baz')\n  });\n\n  var obj1 = MyClass.create({\n    bar: { baz: 'biff' }\n  });\n\n  var obj2 = MyClass.create({\n    bar: { baz: 'biff2' }\n  });\n\n  equal(get(obj1, 'count'), 0, 'should not invoke yet');\n  equal(get(obj2, 'count'), 0, 'should not invoke yet');\n\n  set(get(obj1, 'bar'), 'baz', 'BIFF1');\n  equal(get(obj1, 'count'), 1, 'should invoke observer on obj1');\n  equal(get(obj2, 'count'), 0, 'should not invoke yet');\n\n  set(get(obj2, 'bar'), 'baz', 'BIFF2');\n  equal(get(obj1, 'count'), 1, 'should not invoke again');\n  equal(get(obj2, 'count'), 1, 'should invoke observer on obj2');\n});\n\n\ntestBoth('chain observer on class', function(get, set) {\n\n  var MyClass = Ember.Object.extend({\n    count: 0,\n\n    foo: Ember.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar.baz')\n  });\n\n  var obj1 = MyClass.createWithMixins({\n    bar: { baz: 'biff' }\n  });\n\n  var obj2 = MyClass.createWithMixins({\n    bar: { baz: 'biff2' },\n    bar2: { baz: 'biff3' },\n\n    foo: Ember.observer(function() {\n      set(this, 'count', get(this, 'count')+1);\n    }, 'bar2.baz')\n  });\n\n  equal(get(obj1, 'count'), 0, 'should not invoke yet');\n  equal(get(obj2, 'count'), 0, 'should not invoke yet');\n\n  set(get(obj1, 'bar'), 'baz', 'BIFF1');\n  equal(get(obj1, 'count'), 1, 'should invoke observer on obj1');\n  equal(get(obj2, 'count'), 0, 'should not invoke yet');\n\n  set(get(obj2, 'bar'), 'baz', 'BIFF2');\n  equal(get(obj1, 'count'), 1, 'should not invoke again');\n  equal(get(obj2, 'count'), 0, 'should not invoke yet');\n\n  set(get(obj2, 'bar2'), 'baz', 'BIFF3');\n  equal(get(obj1, 'count'), 1, 'should not invoke again');\n  equal(get(obj2, 'count'), 1, 'should invoke observer on obj2');\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/object/observer_test");minispade.register('ember-runtime/~tests/system/object/reopenClass_test', "(function() {module('system/object/reopenClass');\n\ntest('adds new properties to subclass', function() {\n\n  var Subclass = Ember.Object.extend();\n  Subclass.reopenClass({\n    foo: function() { return 'FOO'; },\n    bar: 'BAR'\n  });\n\n  equal(Subclass.foo(), 'FOO', 'Adds method');\n  equal(Ember.get(Subclass, 'bar'), 'BAR', 'Adds property');\n});\n\ntest('class properties inherited by subclasses', function() {\n\n  var Subclass = Ember.Object.extend();\n  Subclass.reopenClass({\n    foo: function() { return 'FOO'; },\n    bar: 'BAR'\n  });\n\n  var SubSub = Subclass.extend();\n\n  equal(SubSub.foo(), 'FOO', 'Adds method');\n  equal(Ember.get(SubSub, 'bar'), 'BAR', 'Adds property');\n});\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/object/reopenClass_test");minispade.register('ember-runtime/~tests/system/object/reopen_test', "(function() {module('system/core_object/reopenClass');\n\ntest('adds new properties to subclass instance', function() {\n\n  var Subclass = Ember.Object.extend();\n  Subclass.reopen({\n    foo: function() { return 'FOO'; },\n    bar: 'BAR'\n  });\n\n  equal( new Subclass().foo(), 'FOO', 'Adds method');\n  equal(Ember.get(new Subclass(), 'bar'), 'BAR', 'Adds property');\n});\n\ntest('reopened properties inherited by subclasses', function() {\n\n  var Subclass = Ember.Object.extend();\n  var SubSub = Subclass.extend();\n\n  Subclass.reopen({\n    foo: function() { return 'FOO'; },\n    bar: 'BAR'\n  });\n\n\n  equal( new SubSub().foo(), 'FOO', 'Adds method');\n  equal(Ember.get(new SubSub(), 'bar'), 'BAR', 'Adds property');\n});\n\n// We plan to allow this in the future\ntest('does not allow reopening already instantiated classes', function() {\n  var Subclass = Ember.Object.extend();\n\n  Subclass.create();\n\n  Subclass.reopen({\n    trololol: true\n  });\n\n  equal(Subclass.create().get('trololol'), true, \"reopen works\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/object/reopen_test");minispade.register('ember-runtime/~tests/system/object/subclasses_test', "(function() {module('system/object/subclasses');\n\ntest('chains should copy forward to subclasses when prototype created', function () {\n  var ObjectWithChains, objWithChains, SubWithChains, SubSub, subSub;\n  Ember.run(function () {\n    ObjectWithChains = Ember.Object.extend({\n      obj: {\n        a: 'a',\n        hi: 'hi'\n      },\n      aBinding: 'obj.a' // add chain\n    });\n    // realize prototype\n    objWithChains = ObjectWithChains.create();\n    // should not copy chains from parent yet\n    SubWithChains = ObjectWithChains.extend({\n      hiBinding: 'obj.hi', // add chain\n      hello: Ember.computed(function() {\n        return this.get('obj.hi') + ' world';\n      }).property('hi'), // observe chain\n      greetingBinding: 'hello'\n    });\n    SubSub = SubWithChains.extend();\n    // should realize prototypes and copy forward chains\n    subSub = SubSub.create();\n  });\n  equal(subSub.get('greeting'), 'hi world');\n  Ember.run(function () {\n    objWithChains.set('obj.hi', 'hello');\n  });\n  equal(subSub.get('greeting'), 'hello world');\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/object/subclasses_test");minispade.register('ember-runtime/~tests/system/object/toString_test', "(function() {var guidFor = Ember.guidFor, originalLookup = Ember.lookup, lookup;\n\nmodule('system/object/toString', {\n  setup: function() {\n    lookup = Ember.lookup = {};\n  },\n  teardown: function() {\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest(\"toString() returns the same value if called twice\", function() {\n  var Foo = Ember.Namespace.create();\n  Foo.toString = function() { return \"Foo\"; };\n\n  Foo.Bar = Ember.Object.extend();\n\n  equal(Foo.Bar.toString(), \"Foo.Bar\");\n  equal(Foo.Bar.toString(), \"Foo.Bar\");\n\n  var obj = Foo.Bar.create();\n\n  equal(obj.toString(), \"<Foo.Bar:\" + guidFor(obj) + \">\");\n  equal(obj.toString(), \"<Foo.Bar:\" + guidFor(obj) + \">\");\n\n  equal(Foo.Bar.toString(), \"Foo.Bar\");\n});\n\ntest(\"toString on a class returns a useful value when nested in a namespace\", function() {\n  var obj;\n\n  var Foo = Ember.Namespace.create();\n  Foo.toString = function() { return \"Foo\"; };\n\n  Foo.Bar = Ember.Object.extend();\n  equal(Foo.Bar.toString(), \"Foo.Bar\");\n\n  obj = Foo.Bar.create();\n  equal(obj.toString(), \"<Foo.Bar:\" + guidFor(obj) + \">\");\n\n  Foo.Baz = Foo.Bar.extend();\n  equal(Foo.Baz.toString(), \"Foo.Baz\");\n\n  obj = Foo.Baz.create();\n  equal(obj.toString(), \"<Foo.Baz:\" + guidFor(obj) + \">\");\n\n  obj = Foo.Bar.create();\n  equal(obj.toString(), \"<Foo.Bar:\" + guidFor(obj) + \">\");\n});\n\ntest(\"toString on a namespace finds the namespace in Ember.lookup\", function() {\n  var Foo = lookup.Foo = Ember.Namespace.create();\n\n  equal(Foo.toString(), \"Foo\");\n});\n\ntest(\"toString on a namespace finds the namespace in Ember.lookup\", function() {\n  var Foo = lookup.Foo = Ember.Namespace.create(), obj;\n\n  Foo.Bar = Ember.Object.extend();\n\n  equal(Foo.Bar.toString(), \"Foo.Bar\");\n\n  obj = Foo.Bar.create();\n  equal(obj.toString(), \"<Foo.Bar:\" + guidFor(obj) + \">\");\n});\n\ntest('toString includes toStringExtension if defined', function() {\n  var Foo = Ember.Object.extend({\n        toStringExtension: function(){\n          return \"fooey\";\n        }\n      }),\n      foo = Foo.create(),\n      Bar = Ember.Object.extend({}),\n      bar = Bar.create();\n    // simulate these classes being defined on a Namespace\n    Foo[Ember.GUID_KEY+'_name'] = 'Foo';\n    Bar[Ember.GUID_KEY+'_name'] = 'Bar';\n\n  equal(bar.toString(), '<Bar:'+Ember.guidFor(bar)+'>', 'does not include toStringExtension part');\n  equal(foo.toString(), '<Foo:'+Ember.guidFor(foo)+':fooey>', 'Includes toStringExtension result');\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/object/toString_test");minispade.register('ember-runtime/~tests/system/object_proxy_test', "(function() {module(\"Ember.ObjectProxy\");\n\ntestBoth(\"should not proxy properties passed to create\", function (get, set) {\n  var Proxy = Ember.ObjectProxy.extend({\n    cp: Ember.computed(function (key, value) {\n      if (value) {\n        this._cp = value;\n      }\n      return this._cp;\n    })\n  });\n  var proxy = Proxy.create({\n    prop: 'Foo',\n    cp: 'Bar'\n  });\n\n  equal(get(proxy, 'prop'), 'Foo', 'should not have tried to proxy set');\n  equal(proxy._cp, 'Bar', 'should use CP setter');\n});\n\ntestBoth(\"should proxy properties to content\", function(get, set) {\n  var content = {\n        firstName: 'Tom',\n        lastName: 'Dale',\n        unknownProperty: function (key) { return key + ' unknown';}\n      },\n      proxy = Ember.ObjectProxy.create();\n\n  equal(get(proxy, 'firstName'), undefined, 'get on proxy without content should return undefined');\n  raises(function () {\n    set(proxy, 'firstName', 'Foo');\n  }, 'set on proxy without content should raise');\n\n  set(proxy, 'content', content);\n\n  equal(get(proxy, 'firstName'), 'Tom', 'get on proxy with content should forward to content');\n  equal(get(proxy, 'lastName'), 'Dale', 'get on proxy with content should forward to content');\n  equal(get(proxy, 'foo'), 'foo unknown', 'get on proxy with content should forward to content');\n\n  set(proxy, 'lastName', 'Huda');\n\n  equal(get(content, 'lastName'), 'Huda', 'content should have new value from set on proxy');\n  equal(get(proxy, 'lastName'), 'Huda', 'proxy should have new value from set on proxy');\n\n  set(proxy, 'content', {firstName: 'Yehuda', lastName: 'Katz'});\n\n  equal(get(proxy, 'firstName'), 'Yehuda', 'proxy should reflect updated content');\n  equal(get(proxy, 'lastName'), 'Katz', 'proxy should reflect updated content');\n});\n\ntestBoth(\"should work with watched properties\", function(get, set) {\n  var content1 = {firstName: 'Tom', lastName: 'Dale'},\n    content2 = {firstName: 'Yehuda', lastName: 'Katz'},\n    Proxy,\n    proxy,\n    count = 0,\n    last;\n\n  Proxy = Ember.ObjectProxy.extend({\n    fullName: Ember.computed(function () {\n      var firstName = this.get('firstName'),\n          lastName = this.get('lastName');\n      if (firstName && lastName) {\n        return firstName + ' ' + lastName;\n      }\n      return firstName || lastName;\n    }).property('firstName', 'lastName')\n  });\n\n  proxy = Proxy.create();\n\n  Ember.addObserver(proxy, 'fullName', function () {\n    last = get(proxy, 'fullName');\n    count++;\n  });\n\n  // proxy without content returns undefined\n  equal(get(proxy, 'fullName'), undefined);\n\n  // setting content causes all watched properties to change\n  set(proxy, 'content', content1);\n  // both dependent keys changed\n  equal(count, 2);\n  equal(last, 'Tom Dale');\n\n  // setting property in content causes proxy property to change\n  set(content1, 'lastName', 'Huda');\n  equal(count, 3);\n  equal(last, 'Tom Huda');\n\n  // replacing content causes all watched properties to change\n  set(proxy, 'content', content2);\n  // both dependent keys changed\n  equal(count, 5);\n  equal(last, 'Yehuda Katz');\n  // content1 is no longer watched\n  ok(!Ember.isWatching(content1, 'firstName'), 'not watching firstName');\n  ok(!Ember.isWatching(content1, 'lastName'), 'not watching lastName');\n\n  // setting property in new content\n  set(content2, 'firstName', 'Tomhuda');\n  equal(last, 'Tomhuda Katz');\n  equal(count, 6);\n\n  // setting property in proxy syncs with new content\n  set(proxy, 'lastName', 'Katzdale');\n  equal(count, 7);\n  equal(last, 'Tomhuda Katzdale');\n  equal(get(content2, 'firstName'), 'Tomhuda');\n  equal(get(content2, 'lastName'), 'Katzdale');\n});\n\ntest(\"set and get should work with paths\", function () {\n  var content = {foo: {bar: 'baz'}},\n      proxy = Ember.ObjectProxy.create({content: content}),\n      count = 0;\n  proxy.set('foo.bar', 'hello');\n  equal(proxy.get('foo.bar'), 'hello');\n  equal(proxy.get('content.foo.bar'), 'hello');\n\n  proxy.addObserver('foo.bar', function () {\n    count++;\n  });\n\n  proxy.set('foo.bar', 'bye');\n\n  equal(count, 1);\n  equal(proxy.get('foo.bar'), 'bye');\n  equal(proxy.get('content.foo.bar'), 'bye');\n});\n\ntestBoth(\"should transition between watched and unwatched strategies\", function(get, set) {\n  var content = {foo: 'foo'},\n      proxy = Ember.ObjectProxy.create({content: content}),\n      count = 0;\n\n  function observer() {\n    count++;\n  }\n\n  equal(get(proxy, 'foo'), 'foo');\n\n  set(content, 'foo', 'bar');\n\n  equal(get(proxy, 'foo'), 'bar');\n\n  set(proxy, 'foo', 'foo');\n\n  equal(get(content, 'foo'), 'foo');\n  equal(get(proxy, 'foo'), 'foo');\n\n  Ember.addObserver(proxy, 'foo', observer);\n\n  equal(count, 0);\n  equal(get(proxy, 'foo'), 'foo');\n\n  set(content, 'foo', 'bar');\n\n  equal(count, 1);\n  equal(get(proxy, 'foo'), 'bar');\n\n  set(proxy, 'foo', 'foo');\n\n  equal(count, 2);\n  equal(get(content, 'foo'), 'foo');\n  equal(get(proxy, 'foo'), 'foo');\n\n  Ember.removeObserver(proxy, 'foo', observer);\n\n  set(content, 'foo', 'bar');\n\n  equal(get(proxy, 'foo'), 'bar');\n\n  set(proxy, 'foo', 'foo');\n\n  equal(get(content, 'foo'), 'foo');\n  equal(get(proxy, 'foo'), 'foo');\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/object_proxy_test");minispade.register('ember-runtime/~tests/system/set/copyable_suite_test', "(function() {// ..........................................................\n// COPYABLE TESTS\n//\nEmber.CopyableTests.extend({\n  name: 'Ember.Set Copyable',\n\n  newObject: function() {\n    var set = new Ember.Set();\n    set.addObject(Ember.generateGuid());\n    return set;\n  },\n\n  isEqual: function(a,b) {\n    if (!(a instanceof Ember.Set)) return false;\n    if (!(b instanceof Ember.Set)) return false;\n    return Ember.get(a, 'firstObject') === Ember.get(b, 'firstObject');\n  },\n\n  shouldBeFreezable: true\n}).run();\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/set/copyable_suite_test");minispade.register('ember-runtime/~tests/system/set/enumerable_suite_test', "(function() {// ..........................................................\n// MUTABLE ENUMERABLE TESTS\n//\nEmber.MutableEnumerableTests.extend({\n\n  name: 'Ember.Set',\n\n  newObject: function(ary) {\n    ary = ary ? ary.slice() : this.newFixture(3);\n    var ret = new Ember.Set();\n    ret.addObjects(ary);\n    return ret;\n  },\n\n  mutate: function(obj) {\n    obj.addObject(Ember.get(obj, 'length')+1);\n  },\n\n  toArray: function(obj) {\n    return obj.toArray ? obj.toArray() : obj.slice(); // make a copy.\n  }\n\n}).run();\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/set/enumerable_suite_test");minispade.register('ember-runtime/~tests/system/set/extra_test', "(function() {// ..........................................................\n// Ember.Set.init\n//\n\nmodule('Ember.Set.init');\n\ntest('passing an array to new Ember.Set() should instantiate w/ items', function() {\n\n  var get = Ember.get;\n  var ary  = [1,2,3];\n  var aSet = new Ember.Set(ary);\n  var count = 0;\n\n  equal(get(aSet, 'length'), 3, 'should have three items');\n  aSet.forEach(function(x) {\n    ok(Ember.EnumerableUtils.indexOf(ary, x)>=0, 'should find passed item in array');\n    count++;\n  });\n  equal(count, 3, 'iterating should have returned three objects');\n});\n\n\n// ..........................................................\n// Ember.Set.clear\n//\n\nmodule('Ember.Set.clear');\n\ntest('should clear a set of its content', function() {\n\n  var get = Ember.get, set = Ember.set;\n  var aSet = new Ember.Set([1,2,3]);\n  var count = 0;\n\n  equal(get(aSet, 'length'), 3, 'should have three items');\n  ok(get(aSet, 'firstObject'), 'firstObject should return an object');\n  ok(get(aSet, 'lastObject'), 'lastObject should return an object');\n  Ember.addObserver(aSet, '[]', function() { count++; });\n\n  aSet.clear();\n  equal(get(aSet, 'length'), 0, 'should have 0 items');\n  equal(count, 1, 'should have notified of content change');\n  equal(get(aSet, 'firstObject'), null, 'firstObject should return nothing');\n  equal(get(aSet, 'lastObject'), null, 'lastObject should return nothing');\n\n  count = 0;\n  aSet.forEach(function() { count++; });\n  equal(count, 0, 'iterating over items should not invoke callback');\n\n});\n\n// ..........................................................\n// Ember.Set.pop\n//\n\nmodule('Ember.Set.pop');\n\ntest('calling pop should return an object and remove it', function() {\n\n  var aSet = new Ember.Set([1,2,3]);\n  var count = 0, obj;\n  while(count<10 && (obj = aSet.pop())) {\n    equal(aSet.contains(obj), false, 'set should no longer contain object');\n    count++;\n    equal(Ember.get(aSet, 'length'), 3-count, 'length should be shorter');\n  }\n\n  equal(count, 3, 'should only pop 3 objects');\n  equal(Ember.get(aSet, 'length'), 0, 'final length should be zero');\n  equal(aSet.pop(), null, 'extra pops should do nothing');\n});\n\n// ..........................................................\n// Ember.Set.aliases\n//\n\nmodule('Ember.Set aliases');\n\ntest('method aliases', function() {\n  var aSet = new Ember.Set();\n  equal(aSet.add, aSet.addObject, 'add -> addObject');\n  equal(aSet.remove, aSet.removeObject, 'remove -> removeObject');\n  equal(aSet.addEach, aSet.addObjects, 'addEach -> addObjects');\n  equal(aSet.removeEach, aSet.removeObjects, 'removeEach -> removeObjects');\n\n  equal(aSet.push, aSet.addObject, 'push -> addObject');\n  equal(aSet.unshift, aSet.addObject, 'unshift -> addObject');\n  equal(aSet.shift, aSet.pop, 'shift -> pop');\n});\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/set/extra_test");minispade.register('ember-runtime/~tests/system/string/camelize', "(function() {module('Ember.String.camelize');\n\ntest(\"camelize normal string\", function() {\n  deepEqual(Ember.String.camelize('my favorite items'), 'myFavoriteItems');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('my favorite items'.camelize(), 'myFavoriteItems');\n  }\n});\n\ntest(\"camelize capitalized string\", function() {\n  deepEqual(Ember.String.camelize('I Love Ramen'), 'iLoveRamen');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('I Love Ramen'.camelize(), 'iLoveRamen');\n  }\n});\n\ntest(\"camelize dasherized string\", function() {\n  deepEqual(Ember.String.camelize('css-class-name'), 'cssClassName');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('css-class-name'.camelize(), 'cssClassName');\n  }\n});\n\ntest(\"camelize underscored string\", function() {\n  deepEqual(Ember.String.camelize('action_name'), 'actionName');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('action_name'.camelize(), 'actionName');\n  }\n});\n\ntest(\"camelize dot notation string\", function() {\n  deepEqual(Ember.String.camelize('action.name'), 'actionName');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('action.name'.camelize(), 'actionName');\n  }\n});\n\ntest(\"does nothing with camelcased string\", function() {\n  deepEqual(Ember.String.camelize('innerHTML'), 'innerHTML');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('innerHTML'.camelize(), 'innerHTML');\n  }\n});\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/string/camelize");minispade.register('ember-runtime/~tests/system/string/capitalize', "(function() {// ==========================================================================\n// Project:  Ember Runtime\n// Copyright: 2006-2011 Strobe Inc. and contributors.\n//            2008-2011 Apple Inc. All rights reserved.\n// License:   Licensed under MIT license (see license.js)\n// ==========================================================================\n\nmodule('Ember.String.capitalize');\n\ntest(\"capitalize normal string\", function() {\n  deepEqual(Ember.String.capitalize('my favorite items'), 'My favorite items');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('my favorite items'.capitalize(), 'My favorite items');\n  }\n});\n\ntest(\"capitalize dasherized string\", function() {\n  deepEqual(Ember.String.capitalize('css-class-name'), 'Css-class-name');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('css-class-name'.capitalize(), 'Css-class-name');\n  }\n});\n\ntest(\"capitalize underscored string\", function() {\n  deepEqual(Ember.String.capitalize('action_name'), 'Action_name');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('action_name'.capitalize(), 'Action_name');\n  }\n});\n\ntest(\"capitalize camelcased string\", function() {\n  deepEqual(Ember.String.capitalize('innerHTML'), 'InnerHTML');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('innerHTML'.capitalize(), 'InnerHTML');\n  }\n});\n\ntest(\"does nothing with capitalized string\", function() {\n  deepEqual(Ember.String.capitalize('Capitalized string'), 'Capitalized string');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('Capitalized string'.capitalize(), 'Capitalized string');\n  }\n});\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/string/capitalize");minispade.register('ember-runtime/~tests/system/string/classify', "(function() {module('Ember.String.classify');\n\ntest(\"classify normal string\", function() {\n  deepEqual(Ember.String.classify('my favorite items'), 'MyFavoriteItems');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('my favorite items'.classify(), 'MyFavoriteItems');\n  }\n});\n\ntest(\"classify dasherized string\", function() {\n  deepEqual(Ember.String.classify('css-class-name'), 'CssClassName');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('css-class-name'.classify(), 'CssClassName');\n  }\n});\n\ntest(\"classify underscored string\", function() {\n  deepEqual(Ember.String.classify('action_name'), 'ActionName');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('action_name'.classify(), 'ActionName');\n  }\n});\n\ntest(\"does nothing with classified string\", function() {\n  deepEqual(Ember.String.classify('InnerHTML'), 'InnerHTML');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('InnerHTML'.classify(), 'InnerHTML');\n  }\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/string/classify");minispade.register('ember-runtime/~tests/system/string/dasherize', "(function() {module('Ember.String.dasherize');\n\ntest(\"dasherize normal string\", function() {\n  deepEqual(Ember.String.dasherize('my favorite items'), 'my-favorite-items');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('my favorite items'.dasherize(), 'my-favorite-items');\n  }\n});\n\ntest(\"does nothing with dasherized string\", function() {\n  deepEqual(Ember.String.dasherize('css-class-name'), 'css-class-name');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('css-class-name'.dasherize(), 'css-class-name');\n  }\n});\n\ntest(\"dasherize underscored string\", function() {\n  deepEqual(Ember.String.dasherize('action_name'), 'action-name');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('action_name'.dasherize(), 'action-name');\n  }\n});\n\ntest(\"dasherize camelcased string\", function() {\n  deepEqual(Ember.String.dasherize('innerHTML'), 'inner-html');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('innerHTML'.dasherize(), 'inner-html');\n  }\n});\n\ntest(\"dasherize string that is the property name of Object.prototype\", function() {\n  deepEqual(Ember.String.dasherize('toString'), 'to-string');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('toString'.dasherize(), 'to-string');\n  }\n});\n\ntest(\"after call with the same passed value take object from cache\", function() {\n  var res = Ember.String.dasherize('innerHTML');\n\n  var callCount = 0;\n  var decamelize = Ember.String.decamelize;\n\n  try {\n    Ember.String.decamelize = function() {\n      callCount++;\n    };\n    Ember.String.dasherize('innerHTML');\n  } finally {\n    Ember.String.decamelize = decamelize;\n  }\n\n  equal(callCount, 0, \"decamelize is not called again\");\n});\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/string/dasherize");minispade.register('ember-runtime/~tests/system/string/decamelize', "(function() {module('Ember.String.decamelize');\n\ntest(\"does nothing with normal string\", function() {\n  deepEqual(Ember.String.decamelize('my favorite items'), 'my favorite items');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('my favorite items'.decamelize(), 'my favorite items');\n  }\n});\n\ntest(\"does nothing with dasherized string\", function() {\n  deepEqual(Ember.String.decamelize('css-class-name'), 'css-class-name');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('css-class-name'.decamelize(), 'css-class-name');\n  }\n});\n\ntest(\"does nothing with underscored string\", function() {\n  deepEqual(Ember.String.decamelize('action_name'), 'action_name');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('action_name'.decamelize(), 'action_name');\n  }\n});\n\ntest(\"converts a camelized string into all lower case separated by underscores.\", function() {\n  deepEqual(Ember.String.decamelize('innerHTML'), 'inner_html');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('innerHTML'.decamelize(), 'inner_html');\n  }\n});\n})();\n//@ sourceURL=ember-runtime/~tests/system/string/decamelize");minispade.register('ember-runtime/~tests/system/string/fmt_string', "(function() {module('Ember.String.fmt');\n\ntest(\"'Hello %@ %@'.fmt('John', 'Doe') => 'Hello John Doe'\", function() {\n  equal(Ember.String.fmt('Hello %@ %@', ['John', 'Doe']), 'Hello John Doe');\n  if (Ember.EXTEND_PROTOTYPES) {\n    equal('Hello %@ %@'.fmt('John', 'Doe'), 'Hello John Doe');\n  }\n});\n\ntest(\"'Hello %@2 %@1'.fmt('John', 'Doe') => 'Hello Doe John'\", function() {\n  equal(Ember.String.fmt('Hello %@2 %@1', ['John', 'Doe']), 'Hello Doe John');\n  if (Ember.EXTEND_PROTOTYPES) {\n    equal('Hello %@2 %@1'.fmt('John', 'Doe'), 'Hello Doe John');\n  }\n});\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/string/fmt_string");minispade.register('ember-runtime/~tests/system/string/loc_test', "(function() {var oldString;\n\nmodule('Ember.String.loc', {\n  setup: function() {\n    oldString = Ember.STRINGS;\n    Ember.STRINGS = {\n      '_Hello World': 'Bonjour le monde',\n      '_Hello %@ %@': 'Bonjour %@ %@',\n      '_Hello %@# %@#': 'Bonjour %@2 %@1'\n    };\n  },\n\n  teardown: function() {\n    Ember.STRINGS = oldString;\n  }\n});\n\ntest(\"'_Hello World'.loc() => 'Bonjour le monde'\", function() {\n  equal(Ember.String.loc('_Hello World'), 'Bonjour le monde');\n  if (Ember.EXTEND_PROTOTYPES) {\n    equal('_Hello World'.loc(), 'Bonjour le monde');\n  }\n});\n\ntest(\"'_Hello %@ %@'.loc('John', 'Doe') => 'Bonjour John Doe'\", function() {\n  equal(Ember.String.loc('_Hello %@ %@', ['John', 'Doe']), 'Bonjour John Doe');\n  if (Ember.EXTEND_PROTOTYPES) {\n    equal('_Hello %@ %@'.loc('John', 'Doe'), 'Bonjour John Doe');\n  }\n});\n\ntest(\"'_Hello %@# %@#'.loc('John', 'Doe') => 'Bonjour Doe John'\", function() {\n  equal(Ember.String.loc('_Hello %@# %@#', ['John', 'Doe']), 'Bonjour Doe John');\n  if (Ember.EXTEND_PROTOTYPES) {\n    equal('_Hello %@# %@#'.loc('John', 'Doe'), 'Bonjour Doe John');\n  }\n});\n\ntest(\"'_Not In Strings'.loc() => '_Not In Strings'\", function() {\n  equal(Ember.String.loc('_Not In Strings'), '_Not In Strings');\n  if (Ember.EXTEND_PROTOTYPES) {\n    equal('_Not In Strings'.loc(), '_Not In Strings');\n  }\n});\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/string/loc_test");minispade.register('ember-runtime/~tests/system/string/underscore', "(function() {module('Ember.String.underscore');\n\ntest(\"with normal string\", function() {\n  deepEqual(Ember.String.underscore('my favorite items'), 'my_favorite_items');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('my favorite items'.underscore(), 'my_favorite_items');\n  }\n});\n\ntest(\"with dasherized string\", function() {\n  deepEqual(Ember.String.underscore('css-class-name'), 'css_class_name');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('css-class-name'.underscore(), 'css_class_name');\n  }\n});\n\ntest(\"does nothing with underscored string\", function() {\n  deepEqual(Ember.String.underscore('action_name'), 'action_name');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('action_name'.underscore(), 'action_name');\n  }\n});\n\ntest(\"with camelcased string\", function() {\n  deepEqual(Ember.String.underscore('innerHTML'), 'inner_html');\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('innerHTML'.underscore(), 'inner_html');\n  }\n});\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/string/underscore");minispade.register('ember-runtime/~tests/system/string/w_test', "(function() {module('Ember.String.w');\n\ntest(\"'one two three'.w() => ['one','two','three']\", function() {\n  deepEqual(Ember.String.w('one two three'), ['one','two','three']);\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('one two three'.w(), ['one','two','three']);\n  }\n});\n\ntest(\"'one    two    three'.w() with extra spaces between words => ['one','two','three']\", function() {\n  deepEqual(Ember.String.w('one   two  three'), ['one','two','three']);\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('one   two  three'.w(), ['one','two','three']);\n  }\n});\n\ntest(\"'one two three'.w() with tabs\", function() {\n  deepEqual(Ember.String.w('one\\ttwo  three'), ['one','two','three']);\n  if (Ember.EXTEND_PROTOTYPES) {\n    deepEqual('one\\ttwo  three'.w(), ['one','two','three']);\n  }\n});\n\n\n\n})();\n//@ sourceURL=ember-runtime/~tests/system/string/w_test");minispade.register('ember-states/~tests/state_manager_test', "(function() {var get = Ember.get, set = Ember.set;\n\nvar stateManager, loadingState, loadedState, stateEventStub = {\n  entered: 0,\n  enter: function() {\n    this.entered++;\n  },\n\n  exited: 0,\n  exit: function() {\n    this.exited++;\n  },\n\n  reset: function() {\n    this.entered = 0;\n    this.exited = 0;\n  }\n};\n\nmodule(\"Ember.StateManager\", {\n  setup: function() {\n    loadingState = Ember.State.create(stateEventStub);\n    loadedState = Ember.State.create(stateEventStub, {\n      empty: Ember.State.create(stateEventStub)\n    });\n\n    stateManager = Ember.StateManager.create({\n      loadingState: loadingState,\n      loadedState: loadedState\n    });\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      if (stateManager) {\n        stateManager.destroy();\n      }\n    });\n  }\n});\n\ntest(\"it exists\", function() {\n  ok(Ember.Object.detect(Ember.StateManager), \"Ember.StateManager is an Ember.Object\");\n});\n\ntest(\"it discovers states set in its state property\", function() {\n  var states = {\n    loading: Ember.State.create(),\n    loaded: Ember.State.create()\n  };\n\n  stateManager = Ember.StateManager.create({\n    states: states\n  });\n\n  equal(states, stateManager.get('states'), \"reports same states as were set\");\n});\n\ntest(\"it discovers states that are properties of the state manager\", function() {\n  stateManager = Ember.StateManager.create({\n    loading: Ember.State.create(),\n    loaded: Ember.State.create()\n  });\n\n  var states = stateManager.get('states');\n  ok(get(states, 'loading'), \"found loading state\");\n  ok(get(states, 'loaded'), \"found loaded state\");\n});\n\ntest(\"it reports its current state\", function() {\n  ok(get(stateManager, 'currentState') === null, \"currentState defaults to null if no state is specified\");\n\n  stateManager.transitionTo('loadingState');\n  ok(get(stateManager, 'currentState') === loadingState, \"currentState changes after transitionTo() is called\");\n\n  stateManager.transitionTo('loadedState');\n  ok(get(stateManager, 'currentState') === loadedState, \"currentState can change to a sibling state\");\n});\n\ntest(\"it reports its current state path\", function() {\n  strictEqual(get(stateManager, 'currentPath'), null, \"currentPath defaults to null if no state is specified\");\n\n  stateManager.transitionTo('loadingState');\n  equal(get(stateManager, 'currentPath'), 'loadingState', \"currentPath changes after transitionTo() is called\");\n\n  stateManager.transitionTo('loadedState');\n  equal(get(stateManager, 'currentPath'), 'loadedState', \"currentPath can change to a sibling state\");\n});\n\ntest(\"it sends enter and exit events during state transitions\", function() {\n  stateManager.transitionTo('loadingState');\n\n  equal(loadingState.entered, 1, \"state should receive one enter event\");\n  equal(loadingState.exited, 0, \"state should not have received an exit event\");\n  equal(loadedState.entered, 0, \"sibling state should not have received enter event\");\n  equal(loadedState.exited, 0, \"sibling state should not have received exited event\");\n\n  loadingState.reset();\n  loadedState.reset();\n\n  stateManager.transitionTo('loadedState');\n  equal(loadingState.entered, 0, \"state should not receive an enter event\");\n  equal(loadingState.exited, 1, \"state should receive one exit event\");\n  equal(loadedState.entered, 1, \"sibling state should receive one enter event\");\n  equal(loadedState.exited, 0, \"sibling state should not have received exited event\");\n\n  loadingState.reset();\n  loadedState.reset();\n\n  stateManager.transitionTo('loadingState');\n\n  equal(loadingState.entered, 1, \"state should receive one enter event\");\n  equal(loadingState.exited, 0, \"state should not have received an exit event\");\n  equal(loadedState.entered, 0, \"sibling state should not have received enter event\");\n  equal(loadedState.exited, 1, \"sibling state should receive one exit event\");\n});\n\ntest(\"it accepts absolute paths when changing states\", function() {\n  var emptyState = loadedState.empty;\n\n  stateManager.transitionTo('loadingState');\n\n  stateManager.transitionTo('loadedState.empty');\n\n  equal(emptyState.entered, 1, \"sends enter event to substate\");\n  equal(emptyState.exited, 0, \"does not send exit event to substate\");\n  ok(stateManager.get('currentState') === emptyState, \"updates currentState property to state at absolute path\");\n});\n\ntest(\"it does not enter an infinite loop in transitionTo\", function() {\n  var emptyState = loadedState.empty;\n\n  stateManager.transitionTo('loadedState.empty');\n\n  stateManager.transitionTo('');\n  ok(stateManager.get('currentState') === emptyState, \"transitionTo does nothing when given empty name\");\n\n  raises(function() {\n    stateManager.transitionTo('nonexistentState');\n  }, 'Could not find state for path: \"nonexistentState\"');\n\n  ok(stateManager.get('currentState') === emptyState, \"transitionTo does not infinite loop when given nonexistent State\");\n});\n\ntest(\"it automatically transitions to a default state\", function() {\n  stateManager = Ember.StateManager.create({\n    start: Ember.State.create({\n      isStart: true\n    })\n  });\n\n  ok(get(stateManager, 'currentState').isStart, \"automatically transitions to start state\");\n});\n\ntest(\"it automatically transitions to a default state that is an instance\", function() {\n  stateManager = Ember.StateManager.create({\n    states: {\n      foo: Ember.State.create({\n        start: Ember.State.extend({\n          isStart: true\n        })\n      })\n    }\n  });\n\n  stateManager.transitionTo('foo');\n  ok(get(stateManager, 'currentState').isStart, \"automatically transitions to start state\");\n});\n\ntest(\"on a state manager, it automatically transitions to a default state that is an instance\", function() {\n  stateManager = Ember.StateManager.create({\n    states: {\n      start: Ember.State.extend({\n        isStart: true\n      })\n    }\n  });\n\n  ok(get(stateManager, 'currentState').isStart, \"automatically transitions to start state\");\n});\n\ntest(\"it automatically transitions to a default state specified using the initialState property\", function() {\n  stateManager = Ember.StateManager.create({\n    initialState: 'beginning',\n\n    beginning: Ember.State.create({\n      isStart: true\n    })\n  });\n\n  ok(get(stateManager, 'currentState').isStart, \"automatically transitions to beginning state\");\n});\n\ntest(\"it automatically transitions to a default substate specified using the initialState property\", function() {\n  stateManager = Ember.StateManager.create({\n    start: Ember.State.create({\n      initialState: 'beginningSubstate',\n\n      beginningSubstate: Ember.State.create({\n        isStart: true\n      })\n    })\n  });\n\n  ok(get(stateManager, 'currentState').isStart, \"automatically transitions to beginning substate\");\n});\n\ntest(\"it automatically synchronously transitions into initialState in an event\", function() {\n  var count = 0;\n\n  stateManager = Ember.StateManager.create({\n    root: Ember.State.create({\n      original: Ember.State.create({\n        zomgAnEvent: function(manager) {\n          manager.transitionTo('nextState');\n          manager.send('zomgAnotherEvent');\n        }\n      }),\n\n      nextState: Ember.State.create({\n        initialState: 'begin',\n\n        begin: Ember.State.create({\n          zomgAnotherEvent: function(manager) {\n            count++;\n          }\n        })\n      })\n    })\n  });\n\n  Ember.run(function() {\n    stateManager.transitionTo('root.original');\n  });\n\n  Ember.run(function() {\n    stateManager.send('zomgAnEvent');\n    equal(count, 1, \"the initialState was synchronously effective\");\n  });\n});\n\ntest(\"it automatically transitions to multiple substates specified using either start or initialState property\", function() {\n  stateManager = Ember.StateManager.create({\n    start: Ember.State.create({\n      initialState: 'beginningSubstate',\n\n      beginningSubstate: Ember.State.create({\n        start: Ember.State.create({\n          initialState: 'finalSubstate',\n\n          finalSubstate: Ember.State.create({\n            isStart: true\n          })\n        })\n      })\n    })\n  });\n\n  ok(get(stateManager, 'currentState').isStart, \"automatically transitions to final substate\");\n});\n\ntest(\"it triggers setup on initialSubstate\", function() {\n  var parentSetup = false,\n      childSetup = false,\n      grandchildSetup = false;\n\n  stateManager = Ember.StateManager.create({\n    start: Ember.State.create({\n      setup: function() { parentSetup = true; },\n\n      initialState: 'childState',\n\n      childState: Ember.State.create({\n        setup: function() { childSetup = true; },\n\n        initialState: 'grandchildState',\n\n        grandchildState: Ember.State.create({\n          setup: function() { grandchildSetup = true; }\n        })\n      })\n    })\n  });\n\n  ok(parentSetup, \"sets up parent\");\n  ok(childSetup, \"sets up child\");\n  ok(grandchildSetup, \"sets up grandchild\");\n});\n\ntest(\"it throws an assertion error when the initialState does not exist\", function() {\n  raises(function() {\n    Ember.StateManager.create({\n      initialState: 'foo',\n      bar: Ember.State.create()\n    });\n  }, Error, 'raises an exception');\n});\n\nmodule(\"Ember.StateManager - Transitions on Complex State Managers\");\n\n/**\n            SM\n          /    \\\n     Login      Redeem\n    /    |        |    \\\n  Start  Pending Start  Pending\n\n  * Transition from Login.Start to Redeem\n    - Login.Start and Login should receive exit events\n    - Redeem should receiver enter event\n*/\n\ntest(\"it sends exit events to nested states when changing to a top-level state\", function() {\n  var stateManager = Ember.StateManager.create({\n    login: Ember.State.create(stateEventStub, {\n      start: Ember.State.create(stateEventStub),\n      pending: Ember.State.create(stateEventStub)\n    }),\n\n    redeem: Ember.State.create(stateEventStub, {\n      isRedeem: true,\n      start: Ember.State.create(),\n      pending: Ember.State.create()\n    })\n  });\n\n  stateManager.transitionTo('login');\n  equal(stateManager.login.entered, 1, \"precond - it enters the login state\");\n  equal(stateManager.login.start.entered, 1, \"automatically enters the start state\");\n  ok(stateManager.get('currentState') === stateManager.login.start, \"automatically sets currentState to start state\");\n\n  stateManager.login.reset();\n  stateManager.login.start.reset();\n\n  stateManager.transitionTo('redeem');\n\n  equal(stateManager.login.exited, 1, \"login state is exited once\");\n  equal(stateManager.login.start.exited, 1, \"start state is exited once\");\n\n  equal(stateManager.redeem.entered, 1, \"redeemed state is entered once\");\n});\n\ntest(\"it sends exit events in the correct order when changing to a top-level state\", function() {\n  var exitOrder = [],\n      stateManager = Ember.StateManager.create({\n        start: Ember.State.create({\n          outer: Ember.State.create({\n            inner: Ember.State.create({\n              exit: function() { exitOrder.push('exitedInner'); }\n            }),\n            exit: function() { exitOrder.push('exitedOuter'); }\n          })\n        })\n      });\n\n  stateManager.transitionTo('start.outer.inner');\n  stateManager.transitionTo('start');\n  equal(exitOrder.length, 2, \"precond - it calls both exits\");\n  equal(exitOrder[0], 'exitedInner', \"inner exit is called first\");\n  equal(exitOrder[1], 'exitedOuter', \"outer exit is called second\");\n});\n\ntest(\"it sends exit events in the correct order when changing to a state multiple times\", function() {\n  var exitOrder = [],\n      stateManager = Ember.StateManager.create({\n        start: Ember.State.create({\n          outer: Ember.State.create({\n            inner: Ember.State.create({\n              exit: function() { exitOrder.push('exitedInner'); }\n            }),\n            exit: function() { exitOrder.push('exitedOuter'); }\n          })\n        })\n      });\n\n  stateManager.transitionTo('start.outer.inner');\n  stateManager.transitionTo('start');\n  stateManager.transitionTo('start.outer.inner');\n  exitOrder = [];\n  stateManager.transitionTo('start');\n  equal(exitOrder.length, 2, \"precond - it calls both exits\");\n  equal(exitOrder[0], 'exitedInner', \"inner exit is called first\");\n  equal(exitOrder[1], 'exitedOuter', \"outer exit is called second\");\n});\n\nvar passedContext, passedContexts, loadingEventCalled, loadedEventCalled, eventInChildCalled;\nloadingEventCalled = loadedEventCalled = eventInChildCalled = 0;\n\nmodule(\"Ember.StateManager - Event Dispatching\", {\n  setup: function() {\n    stateManager = Ember.StateManager.create({\n      loading: Ember.State.create({\n        anEvent: function(manager, context) {\n          loadingEventCalled++;\n          passedContext = context;\n          passedContexts = [].slice.call(arguments, 1);\n        }\n      }),\n\n      loaded: Ember.State.create({\n        anEvent: function() {\n          loadedEventCalled++;\n        },\n\n        eventInChild: function() {\n          eventInChildCalled++;\n        },\n\n        empty: Ember.State.create({\n          eventInChild: function() {\n            eventInChildCalled++;\n          }\n        })\n      })\n    });\n\n    stateManager.transitionTo('loading');\n  }\n});\n\ntest(\"it dispatches events to the current state\", function() {\n  stateManager.send('anEvent');\n\n  equal(loadingEventCalled, 1, \"event was triggered\");\n});\n\ntest(\"it dispatches events to a parent state if the child state does not respond to it\", function() {\n  stateManager.transitionTo('loaded.empty');\n  stateManager.send('anEvent');\n\n  equal(loadedEventCalled, 1, \"parent state receives event\");\n});\n\ntest(\"it does not dispatch events to parents if the child responds to it\", function() {\n  stateManager.transitionTo('loaded.empty');\n  stateManager.send('eventInChild');\n\n  equal(eventInChildCalled, 1, \"does not dispatch event to parent\");\n});\n\ntest(\"it supports arguments to events\", function() {\n  stateManager.send('anEvent', { context: true });\n  equal(passedContext.context, true, \"send passes along a context\");\n});\n\ntest(\"it supports multiple arguments to events\", function() {\n  stateManager.send('anEvent', {name: 'bestie'}, {name: 'crofty'});\n  equal(passedContexts[0].name, 'bestie', \"send passes along the first context\");\n  equal(passedContexts[1].name, 'crofty', \"send passes along the second context\");\n});\n\ntest(\"it throws an exception if an event is dispatched that is unhandled\", function() {\n  raises(function() {\n    stateManager.send('unhandledEvent');\n  }, Error, \"exception was raised\");\n\n  stateManager = Ember.StateManager.create({\n    initialState: 'loading',\n    errorOnUnhandledEvent: false,\n    loading: Ember.State.create({\n      anEvent: function() {}\n    })\n  });\n\n  stateManager.send('unhandledEvent');\n  ok(true, \"does not raise exception when errorOnUnhandledEvent is set to false\");\n});\n\ntest(\"it looks for unhandledEvent handler in the currentState if event is not handled by named handler\", function() {\n  var wasCalled = 0,\n      evt = \"foo\",\n      calledWithOriginalEventName,\n      calledWithEvent;\n  stateManager = Ember.StateManager.create({\n    initialState: 'loading',\n    loading: Ember.State.create({\n      unhandledEvent: function(manager, originalEventName, event) {\n        wasCalled = true;\n        calledWithOriginalEventName = originalEventName;\n        calledWithEvent = event;\n      }\n    })\n  });\n  stateManager.send(\"somethingUnhandled\", evt);\n  ok(wasCalled);\n  equal(calledWithOriginalEventName, 'somethingUnhandled');\n  equal(calledWithEvent, evt);\n});\n\ntest(\"it looks for unhandledEvent handler in the stateManager if event is not handled by named handler\", function() {\n  var wasCalled = 0,\n      evt = \"foo\",\n      calledWithOriginalEventName,\n      calledWithEvent;\n  stateManager = Ember.StateManager.create({\n    initialState: 'loading',\n    unhandledEvent: function(manager, originalEventName, event) {\n      wasCalled = true;\n      calledWithOriginalEventName = originalEventName;\n      calledWithEvent = event;\n    },\n    loading: Ember.State.create({})\n  });\n  stateManager.send(\"somethingUnhandled\", evt);\n  ok(wasCalled);\n  equal(calledWithOriginalEventName, 'somethingUnhandled');\n  equal(calledWithEvent, evt);\n});\n\nmodule(\"Ember.Statemanager - Pivot states\", {\n  setup: function() {\n    var State = Ember.State.extend(stateEventStub);\n\n    stateManager = Ember.StateManager.create(stateEventStub, {\n      grandparent: State.create({\n        parent: State.create({\n          child: State.create(),\n          sibling: State.create()\n        }),\n        cousin: State.create()\n      })\n    });\n  }\n});\n\ntest(\"transitionTo triggers all enter states\", function() {\n  stateManager.transitionTo('grandparent.parent.child');\n  equal(stateManager.grandparent.entered, 1, \"the top level should be entered\");\n  equal(stateManager.grandparent.parent.entered, 1, \"intermediate states should be entered\");\n  equal(stateManager.grandparent.parent.child.entered, 1, \"the final state should be entered\");\n\n  stateManager.transitionTo('grandparent.parent.sibling');\n  equal(stateManager.grandparent.entered, 1, \"the top level should not be re-entered\");\n  equal(stateManager.grandparent.parent.entered, 1, \"intermediate states should not be re-entered\");\n  equal(stateManager.grandparent.parent.child.entered, 1, \"the final state should not be re-entered\");\n\n  equal(stateManager.grandparent.parent.child.exited, 1, \"the child should have exited\");\n  equal(stateManager.grandparent.exited, 0, \"the top level should not have have exited\");\n  equal(stateManager.grandparent.parent.exited, 0, \"intermediate states should not have exited\");\n});\n\ntest(\"transitionTo with current state does not trigger enter or exit\", function() {\n  stateManager.transitionTo('grandparent.parent.child');\n  stateManager.transitionTo('grandparent.parent.child');\n  equal(stateManager.grandparent.entered, 1, \"the top level should only be entered once\");\n  equal(stateManager.grandparent.parent.entered, 1, \"intermediate states should only be entered once\");\n  equal(stateManager.grandparent.parent.child.entered, 1, \"the final state should only be entered once\");\n  equal(stateManager.grandparent.parent.child.exited, 0, \"the final state should not be exited\");\n});\n\nmodule(\"Transition contexts\");\n\ntest(\"if a context is passed to a transition, the state's setup event is triggered after the transition has completed\", function() {\n  expect(1);\n  var context = {};\n\n  Ember.run(function() {\n    stateManager = Ember.StateManager.create({\n      start: Ember.State.create({\n        goNext: function(manager, context) {\n          manager.transitionTo('next', context);\n        }\n      }),\n\n      next: Ember.State.create({\n        setup: function(manager, passedContext) {\n          equal(context, passedContext, \"The context is passed through\");\n        }\n      })\n    });\n  });\n\n  stateManager.send('goNext', context);\n});\n\ntest(\"if a context is passed to a transition and the path is to the current state, the state's setup event is triggered again\", function() {\n  expect(2);\n  var counter = 0;\n\n  Ember.run(function() {\n    stateManager = Ember.StateManager.create({\n      start: Ember.State.create({\n        goNext: function(manager, context) {\n          counter++;\n          manager.transitionTo('foo.next', counter);\n        }\n      }),\n\n      foo: Ember.State.create({\n        next: Ember.State.create({\n          goNext: function(manager, context) {\n            counter++;\n            manager.transitionTo('next', counter);\n          },\n\n          setup: function(manager, context) {\n            equal(context, counter, \"The context is passed through\");\n          }\n        })\n      })\n    });\n  });\n\n  stateManager.send('goNext', counter);\n  stateManager.send('goNext', counter);\n});\n\ntest(\"if no context is provided, setup is triggered with an undefined context\", function() {\n  expect(1);\n\n  Ember.run(function() {\n    stateManager = Ember.StateManager.create({\n      start: Ember.State.create({\n        goNext: function(manager) {\n          manager.transitionTo('next');\n        },\n\n        next: Ember.State.create({\n          setup: function(manager, context) {\n            equal(context, undefined, \"setup is called with no context\");\n          }\n        })\n      })\n    });\n  });\n\n  stateManager.send('goNext');\n});\n\ntest(\"multiple contexts can be provided in a single transitionTo\", function() {\n  expect(2);\n\n  Ember.run(function() {\n    stateManager = Ember.StateManager.create({\n      start: Ember.State.create(),\n\n      planters: Ember.State.create({\n        setup: function(manager, context) {\n          deepEqual(context, { company: true });\n        },\n\n        nuts: Ember.State.create({\n          setup: function(manager, context) {\n            deepEqual(context, { product: true });\n          }\n        })\n      })\n    });\n  });\n\n  stateManager.transitionTo('planters.nuts', { company: true }, { product: true });\n});\n\ntest(\"multiple contexts only apply to states that need them\", function() {\n  expect(4);\n\n  Ember.run(function() {\n    stateManager = Ember.StateManager.create({\n      start: Ember.State.create(),\n\n      parent: Ember.State.create({\n        hasContext: false,\n\n        setup: function(manager, context) {\n          equal(context, undefined);\n        },\n\n        child: Ember.State.create({\n          setup: function(manager, context) {\n            equal(context, 'one');\n          },\n\n          grandchild: Ember.State.create({\n            initialState: 'greatGrandchild',\n\n            setup: function(manager, context) {\n              equal(context, 'two');\n            },\n\n            greatGrandchild: Ember.State.create({\n              setup: function(manager, context) {\n                equal(context, undefined);\n              }\n            })\n          })\n        })\n      })\n    });\n  });\n\n  stateManager.transitionTo('parent.child.grandchild', 'one', 'two');\n});\n\ntest(\"transitionEvent is called for each nested state\", function() {\n  expect(4);\n\n  var calledOnParent = false,\n      calledOnChild = true;\n\n  Ember.run(function() {\n    stateManager = Ember.StateManager.create({\n      start: Ember.State.create(),\n\n      planters: Ember.State.create({\n        setup: function(manager, context) {\n          calledOnParent = true;\n        },\n\n        nuts: Ember.State.create({\n          setup: function(manager, context) {\n            calledOnChild = true;\n          }\n        })\n      })\n    });\n  });\n\n  stateManager.transitionTo('planters.nuts');\n\n  ok(calledOnParent, 'called transitionEvent on parent');\n  ok(calledOnChild, 'called transitionEvent on child');\n\n  // repeat the test now that the path is cached\n\n  stateManager.transitionTo('start');\n\n  calledOnParent = false;\n  calledOnChild = false;\n\n  stateManager.transitionTo('planters.nuts');\n\n  ok(calledOnParent, 'called transitionEvent on parent');\n  ok(calledOnChild, 'called transitionEvent on child');\n});\n\ntest(\"transitionEvent is called for each nested state with context\", function() {\n  expect(8);\n\n  var calledOnParent = false,\n      calledOnChild = true;\n\n  Ember.run(function() {\n    stateManager = Ember.StateManager.create({\n      start: Ember.State.create(),\n\n      planters: Ember.State.create({\n        setup: function(manager, context) {\n          calledOnParent = true;\n          ok(!context, 'single context is not called on parent');\n        },\n\n        nuts: Ember.State.create({\n          setup: function(manager, context) {\n            calledOnChild = true;\n            equal(context, 'context', 'child gets context');\n          }\n        })\n      })\n    });\n  });\n\n  stateManager.transitionTo('planters.nuts', 'context');\n\n  ok(calledOnParent, 'called transitionEvent on parent');\n  ok(calledOnChild, 'called transitionEvent on child');\n\n  // repeat the test now that the path is cached\n\n  stateManager.transitionTo('start');\n\n  calledOnParent = false;\n  calledOnChild = false;\n\n  stateManager.transitionTo('planters.nuts', 'context');\n\n  ok(calledOnParent, 'called transitionEvent on parent');\n  ok(calledOnChild, 'called transitionEvent on child');\n});\n\ntest(\"nothing happens if transitioning to a parent state when the current state is also the initial state\", function() {\n  var calledOnParent = 0,\n      calledOnChild = 0;\n\n  Ember.run(function() {\n    stateManager = Ember.StateManager.create({\n      start: Ember.State.create({\n        initialState: 'first',\n\n        setup: function() {\n          calledOnParent++;\n        },\n\n        first: Ember.State.create({\n          setup: function() {\n            calledOnChild++;\n          }\n        })\n      })\n    });\n  });\n\n  equal(calledOnParent, 1, 'precond - setup parent');\n  equal(calledOnChild, 1, 'precond - setup child');\n  equal(stateManager.get('currentState.path'), 'start.first', 'precond - is in expected state');\n\n  stateManager.transitionTo('start');\n\n  equal(calledOnParent, 1, 'does not transition to parent again');\n  equal(calledOnChild, 1, 'does not transition to child again');\n  equal(stateManager.get('currentState.path'), 'start.first', 'does not change state');\n\n});\n\n})();\n//@ sourceURL=ember-states/~tests/state_manager_test");minispade.register('ember-states/~tests/state_test', "(function() {var get = Ember.get, set = Ember.set, _$;\n\nmodule(\"Ember.State\");\n\ntest(\"exists\", function() {\n  ok(Ember.Object.detect(Ember.State), \"Ember.State is an Ember.Object\");\n});\n\ntest(\"creating a state with substates sets the parentState property\", function() {\n  var state = Ember.State.create({\n    child: Ember.State.create()\n  });\n\n  equal(state.get('child.parentState'), state, \"A child state gets its parent state\");\n  deepEqual(state.get('childStates'), [ state.get('child') ], \"The childStates method returns a state's child states\");\n});\n\ntest(\"a state is passed its state manager when receiving an enter event\", function() {\n  expect(2);\n\n  var count = 0;\n\n  var states = {\n    load: Ember.State.create({\n      enter: function(passedStateManager) {\n        if (count === 0) {\n          ok(passedStateManager.get('isFirst'), \"passes first state manager when created\");\n        } else {\n          ok(passedStateManager.get('isSecond'), \"passes second state manager when created\");\n        }\n\n        count++;\n      }\n    })\n  };\n\n  var stateManager = Ember.StateManager.create({\n    initialState: 'load',\n    isFirst: true,\n\n    states: states\n  });\n\n  var anotherStateManager = Ember.StateManager.create({\n    initialState: 'load',\n    isSecond: true,\n\n    states: states\n  });\n});\n\ntest(\"a state can have listeners that are fired when the state is entered\", function() {\n  expect(2);\n\n  var count = 0;\n\n  var states = {\n    load: Ember.State.create()\n  };\n\n  states.load.on('enter', function(passedStateManager) {\n    if (count === 0) {\n      ok(passedStateManager.get('isFirst'), \"passes first state manager when created\");\n    } else {\n      ok(passedStateManager.get('isSecond'), \"passes second state manager when created\");\n    }\n\n    count++;\n  });\n\n  var stateManager = Ember.StateManager.create({\n    initialState: 'load',\n    isFirst: true,\n\n    states: states\n  });\n\n  var anotherStateManager = Ember.StateManager.create({\n    initialState: 'load',\n    isSecond: true,\n\n    states: states\n  });\n});\n\ntest(\"a state finds properties that are states and copies them to the states hash\", function() {\n  var state1 = Ember.State.create();\n  var state2 = Ember.State.create();\n\n  var superClass = Ember.State.extend({\n    state1: state1\n  });\n\n  var stateInstance = superClass.create({\n    state2: state2\n  });\n\n  var states = get(stateInstance, 'states');\n\n  deepEqual(states, { state1: state1, state2: state2 }, \"states should be retrieved from both the instance and its class\");\n});\n\ntest(\"a state finds properties that are state classes and instantiates them\", function() {\n  var state1 = Ember.State.extend({\n    isState1: true\n  });\n  var state2 = Ember.State.extend({\n    isState2: true\n  });\n\n  var superClass = Ember.State.extend({\n    state1: state1\n  });\n\n  var stateInstance = superClass.create({\n    state2: state2\n  });\n\n  var states = get(stateInstance, 'states');\n\n  equal(get(states.state1, 'isState1'), true, \"instantiated first state\");\n  equal(get(states.state2, 'isState2'), true, \"instantiated second state\");\n});\n\ntest(\"states set up proper names on their children\", function() {\n  var manager = Ember.StateManager.create({\n    states: {\n      first: Ember.State.extend({\n        insideFirst: Ember.State.extend({\n\n        })\n      })\n    }\n  });\n\n  manager.transitionTo('first');\n  equal(get(manager, 'currentState.path'), 'first');\n\n  manager.transitionTo('first.insideFirst');\n  equal(get(manager, 'currentState.path'), 'first.insideFirst');\n});\n\ntest(\"states with child instances set up proper names on their children\", function() {\n  var manager = Ember.StateManager.create({\n    states: {\n      first: Ember.State.create({\n        insideFirst: Ember.State.create({\n\n        })\n      })\n    }\n  });\n\n  manager.transitionTo('first');\n  equal(get(manager, 'currentState.path'), 'first');\n\n  manager.transitionTo('first.insideFirst');\n  equal(get(manager, 'currentState.path'), 'first.insideFirst');\n});\n\ntest(\"the isLeaf property is false when a state has child states\", function() {\n  var manager = Ember.StateManager.create({\n    states: {\n      first: Ember.State.create({\n        insideFirst: Ember.State.create(),\n        otherInsideFirst: Ember.State.create({\n          definitelyInside: Ember.State.create()\n        })\n      })\n    }\n  });\n\n  var first = manager.get('states.first');\n  var insideFirst = first.get('states.insideFirst');\n  var otherInsideFirst = first.get('states.otherInsideFirst');\n  var definitelyInside = otherInsideFirst.get('states.definitelyInside');\n\n  equal(first.get('isLeaf'), false);\n  equal(insideFirst.get('isLeaf'), true);\n  equal(otherInsideFirst.get('isLeaf'), false);\n  equal(definitelyInside.get('isLeaf'), true);\n});\n\nmodule(\"Ember.State.transitionTo\", {\n  setup: function(){\n    _$ = Ember.$;\n    Ember.$ = {};\n    Ember.$.Event = function(){};\n  },\n  teardown: function(){\n    Ember.$ = _$;\n  }\n});\ntest(\"sets the transition target\", function(){\n  var receivedTarget,\n      receivedContext,\n      stateManager,\n      transitionFunction;\n\n  stateManager = {\n    transitionTo: function(target, context){\n      receivedTarget = target;\n      receivedContext = context;\n    }\n  };\n\n  transitionFunction = Ember.State.transitionTo('targetState');\n\n  transitionFunction(stateManager, new Ember.$.Event());\n\n  equal(receivedTarget, 'targetState');\n  ok(!receivedContext, \"does not pass a context when given an event without context\");\n});\n\ntest(\"passes no context arguments when there are no contexts\", function(){\n  var contextArgsCount,\n      stateManager,\n      transitionFunction,\n      event;\n\n  event = new Ember.$.Event();\n  event.contexts = [];\n\n  stateManager = {\n    transitionTo: function(){\n      contextArgsCount = [].slice.call(arguments, 1).length;\n    }\n  };\n\n  transitionFunction = Ember.State.transitionTo('targetState');\n\n  transitionFunction(stateManager, event);\n\n  equal( contextArgsCount, 0);\n});\n\ntest(\"passes through a single context\", function(){\n  var receivedContext,\n      stateManager,\n      transitionFunction,\n      event;\n\n  event = new Ember.$.Event();\n  event.contexts = [{ value: 'context value' }];\n\n  stateManager = {\n    transitionTo: function(target, context){\n      receivedContext = context;\n    }\n  };\n\n  transitionFunction = Ember.State.transitionTo('targetState');\n\n  transitionFunction(stateManager, event);\n\n  equal( receivedContext, event.contexts[0]);\n});\n\ntest(\"passes through multiple contexts as additional arguments\", function(){\n  var receivedContexts,\n      stateManager,\n      transitionFunction,\n      event;\n\n  event = new Ember.$.Event();\n  event.contexts = [ { value: 'context1' }, { value: 'context2' } ];\n\n  stateManager = {\n    transitionTo: function(target){\n      receivedContexts = [].slice.call(arguments, 1);\n    }\n  };\n\n  transitionFunction = Ember.State.transitionTo('targetState');\n\n  transitionFunction(stateManager, event);\n\n  deepEqual( receivedContexts, event.contexts);\n});\n\ntest(\"does not mutate the event contexts value\", function(){\n  var receivedContexts,\n      stateManager,\n      transitionFunction,\n      originalContext,\n      event;\n\n  originalContext = [ { value: 'context1' }, { value: 'context2' } ];\n\n  event = new Ember.$.Event();\n  event.contexts = originalContext.slice();\n\n  stateManager = {\n    transitionTo: function(target){\n      receivedContexts = [].slice.call(arguments, 1);\n    }\n  };\n\n  transitionFunction = Ember.State.transitionTo('targetState');\n\n  transitionFunction(stateManager, event);\n\n  deepEqual(event.contexts, originalContext);\n});\n\ntest(\"passes no context arguments when called with no context or event\", function(){\n  var receivedContexts,\n      stateManager,\n      transitionFunction;\n\n  stateManager = {\n    transitionTo: function(target){\n      receivedContexts = [].slice.call(arguments, 1);\n    }\n  };\n\n  transitionFunction = Ember.State.transitionTo('targetState');\n\n  transitionFunction(stateManager);\n\n  equal( receivedContexts.length, 0, \"transitionTo receives no context\");\n});\n\ntest(\"handles contexts without an event\", function(){\n  var receivedContexts,\n      stateManager,\n      transitionFunction,\n      context1,\n      context2;\n\n  context1 = { value: 'context1', contexts: 'I am not an event'};\n  context2 = { value: 'context2', contexts: ''};\n\n  stateManager = {\n    transitionTo: function(target){\n      receivedContexts = [].slice.call(arguments, 1);\n    }\n  };\n\n  transitionFunction = Ember.State.transitionTo('targetState');\n\n  transitionFunction(stateManager, context1, context2);\n\n  equal( receivedContexts[0], context1, \"the first context is passed through\" );\n  equal( receivedContexts[1], context2, \"the second context is passed through\" );\n});\n\n})();\n//@ sourceURL=ember-states/~tests/state_test");minispade.register('ember-views/~tests/system/event_dispatcher_test', "(function() {var view;\nvar dispatcher;\nvar set = Ember.set, get = Ember.get;\n\nmodule(\"Ember.EventDispatcher\", {\n  setup: function() {\n    Ember.run(function() {\n      dispatcher = Ember.EventDispatcher.create();\n      dispatcher.setup();\n    });\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      if (view) { view.destroy(); }\n      dispatcher.destroy();\n    });\n  }\n});\n\ntest(\"should dispatch events to views\", function() {\n  var receivedEvent;\n  var parentMouseDownCalled = 0;\n  var childKeyDownCalled = 0;\n  var parentKeyDownCalled = 0;\n\n  view = Ember.ContainerView.createWithMixins({\n    childViews: ['child'],\n\n    child: Ember.View.extend({\n      render: function(buffer) {\n        buffer.push('<span id=\"wot\">ewot</span>');\n      },\n\n      keyDown: function(evt) {\n        childKeyDownCalled++;\n\n        return false;\n      }\n    }),\n\n    render: function(buffer) {\n      buffer.push('some <span id=\"awesome\">awesome</span> content');\n      this._super(buffer);\n    },\n\n    mouseDown: function(evt) {\n      parentMouseDownCalled++;\n      receivedEvent = evt;\n    },\n\n    keyDown: function(evt) {\n      parentKeyDownCalled++;\n    }\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  view.$().trigger('mousedown');\n\n  ok(receivedEvent, \"passes event to associated event method\");\n  receivedEvent = null;\n  parentMouseDownCalled = 0;\n\n  view.$('span#awesome').trigger('mousedown');\n  ok(receivedEvent, \"event bubbles up to nearest Ember.View\");\n  equal(parentMouseDownCalled, 1, \"does not trigger the parent handlers twice because of browser bubbling\");\n  receivedEvent = null;\n\n  Ember.$('#wot').trigger('mousedown');\n  ok(receivedEvent, \"event bubbles up to nearest Ember.View\");\n\n  Ember.$('#wot').trigger('keydown');\n  equal(childKeyDownCalled, 1, \"calls keyDown on child view\");\n  equal(parentKeyDownCalled, 0, \"does not call keyDown on parent if child handles event\");\n});\n\ntest(\"should not dispatch events to views not inDOM\", function() {\n  var receivedEvent;\n\n  view = Ember.View.createWithMixins({\n    render: function(buffer) {\n      buffer.push('some <span id=\"awesome\">awesome</span> content');\n      this._super(buffer);\n    },\n\n    mouseDown: function(evt) {\n      receivedEvent = evt;\n    }\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  var $element = view.$();\n\n  Ember.run(function() {\n    view.set('element', null); // Force into preRender\n  });\n\n  $element.trigger('mousedown');\n\n  ok(!receivedEvent, \"does not pass event to associated event method\");\n  receivedEvent = null;\n\n  $element.find('span#awesome').trigger('mousedown');\n  ok(!receivedEvent, \"event does not bubble up to nearest Ember.View\");\n  receivedEvent = null;\n\n  // Cleanup\n  $element.remove();\n});\n\ntest(\"should send change events up view hierarchy if view contains form elements\", function() {\n  var receivedEvent;\n  view = Ember.View.create({\n    render: function(buffer) {\n      buffer.push('<input id=\"is-done\" type=\"checkbox\">');\n    },\n\n    change: function(evt) {\n      receivedEvent = evt;\n    }\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  Ember.$('#is-done').trigger('change');\n  ok(receivedEvent, \"calls change method when a child element is changed\");\n  equal(receivedEvent.target, Ember.$('#is-done')[0], \"target property is the element that was clicked\");\n});\n\ntest(\"events should stop propagating if the view is destroyed\", function() {\n  var parentViewReceived, receivedEvent;\n\n  var parentView = Ember.ContainerView.create({\n    change: function(evt) {\n      parentViewReceived = true;\n    }\n  });\n\n  view = parentView.createChildView(Ember.View, {\n    render: function(buffer) {\n      buffer.push('<input id=\"is-done\" type=\"checkbox\">');\n    },\n\n    change: function(evt) {\n      receivedEvent = true;\n      var self = this;\n      Ember.run(function() {\n        get(self, 'parentView').destroy();\n      });\n    }\n  });\n\n  parentView.pushObject(view);\n\n  Ember.run(function() {\n    parentView.append();\n  });\n\n  ok(Ember.$('#is-done').length, \"precond - view is in the DOM\");\n  Ember.$('#is-done').trigger('change');\n  ok(!Ember.$('#is-done').length, \"precond - view is not in the DOM\");\n  ok(receivedEvent, \"calls change method when a child element is changed\");\n  ok(!parentViewReceived, \"parent view does not receive the event\");\n});\n\ntest(\"should not interfere with event propagation\", function() {\n  var receivedEvent;\n  view = Ember.View.create({\n    render: function(buffer) {\n      buffer.push('<div id=\"propagate-test-div\"></div>');\n    }\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  Ember.$(window).bind('click', function(evt) {\n    receivedEvent = evt;\n  });\n\n  Ember.$('#propagate-test-div').click();\n\n  ok(receivedEvent, \"allowed event to propagate outside Ember\");\n  deepEqual(receivedEvent.target, Ember.$('#propagate-test-div')[0], \"target property is the element that was clicked\");\n});\n\ntest(\"should dispatch events to nearest event manager\", function() {\n  var receivedEvent=0;\n  view = Ember.ContainerView.create({\n    render: function(buffer) {\n      buffer.push('<input id=\"is-done\" type=\"checkbox\">');\n    },\n\n    eventManager: Ember.Object.create({\n      mouseDown: function() {\n        receivedEvent++;\n      }\n    }),\n\n    mouseDown: function() {}\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  Ember.$('#is-done').trigger('mousedown');\n  equal(receivedEvent, 1, \"event should go to manager and not view\");\n});\n\ntest(\"event manager should be able to re-dispatch events to view\", function() {\n\n  var receivedEvent=0;\n  view = Ember.ContainerView.createWithMixins({\n    elementId: 'containerView',\n\n    eventManager: Ember.Object.create({\n      mouseDown: function(evt, view) {\n        // Re-dispatch event when you get it.\n        //\n        // The second parameter tells the dispatcher\n        // that this event has been handled. This\n        // API will clearly need to be reworked since\n        // multiple eventManagers in a single view\n        // hierarchy would break, but it shows that\n        // re-dispatching works\n        view.$().trigger('mousedown',this);\n      }\n    }),\n\n    childViews: ['child'],\n\n    child: Ember.View.extend({\n      elementId: 'nestedView',\n\n      mouseDown: function(evt) {\n        receivedEvent++;\n      }\n    }),\n\n    mouseDown: function(evt) {\n      receivedEvent++;\n    }\n  });\n\n  Ember.run(function() { view.append(); });\n\n  Ember.$('#nestedView').trigger('mousedown');\n  equal(receivedEvent, 2, \"event should go to manager and not view\");\n});\n\n})();\n//@ sourceURL=ember-views/~tests/system/event_dispatcher_test");minispade.register('ember-views/~tests/system/ext_test', "(function() {module(\"Ember.View additions to run queue\");\n\ntest(\"View hierarchy is done rendering to DOM when functions queued in afterRender execute\", function() {\n  var lookup1, lookup2;\n  var childView = Ember.View.create({\n    elementId: 'child_view',\n    render: function(buffer) {\n      buffer.push('child');\n    },\n    didInsertElement: function(){\n      this.$().addClass('extra-class');\n    }\n  });\n  var parentView = Ember.View.create({\n    elementId: 'parent_view',\n    render: function(buffer) {\n      buffer.push('parent');\n      this.appendChild(childView);\n    },\n    didInsertElement: function() {\n      lookup1 = this.$('.extra-class');\n      Ember.run.scheduleOnce('afterRender', this, function(){\n        lookup2 = this.$('.extra-class');\n      });\n    }\n  });\n\n  Ember.run(function() {\n    parentView.appendTo('#qunit-fixture');\n  });\n\n  equal(lookup1.length, 0, \"doesn't not find child in DOM on didInsertElement\");\n  equal(lookup2.length, 1, \"finds child in DOM afterRender\");\n\n  Ember.run(function(){\n    parentView.destroy();\n  });\n});\n\n})();\n//@ sourceURL=ember-views/~tests/system/ext_test");minispade.register('ember-views/~tests/system/jquery_ext_test', "(function() {var view, dispatcher;\n\n// Adapted from https://github.com/jquery/jquery/blob/f30f7732e7775b6e417c4c22ced7adb2bf76bf89/test/data/testinit.js\nvar canDataTransfer,\n    fireNativeWithDataTransfer;\nif (document.createEvent) {\n  canDataTransfer = !!document.createEvent('HTMLEvents').dataTransfer;\n  fireNativeWithDataTransfer = function(node, type, dataTransfer) {\n    var event = document.createEvent('HTMLEvents');\n    event.initEvent(type, true, true);\n    event.dataTransfer = dataTransfer;\n    node.dispatchEvent(event);\n  };\n} else {\n  canDataTransfer = !!document.createEventObject().dataTransfer;\n  fireNativeWithDataTransfer = function(node, type, dataTransfer) {\n    var event = document.createEventObject();\n    event.dataTransfer = dataTransfer;\n    node.fireEvent('on' + type, event);\n  };\n}\n\nmodule(\"Ember.EventDispatcher\", {\n  setup: function() {\n    Ember.run(function() {\n      dispatcher = Ember.EventDispatcher.create();\n      dispatcher.setup();\n    });\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      if (view) { view.destroy(); }\n      dispatcher.destroy();\n    });\n  }\n});\n\nif (canDataTransfer) {\n  test(\"jQuery.event.fix copies over the dataTransfer property\", function() {\n    var originalEvent;\n    var receivedEvent;\n\n    originalEvent = {\n      type: 'drop',\n      dataTransfer: 'success',\n      target: document.body\n    };\n\n    receivedEvent = Ember.$.event.fix(originalEvent);\n\n    ok(receivedEvent !== originalEvent, \"attributes are copied to a new event object\");\n    equal(receivedEvent.dataTransfer, originalEvent.dataTransfer, \"copies dataTransfer property to jQuery event\");\n  });\n\n  test(\"drop handler should receive event with dataTransfer property\", function() {\n    var receivedEvent;\n    var dropCalled = 0;\n\n    view = Ember.View.createWithMixins({\n      render: function(buffer) {\n        buffer.push('please drop stuff on me');\n        this._super(buffer);\n      },\n\n      drop: function(evt) {\n        receivedEvent = evt;\n        dropCalled++;\n      }\n    });\n\n    Ember.run(function() {\n      view.append();\n    });\n\n    fireNativeWithDataTransfer(view.$().get(0), 'drop', 'success');\n\n    equal(dropCalled, 1, \"called drop handler once\");\n    equal(receivedEvent.dataTransfer, 'success', \"copies dataTransfer property to jQuery event\");\n  });\n}\n\n})();\n//@ sourceURL=ember-views/~tests/system/jquery_ext_test");minispade.register('ember-views/~tests/system/render_buffer_test', "(function() {var set = Ember.set, get = Ember.get;\n\n// .......................................................\n//  render()\n//\nmodule(\"Ember.RenderBuffer\");\n\ntest(\"RenderBuffers combine strings\", function() {\n  var buffer = new Ember.RenderBuffer('div');\n  buffer.pushOpeningTag();\n\n  buffer.push('a');\n  buffer.push('b');\n\n  equal(\"<div>ab</div>\", buffer.string(), \"Multiple pushes should concatenate\");\n});\n\ntest(\"value of 0 is included in output\", function() {\n  var buffer, $el;\n\n  buffer = new Ember.RenderBuffer('input');\n  buffer.prop('value', 0);\n  buffer.pushOpeningTag();\n  $el = buffer.element();\n\n  strictEqual($el.value, '0', \"generated element has value of '0'\");\n\n  buffer = new Ember.RenderBuffer('input');\n  buffer.prop('value', 0);\n  buffer.push('<div>');\n  buffer.pushOpeningTag();\n  buffer.push('</div>');\n  $el = Ember.$(buffer.innerString());\n\n  strictEqual($el.find('input').val(), '0', \"raw tag has value of '0'\");\n});\n\ntest(\"prevents XSS injection via `id`\", function() {\n  var buffer = new Ember.RenderBuffer('div');\n\n  buffer.push('<span></span>'); // We need the buffer to not be empty so we use the string path\n  buffer.id('hacked\" megahax=\"yes');\n  buffer.pushOpeningTag();\n\n  equal('<span></span><div id=\"hacked&quot; megahax=&quot;yes\">', buffer.string());\n});\n\ntest(\"prevents XSS injection via `attr`\", function() {\n  var buffer = new Ember.RenderBuffer('div');\n\n  buffer.push('<span></span>'); // We need the buffer to not be empty so we use the string path\n  buffer.attr('id', 'trololol\" onmouseover=\"pwn()');\n  buffer.attr('class', \"hax><img src=\\\"trollface.png\\\"\");\n  buffer.pushOpeningTag();\n\n  equal('<span></span><div id=\"trololol&quot; onmouseover=&quot;pwn()\" class=\"hax&gt;&lt;img src=&quot;trollface.png&quot;\">', buffer.string());\n});\n\ntest(\"prevents XSS injection via `addClass`\", function() {\n  var buffer = new Ember.RenderBuffer('div');\n\n  buffer.push('<span></span>'); // We need the buffer to not be empty so we use the string path\n  buffer.addClass('megahax\" xss=\"true');\n  buffer.pushOpeningTag();\n\n  // Regular check then check for IE\n  equal('<span></span><div class=\"megahax&quot; xss=&quot;true\">', buffer.string());\n});\n\ntest(\"prevents XSS injection via `style`\", function() {\n  var buffer = new Ember.RenderBuffer('div');\n\n  buffer.push('<span></span>'); // We need the buffer to not be empty so we use the string path\n  buffer.style('color', 'blue;\" xss=\"true\" style=\"color:red');\n  buffer.pushOpeningTag();\n\n  equal('<span></span><div style=\"color:blue;&quot; xss=&quot;true&quot; style=&quot;color:red;\">', buffer.string());\n});\n\ntest(\"handles null props - Issue #2019\", function() {\n  var buffer = new Ember.RenderBuffer('div');\n\n  buffer.push('<span></span>'); // We need the buffer to not be empty so we use the string path\n  buffer.prop('value', null);\n  buffer.pushOpeningTag();\n\n  equal('<span></span><div>', buffer.string());\n});\n\ntest(\"handles browsers like Firefox < 11 that don't support outerHTML Issue #1952\", function(){\n  var buffer = new Ember.RenderBuffer('div');\n  buffer.pushOpeningTag();\n  // Make sure element.outerHTML is falsy to trigger the fallback.\n  var elementStub = '<div></div>';\n  buffer.element = function(){ return elementStub; };\n  equal(new XMLSerializer().serializeToString(elementStub), buffer.string());\n});\n\nmodule(\"Ember.RenderBuffer - without tagName\");\n\ntest(\"It is possible to create a RenderBuffer without a tagName\", function() {\n  var buffer = new Ember.RenderBuffer();\n  buffer.push('a');\n  buffer.push('b');\n  buffer.push('c');\n\n  equal(buffer.string(), \"abc\", \"Buffers without tagNames do not wrap the content in a tag\");\n});\n\nmodule(\"Ember.RenderBuffer#element\");\n\ntest(\"properly handles old IE's zero-scope bug\", function() {\n  var buffer = new Ember.RenderBuffer('div');\n  buffer.pushOpeningTag();\n  buffer.push('<script></script>foo');\n\n  var element = buffer.element();\n  ok(Ember.$(element).html().match(/script/i), \"should have script tag\");\n  ok(!Ember.$(element).html().match(/&shy;/), \"should not have &shy;\");\n});\n\n})();\n//@ sourceURL=ember-views/~tests/system/render_buffer_test");minispade.register('ember-views/~tests/views/collection_test', "(function() {var set = Ember.set, get = Ember.get;\nvar forEach = Ember.EnumerableUtils.forEach;\nvar view;\n\nmodule(\"Ember.CollectionView\", {\n  setup: function() {\n    Ember.CollectionView.CONTAINER_MAP.del = 'em';\n  },\n  teardown: function() {\n    delete Ember.CollectionView.CONTAINER_MAP.del;\n    Ember.run(function(){\n      if (view) { view.destroy(); }\n    });\n  }\n});\n\ntest(\"should render a view for each item in its content array\", function() {\n  view = Ember.CollectionView.create({\n    content: Ember.A([1, 2, 3, 4])\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n  equal(view.$('div').length, 4);\n});\n\ntest(\"should render the emptyView if content array is empty (view class)\", function() {\n  view = Ember.CollectionView.create({\n    tagName: 'del',\n    content: Ember.A(),\n\n    emptyView: Ember.View.extend({\n      tagName: 'kbd',\n      render: function(buf) {\n        buf.push(\"OY SORRY GUVNAH NO NEWS TODAY EH\");\n      }\n    })\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  ok(view.$().find('kbd:contains(\"OY SORRY GUVNAH\")').length, \"displays empty view\");\n});\n\ntest(\"should render the emptyView if content array is empty (view instance)\", function() {\n  view = Ember.CollectionView.create({\n    tagName: 'del',\n    content: Ember.A(),\n\n    emptyView: Ember.View.create({\n      tagName: 'kbd',\n      render: function(buf) {\n        buf.push(\"OY SORRY GUVNAH NO NEWS TODAY EH\");\n      }\n    })\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  ok(view.$().find('kbd:contains(\"OY SORRY GUVNAH\")').length, \"displays empty view\");\n});\n\ntest(\"should be able to override the tag name of itemViewClass even if tag is in default mapping\", function() {\n  view = Ember.CollectionView.create({\n    tagName: 'del',\n    content: Ember.A(['NEWS GUVNAH']),\n\n    itemViewClass: Ember.View.extend({\n      tagName: 'kbd',\n      render: function(buf) {\n        buf.push(get(this, 'content'));\n      }\n    })\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  ok(view.$().find('kbd:contains(\"NEWS GUVNAH\")').length, \"displays the item view with proper tag name\");\n});\n\ntest(\"should allow custom item views by setting itemViewClass\", function() {\n  var passedContents = [];\n  view = Ember.CollectionView.create({\n    content: Ember.A(['foo', 'bar', 'baz']),\n\n    itemViewClass: Ember.View.extend({\n      render: function(buf) {\n        passedContents.push(get(this, 'content'));\n        buf.push(get(this, 'content'));\n      }\n    })\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  deepEqual(passedContents, ['foo', 'bar', 'baz'], \"sets the content property on each item view\");\n\n  forEach(passedContents, function(item) {\n    equal(view.$(':contains(\"'+item+'\")').length, 1);\n  });\n});\n\ntest(\"should insert a new item in DOM when an item is added to the content array\", function() {\n  var content = Ember.A(['foo', 'bar', 'baz']);\n\n  view = Ember.CollectionView.create({\n    content: content,\n\n    itemViewClass: Ember.View.extend({\n      render: function(buf) {\n        buf.push(get(this, 'content'));\n      }\n    })\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  forEach(content, function(item) {\n    equal(view.$(':contains(\"'+item+'\")').length, 1, \"precond - generates pre-existing items\");\n  });\n\n  Ember.run(function() {\n    content.insertAt(1, 'quux');\n  });\n\n  equal(Ember.$.trim(view.$(':nth-child(2)').text()), 'quux');\n});\n\ntest(\"should remove an item from DOM when an item is removed from the content array\", function() {\n  var content = Ember.A(['foo', 'bar', 'baz']);\n\n  view = Ember.CollectionView.create({\n    content: content,\n\n    itemViewClass: Ember.View.extend({\n      render: function(buf) {\n        buf.push(get(this, 'content'));\n      }\n    })\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  forEach(content, function(item) {\n    equal(view.$(':contains(\"'+item+'\")').length, 1, \"precond - generates pre-existing items\");\n  });\n\n  Ember.run(function() {\n    content.removeAt(1);\n  });\n\n  forEach(content, function(item, idx) {\n    equal(view.$(Ember.String.fmt(':nth-child(%@)', [String(idx+1)])).text(), item);\n  });\n});\n\ntest(\"it updates the view if an item is replaced\", function() {\n  var content = Ember.A(['foo', 'bar', 'baz']);\n  view = Ember.CollectionView.create({\n    content: content,\n\n    itemViewClass: Ember.View.extend({\n      render: function(buf) {\n        buf.push(get(this, 'content'));\n      }\n    })\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  forEach(content, function(item) {\n    equal(view.$(':contains(\"'+item+'\")').length, 1, \"precond - generates pre-existing items\");\n  });\n\n  Ember.run(function() {\n    content.removeAt(1);\n    content.insertAt(1, \"Kazuki\" );\n  });\n\n  forEach(content, function(item, idx) {\n    equal(Ember.$.trim(view.$(Ember.String.fmt(':nth-child(%@)', [String(idx+1)])).text()), item, \"postcond - correct array update\");\n  });\n});\n\ntest(\"can add and replace in the same runloop\", function() {\n  var content = Ember.A(['foo', 'bar', 'baz']);\n  view = Ember.CollectionView.create({\n    content: content,\n\n    itemViewClass: Ember.View.extend({\n      render: function(buf) {\n        buf.push(get(this, 'content'));\n      }\n    })\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  forEach(content, function(item) {\n    equal(view.$(':contains(\"'+item+'\")').length, 1, \"precond - generates pre-existing items\");\n  });\n\n  Ember.run(function() {\n    content.pushObject(\"Tom Dale\" );\n    content.removeAt(0);\n    content.insertAt(0, \"Kazuki\" );\n  });\n\n  forEach(content, function(item, idx) {\n    equal(Ember.$.trim(view.$(Ember.String.fmt(':nth-child(%@)', [String(idx+1)])).text()), item, \"postcond - correct array update\");\n  });\n\n});\n\ntest(\"can add and replace the object before the add in the same runloop\", function() {\n  var content = Ember.A(['foo', 'bar', 'baz']);\n  view = Ember.CollectionView.create({\n    content: content,\n\n    itemViewClass: Ember.View.extend({\n      render: function(buf) {\n        buf.push(get(this, 'content'));\n      }\n    })\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  forEach(content, function(item) {\n    equal(view.$(':contains(\"'+item+'\")').length, 1, \"precond - generates pre-existing items\");\n  });\n\n  Ember.run(function() {\n    content.pushObject(\"Tom Dale\" );\n    content.removeAt(1);\n    content.insertAt(1, \"Kazuki\" );\n  });\n\n  forEach(content, function(item, idx) {\n    equal(Ember.$.trim(view.$(Ember.String.fmt(':nth-child(%@)', [String(idx+1)])).text()), item, \"postcond - correct array update\");\n  });\n});\n\ntest(\"can add and replace complicatedly\", function() {\n  var content = Ember.A(['foo', 'bar', 'baz']);\n  view = Ember.CollectionView.create({\n    content: content,\n\n    itemViewClass: Ember.View.extend({\n      render: function(buf) {\n        buf.push(get(this, 'content'));\n      }\n    })\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  forEach(content, function(item) {\n    equal(view.$(':contains(\"'+item+'\")').length, 1, \"precond - generates pre-existing items\");\n  });\n\n  Ember.run(function() {\n    content.pushObject(\"Tom Dale\" );\n    content.removeAt(1);\n    content.insertAt(1, \"Kazuki\" );\n    content.pushObject(\"Firestone\" );\n    content.pushObject(\"McMunch\" );\n  });\n\n  forEach(content, function(item, idx) {\n    equal(Ember.$.trim(view.$(Ember.String.fmt(':nth-child(%@)', [String(idx+1)])).text()), item, \"postcond - correct array update: \"+item.name+\"!=\"+view.$(Ember.String.fmt(':nth-child(%@)', [String(idx+1)])).text());\n  });\n});\n\ntest(\"can add and replace complicatedly harder\", function() {\n  var content = Ember.A(['foo', 'bar', 'baz']);\n  view = Ember.CollectionView.create({\n    content: content,\n\n    itemViewClass: Ember.View.extend({\n      render: function(buf) {\n        buf.push(get(this, 'content'));\n      }\n    })\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  forEach(content, function(item) {\n    equal(view.$(':contains(\"'+item+'\")').length, 1, \"precond - generates pre-existing items\");\n  });\n\n  Ember.run(function() {\n    content.pushObject(\"Tom Dale\" );\n    content.removeAt(1);\n    content.insertAt(1, \"Kazuki\" );\n    content.pushObject(\"Firestone\" );\n    content.pushObject(\"McMunch\" );\n    content.removeAt(2);\n  });\n\n  forEach(content, function(item, idx) {\n    equal(Ember.$.trim(view.$(Ember.String.fmt(':nth-child(%@)', [String(idx+1)])).text()), item, \"postcond - correct array update\");\n  });\n});\n\ntest(\"should allow changes to content object before layer is created\", function() {\n  view = Ember.CollectionView.create({\n    content: null\n  });\n\n\n  Ember.run(function() {\n    set(view, 'content', Ember.A());\n    set(view, 'content', Ember.A([1, 2, 3]));\n    set(view, 'content', Ember.A([1, 2]));\n    view.append();\n  });\n\n  ok(view.$().children().length);\n});\n\ntest(\"should fire life cycle events when elements are added and removed\", function() {\n  var view,\n    didInsertElement = 0,\n    willDestroyElement = 0,\n    willDestroy = 0,\n    destroy = 0,\n    content = Ember.A([1, 2, 3]);\n  Ember.run(function () {\n    view = Ember.CollectionView.create({\n      content: content,\n      itemViewClass: Ember.View.extend({\n        render: function(buf) {\n          buf.push(get(this, 'content'));\n        },\n        didInsertElement: function () {\n          didInsertElement++;\n        },\n        willDestroyElement: function () {\n          willDestroyElement++;\n        },\n        willDestroy: function () {\n          willDestroy++;\n          this._super();\n        },\n        destroy: function() {\n          destroy++;\n          this._super();\n        }\n      })\n    });\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(didInsertElement, 3);\n  equal(willDestroyElement, 0);\n  equal(willDestroy, 0);\n  equal(destroy, 0);\n  equal(view.$().text(), '123');\n\n  Ember.run(function () {\n    content.pushObject(4);\n    content.unshiftObject(0);\n  });\n\n\n  equal(didInsertElement, 5);\n  equal(willDestroyElement, 0);\n  equal(willDestroy, 0);\n  equal(destroy, 0);\n  // Remove whitspace added by IE 8\n  equal(view.$().text().replace(/\\s+/g,''), '01234');\n\n  Ember.run(function () {\n    content.popObject();\n    content.shiftObject();\n  });\n\n  equal(didInsertElement, 5);\n  equal(willDestroyElement, 2);\n  equal(willDestroy, 2);\n  equal(destroy, 2);\n  // Remove whitspace added by IE 8\n  equal(view.$().text().replace(/\\s+/g,''), '123');\n\n  Ember.run(function () {\n    view.set('content', Ember.A([7,8,9]));\n  });\n\n  equal(didInsertElement, 8);\n  equal(willDestroyElement, 5);\n  equal(willDestroy, 5);\n  equal(destroy, 5);\n  // Remove whitspace added by IE 8\n  equal(view.$().text().replace(/\\s+/g,''), '789');\n\n  Ember.run(function () {\n    view.destroy();\n  });\n\n  equal(didInsertElement, 8);\n  equal(willDestroyElement, 8);\n  equal(willDestroy, 8);\n  equal(destroy, 8);\n});\n\ntest(\"should allow changing content property to be null\", function() {\n  view = Ember.CollectionView.create({\n    content: Ember.A([1, 2, 3]),\n\n    emptyView: Ember.View.extend({\n      template: function() { return \"(empty)\"; }\n    })\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  equal(view.$().children().length, 3, \"precond - creates three elements\");\n\n  Ember.run(function() {\n    set(view, 'content', null);\n  });\n\n  equal(Ember.$.trim(view.$().children().text()), \"(empty)\", \"should display empty view\");\n});\n\ntest(\"should allow items to access to the CollectionView's current index in the content array\", function() {\n  view = Ember.CollectionView.create({\n    content: Ember.A(['zero', 'one', 'two']),\n    itemViewClass: Ember.View.extend({\n      render: function(buf) {\n        buf.push(get(this, 'contentIndex'));\n      }\n    })\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  deepEqual(view.$(':nth-child(1)').text(), \"0\");\n  deepEqual(view.$(':nth-child(2)').text(), \"1\");\n  deepEqual(view.$(':nth-child(3)').text(), \"2\");\n});\n\ntest(\"should allow declaration of itemViewClass as a string\", function() {\n  view = Ember.CollectionView.create({\n    content: Ember.A([1, 2, 3]),\n    itemViewClass: 'Ember.View'\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(view.$('.ember-view').length, 3);\n});\n\ntest(\"should not render the emptyView if content is emptied and refilled in the same run loop\", function() {\n  view = Ember.CollectionView.create({\n    tagName: 'div',\n    content: Ember.A(['NEWS GUVNAH']),\n\n    emptyView: Ember.View.extend({\n      tagName: 'kbd',\n      render: function(buf) {\n        buf.push(\"OY SORRY GUVNAH NO NEWS TODAY EH\");\n      }\n    })\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  equal(view.$().find('kbd:contains(\"OY SORRY GUVNAH\")').length, 0);\n\n  Ember.run(function() {\n    view.get('content').popObject();\n    view.get('content').pushObject(['NEWS GUVNAH']);\n  });\n  equal(view.$('div').length, 1);\n  equal(view.$().find('kbd:contains(\"OY SORRY GUVNAH\")').length, 0);\n});\n\ntest(\"a array_proxy that backs an sorted array_controller that backs a collection view functions properly\", function() {\n\n  var array = Ember.A([{ name: \"Other Katz\" }]);\n  var arrayProxy = Ember.ArrayProxy.create({content: array});\n\n  var sortedController = Ember.ArrayController.create({\n    content: arrayProxy,\n    sortProperties: ['name']\n  });\n\n  var container = Ember.CollectionView.create({\n    content: sortedController\n  });\n\n  Ember.run(function() {\n    container.appendTo('#qunit-fixture');\n  });\n\n  Ember.run(function() {\n    arrayProxy.addObjects([{ name: \"Scumbag Demon\" }, { name: \"Lord British\" }]);\n  });\n\n  equal(container.get('content.length'), 3, 'ArrayController should have 3 entries');\n  equal(container.get('content.content.length'), 3, 'RecordArray should have 3 entries');\n  equal(container.get('childViews.length'), 3, 'CollectionView should have 3 entries');\n\n  Ember.run(function() {\n    container.destroy();\n  });\n});\n\n})();\n//@ sourceURL=ember-views/~tests/views/collection_test");minispade.register('ember-views/~tests/views/container_view_test', "(function() {var get = Ember.get, set = Ember.set, container, view;\n\nmodule(\"ember-views/views/container_view_test\", {\n  teardown: function() {\n    Ember.run(function() {\n      container.destroy();\n      if (view) { view.destroy(); }\n    });\n  }\n});\n\ntest(\"should be able to insert views after the DOM representation is created\", function() {\n  container = Ember.ContainerView.create({\n    classNameBindings: ['name'],\n    name: 'foo'\n  });\n\n  Ember.run(function() {\n    container.appendTo('#qunit-fixture');\n  });\n\n  view = Ember.View.create({\n    template: function() {\n      return \"This is my moment\";\n    }\n  });\n\n  Ember.run(function() {\n    container.pushObject(view);\n  });\n\n  equal(Ember.$.trim(container.$().text()), \"This is my moment\");\n\n  Ember.run(function(){\n    container.destroy();\n  });\n\n});\n\ntest(\"should be able to observe properties that contain child views\", function() {\n  Ember.run(function() {\n    container = Ember.ContainerView.create({\n      childViews: ['displayView'],\n      displayIsDisplayedBinding: 'displayView.isDisplayed',\n\n      displayView: Ember.View.extend({\n        isDisplayed: true\n      })\n    });\n\n    container.appendTo('#qunit-fixture');\n  });\n  ok(container.get('displayIsDisplayed'), \"can bind to child view\");\n});\n\ntest(\"should set the parentView property on views that are added to the child views array\", function() {\n  container = Ember.ContainerView.create();\n\n  var View = Ember.View.extend({\n      template: function() {\n        return \"This is my moment\";\n      }\n    });\n\n  view = View.create();\n\n  container.pushObject(view);\n  equal(view.get('parentView'), container, \"sets the parent view after the childView is appended\");\n\n  Ember.run(function() {\n    container.removeObject(view);\n  });\n  equal(get(view, 'parentView'), null, \"sets parentView to null when a view is removed\");\n\n  Ember.run(function() {\n    container.appendTo('#qunit-fixture');\n  });\n\n  Ember.run(function(){\n    container.pushObject(view);\n  });\n\n  equal(get(view, 'parentView'), container, \"sets the parent view after the childView is appended\");\n\n  var secondView = View.create(),\n      thirdView = View.create(),\n      fourthView = View.create();\n\n  Ember.run(function(){\n    container.pushObject(secondView);\n    container.replace(1, 0, [thirdView, fourthView]);\n  });\n\n  equal(get(secondView, 'parentView'), container, \"sets the parent view of the second view\");\n  equal(get(thirdView, 'parentView'), container, \"sets the parent view of the third view\");\n  equal(get(fourthView, 'parentView'), container, \"sets the parent view of the fourth view\");\n\n  Ember.run(function() {\n    container.replace(2, 2);\n  });\n\n  equal(get(view, 'parentView'), container, \"doesn't change non-removed view\");\n  equal(get(thirdView, 'parentView'), container, \"doesn't change non-removed view\");\n  equal(get(secondView, 'parentView'), null, \"clears the parent view of the third view\");\n  equal(get(fourthView, 'parentView'), null, \"clears the parent view of the fourth view\");\n\n  Ember.run(function() {\n    secondView.destroy();\n    thirdView.destroy();\n    fourthView.destroy();\n  });\n});\n\ntest(\"views that are removed from a ContainerView should have their child views cleared\", function() {\n  container = Ember.ContainerView.create();\n  view = Ember.View.createWithMixins({\n    remove: function() {\n      this._super();\n    },\n    template: function(context, options) {\n      options.data.view.appendChild(Ember.View);\n    }\n  });\n\n  container.pushObject(view);\n\n  Ember.run(function() {\n    container.appendTo('#qunit-fixture');\n  });\n\n  equal(get(view, 'childViews.length'), 1, \"precond - renders one child view\");\n  Ember.run(function() {\n    container.removeObject(view);\n  });\n  equal(get(view, 'childViews.length'), 0, \"child views are cleared when removed from container view\");\n  equal(container.$().html(),'', \"the child view is removed from the DOM\");\n});\n\ntest(\"if a ContainerView starts with an empy currentView, nothing is displayed\", function() {\n  container = Ember.ContainerView.create();\n\n  Ember.run(function() {\n    container.appendTo('#qunit-fixture');\n  });\n\n  equal(container.$().text(), '', \"has a empty contents\");\n  equal(get(container, 'childViews.length'), 0, \"should not have any child views\");\n});\n\ntest(\"if a ContainerView starts with a currentView, it is rendered as a child view\", function() {\n  var controller = Ember.Controller.create();\n  container = Ember.ContainerView.create({\n    controller: controller\n  });\n  var context = null;\n  var templateData = null;\n  var mainView = Ember.View.create({\n    template: function(ctx, opts) {\n      context = ctx;\n      templateData = opts.data;\n      return \"This is the main view.\";\n    }\n  });\n\n  set(container, 'currentView', mainView);\n\n  Ember.run(function() {\n    container.appendTo('#qunit-fixture');\n  });\n\n  equal(Ember.$.trim(container.$().text()), \"This is the main view.\", \"should render its child\");\n  equal(get(container, 'length'), 1, \"should have one child view\");\n  equal(container.objectAt(0), mainView, \"should have the currentView as the only child view\");\n  equal(mainView.get('parentView'), container, \"parentView is setup\");\n  equal(context, container.get('context'), 'context preserved');\n  equal(templateData.keywords.controller, controller, 'templateData is setup');\n  equal(templateData.keywords.view, mainView, 'templateData is setup');\n});\n\ntest(\"if a ContainerView is created with a currentView, it is rendered as a child view\", function() {\n  var context = null;\n  var templateData = null;\n  var mainView = Ember.View.create({\n    template: function(ctx, opts) {\n      context = ctx;\n      templateData = opts.data;\n      return \"This is the main view.\";\n    }\n  });\n\n  var controller = Ember.Controller.create();\n\n  container = Ember.ContainerView.create({\n    currentView: mainView,\n    controller: controller\n  });\n\n  Ember.run(function() {\n    container.appendTo('#qunit-fixture');\n  });\n\n  equal(container.$().text(), \"This is the main view.\", \"should render its child\");\n  equal(get(container, 'length'), 1, \"should have one child view\");\n  equal(container.objectAt(0), mainView, \"should have the currentView as the only child view\");\n  equal(mainView.get('parentView'), container, \"parentView is setup\");\n  equal(context, container.get('context'), 'context preserved');\n  equal(templateData.keywords.controller, controller, 'templateData is setup');\n  equal(templateData.keywords.view, mainView, 'templateData is setup');\n});\n\ntest(\"if a ContainerView starts with no currentView and then one is set, the ContainerView is updated\", function() {\n  var context = null;\n  var templateData = null;\n  var mainView = Ember.View.create({\n    template: function(ctx, opts) {\n      context = ctx;\n      templateData = opts.data;\n      return \"This is the main view.\";\n    }\n  });\n\n  var controller = Ember.Controller.create();\n\n  container = Ember.ContainerView.create({\n    controller: controller\n  });\n\n  Ember.run(function() {\n    container.appendTo('#qunit-fixture');\n  });\n\n  equal(container.$().text(), '', \"has a empty contents\");\n  equal(get(container, 'childViews.length'), 0, \"should not have any child views\");\n\n  Ember.run(function() {\n    set(container, 'currentView', mainView);\n  });\n\n  equal(container.$().text(), \"This is the main view.\", \"should render its child\");\n  equal(get(container, 'length'), 1, \"should have one child view\");\n  equal(container.objectAt(0), mainView, \"should have the currentView as the only child view\");\n  equal(mainView.get('parentView'), container, \"parentView is setup\");\n  equal(context, container.get('context'), 'context preserved');\n  equal(templateData.keywords.controller, controller, 'templateData is setup');\n  equal(templateData.keywords.view, mainView, 'templateData is setup');\n});\n\ntest(\"if a ContainerView starts with a currentView and then is set to null, the ContainerView is updated\", function() {\n  var context = null;\n  var templateData = null;\n  var mainView = Ember.View.create({\n    template: function(ctx, opts) {\n      context = ctx;\n      templateData = opts.data;\n      return \"This is the main view.\";\n    }\n  });\n\n  var controller = Ember.Controller.create();\n\n  container = Ember.ContainerView.create({\n    controller: controller\n  });\n\n  container.set('currentView', mainView);\n\n  Ember.run(function() {\n    container.appendTo('#qunit-fixture');\n  });\n\n  equal(container.$().text(), \"This is the main view.\", \"should render its child\");\n  equal(get(container, 'length'), 1, \"should have one child view\");\n  equal(container.objectAt(0), mainView, \"should have the currentView as the only child view\");\n  equal(mainView.get('parentView'), container, \"parentView is setup\");\n  equal(context, container.get('context'), 'context preserved');\n  equal(templateData.keywords.controller, controller, 'templateData is setup');\n  equal(templateData.keywords.view, mainView, 'templateData is setup');\n\n  Ember.run(function() {\n    set(container, 'currentView', null);\n  });\n\n  equal(container.$().text(), '', \"has a empty contents\");\n  equal(get(container, 'childViews.length'), 0, \"should not have any child views\");\n});\n\ntest(\"if a ContainerView starts with a currentView and then is set to null, the ContainerView is updated and the previous currentView is destroyed\", function() {\n  var context = null;\n  var templateData = null;\n  var mainView = Ember.View.create({\n    template: function(ctx, opts) {\n      context = ctx;\n      templateData = opts.data;\n      return \"This is the main view.\";\n    }\n  });\n\n  var controller = Ember.Controller.create();\n\n  container = Ember.ContainerView.create({\n    controller: controller\n  });\n\n  container.set('currentView', mainView);\n\n  Ember.run(function() {\n    container.appendTo('#qunit-fixture');\n  });\n\n  equal(container.$().text(), \"This is the main view.\", \"should render its child\");\n  equal(get(container, 'length'), 1, \"should have one child view\");\n  equal(container.objectAt(0), mainView, \"should have the currentView as the only child view\");\n  equal(mainView.get('parentView'), container, \"parentView is setup\");\n  equal(context, container.get('context'), 'context preserved');\n  equal(templateData.keywords.controller, controller, 'templateData is setup');\n  equal(templateData.keywords.view, mainView, 'templateData is setup');\n\n  Ember.run(function() {\n    set(container, 'currentView', null);\n  });\n\n  equal(mainView.isDestroyed, true, 'should destroy the previous currentView.');\n\n  equal(container.$().text(), '', \"has a empty contents\");\n  equal(get(container, 'childViews.length'), 0, \"should not have any child views\");\n});\n\ntest(\"if a ContainerView starts with a currentView and then a different currentView is set, the old view is destroyed and the new one is added\", function() {\n  container = Ember.ContainerView.create();\n  var mainView = Ember.View.create({\n    template: function() {\n      return \"This is the main view.\";\n    }\n  });\n\n  var secondaryView = Ember.View.create({\n    template: function() {\n      return \"This is the secondary view.\";\n    }\n  });\n\n  var tertiaryView = Ember.View.create({\n    template: function() {\n      return \"This is the tertiary view.\";\n    }\n  });\n\n  container.set('currentView', mainView);\n\n  Ember.run(function() {\n    container.appendTo('#qunit-fixture');\n  });\n\n  equal(container.$().text(), \"This is the main view.\", \"should render its child\");\n  equal(get(container, 'length'), 1, \"should have one child view\");\n  equal(container.objectAt(0), mainView, \"should have the currentView as the only child view\");\n\n  Ember.run(function() {\n    set(container, 'currentView', secondaryView);\n    equal(get(container, 'length'), 1, \"should have one child view\");\n    equal(container.objectAt(0), secondaryView, \"should have the currentView as the only child view\");\n  });\n\n  equal(mainView.isDestroyed, true, 'should destroy the previous currentView: mainView.');\n\n  equal(Ember.$.trim(container.$().text()), \"This is the secondary view.\", \"should render its child\");\n\n  Ember.run(function() {\n    set(container, 'currentView', tertiaryView);\n    equal(get(container, 'length'), 1, \"should have one child view\");\n    equal(container.objectAt(0), tertiaryView, \"should have the currentView as the only child view\");\n  });\n\n  equal(secondaryView.isDestroyed, true, 'should destroy the previous currentView: secondaryView.');\n\n  equal(Ember.$.trim(container.$().text()), \"This is the tertiary view.\", \"should render its child\");\n});\n\ntest(\"should be able to modify childViews many times during an run loop\", function () {\n\n  container = Ember.ContainerView.create();\n\n  Ember.run(function() {\n    container.appendTo('#qunit-fixture');\n  });\n\n  var one = Ember.View.create({\n    template: function() {\n      return 'one';\n    }\n  });\n\n  var two = Ember.View.create({\n    template: function() {\n      return 'two';\n    }\n  });\n\n  var three = Ember.View.create({\n    template: function() {\n      return 'three';\n    }\n  });\n\n  Ember.run(function() {\n    // initial order\n    container.pushObjects([three, one, two]);\n    // sort\n    container.removeObject(three);\n    container.pushObject(three);\n  });\n\n  // Remove whitespace added by IE 8\n  equal(container.$().text().replace(/\\s+/g,''), 'onetwothree');\n});\n\ntest(\"should be able to modify childViews then remove the ContainerView in same run loop\", function () {\n  container = Ember.ContainerView.create();\n\n  Ember.run(function() {\n    container.appendTo('#qunit-fixture');\n  });\n\n  var count = 0;\n  var child = Ember.View.create({\n    template: function () { count++; return 'child'; }\n  });\n\n  Ember.run(function() {\n    container.pushObject(child);\n    container.remove();\n  });\n\n  equal(count, 0, 'did not render child');\n});\n\ntest(\"should be able to modify childViews then destroy the ContainerView in same run loop\", function () {\n    container = Ember.ContainerView.create();\n\n  Ember.run(function() {\n    container.appendTo('#qunit-fixture');\n  });\n\n  var count = 0;\n  var child = Ember.View.create({\n    template: function () { count++; return 'child'; }\n  });\n\n  Ember.run(function() {\n    container.pushObject(child);\n    container.destroy();\n  });\n\n  equal(count, 0, 'did not render child');\n});\n\n\ntest(\"should be able to modify childViews then rerender the ContainerView in same run loop\", function () {\n    container = Ember.ContainerView.create();\n\n  Ember.run(function() {\n    container.appendTo('#qunit-fixture');\n  });\n\n  var count = 0;\n  var child = Ember.View.create({\n    template: function () { count++; return 'child'; }\n  });\n\n  Ember.run(function() {\n    container.pushObject(child);\n    container.rerender();\n  });\n\n  equal(count, 1, 'rendered child only once');\n});\n\ntest(\"should be able to modify childViews then rerender then modify again the ContainerView in same run loop\", function () {\n  container = Ember.ContainerView.create();\n\n  Ember.run(function() {\n    container.appendTo('#qunit-fixture');\n  });\n\n  var Child = Ember.View.extend({\n    count: 0,\n    render: function (buffer) {\n      this.count++;\n      buffer.push(this.label);\n    }\n  });\n  var one = Child.create({label: 'one'});\n  var two = Child.create({label: 'two'});\n\n  Ember.run(function() {\n    container.pushObject(one);\n    container.pushObject(two);\n  });\n\n  equal(one.count, 1, 'rendered child only once');\n  equal(two.count, 1, 'rendered child only once');\n  // Remove whitespace added by IE 8\n  equal(container.$().text().replace(/\\s+/g, ''), 'onetwo');\n});\n\ntest(\"should be able to modify childViews then rerender again the ContainerView in same run loop and then modify again\", function () {\n  container = Ember.ContainerView.create();\n\n  Ember.run(function() {\n    container.appendTo('#qunit-fixture');\n  });\n\n  var Child = Ember.View.extend({\n    count: 0,\n    render: function (buffer) {\n      this.count++;\n      buffer.push(this.label);\n    }\n  });\n  var one = Child.create({label: 'one'});\n  var two = Child.create({label: 'two'});\n\n  Ember.run(function() {\n    container.pushObject(one);\n    container.rerender();\n  });\n\n  equal(one.count, 1, 'rendered child only once');\n  equal(container.$().text(), 'one');\n\n  Ember.run(function () {\n    container.pushObject(two);\n  });\n\n  equal(one.count, 1, 'rendered child only once');\n  equal(two.count, 1, 'rendered child only once');\n  // IE 8 adds a line break but this shouldn't affect validity\n  equal(container.$().text().replace(/\\s/g, ''), 'onetwo');\n});\n\ntest(\"should invalidate `element` on itself and childViews when being rendered by ensureChildrenAreInDOM\", function () {\n  var root = Ember.ContainerView.create();\n\n  view = Ember.View.create({ template: function() {} });\n  container = Ember.ContainerView.create({ childViews: ['child'], child: view });\n\n  Ember.run(function() {\n    root.appendTo('#qunit-fixture');\n  });\n\n  Ember.run(function() {\n    root.pushObject(container);\n\n    // Get the parent and child's elements to cause them to be cached as null\n    container.get('element');\n    view.get('element');\n  });\n\n  ok(!!container.get('element'), \"Parent's element should have been recomputed after being rendered\");\n  ok(!!view.get('element'), \"Child's element should have been recomputed after being rendered\");\n\n  Ember.run(function() {\n    root.destroy();\n  });\n});\n\n})();\n//@ sourceURL=ember-views/~tests/views/container_view_test");minispade.register('ember-views/~tests/views/view/append_to_test', "(function() {var set = Ember.set, get = Ember.get;\n\nvar View, view, willDestroyCalled, childView;\n\nmodule(\"Ember.View - append() and appendTo()\", {\n  setup: function() {\n    View = Ember.View.extend({});\n  },\n\n  teardown: function() {\n    Ember.run(function(){\n      if (!view.isDestroyed) { view.destroy(); }\n    });\n  }\n});\n\ntest(\"should be added to the specified element when calling append()\", function() {\n  Ember.$(\"#qunit-fixture\").html('<div id=\"menu\"></div>');\n\n  view = View.create();\n\n  ok(!get(view, 'element'), \"precond - should not have an element\");\n\n  Ember.run(function() {\n    view.appendTo('#menu');\n  });\n\n  var viewElem = Ember.$('#menu').children();\n  ok(viewElem.length > 0, \"creates and appends the view's element\");\n});\n\ntest(\"should be added to the document body when calling appendTo()\", function() {\n  view = View.create({\n    render: function(buffer) {\n      buffer.push(\"foo bar baz\");\n    }\n  });\n\n  ok(!get(view, 'element'), \"precond - should not have an element\");\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  var viewElem = Ember.$(document.body).find(':contains(\"foo bar baz\")');\n  ok(viewElem.length > 0, \"creates and appends the view's element\");\n});\n\ntest(\"append calls willInsertElement and didInsertElement callbacks\", function(){\n  var willInsertElementCalled = false;\n  var willInsertElementCalledInChild = false;\n  var didInsertElementCalled = false;\n\n  var ViewWithCallback = View.extend({\n    willInsertElement: function(){\n      willInsertElementCalled = true;\n    },\n    didInsertElement: function(){\n      didInsertElementCalled = true;\n    },\n    render: function(buffer) {\n      this.appendChild(Ember.View.create({\n        willInsertElement: function() {\n          willInsertElementCalledInChild = true;\n        }\n      }));\n    }\n  });\n\n  view = ViewWithCallback.create();\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  ok(willInsertElementCalled, \"willInsertElement called\");\n  ok(willInsertElementCalledInChild, \"willInsertElement called in child\");\n  ok(didInsertElementCalled, \"didInsertElement called\");\n});\n\ntest(\"remove removes an element from the DOM\", function() {\n  willDestroyCalled = 0;\n\n  view = View.create({\n    willDestroyElement: function() {\n      willDestroyCalled++;\n    }\n  });\n\n  ok(!get(view, 'element'), \"precond - should not have an element\");\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  ok(Ember.$(\"#\" + get(view, 'elementId')).length === 1, \"precond - element was inserted\");\n\n  Ember.run(function() {\n    view.remove();\n  });\n\n  ok(Ember.$(\"#\" + get(view, 'elementId')).length === 0, \"remove removes an element from the DOM\");\n  ok(Ember.View.views[get(view, 'elementId')] === undefined, \"remove does not remove the view from the view hash\");\n  ok(!get(view, 'element'), \"remove nulls out the element\");\n  equal(willDestroyCalled, 1, \"the willDestroyElement hook was called once\");\n});\n\ntest(\"destroy more forcibly removes the view\", function() {\n  willDestroyCalled = 0;\n\n  view = View.create({\n    willDestroyElement: function() {\n      willDestroyCalled++;\n    }\n  });\n\n  ok(!get(view, 'element'), \"precond - should not have an element\");\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  ok(Ember.$(\"#\" + get(view, 'elementId')).length === 1, \"precond - element was inserted\");\n\n  Ember.run(function() {\n    view.destroy();\n  });\n\n  ok(Ember.$(\"#\" + get(view, 'elementId')).length === 0, \"destroy removes an element from the DOM\");\n  ok(Ember.View.views[get(view, 'elementId')] === undefined, \"destroy removes a view from the global views hash\");\n  equal(get(view, 'isDestroyed'), true, \"the view is marked as destroyed\");\n  ok(!get(view, 'element'), \"the view no longer has an element\");\n  equal(willDestroyCalled, 1, \"the willDestroyElement hook was called once\");\n});\n\nmodule(\"Ember.View - append() and appendTo() in a view hierarchy\", {\n  setup: function() {\n    View = Ember.ContainerView.extend({\n      childViews: ['child'],\n      child: Ember.View.extend({\n        elementId: 'child'\n      })\n    });\n  },\n\n  teardown: function() {\n    Ember.run(function(){\n      if (!view.isDestroyed) { view.destroy(); }\n    });\n  }\n});\n\ntest(\"should be added to the specified element when calling appendTo()\", function() {\n  Ember.$(\"#qunit-fixture\").html('<div id=\"menu\"></div>');\n\n  view = View.create();\n\n  ok(!get(view, 'element'), \"precond - should not have an element\");\n\n  Ember.run(function() {\n    view.appendTo('#menu');\n  });\n\n  var viewElem = Ember.$('#menu #child');\n  ok(viewElem.length > 0, \"creates and appends the view's element\");\n});\n\ntest(\"should be added to the document body when calling append()\", function() {\n  Ember.$(\"#qunit-fixture\").html('<div id=\"menu\"></div>');\n\n  view = View.create();\n\n  ok(!get(view, 'element'), \"precond - should not have an element\");\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  var viewElem = Ember.$('#child');\n  ok(viewElem.length > 0, \"creates and appends the view's element\");\n});\n\nmodule(\"Ember.View - removing views in a view hierarchy\", {\n  setup: function() {\n    willDestroyCalled = 0;\n\n    view = Ember.ContainerView.create({\n      childViews: ['child'],\n      child: Ember.View.create({\n        willDestroyElement: function() {\n          willDestroyCalled++;\n        }\n      })\n    });\n\n    childView = get(view, 'child');\n  },\n\n  teardown: function() {\n    Ember.run(function(){\n      if (!view.isDestroyed) { view.destroy(); }\n    });\n  }\n});\n\ntest(\"remove removes child elements from the DOM\", function() {\n  ok(!get(childView, 'element'), \"precond - should not have an element\");\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  ok(Ember.$(\"#\" + get(childView, 'elementId')).length === 1, \"precond - element was inserted\");\n\n  // remove parent view\n  Ember.run(function() {\n    view.remove();\n  });\n\n  ok(Ember.$(\"#\" + get(childView, 'elementId')).length === 0, \"remove removes child elements the DOM\");\n  ok(Ember.View.views[get(childView, 'elementId')] === undefined, \"remove does not remove child views from the view hash\");\n  ok(!get(childView, 'element'), \"remove nulls out child elements\");\n  equal(willDestroyCalled, 1, \"the willDestroyElement hook was called once\");\n});\n\ntest(\"destroy more forcibly removes child views\", function() {\n  ok(!get(childView, 'element'), \"precond - should not have an element\");\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  ok(Ember.$(\"#\" + get(childView, 'elementId')).length === 1, \"precond - child element was inserted\");\n\n  willDestroyCalled = 0;\n\n  Ember.run(function() {\n    view.destroy();\n  });\n\n  ok(Ember.$(\"#\" + get(childView, 'elementId')).length === 0, \"destroy removes child elements from the DOM\");\n  ok(Ember.View.views[get(childView, 'elementId')] === undefined, \"destroy removes a child views from the global views hash\");\n  equal(get(childView, 'isDestroyed'), true, \"child views are marked as destroyed\");\n  ok(!get(childView, 'element'), \"child views no longer have an element\");\n  equal(willDestroyCalled, 1, \"the willDestroyElement hook was called once on children\");\n});\n\ntest(\"destroy removes a child view from its parent\", function() {\n  ok(!get(childView, 'element'), \"precond - should not have an element\");\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  ok(Ember.$(\"#\" + get(childView, 'elementId')).length === 1, \"precond - child element was inserted\");\n\n  Ember.run(function() {\n    childView.destroy();\n  });\n\n  ok(get(view, 'childViews.length') === 0, \"Destroyed child views should be removed from their parent\");\n});\n\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/append_to_test");minispade.register('ember-views/~tests/views/view/attribute_bindings_test', "(function() {/*global Test:true*/\nvar set = Ember.set, get = Ember.get;\n\nvar originalLookup = Ember.lookup, lookup, view;\n\nvar appendView = function() {\n  Ember.run(function() { view.appendTo('#qunit-fixture'); });\n};\n\nmodule(\"Ember.View - Attribute Bindings\", {\n  setup: function() {\n    Ember.lookup = lookup = {};\n  },\n  teardown: function() {\n    if (view) {\n      Ember.run(function(){\n        view.destroy();\n      });\n      view = null;\n    }\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest(\"should render attribute bindings\", function() {\n  view = Ember.View.create({\n    classNameBindings: ['priority', 'isUrgent', 'isClassified:classified', 'canIgnore'],\n    attributeBindings: ['type', 'isDisabled:disabled', 'exploded', 'destroyed', 'exists', 'nothing', 'notDefined', 'notNumber', 'explosions'],\n\n    type: 'submit',\n    isDisabled: true,\n    exploded: false,\n    destroyed: false,\n    exists: true,\n    nothing: null,\n    notDefined: undefined,\n    notNumber: NaN\n  });\n\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  equal(view.$().attr('type'), 'submit', \"updates type attribute\");\n  ok(view.$().prop('disabled'), \"supports customizing attribute name for Boolean values\");\n  ok(!view.$().prop('exploded'), \"removes exploded attribute when false\");\n  ok(!view.$().prop('destroyed'), \"removes destroyed attribute when false\");\n  ok(view.$().prop('exists'), \"adds exists attribute when true\");\n  ok(!view.$().attr('nothing'), \"removes nothing attribute when null\");\n  ok(!view.$().attr('notDefined'), \"removes notDefined attribute when undefined\");\n  ok(!view.$().attr('notNumber'), \"removes notNumber attribute when NaN\");\n});\n\ntest(\"should update attribute bindings\", function() {\n  view = Ember.View.create({\n    classNameBindings: ['priority', 'isUrgent', 'isClassified:classified', 'canIgnore'],\n    attributeBindings: ['type', 'isDisabled:disabled', 'exploded', 'destroyed', 'exists', 'nothing', 'notDefined', 'notNumber', 'explosions'],\n\n    type: 'reset',\n    isDisabled: true,\n    exploded: true,\n    destroyed: true,\n    exists: false,\n    nothing: true,\n    notDefined: true,\n    notNumber: true,\n    explosions: 15\n  });\n\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  equal(view.$().attr('type'), 'reset', \"adds type attribute\");\n  ok(view.$().prop('disabled'), \"adds disabled attribute when true\");\n  ok(view.$().prop('exploded'), \"adds exploded attribute when true\");\n  ok(view.$().prop('destroyed'), \"adds destroyed attribute when true\");\n  ok(!view.$().prop('exists'), \"does not add exists attribute when false\");\n  ok(view.$().prop('nothing'), \"adds nothing attribute when true\");\n  ok(view.$().prop('notDefined'), \"adds notDefined attribute when true\");\n  ok(view.$().prop('notNumber'), \"adds notNumber attribute when true\");\n  equal(view.$().attr('explosions'), \"15\", \"adds integer attributes\");\n\n  Ember.run(function(){\n    view.set('type', 'submit');\n    view.set('isDisabled', false);\n    view.set('exploded', false);\n    view.set('destroyed', false);\n    view.set('exists', true);\n    view.set('nothing', null);\n    view.set('notDefined', undefined);\n    view.set('notNumber', NaN);\n  });\n\n  equal(view.$().attr('type'), 'submit', \"updates type attribute\");\n  ok(!view.$().prop('disabled'), \"removes disabled attribute when false\");\n  ok(!view.$().prop('exploded'), \"removes exploded attribute when false\");\n  ok(!view.$().prop('destroyed'), \"removes destroyed attribute when false\");\n  ok(view.$().prop('exists'), \"adds exists attribute when true\");\n  ok(!view.$().attr('nothing'), \"removes nothing attribute when null\");\n  ok(!view.$().attr('notDefined'), \"removes notDefined attribute when undefined\");\n  ok(!view.$().attr('notNumber'), \"removes notNumber attribute when NaN\");\n});\n\n// This comes into play when using the {{#each}} helper. If the\n// passed array item is a String, it will be converted into a\n// String object instead of a normal string.\ntest(\"should allow binding to String objects\", function() {\n  view = Ember.View.create({\n    attributeBindings: ['foo'],\n    // JSHint doesn't like `new String` so we'll create it the same way it gets created in practice\n    foo: (function(){ return this; }).call(\"bar\")\n  });\n\n  Ember.run(function(){\n    view.createElement();\n  });\n\n\n  equal(view.$().attr('foo'), 'bar', \"should convert String object to bare string\");\n});\n\ntest(\"should teardown observers on rerender\", function() {\n  view = Ember.View.create({\n    attributeBindings: ['foo'],\n    classNameBindings: ['foo'],\n    foo: 'bar'\n  });\n\n  appendView();\n\n  equal(Ember.observersFor(view, 'foo').length, 2);\n\n  Ember.run(function() {\n    view.rerender();\n  });\n\n  equal(Ember.observersFor(view, 'foo').length, 2);\n});\n\ntest(\"handles attribute bindings for properties\", function() {\n  view = Ember.View.create({\n    attributeBindings: ['checked'],\n    checked: null\n  });\n\n  appendView();\n\n  equal(!!view.$().prop('checked'), false, 'precond - is not checked');\n\n  Ember.run(function() {\n    view.set('checked', true);\n  });\n\n  equal(view.$().prop('checked'), true, 'changes to checked');\n\n  Ember.run(function() {\n    view.set('checked', false);\n  });\n\n  equal(view.$().prop('checked'), false, 'changes to unchecked');\n});\n\ntest(\"handles `undefined` value for properties\", function() {\n  view = Ember.View.create({\n    attributeBindings: ['value'],\n    value: \"test\"\n  });\n\n  appendView();\n\n  equal(view.$().prop('value'), \"test\", \"value is defined\");\n\n  Ember.run(function() {\n    view.set('value', undefined);\n  });\n\n  equal(!!view.$().prop('value'), false, \"value is not defined\");\n});\n\ntest(\"attributeBindings should not fail if view has been removed\", function(){\n  Ember.run(function(){\n    view = Ember.View.create({\n      attributeBindings: ['checked'],\n      checked: true\n    });\n  });\n  Ember.run(function(){\n    view.createElement();\n  });\n  var error;\n  try {\n    Ember.run(function(){\n      Ember.changeProperties(function(){\n        view.set('checked', false);\n        view.remove();\n      });\n    });\n  } catch(e) {\n    error = e;\n  }\n  ok(!error, error);\n});\n\ntest(\"attributeBindings should not fail if view has been destroyed\", function(){\n  Ember.run(function(){\n    view = Ember.View.create({\n      attributeBindings: ['checked'],\n      checked: true\n    });\n  });\n  Ember.run(function(){\n    view.createElement();\n  });\n  var error;\n  try {\n    Ember.run(function(){\n      Ember.changeProperties(function(){\n        view.set('checked', false);\n        view.destroy();\n      });\n    });\n  } catch(e) {\n    error = e;\n  }\n  ok(!error, error);\n});\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/attribute_bindings_test");minispade.register('ember-views/~tests/views/view/child_views_test', "(function() {(function() {\n  var parentView, childView, childViews;\n  var get = Ember.get;\n\n  module('tests/views/view/child_views_tests.js', {\n    setup: function() {\n      parentView = Ember.View.create({\n        render: function(buffer) {\n          buffer.push('Em');\n          this.appendChild(childView);\n        }\n      });\n\n      childView = Ember.View.create({\n        template: function() { return 'ber'; }\n      });\n    },\n\n    teardown: function() {\n      Ember.run(function(){\n        parentView.destroy();\n        childView.destroy();\n      });\n\n      childViews = null;\n    }\n  });\n\n  // no parent element, buffer, no element\n  // parent element\n\n  // no parent element, no buffer, no element\n  test(\"should render an inserted child view when the child is inserted before a DOM element is created\", function() {\n    Ember.run(function() {\n      parentView.append();\n    });\n\n    equal(parentView.$().text(), 'Ember', 'renders the child view after the parent view');\n  });\n\n  test(\"should not duplicate childViews when rerendering in buffer\", function() {\n\n    var Inner = Ember.View.extend({\n      template: function() { return ''; }\n    });\n\n    var Inner2 = Ember.View.extend({\n      template: function() { return ''; }\n    });\n\n    var Middle = Ember.View.extend({\n      render: function(buffer) {\n        this.appendChild(Inner);\n        this.appendChild(Inner2);\n      }\n    });\n\n    var outer = Ember.View.create({\n      render: function(buffer) {\n        this.middle = this.appendChild(Middle);\n      }\n    });\n\n    Ember.run(function() {\n      outer.renderToBuffer();\n    });\n\n    equal(outer.get('middle.childViews.length'), 2, 'precond middle has 2 child views rendered to buffer');\n\n    raises(function() {\n      Ember.run(function() {\n        outer.middle.rerender();\n      });\n    }, /Something you did caused a view to re-render after it rendered but before it was inserted into the DOM./);\n\n    equal(outer.get('middle.childViews.length'), 2, 'middle has 2 child views rendered to buffer');\n\n    Ember.run(function() {\n      outer.destroy();\n    });\n  });\n\n})();\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/child_views_test");minispade.register('ember-views/~tests/views/view/class_name_bindings_test', "(function() {var set = Ember.set, get = Ember.get, view;\n\nmodule(\"Ember.View - Class Name Bindings\", {\n  teardown: function() {\n    Ember.run(function() {\n      view.destroy();\n    });\n  }\n});\n\ntest(\"should apply bound class names to the element\", function() {\n  view = Ember.View.create({\n    classNameBindings: ['priority', 'isUrgent', 'isClassified:classified',\n                        'canIgnore', 'messages.count', 'messages.resent:is-resent',\n                        'isNumber:is-number', 'isFalsy::is-falsy', 'isTruthy::is-not-truthy',\n                        'isEnabled:enabled:disabled'],\n\n    priority: 'high',\n    isUrgent: true,\n    isClassified: true,\n    canIgnore: false,\n    isNumber: 5,\n    isFalsy: 0,\n    isTruthy: 'abc',\n    isEnabled: true,\n\n    messages: {\n      count: 'five-messages',\n      resent: true\n    }\n  });\n\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  ok(view.$().hasClass('high'), \"adds string values as class name\");\n  ok(view.$().hasClass('is-urgent'), \"adds true Boolean values by dasherizing\");\n  ok(view.$().hasClass('classified'), \"supports customizing class name for Boolean values\");\n  ok(view.$().hasClass('five-messages'), \"supports paths in bindings\");\n  ok(view.$().hasClass('is-resent'), \"supports customing class name for paths\");\n  ok(view.$().hasClass('is-number'), \"supports colon syntax with truthy properties\");\n  ok(view.$().hasClass('is-falsy'), \"supports colon syntax with falsy properties\");\n  ok(!view.$().hasClass('abc'), \"does not add values as classes when falsy classes have been specified\");\n  ok(!view.$().hasClass('is-not-truthy'), \"does not add falsy classes when values are truthy\");\n  ok(!view.$().hasClass('can-ignore'), \"does not add false Boolean values as class\");\n  ok(view.$().hasClass('enabled'), \"supports customizing class name for Boolean values with negation\");\n  ok(!view.$().hasClass('disabled'), \"does not add class name for negated binding\");\n});\n\ntest(\"should add, remove, or change class names if changed after element is created\", function() {\n  view = Ember.View.create({\n    classNameBindings: ['priority', 'isUrgent', 'isClassified:classified',\n                        'canIgnore', 'messages.count', 'messages.resent:is-resent',\n                        'isEnabled:enabled:disabled'],\n\n    priority: 'high',\n    isUrgent: true,\n    isClassified: true,\n    canIgnore: false,\n    isEnabled: true,\n\n    messages: Ember.Object.create({\n      count: 'five-messages',\n      resent: false\n    })\n  });\n\n  Ember.run(function(){\n    view.createElement();\n    set(view, 'priority', 'orange');\n    set(view, 'isUrgent', false);\n    set(view, 'canIgnore', true);\n    set(view, 'isEnabled', false);\n    set(view, 'messages.count', 'six-messages');\n    set(view, 'messages.resent', true );\n  });\n\n  ok(view.$().hasClass('orange'), \"updates string values\");\n  ok(!view.$().hasClass('high'), \"removes old string value\");\n\n  ok(!view.$().hasClass('is-urgent', \"removes dasherized class when changed from true to false\"));\n  ok(view.$().hasClass('can-ignore'), \"adds dasherized class when changed from false to true\");\n\n  ok(view.$().hasClass('six-messages'), \"adds new value when path changes\");\n  ok(!view.$().hasClass('five-messages'), \"removes old value when path changes\");\n\n  ok(view.$().hasClass('is-resent'), \"adds customized class name when path changes\");\n\n  ok(!view.$().hasClass('enabled'), \"updates class name for negated binding\");\n  ok(view.$().hasClass('disabled'), \"adds negated class name for negated binding\");\n});\n\ntest(\":: class name syntax works with an empty true class\", function() {\n  view = Ember.View.create({\n    isEnabled: false,\n    classNameBindings: ['isEnabled::not-enabled']\n  });\n\n  Ember.run(function(){ view.createElement(); });\n\n  equal(view.$().attr('class'), 'ember-view not-enabled', \"false class is rendered when property is false\");\n\n  Ember.run(function(){ view.set('isEnabled', true); });\n\n  equal(view.$().attr('class'), 'ember-view', \"no class is added when property is true and the class is empty\");\n});\n\ntest(\"classNames should not be duplicated on rerender\", function(){\n  Ember.run(function(){\n    view = Ember.View.create({\n      classNameBindings: ['priority'],\n      priority: 'high'\n    });\n  });\n\n\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  equal(view.$().attr('class'), 'ember-view high');\n\n  Ember.run(function(){\n    view.rerender();\n  });\n\n  equal(view.$().attr('class'), 'ember-view high');\n});\n\ntest(\"classNameBindings should work when the binding property is updated and the view has been removed of the DOM\", function(){\n  Ember.run(function(){\n    view = Ember.View.create({\n      classNameBindings: ['priority'],\n      priority: 'high'\n    });\n  });\n\n\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  equal(view.$().attr('class'), 'ember-view high');\n\n  Ember.run(function(){\n    view.remove();\n  });\n\n  view.set('priority', 'low');\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  equal(view.$().attr('class'), 'ember-view low');\n\n});\n\ntest(\"classNames removed by a classNameBindings observer should not re-appear on rerender\", function(){\n  view = Ember.View.create({\n    classNameBindings: ['isUrgent'],\n    isUrgent: true\n  });\n\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  equal(view.$().attr('class'), 'ember-view is-urgent');\n\n  Ember.run(function(){\n    view.set('isUrgent', false);\n  });\n\n  equal(view.$().attr('class'), 'ember-view');\n\n  Ember.run(function(){\n    view.rerender();\n  });\n\n  equal(view.$().attr('class'), 'ember-view');\n});\n\ntest(\"classNameBindings lifecycle test\", function(){\n  Ember.run(function(){\n    view = Ember.View.create({\n      classNameBindings: ['priority'],\n      priority: 'high'\n    });\n  });\n\n  equal(Ember.isWatching(view, 'priority'), false);\n\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  equal(view.$().attr('class'), 'ember-view high');\n  equal(Ember.isWatching(view, 'priority'), true);\n\n  Ember.run(function(){\n    view.remove();\n    view.set('priority', 'low');\n  });\n\n  equal(Ember.isWatching(view, 'priority'), false);\n});\n\ntest(\"classNameBindings should not fail if view has been removed\", function(){\n  Ember.run(function(){\n    view = Ember.View.create({\n      classNameBindings: ['priority'],\n      priority: 'high'\n    });\n  });\n  Ember.run(function(){\n    view.createElement();\n  });\n  var error;\n  try {\n    Ember.run(function(){\n      Ember.changeProperties(function(){\n        view.set('priority', 'low');\n        view.remove();\n      });\n    });\n  } catch(e) {\n    error = e;\n  }\n  ok(!error, error);\n});\n\ntest(\"classNameBindings should not fail if view has been destroyed\", function(){\n  Ember.run(function(){\n    view = Ember.View.create({\n      classNameBindings: ['priority'],\n      priority: 'high'\n    });\n  });\n  Ember.run(function(){\n    view.createElement();\n  });\n  var error;\n  try {\n    Ember.run(function(){\n      Ember.changeProperties(function(){\n        view.set('priority', 'low');\n        view.destroy();\n      });\n    });\n  } catch(e) {\n    error = e;\n  }\n  ok(!error, error);\n});\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/class_name_bindings_test");minispade.register('ember-views/~tests/views/view/class_string_for_value_test', "(function() {module(\"Ember.View - _classStringForValue\");\n\nvar cSFV = Ember.View._classStringForValue;\n\ntest(\"returns dasherized version of last path part if value is true\", function() {\n  equal(cSFV(\"propertyName\", true), \"property-name\", \"class is dasherized\");\n  equal(cSFV(\"content.propertyName\", true), \"property-name\", \"class is dasherized\");\n});\n\ntest(\"returns className if value is true and className is specified\", function() {\n  equal(cSFV(\"propertyName\", true, \"truthyClass\"), \"truthyClass\", \"returns className if given\");\n  equal(cSFV(\"content.propertyName\", true, \"truthyClass\"), \"truthyClass\", \"returns className if given\");\n});\n\ntest(\"returns falsyClassName if value is false and falsyClassName is specified\", function() {\n  equal(cSFV(\"propertyName\", false, \"truthyClass\", \"falsyClass\"), \"falsyClass\", \"returns falsyClassName if given\");\n  equal(cSFV(\"content.propertyName\", false, \"truthyClass\", \"falsyClass\"), \"falsyClass\", \"returns falsyClassName if given\");\n});\n\ntest(\"returns null if value is false and falsyClassName is not specified\", function() {\n  equal(cSFV(\"propertyName\", false, \"truthyClass\"), null, \"returns null if falsyClassName is not specified\");\n  equal(cSFV(\"content.propertyName\", false, \"truthyClass\"), null, \"returns null if falsyClassName is not specified\");\n});\n\ntest(\"returns null if value is false\", function() {\n  equal(cSFV(\"propertyName\", false), null, \"returns null if value is false\");\n  equal(cSFV(\"content.propertyName\", false), null, \"returns null if value is false\");\n});\n\ntest(\"returns null if value is true and className is not specified and falsyClassName is specified\", function() {\n  equal(cSFV(\"propertyName\", true, undefined, \"falsyClassName\"), null, \"returns null if value is true\");\n  equal(cSFV(\"content.propertyName\", true, undefined, \"falsyClassName\"), null, \"returns null if value is true\");\n});\n\ntest(\"returns the value if the value is truthy\", function() {\n  equal(cSFV(\"propertyName\", \"myString\"), \"myString\", \"returns value if the value is truthy\");\n  equal(cSFV(\"content.propertyName\", \"myString\"), \"myString\", \"returns value if the value is truthy\");\n\n  equal(cSFV(\"propertyName\", \"123\"), 123, \"returns value if the value is truthy\");\n  equal(cSFV(\"content.propertyName\", 123), 123, \"returns value if the value is truthy\");\n});\n})();\n//@ sourceURL=ember-views/~tests/views/view/class_string_for_value_test");minispade.register('ember-views/~tests/views/view/context_test', "(function() {module(\"Ember.View - context property\");\n\ntest(\"setting a controller on an inner view should change it context\", function() {\n  var App = {};\n  var a = { name: 'a' };\n  var b = { name: 'b' };\n\n  var innerView = Ember.View.create();\n  var middleView = Ember.ContainerView.create();\n  var outerView = App.outerView = Ember.ContainerView.create({\n    controller: a\n  });\n\n  Ember.run(function() {\n    outerView.appendTo('#qunit-fixture');\n  });\n\n  Ember.run(function () {\n    outerView.set('currentView', middleView);\n  });\n\n  Ember.run(function () {\n    innerView.set('controller', b);\n    middleView.set('currentView', innerView);\n  });\n\n  // assert\n  equal(outerView.get('context'), a, 'outer context correct');\n  equal(middleView.get('context'), a, 'middle context correct');\n  equal(innerView.get('context'), b, 'inner context correct');\n\n  Ember.run(function() {\n    innerView.destroy();\n    middleView.destroy();\n    outerView.destroy();\n  });\n});\n\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/context_test");minispade.register('ember-views/~tests/views/view/controller_test', "(function() {module(\"Ember.View - controller property\");\n\ntest(\"controller property should be inherited from nearest ancestor with controller\", function() {\n  var grandparent = Ember.ContainerView.create();\n  var parent = Ember.ContainerView.create();\n  var child = Ember.ContainerView.create();\n  var grandchild = Ember.ContainerView.create();\n\n  var grandparentController = {};\n  var parentController = {};\n\n  Ember.run(function() {\n    grandparent.set('controller', grandparentController);\n    parent.set('controller', parentController);\n\n    grandparent.pushObject(parent);\n    parent.pushObject(child);\n\n    strictEqual(grandparent.get('controller'), grandparentController);\n    strictEqual(parent.get('controller'), parentController);\n    strictEqual(child.get('controller'), parentController);\n    strictEqual(grandchild.get('controller'), null);\n\n    child.pushObject(grandchild);\n    strictEqual(grandchild.get('controller'), parentController);\n\n    var newController = {};\n    parent.set('controller', newController);\n    strictEqual(parent.get('controller'), newController);\n    strictEqual(child.get('controller'), newController);\n    strictEqual(grandchild.get('controller'), newController);\n  });\n\n  Ember.run(function() {\n    grandparent.destroy();\n    parent.destroy();\n    child.destroy();\n    grandchild.destroy();\n  });\n});\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/controller_test");minispade.register('ember-views/~tests/views/view/create_child_view_test', "(function() {var set = Ember.set, get = Ember.get;\n\nvar view, myViewClass, newView;\n\nmodule(\"Ember.View#createChildView\", {\n  setup: function() {\n    view = Ember.View.create();\n    myViewClass = Ember.View.extend({ isMyView: true, foo: 'bar' });\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      view.destroy();\n      newView.destroy();\n    });\n  }\n});\n\ntest(\"should create view from class with any passed attributes\", function() {\n  var attrs = { foo: \"baz\" };\n  newView = view.createChildView(myViewClass, attrs);\n  ok(get(newView, 'isMyView'), 'newView is instance of myView');\n  equal(get(newView, 'foo'), 'baz', 'view did get custom attributes');\n  ok(!attrs.parentView, \"the original attributes hash was not mutated\");\n});\n\ntest(\"should set newView.parentView to receiver\", function() {\n  newView = view.createChildView(myViewClass) ;\n  equal(get(newView, 'parentView'), view, 'newView.parentView == view');\n});\n\ntest(\"should create property on parentView to a childView instance if provided a viewName\", function() {\n  var attrs = { viewName: \"someChildView\" };\n  newView = view.createChildView(myViewClass, attrs);\n\n  equal(get(view, 'someChildView'), newView);\n});\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/create_child_view_test");minispade.register('ember-views/~tests/views/view/create_element_test', "(function() {var set = Ember.set, get = Ember.get, view;\n\nmodule(\"Ember.View#createElement\", {\n  teardown: function() {\n    Ember.run(function() {\n      view.destroy();\n    });\n  }\n});\n\ntest(\"returns the receiver\", function() {\n  var ret;\n\n  view = Ember.View.create();\n\n  Ember.run(function(){\n    ret = view.createElement();\n  });\n\n  equal(ret, view, 'returns receiver');\n});\n\ntest(\"calls render and turns resultant string into element\", function() {\n  view = Ember.View.create({\n    tagName: 'span',\n\n    render: function(buffer) {\n      buffer.push(\"foo\");\n    }\n  });\n\n  equal(get(view, 'element'), null, 'precondition - has no element');\n  Ember.run(function(){\n    view.createElement();\n  });\n\n\n  var elem = get(view, 'element');\n  ok(elem, 'has element now');\n  equal(elem.innerHTML, 'foo', 'has innerHTML from context');\n  equal(elem.tagName.toString().toLowerCase(), 'span', 'has tagName from view');\n});\n\ntest(\"generated element include HTML from child views as well\", function() {\n  view = Ember.ContainerView.create({\n    childViews: [ Ember.View.create({ elementId: \"foo\" })]\n  });\n\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  ok(view.$('#foo').length, 'has element with child elementId');\n});\n\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/create_element_test");minispade.register('ember-views/~tests/views/view/destroy_element_test', "(function() {var set = Ember.set, get = Ember.get, view;\n\nmodule(\"Ember.View#destroyElement\", {\n  teardown: function() {\n    Ember.run(function() {\n      view.destroy();\n    });\n  }\n});\n\ntest(\"if it has no element, does nothing\", function() {\n  var callCount = 0;\n  view = Ember.View.create({\n    willDestroyElement: function() { callCount++; }\n  });\n\n  ok(!get(view, 'element'), 'precond - does NOT have element');\n\n  Ember.run(function() {\n    view.destroyElement();\n  });\n\n  equal(callCount, 0, 'did not invoke callback');\n});\n\ntest(\"if it has a element, calls willDestroyElement on receiver and child views then deletes the element\", function() {\n  var parentCount = 0, childCount = 0;\n\n  view = Ember.ContainerView.create({\n    willDestroyElement: function() { parentCount++; },\n    childViews: [Ember.ContainerView.extend({\n      // no willDestroyElement here... make sure no errors are thrown\n      childViews: [Ember.View.extend({\n        willDestroyElement: function() { childCount++; }\n      })]\n    })]\n  });\n\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  ok(get(view, 'element'), 'precond - view has element');\n\n  Ember.run(function() {\n    view.destroyElement();\n  });\n\n  equal(parentCount, 1, 'invoked destroy element on the parent');\n  equal(childCount, 1, 'invoked destroy element on the child');\n  ok(!get(view, 'element'), 'view no longer has element');\n  ok(!get(get(view, 'childViews').objectAt(0), 'element'), 'child no longer has an element');\n});\n\ntest(\"returns receiver\", function() {\n  var ret;\n  view = Ember.View.create();\n\n  Ember.run(function(){\n    view.createElement();\n    ret = view.destroyElement();\n  });\n\n  equal(ret, view, 'returns receiver');\n});\n\ntest(\"removes element from parentNode if in DOM\", function() {\n  view = Ember.View.create();\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  var parent = view.$().parent();\n\n  ok(get(view, 'element'), 'precond - has element');\n\n  Ember.run(function() {\n    view.destroyElement();\n  });\n\n  equal(view.$(), undefined, 'view has no selector');\n  ok(!parent.find('#'+view.get('elementId')).length, 'element no longer in parent node');\n});\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/destroy_element_test");minispade.register('ember-views/~tests/views/view/destroy_test', "(function() {var set = Ember.set, get = Ember.get;\n\nmodule(\"Ember.View#destroy\");\n\ntest(\"should teardown viewName on parentView when childView is destroyed\", function() {\n  var viewName = \"someChildView\",\n      parentView = Ember.View.create(),\n      childView = parentView.createChildView(Ember.View, {viewName: viewName});\n\n  equal(get(parentView, viewName), childView, \"Precond - child view was registered on parent\");\n\n  Ember.run(function(){\n    childView.destroy();\n  });\n\n  equal(get(parentView, viewName), null, \"viewName reference was removed on parent\");\n\n  Ember.run(function() {\n    parentView.destroy();\n  });\n});\n\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/destroy_test");minispade.register('ember-views/~tests/views/view/element_test', "(function() {var set = Ember.set, get = Ember.get;\n\nvar parentView, child, parentDom, childDom, view;\n\nmodule(\"Ember.View#element\", {\n  teardown: function() {\n    Ember.run(function() {\n      if (parentView) { parentView.destroy(); }\n      view.destroy();\n    });\n  }\n});\n\ntest(\"returns null if the view has no element and no parent view\", function() {\n  view = Ember.View.create() ;\n  equal(get(view, 'parentView'), null, 'precond - has no parentView');\n  equal(get(view, 'element'), null, 'has no element');\n});\n\ntest(\"returns null if the view has no element and parent view has no element\", function() {\n  parentView = Ember.ContainerView.create({\n    childViews: [ Ember.View.extend() ]\n  });\n  view = get(parentView, 'childViews').objectAt(0);\n\n  equal(get(view, 'parentView'), parentView, 'precond - has parent view');\n  equal(get(parentView, 'element'), null, 'parentView has no element');\n  equal(get(view, 'element'), null, ' has no element');\n});\n\ntest(\"returns element if you set the value\", function() {\n  view = Ember.View.create();\n  equal(get(view, 'element'), null, 'precond- has no element');\n\n  var dom = document.createElement('div');\n  set(view, 'element', dom);\n\n  equal(get(view, 'element'), dom, 'now has set element');\n});\n\n\nmodule(\"Ember.View#element - autodiscovery\", {\n  setup: function() {\n    parentView = Ember.ContainerView.create({\n      childViews: [ Ember.View.extend({\n        elementId: 'child-view'\n      }) ]\n    });\n\n    child = get(parentView, 'childViews').objectAt(0);\n\n    // setup parent/child dom\n    parentDom = Ember.$(\"<div><div id='child-view'></div></div>\")[0];\n\n    // set parent element...\n    set(parentView, 'element', parentDom);\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      parentView.destroy();\n      if (view) { view.destroy(); }\n    });\n    parentView = child = parentDom = childDom = null ;\n  }\n});\n\ntest(\"discovers element if has no element but parent view does have element\", function() {\n  equal(get(parentView, 'element'), parentDom, 'precond - parent has element');\n  ok(parentDom.firstChild, 'precond - parentDom has first child');\n\n  equal(child.$().attr('id'), 'child-view', 'view discovered child');\n});\n\ntest(\"should not allow the elementId to be changed after inserted\", function() {\n  view = Ember.View.create({\n    elementId: 'one'\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  raises(function() {\n    view.set('elementId', 'two');\n  }, \"raises elementId changed exception\");\n\n  equal(view.get('elementId'), 'one', 'elementId is still \"one\"');\n});\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/element_test");minispade.register('ember-views/~tests/views/view/evented_test', "(function() {var set = Ember.set, get = Ember.get, view;\n\nmodule(\"Ember.View evented helpers\", {\n  teardown: function() {\n    Ember.run(function() {\n      view.destroy();\n    });\n  }\n});\n\ntest(\"fire should call method sharing event name if it exists on the view\", function() {\n  var eventFired = false;\n\n  view = Ember.View.create({\n    fireMyEvent: function() {\n      this.trigger('myEvent');\n    },\n\n    myEvent: function() {\n      eventFired = true;\n    }\n  });\n\n  Ember.run(function() {\n    view.fireMyEvent();\n  });\n\n  equal(eventFired, true, \"fired the view method sharing the event name\");\n});\n\ntest(\"fire does not require a view method with the same name\", function() {\n  var eventFired = false;\n\n  view = Ember.View.create({\n    fireMyEvent: function() {\n      this.trigger('myEvent');\n    }\n  });\n\n  var listenObject = Ember.Object.create({\n    onMyEvent: function() {\n      eventFired = true;\n    }\n  });\n\n  view.on('myEvent', listenObject, 'onMyEvent');\n\n  Ember.run(function() {\n    view.fireMyEvent();\n  });\n\n  equal(eventFired, true, \"fired the event without a view method sharing its name\");\n\n  Ember.run(function() {\n    listenObject.destroy();\n  });\n});\n\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/evented_test");minispade.register('ember-views/~tests/views/view/init_test', "(function() {/*global TestApp:true*/\nvar set = Ember.set, get = Ember.get;\n\nvar originalLookup = Ember.lookup, lookup, view;\n\nmodule(\"Ember.View.create\", {\n  setup: function() {\n    Ember.lookup = lookup = {};\n  },\n  teardown: function() {\n    Ember.run(function() {\n      view.destroy();\n    });\n\n    Ember.lookup = originalLookup;\n  }\n});\n\ntest(\"registers view in the global views hash using layerId for event targeted\", function() {\n  view = Ember.View.create();\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n  equal(Ember.View.views[get(view, 'elementId')], view, 'registers view');\n});\n\ntest(\"registers itself with a controller if the viewController property is set\", function() {\n  lookup.TestApp = {};\n  lookup.TestApp.fooController = Ember.Object.create();\n\n  view = Ember.View.create({\n    viewController: 'TestApp.fooController'\n  });\n\n  equal(lookup.TestApp.fooController.get('view'), view, \"sets the view property of the controller\");\n});\n\nmodule(\"Ember.View.createWithMixins\");\n\ntest(\"should warn if a non-array is used for classNames\", function() {\n  raises(function() {\n    Ember.View.createWithMixins({\n      elementId: 'test',\n      classNames: Ember.computed(function() {\n        return ['className'];\n      }).volatile()\n    });\n  }, /Only arrays are allowed/i, 'should warn that an array was not used');\n});\n\ntest(\"should warn if a non-array is used for classNamesBindings\", function() {\n  raises(function() {\n    Ember.View.createWithMixins({\n      elementId: 'test',\n      classNameBindings: Ember.computed(function() {\n        return ['className'];\n      }).volatile()\n    });\n  }, /Only arrays are allowed/i, 'should warn that an array was not used');\n});\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/init_test");minispade.register('ember-views/~tests/views/view/is_visible_test', "(function() {var get = Ember.get, set = Ember.set;\n\nvar View, view, parentBecameVisible, childBecameVisible, grandchildBecameVisible;\nvar parentBecameHidden, childBecameHidden, grandchildBecameHidden;\n\nmodule(\"Ember.View#isVisible\", {\n  setup: function() {\n    parentBecameVisible=0;\n    childBecameVisible=0;\n    grandchildBecameVisible=0;\n    parentBecameHidden=0;\n    childBecameHidden=0;\n    grandchildBecameHidden=0;\n\n    View = Ember.ContainerView.extend({\n      childViews: ['child'],\n      becameVisible: function() { parentBecameVisible++; },\n      becameHidden: function() { parentBecameHidden++; },\n\n      child: Ember.ContainerView.extend({\n        childViews: ['grandchild'],\n        becameVisible: function() { childBecameVisible++; },\n        becameHidden: function() { childBecameHidden++; },\n\n        grandchild: Ember.View.extend({\n          template: function() { return \"seems weird bro\"; },\n          becameVisible: function() { grandchildBecameVisible++; },\n          becameHidden: function() { grandchildBecameHidden++; }\n        })\n      })\n    });\n  },\n\n  teardown: function() {\n    if (view) {\n      Ember.run(function(){ view.destroy(); });\n    }\n  }\n});\n\ntest(\"should hide views when isVisible is false\", function() {\n  view = Ember.View.create({\n    isVisible: false\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  ok(view.$().is(':hidden'), \"the view is hidden\");\n\n  set(view, 'isVisible', true);\n  ok(view.$().is(':visible'), \"the view is visible\");\n  Ember.run(function() {\n    view.remove();\n  });\n});\n\ntest(\"should hide element if isVisible is false before element is created\", function() {\n  view = Ember.View.create({\n    isVisible: false\n  });\n\n  ok(!get(view, 'isVisible'), \"precond - view is not visible\");\n\n  set(view, 'template', function() { return \"foo\"; });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  ok(view.$().is(':hidden'), \"should be hidden\");\n\n  Ember.run(function() {\n    view.remove();\n  });\n\n  set(view, 'isVisible', true);\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  ok(view.$().is(':visible'), \"view should be visible\");\n\n  Ember.run(function() {\n    view.remove();\n  });\n});\n\ntest(\"view should be notified after isVisible is set to false and the element has been hidden\", function() {\n  Ember.run(function(){\n    view = View.create({ isVisible: false });\n    view.append();\n  });\n\n  ok(view.$().is(':hidden'), \"precond - view is hidden when appended\");\n\n  Ember.run(function() {\n    view.set('isVisible', true);\n  });\n\n  ok(view.$().is(':visible'), \"precond - view is now visible\");\n  equal(parentBecameVisible, 1);\n  equal(childBecameVisible, 1);\n  equal(grandchildBecameVisible, 1);\n});\n\ntest(\"view should be notified after isVisible is set to false and the element has been hidden\", function() {\n  view = View.create({ isVisible: true });\n  var childView = view.get('childViews').objectAt(0);\n  var grandchildView = childView.get('childViews').objectAt(0);\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  ok(view.$().is(':visible'), \"precond - view is visible when appended\");\n\n  Ember.run(function() {\n    childView.set('isVisible', false);\n  });\n\n  ok(childView.$().is(':hidden'), \"precond - view is now hidden\");\n\n  equal(childBecameHidden, 1);\n  equal(grandchildBecameHidden, 1);\n});\n\ntest(\"view should be notified after isVisible is set to true and the element has been shown\", function() {\n  view = View.create({ isVisible: false });\n  var childView = view.get('childViews').objectAt(0);\n  var grandchildView = childView.get('childViews').objectAt(0);\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  ok(view.$().is(':hidden'), \"precond - view is hidden when appended\");\n\n  Ember.run(function() {\n    view.set('isVisible', true);\n  });\n\n  ok(view.$().is(':visible'), \"precond - view is now visible\");\n\n  equal(parentBecameVisible, 1);\n  equal(childBecameVisible, 1);\n  equal(grandchildBecameVisible, 1);\n});\n\ntest(\"if a view descends from a hidden view, making isVisible true should not trigger becameVisible\", function() {\n  view = View.create({ isVisible: true });\n  var childView = view.get('childViews').objectAt(0);\n  var grandchildView = childView.get('childViews').objectAt(0);\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  ok(view.$().is(':visible'), \"precond - view is visible when appended\");\n\n  Ember.run(function() {\n    childView.set('isVisible', false);\n  });\n\n  Ember.run(function() {\n    view.set('isVisible', false);\n  });\n\n  childBecameVisible = 0;\n  grandchildBecameVisible = 0;\n\n  Ember.run(function() {\n    childView.set('isVisible', true);\n  });\n\n  equal(childBecameVisible, 0, \"the child did not become visible\");\n  equal(grandchildBecameVisible, 0, \"the grandchild did not become visible\");\n});\n\ntest(\"if a child view becomes visible while its parent is hidden, if its parent later becomes visible, it receives a becameVisible callback\", function() {\n  view = View.create({ isVisible: false });\n  var childView = view.get('childViews').objectAt(0);\n  var grandchildView = childView.get('childViews').objectAt(0);\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  ok(view.$().is(':hidden'), \"precond - view is hidden when appended\");\n\n  Ember.run(function() {\n    childView.set('isVisible', true);\n  });\n\n  equal(childBecameVisible, 0, \"child did not become visible since parent is hidden\");\n  equal(grandchildBecameVisible, 0, \"grandchild did not become visible since parent is hidden\");\n\n  Ember.run(function() {\n    view.set('isVisible', true);\n  });\n\n  equal(parentBecameVisible, 1);\n  equal(childBecameVisible, 1);\n  equal(grandchildBecameVisible, 1);\n});\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/is_visible_test");minispade.register('ember-views/~tests/views/view/jquery_test', "(function() {var set = Ember.set, get = Ember.get;\n\nvar view ;\nmodule(\"Ember.View#$\", {\n  setup: function() {\n    view = Ember.View.extend({\n      render: function(context, firstTime) {\n        context.push('<span></span>');\n      }\n    }).create();\n\n    Ember.run(function() {\n      view.append();\n    });\n  },\n\n  teardown: function() {\n    Ember.run(function(){\n      view.destroy();\n    });\n  }\n});\n\ntest(\"returns undefined if no element\", function() {\n  var view = Ember.View.create();\n  ok(!get(view, 'element'), 'precond - should have no element');\n  equal(view.$(), undefined, 'should return undefined');\n  equal(view.$('span'), undefined, 'should undefined if filter passed');\n\n  Ember.run(function() {\n    view.destroy();\n  });\n});\n\ntest(\"returns jQuery object selecting element if provided\", function() {\n  ok(get(view, 'element'), 'precond - should have element');\n\n  var jquery = view.$();\n  equal(jquery.length, 1, 'view.$() should have one element');\n  equal(jquery[0], get(view, 'element'), 'element should be element');\n});\n\ntest(\"returns jQuery object selecting element inside element if provided\", function() {\n  ok(get(view, 'element'), 'precond - should have element');\n\n  var jquery = view.$('span');\n  equal(jquery.length, 1, 'view.$() should have one element');\n  equal(jquery[0].parentNode, get(view, 'element'), 'element should be in element');\n});\n\ntest(\"returns empty jQuery object if filter passed that does not match item in parent\", function() {\n  ok(get(view, 'element'), 'precond - should have element');\n\n  var jquery = view.$('body'); // would normally work if not scoped to view\n  equal(jquery.length, 0, 'view.$(body) should have no elements');\n});\n\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/jquery_test");minispade.register('ember-views/~tests/views/view/layout_test', "(function() {var set = Ember.set, get = Ember.get, container, view;\n\nmodule(\"Ember.View - Layout Functionality\", {\n  setup: function() {\n    container = new Ember.Container();\n    container.optionsForType('template', { instantiate: false });\n  },\n  teardown: function() {\n    Ember.run(function() {\n      view.destroy();\n    });\n  }\n});\n\ntest(\"should call the function of the associated layout\", function() {\n  var templateCalled = 0, layoutCalled = 0;\n\n  container.register('template:template', function() { templateCalled++; });\n  container.register('template:layout', function() { layoutCalled++; });\n\n  view = Ember.View.create({\n    container: container,\n    layoutName: 'layout',\n    templateName: 'template'\n  });\n\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  equal(templateCalled, 0, \"template is not called when layout is present\");\n  equal(layoutCalled, 1, \"layout is called when layout is present\");\n});\n\ntest(\"should call the function of the associated template with itself as the context\", function() {\n  container.register('template:testTemplate', function(dataSource) {\n    return \"<h1 id='twas-called'>template was called for \" + get(dataSource, 'personName') + \"</h1>\";\n  });\n\n  view = Ember.View.create({\n    container: container,\n    layoutName: 'testTemplate',\n\n    context: {\n      personName: \"Tom DAAAALE\"\n    }\n  });\n\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  equal(\"template was called for Tom DAAAALE\", view.$('#twas-called').text(), \"the named template was called with the view as the data source\");\n});\n\ntest(\"should fall back to defaultTemplate if neither template nor templateName are provided\", function() {\n  var View;\n\n  View = Ember.View.extend({\n    defaultLayout: function(dataSource) { return \"<h1 id='twas-called'>template was called for \" + get(dataSource, 'personName') + \"</h1>\"; }\n  });\n\n  view = View.create({\n    context: {\n      personName: \"Tom DAAAALE\"\n    }\n  });\n\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  equal(\"template was called for Tom DAAAALE\", view.$('#twas-called').text(), \"the named template was called with the view as the data source\");\n});\n\ntest(\"should not use defaultLayout if layout is provided\", function() {\n  var View;\n\n  View = Ember.View.extend({\n    layout:  function() { return \"foo\"; },\n    defaultLayout: function(dataSource) { return \"<h1 id='twas-called'>template was called for \" + get(dataSource, 'personName') + \"</h1>\"; }\n  });\n\n  view = View.create();\n  Ember.run(function(){\n    view.createElement();\n  });\n\n\n  equal(\"foo\", view.$().text(), \"default layout was not printed\");\n});\n\ntest(\"the template property is available to the layout template\", function() {\n  view = Ember.View.create({\n    template: function(context, options) {\n      options.data.buffer.push(\" derp\");\n    },\n\n    layout: function(context, options) {\n      options.data.buffer.push(\"Herp\");\n      get(options.data.view, 'template')(context, options);\n    }\n  });\n\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  equal(\"Herp derp\", view.$().text(), \"the layout has access to the template\");\n});\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/layout_test");minispade.register('ember-views/~tests/views/view/nearest_of_type_test', "(function() {var set = Ember.set, get = Ember.get, parentView, view;\n\nmodule(\"Ember.View#nearest*\", {\n  teardown: function() {\n    Ember.run(function() {\n      if (parentView) { parentView.destroy(); }\n      if (view) { view.destroy(); }\n    });\n  }\n});\n\n(function() {\n  var Mixin = Ember.Mixin.create({}),\n      Parent = Ember.View.extend(Mixin, {\n        render: function(buffer) {\n          this.appendChild( Ember.View.create() );\n        }\n      });\n\n  test(\"nearestOfType should find the closest view by view class\", function() {\n    var child;\n\n    Ember.run(function() {\n      parentView = Parent.create();\n      parentView.appendTo('#qunit-fixture');\n    });\n\n    child = parentView.get('childViews')[0];\n    equal(child.nearestOfType(Parent), parentView, \"finds closest view in the hierarchy by class\");\n  });\n\n  test(\"nearestOfType should find the closest view by mixin\", function() {\n    var child;\n\n    Ember.run(function() {\n      parentView = Parent.create();\n      parentView.appendTo('#qunit-fixture');\n    });\n\n    child = parentView.get('childViews')[0];\n    equal(child.nearestOfType(Mixin), parentView, \"finds closest view in the hierarchy by class\");\n  });\n\ntest(\"nearestWithProperty should search immediate parent\", function(){\n  var childView;\n\n  view = Ember.View.create({\n    myProp: true,\n\n    render: function(buffer) {\n      this.appendChild(Ember.View.create());\n    }\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  childView = view.get('childViews')[0];\n  equal(childView.nearestWithProperty('myProp'), view);\n\n});\n\n}());\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/nearest_of_type_test");minispade.register('ember-views/~tests/views/view/parse_property_path_test', "(function() {module(\"Ember.View - _parsePropertyPath\");\n\ntest(\"it works with a simple property path\", function() {\n  var parsed = Ember.View._parsePropertyPath(\"simpleProperty\");\n\n  equal(parsed.path, \"simpleProperty\", \"path is parsed correctly\");\n  equal(parsed.className, undefined, \"there is no className\");\n  equal(parsed.falsyClassName, undefined, \"there is no falsyClassName\");\n  equal(parsed.classNames, \"\", \"there is no classNames\");\n});\n\ntest(\"it works with a more complex property path\", function() {\n  var parsed = Ember.View._parsePropertyPath(\"content.simpleProperty\");\n\n  equal(parsed.path, \"content.simpleProperty\", \"path is parsed correctly\");\n  equal(parsed.className, undefined, \"there is no className\");\n  equal(parsed.falsyClassName, undefined, \"there is no falsyClassName\");\n  equal(parsed.classNames, \"\", \"there is no classNames\");\n});\n\ntest(\"className is extracted\", function() {\n  var parsed = Ember.View._parsePropertyPath(\"content.simpleProperty:class\");\n\n  equal(parsed.path, \"content.simpleProperty\", \"path is parsed correctly\");\n  equal(parsed.className, \"class\", \"className is extracted\");\n  equal(parsed.falsyClassName, undefined, \"there is no falsyClassName\");\n  equal(parsed.classNames, \":class\", \"there is a classNames\");\n});\n\ntest(\"falsyClassName is extracted\", function() {\n  var parsed = Ember.View._parsePropertyPath(\"content.simpleProperty:class:falsyClass\");\n\n  equal(parsed.path, \"content.simpleProperty\", \"path is parsed correctly\");\n  equal(parsed.className, \"class\", \"className is extracted\");\n  equal(parsed.falsyClassName, \"falsyClass\", \"falsyClassName is extracted\");\n  equal(parsed.classNames, \":class:falsyClass\", \"there is a classNames\");\n});\n\ntest(\"it works with an empty true class\", function() {\n  var parsed = Ember.View._parsePropertyPath(\"content.simpleProperty::falsyClass\");\n\n  equal(parsed.path, \"content.simpleProperty\", \"path is parsed correctly\");\n  equal(parsed.className, undefined, \"className is undefined\");\n  equal(parsed.falsyClassName, \"falsyClass\", \"falsyClassName is extracted\");\n  equal(parsed.classNames, \"::falsyClass\", \"there is a classNames\");\n});\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/parse_property_path_test");minispade.register('ember-views/~tests/views/view/remove_test', "(function() {var set = Ember.set, get = Ember.get;\nvar indexOf = Ember.EnumerableUtils.indexOf;\n\n// .......................................................\n// removeChild()\n//\n\nvar parentView, child;\nmodule(\"Ember.View#removeChild\", {\n  setup: function() {\n    parentView = Ember.ContainerView.create({ childViews: [Ember.View] });\n    child = get(parentView, 'childViews').objectAt(0);\n  },\n  teardown: function() {\n    Ember.run(function() {\n      parentView.destroy();\n      child.destroy();\n    });\n  }\n});\n\ntest(\"returns receiver\", function() {\n  equal(parentView.removeChild(child), parentView, 'receiver');\n});\n\ntest(\"removes child from parent.childViews array\", function() {\n  ok(indexOf(get(parentView, 'childViews'), child)>=0, 'precond - has child in childViews array before remove');\n  parentView.removeChild(child);\n  ok(indexOf(get(parentView, 'childViews'), child)<0, 'removed child');\n});\n\ntest(\"sets parentView property to null\", function() {\n  ok(get(child, 'parentView'), 'precond - has parentView');\n  parentView.removeChild(child);\n  ok(!get(child, 'parentView'), 'parentView is now null');\n});\n\n// .......................................................\n// removeAllChildren()\n//\nvar view, childViews;\nmodule(\"Ember.View#removeAllChildren\", {\n  setup: function() {\n    view = Ember.ContainerView.create({\n      childViews: [Ember.View, Ember.View, Ember.View]\n    });\n    childViews = view.get('childViews');\n  },\n  teardown: function() {\n    Ember.run(function() {\n      childViews.forEach(function(v){ v.destroy(); });\n      view.destroy();\n    });\n  }\n});\n\ntest(\"removes all child views\", function() {\n  equal(get(view, 'childViews.length'), 3, 'precond - has child views');\n\n  view.removeAllChildren();\n  equal(get(view, 'childViews.length'), 0, 'removed all children');\n});\n\ntest(\"returns receiver\", function() {\n  equal(view.removeAllChildren(), view, 'receiver');\n});\n\n// .......................................................\n// removeFromParent()\n//\nmodule(\"Ember.View#removeFromParent\", {\n  teardown: function() {\n    Ember.run(function() {\n      if (parentView) { parentView.destroy(); }\n      if (child) { child.destroy(); }\n      if (view) { view.destroy(); }\n    });\n  }\n});\n\ntest(\"removes view from parent view\", function() {\n  parentView = Ember.ContainerView.create({ childViews: [Ember.View] });\n  child = get(parentView, 'childViews').objectAt(0);\n  ok(get(child, 'parentView'), 'precond - has parentView');\n\n  Ember.run(function(){\n    parentView.createElement();\n  });\n\n  ok(parentView.$('div').length, \"precond - has a child DOM element\");\n\n  Ember.run(function() {\n    child.removeFromParent();\n  });\n\n  ok(!get(child, 'parentView'), 'no longer has parentView');\n  ok(indexOf(get(parentView, 'childViews'), child)<0, 'no longer in parent childViews');\n  equal(parentView.$('div').length, 0, \"removes DOM element from parent\");\n});\n\ntest(\"returns receiver\", function() {\n  parentView = Ember.ContainerView.create({ childViews: [Ember.View] });\n  child = get(parentView, 'childViews').objectAt(0);\n  var removed = Ember.run(function() {\n    return child.removeFromParent();\n  });\n\n  equal(removed, child, 'receiver');\n});\n\ntest(\"does nothing if not in parentView\", function() {\n  var callCount = 0;\n  child = Ember.View.create();\n\n  // monkey patch for testing...\n  ok(!get(child, 'parentView'), 'precond - has no parent');\n\n  child.removeFromParent();\n\n  Ember.run(function() {\n    child.destroy();\n  });\n});\n\n\ntest(\"the DOM element is gone after doing append and remove in two separate runloops\", function() {\n  view = Ember.View.create();\n  Ember.run(function() {\n    view.append();\n  });\n  Ember.run(function() {\n    view.remove();\n  });\n\n  var viewElem = Ember.$('#'+get(view, 'elementId'));\n  ok(viewElem.length === 0, \"view's element doesn't exist in DOM\");\n});\n\ntest(\"the DOM element is gone after doing append and remove in a single runloop\", function() {\n  view = Ember.View.create();\n  Ember.run(function() {\n    view.append();\n    view.remove();\n  });\n\n  var viewElem = Ember.$('#'+get(view, 'elementId'));\n  ok(viewElem.length === 0, \"view's element doesn't exist in DOM\");\n});\n\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/remove_test");minispade.register('ember-views/~tests/views/view/render_test', "(function() {/*global module test equals context ok same */\n\nvar set = Ember.set, get = Ember.get, view;\n\n// .......................................................\n//  render()\n//\nmodule(\"Ember.View#render\", {\n  teardown: function() {\n    Ember.run(function() {\n      view.destroy();\n    });\n  }\n});\n\ntest(\"default implementation does not render child views\", function() {\n\n  var rendered = 0, updated = 0, parentRendered = 0, parentUpdated = 0 ;\n  view = Ember.ContainerView.createWithMixins({\n    childViews: [\"child\"],\n\n    render: function(buffer) {\n      parentRendered++;\n      this._super(buffer);\n    },\n\n    child: Ember.View.createWithMixins({\n      render: function(buffer) {\n        rendered++;\n        this._super(buffer);\n      }\n    })\n  });\n\n  Ember.run(function(){\n    view.createElement();\n  });\n  equal(rendered, 1, 'rendered the child once');\n  equal(parentRendered, 1);\n  equal(view.$('div').length, 1);\n\n});\n\ntest(\"should invoke renderChildViews if layer is destroyed then re-rendered\", function() {\n\n  var rendered = 0, parentRendered = 0, parentUpdated = 0 ;\n  view = Ember.ContainerView.createWithMixins({\n    childViews: [\"child\"],\n\n    render: function(buffer) {\n      parentRendered++;\n      this._super(buffer);\n    },\n\n    child: Ember.View.createWithMixins({\n      render: function(buffer) {\n        rendered++;\n        this._super(buffer);\n      }\n    })\n  });\n\n  Ember.run(function() {\n    view.append();\n  });\n\n  equal(rendered, 1, 'rendered the child once');\n  equal(parentRendered, 1);\n  equal(view.$('div').length, 1);\n\n  Ember.run(function() {\n    view.rerender();\n  });\n\n  equal(rendered, 2, 'rendered the child twice');\n  equal(parentRendered, 2);\n  equal(view.$('div').length, 1);\n\n  Ember.run(function(){\n    view.destroy();\n  });\n});\n\ntest(\"should render child views with a different tagName\", function() {\n  var rendered = 0, parentRendered = 0, parentUpdated = 0 ;\n\n  view = Ember.ContainerView.create({\n    childViews: [\"child\"],\n\n    child: Ember.View.create({\n      tagName: 'aside'\n    })\n  });\n\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  equal(view.$('aside').length, 1);\n});\n\ntest(\"should add ember-view to views\", function() {\n  view = Ember.View.create();\n\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  ok(view.$().hasClass('ember-view'), \"the view has ember-view\");\n});\n\ntest(\"should not add role attribute unless one is specified\", function() {\n  view = Ember.View.create();\n\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  ok(view.$().attr('role') === undefined, \"does not have a role attribute\");\n});\n\ntest(\"should re-render if the context is changed\", function() {\n  view = Ember.View.create({\n    elementId: 'template-context-test',\n    context: { foo: \"bar\" },\n    render: function(buffer) {\n      var value = get(get(this, 'context'), 'foo');\n      buffer.push(value);\n    }\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  equal(Ember.$('#qunit-fixture #template-context-test').text(), \"bar\", \"precond - renders the view with the initial value\");\n\n  Ember.run(function() {\n    view.set('context', {\n      foo: \"bang baz\"\n    });\n  });\n\n  equal(Ember.$('#qunit-fixture #template-context-test').text(), \"bang baz\", \"re-renders the view with the updated context\");\n});\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/render_test");minispade.register('ember-views/~tests/views/view/replace_in_test', "(function() {var set = Ember.set, get = Ember.get;\n\nvar View, view, willDestroyCalled, childView;\n\nmodule(\"Ember.View - replaceIn()\", {\n  setup: function() {\n    View = Ember.View.extend({});\n  },\n\n  teardown: function() {\n    Ember.run(function(){\n      view.destroy();\n    });\n  }\n});\n\ntest(\"should be added to the specified element when calling replaceIn()\", function() {\n  Ember.$(\"#qunit-fixture\").html('<div id=\"menu\"></div>');\n\n  view = View.create();\n\n  ok(!get(view, 'element'), \"precond - should not have an element\");\n\n  Ember.run(function() {\n    view.replaceIn('#menu');\n  });\n\n  var viewElem = Ember.$('#menu').children();\n  ok(viewElem.length > 0, \"creates and replaces the view's element\");\n});\n\ntest(\"should remove previous elements when calling replaceIn()\", function() {\n  Ember.$(\"#qunit-fixture\").html('<div id=\"menu\"><p>Foo</p></div>');\n  var viewElem = Ember.$('#menu').children();\n\n  view = View.create();\n\n  ok(viewElem.length === 1, \"should have one element\");\n\n  Ember.run(function() {\n    view.replaceIn('#menu');\n  });\n\n  ok(viewElem.length === 1, \"should have one element\");\n\n});\n\nmodule(\"Ember.View - replaceIn() in a view hierarchy\", {\n  setup: function() {\n    View = Ember.ContainerView.extend({\n      childViews: ['child'],\n      child: Ember.View.extend({\n        elementId: 'child'\n      })\n    });\n  },\n\n  teardown: function() {\n    Ember.run(function(){\n      view.destroy();\n    });\n  }\n});\n\ntest(\"should be added to the specified element when calling replaceIn()\", function() {\n  Ember.$(\"#qunit-fixture\").html('<div id=\"menu\"></div>');\n\n  view = View.create();\n\n  ok(!get(view, 'element'), \"precond - should not have an element\");\n\n  Ember.run(function() {\n    view.replaceIn('#menu');\n  });\n\n  var viewElem = Ember.$('#menu #child');\n  ok(viewElem.length > 0, \"creates and replaces the view's element\");\n});\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/replace_in_test");minispade.register('ember-views/~tests/views/view/template_test', "(function() {var set = Ember.set, get = Ember.get, container, view;\n\nmodule(\"Ember.View - Template Functionality\", {\n  setup: function() {\n    container = new Ember.Container();\n    container.optionsForType('template', { instantiate: false });\n  },\n  teardown: function() {\n    Ember.run(function() {\n      if (view) { view.destroy(); }\n    });\n  }\n});\n\ntest(\"should call the function of the associated template\", function() {\n  container.register('template:testTemplate', function() {\n    return \"<h1 id='twas-called'>template was called</h1>\";\n  });\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'testTemplate'\n  });\n\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  ok(view.$('#twas-called').length, \"the named template was called\");\n});\n\ntest(\"should call the function of the associated template with itself as the context\", function() {\n  container.register('template:testTemplate', function(dataSource) {\n    return \"<h1 id='twas-called'>template was called for \" + get(dataSource, 'personName') + \"</h1>\";\n  });\n\n  view = Ember.View.create({\n    container: container,\n    templateName: 'testTemplate',\n\n    context: {\n      personName: \"Tom DAAAALE\"\n    }\n  });\n\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  equal(\"template was called for Tom DAAAALE\", view.$('#twas-called').text(), \"the named template was called with the view as the data source\");\n});\n\ntest(\"should fall back to defaultTemplate if neither template nor templateName are provided\", function() {\n  var View;\n\n  View = Ember.View.extend({\n    defaultTemplate: function(dataSource) { return \"<h1 id='twas-called'>template was called for \" + get(dataSource, 'personName') + \"</h1>\"; }\n  });\n\n  view = View.create({\n    context: {\n      personName: \"Tom DAAAALE\"\n    }\n  });\n\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  equal(\"template was called for Tom DAAAALE\", view.$('#twas-called').text(), \"the named template was called with the view as the data source\");\n});\n\ntest(\"should not use defaultTemplate if template is provided\", function() {\n  var View;\n\n  View = Ember.View.extend({\n    template:  function() { return \"foo\"; },\n    defaultTemplate: function(dataSource) { return \"<h1 id='twas-called'>template was called for \" + get(dataSource, 'personName') + \"</h1>\"; }\n  });\n\n  view = View.create();\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  equal(\"foo\", view.$().text(), \"default template was not printed\");\n});\n\ntest(\"should not use defaultTemplate if template is provided\", function() {\n  var View;\n\n  container.register('template:foobar', function() { return 'foo'; });\n\n  View = Ember.View.extend({\n    container: container,\n    templateName: 'foobar',\n    defaultTemplate: function(dataSource) { return \"<h1 id='twas-called'>template was called for \" + get(dataSource, 'personName') + \"</h1>\"; }\n  });\n\n  view = View.create();\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  equal(\"foo\", view.$().text(), \"default template was not printed\");\n});\n\ntest(\"should render an empty element if no template is specified\", function() {\n  view = Ember.View.create();\n  Ember.run(function(){\n    view.createElement();\n  });\n\n  equal(view.$().html(), '', \"view div should be empty\");\n});\n\ntest(\"should provide a controller to the template if a controller is specified on the view\", function() {\n  expect(7);\n\n  var Controller1 = Ember.Object.extend({\n    toString: function() { return \"Controller1\"; }\n  });\n\n  var Controller2 = Ember.Object.extend({\n    toString: function() { return \"Controller2\"; }\n  });\n\n  var controller1 = Controller1.create(),\n      controller2 = Controller2.create(),\n      optionsDataKeywordsControllerForView,\n      optionsDataKeywordsControllerForChildView,\n      contextForView,\n      contextForControllerlessView;\n\n  view = Ember.View.create({\n    controller: controller1,\n\n    template: function(buffer, options) {\n      optionsDataKeywordsControllerForView = options.data.keywords.controller;\n    }\n  });\n\n  Ember.run(function() {\n    view.appendTo('#qunit-fixture');\n  });\n\n  strictEqual(optionsDataKeywordsControllerForView, controller1, \"passes the controller in the data\");\n\n  Ember.run(function(){\n    view.destroy();\n  });\n\n  var parentView = Ember.View.create({\n    controller: controller1,\n\n    template: function(buffer, options) {\n      options.data.view.appendChild(Ember.View.create({\n        controller: controller2,\n        templateData: options.data,\n        template: function(context, options) {\n          contextForView = context;\n          optionsDataKeywordsControllerForChildView = options.data.keywords.controller;\n        }\n      }));\n      optionsDataKeywordsControllerForView = options.data.keywords.controller;\n    }\n  });\n\n  Ember.run(function() {\n    parentView.appendTo('#qunit-fixture');\n  });\n\n  strictEqual(optionsDataKeywordsControllerForView, controller1, \"passes the controller in the data\");\n  strictEqual(optionsDataKeywordsControllerForChildView, controller2, \"passes the child view's controller in the data\");\n\n  Ember.run(function(){\n    parentView.destroy();\n  });\n\n  var parentViewWithControllerlessChild = Ember.View.create({\n    controller: controller1,\n\n    template: function(buffer, options) {\n      options.data.view.appendChild(Ember.View.create({\n        templateData: options.data,\n        template: function(context, options) {\n          contextForControllerlessView = context;\n          optionsDataKeywordsControllerForChildView = options.data.keywords.controller;\n        }\n      }));\n      optionsDataKeywordsControllerForView = options.data.keywords.controller;\n    }\n  });\n\n  Ember.run(function() {\n    parentViewWithControllerlessChild.appendTo('#qunit-fixture');\n  });\n\n  strictEqual(optionsDataKeywordsControllerForView, controller1, \"passes the original controller in the data\");\n  strictEqual(optionsDataKeywordsControllerForChildView, controller1, \"passes the controller in the data to child views\");\n  strictEqual(contextForView, controller2, \"passes the controller in as the main context of the parent view\");\n  strictEqual(contextForControllerlessView, controller1, \"passes the controller in as the main context of the child view\");\n\n  Ember.run(function() {\n    parentView.destroy();\n    parentViewWithControllerlessChild.destroy();\n  });\n});\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/template_test");minispade.register('ember-views/~tests/views/view/view_lifecycle_test', "(function() {/*global ViewTest:true*/\n\nvar originalLookup = Ember.lookup, lookup, view;\n\nmodule(\"views/view/view_lifecycle_test - pre-render\", {\n  setup: function() {\n    Ember.lookup = lookup = {};\n  },\n\n  teardown: function() {\n    if (view) {\n      Ember.run(function(){\n        view.destroy();\n      });\n    }\n    Ember.lookup = originalLookup;\n  }\n});\n\nfunction tmpl(str) {\n  return function(context, options) {\n    options.data.buffer.push(str);\n  };\n}\n\ntest(\"should create and append a DOM element after bindings have synced\", function() {\n  var ViewTest;\n\n  lookup.ViewTest = ViewTest = {};\n\n  Ember.run(function() {\n    ViewTest.fakeController = Ember.Object.create({\n      fakeThing: 'controllerPropertyValue'\n    });\n\n    view = Ember.View.createWithMixins({\n      fooBinding: 'ViewTest.fakeController.fakeThing',\n\n      render: function(buffer) {\n        buffer.push(this.get('foo'));\n      }\n    });\n\n    ok(!view.get('element'), \"precond - does not have an element before appending\");\n\n    view.append();\n  });\n\n  equal(view.$().text(), 'controllerPropertyValue', \"renders and appends after bindings have synced\");\n});\n\ntest(\"should throw an exception if trying to append a child before rendering has begun\", function() {\n  Ember.run(function() {\n    view = Ember.View.create();\n  });\n\n  raises(function() {\n    view.appendChild(Ember.View, {});\n  }, null, \"throws an error when calling appendChild()\");\n});\n\ntest(\"should not affect rendering if rerender is called before initial render happens\", function() {\n  Ember.run(function() {\n    view = Ember.View.create({\n      template: tmpl(\"Rerender me!\")\n    });\n\n    view.rerender();\n    view.append();\n  });\n\n  equal(view.$().text(), \"Rerender me!\", \"renders correctly if rerender is called first\");\n});\n\ntest(\"should not affect rendering if destroyElement is called before initial render happens\", function() {\n  Ember.run(function() {\n    view = Ember.View.create({\n      template: tmpl(\"Don't destroy me!\")\n    });\n\n    view.destroyElement();\n    view.append();\n  });\n\n  equal(view.$().text(), \"Don't destroy me!\", \"renders correctly if destroyElement is called first\");\n});\n\nmodule(\"views/view/view_lifecycle_test - in render\", {\n  setup: function() {\n\n  },\n\n  teardown: function() {\n    if (view) {\n      Ember.run(function(){\n        view.destroy();\n      });\n    }\n  }\n});\n\ntest(\"appendChild should work inside a template\", function() {\n  Ember.run(function() {\n    view = Ember.View.create({\n      template: function(context, options) {\n        var buffer = options.data.buffer;\n\n        buffer.push(\"<h1>Hi!</h1>\");\n\n        options.data.view.appendChild(Ember.View, {\n          template: tmpl(\"Inception reached\")\n        });\n\n        buffer.push(\"<div class='footer'>Wait for the kick</div>\");\n      }\n    });\n\n    view.appendTo(\"#qunit-fixture\");\n  });\n\n  ok(view.$('h1').length === 1 && view.$('div').length === 2,\n     \"The appended child is visible\");\n});\n\ntest(\"rerender should throw inside a template\", function() {\n  raises(function() {\n    Ember.run(function() {\n      var renderCount = 0;\n      view = Ember.View.create({\n        template: function(context, options) {\n          var view = options.data.view;\n\n          var child1 = view.appendChild(Ember.View, {\n            template: function(context, options) {\n              renderCount++;\n              options.data.buffer.push(String(renderCount));\n            }\n          });\n\n          var child2 = view.appendChild(Ember.View, {\n            template: function(context, options) {\n              options.data.buffer.push(\"Inside child2\");\n              child1.rerender();\n            }\n          });\n        }\n      });\n\n      view.appendTo(\"#qunit-fixture\");\n    });\n  }, /Something you did caused a view to re-render after it rendered but before it was inserted into the DOM./);\n});\n\nmodule(\"views/view/view_lifecycle_test - in DOM\", {\n  teardown: function() {\n    if (view) {\n      Ember.run(function(){\n        view.destroy();\n      });\n    }\n  }\n});\n\ntest(\"should throw an exception when calling appendChild when DOM element exists\", function() {\n  Ember.run(function() {\n    view = Ember.View.create({\n      template: tmpl(\"Wait for the kick\")\n    });\n\n    view.append();\n  });\n\n  raises(function() {\n    view.appendChild(Ember.View, {\n      template: tmpl(\"Ah ah ah! You didn't say the magic word!\")\n    });\n  }, null, \"throws an exception when calling appendChild after element is created\");\n});\n\ntest(\"should replace DOM representation if rerender() is called after element is created\", function() {\n  Ember.run(function() {\n    view = Ember.View.create({\n      template: function(context, options) {\n        var buffer = options.data.buffer;\n        var value = context.get('shape');\n\n        buffer.push(\"Do not taunt happy fun \"+value);\n      },\n\n      context: Ember.Object.create({\n        shape: 'sphere'\n      })\n    });\n\n    view.append();\n  });\n\n  equal(view.$().text(), \"Do not taunt happy fun sphere\", \"precond - creates DOM element\");\n\n  view.set('context.shape', 'ball');\n  Ember.run(function() {\n    view.rerender();\n  });\n\n  equal(view.$().text(), \"Do not taunt happy fun ball\", \"rerenders DOM element when rerender() is called\");\n});\n\ntest(\"should destroy DOM representation when destroyElement is called\", function() {\n  Ember.run(function() {\n    view = Ember.View.create({\n      template: tmpl(\"Don't fear the reaper\")\n    });\n\n    view.append();\n  });\n\n  ok(view.get('element'), \"precond - generates a DOM element\");\n\n  Ember.run(function() {\n    view.destroyElement();\n  });\n\n  ok(!view.get('element'), \"destroys view when destroyElement() is called\");\n});\n\ntest(\"should destroy DOM representation when destroy is called\", function() {\n  Ember.run(function() {\n    view = Ember.View.create({\n      template: tmpl(\"<div id='warning'>Don't fear the reaper</div>\")\n    });\n\n    view.append();\n  });\n\n  ok(view.get('element'), \"precond - generates a DOM element\");\n\n  Ember.run(function() {\n    view.destroy();\n  });\n\n  ok(Ember.$('#warning').length === 0, \"destroys element when destroy() is called\");\n});\n\ntest(\"should throw an exception if trying to append an element that is already in DOM\", function() {\n  Ember.run(function() {\n    view = Ember.View.create({\n      template: tmpl('Broseidon, King of the Brocean')\n    });\n\n    view.append();\n  });\n\n  ok(view.get('element'), \"precond - creates DOM element\");\n\n  raises(function() {\n    Ember.run(function() {\n      view.append();\n    });\n  }, null, \"raises an exception on second append\");\n});\n\nmodule(\"views/view/view_lifecycle_test - destroyed\");\n\ntest(\"should throw an exception when calling appendChild after view is destroyed\", function() {\n  Ember.run(function() {\n    view = Ember.View.create({\n      template: tmpl(\"Wait for the kick\")\n    });\n\n    view.append();\n  });\n\n  Ember.run(function() {\n    view.destroy();\n  });\n\n  raises(function() {\n    view.appendChild(Ember.View, {\n      template: tmpl(\"Ah ah ah! You didn't say the magic word!\")\n    });\n  }, null, \"throws an exception when calling appendChild\");\n});\n\ntest(\"should throw an exception when rerender is called after view is destroyed\", function() {\n  Ember.run(function() {\n    view = Ember.View.create({\n      template: tmpl('foo')\n    });\n\n    view.append();\n  });\n\n  Ember.run(function() {\n    view.destroy();\n  });\n\n  raises(function() {\n    view.rerender();\n  }, null, \"throws an exception when calling rerender\");\n});\n\ntest(\"should throw an exception when destroyElement is called after view is destroyed\", function() {\n  Ember.run(function() {\n    view = Ember.View.create({\n      template: tmpl('foo')\n    });\n\n    view.append();\n  });\n\n  Ember.run(function() {\n    view.destroy();\n  });\n\n  raises(function() {\n    view.destroyElement();\n  }, null, \"throws an exception when calling destroyElement\");\n});\n\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/view_lifecycle_test");minispade.register('ember-views/~tests/views/view/virtual_views_test', "(function() {var get = Ember.get, set = Ember.set, rootView, childView;\n\nmodule(\"virtual views\", {\n  teardown: function() {\n    Ember.run(function() {\n      rootView.destroy();\n      childView.destroy();\n    });\n  }\n});\n\ntest(\"a virtual view does not appear as a view's parentView\", function() {\n  rootView = Ember.View.create({\n    elementId: 'root-view',\n\n    render: function(buffer) {\n      buffer.push(\"<h1>Hi</h1>\");\n      this.appendChild(virtualView);\n    }\n  });\n\n  var virtualView = Ember.View.create({\n    isVirtual: true,\n    tagName: '',\n\n    render: function(buffer) {\n      buffer.push(\"<h2>Virtual</h2>\");\n      this.appendChild(childView);\n    }\n  });\n\n  childView = Ember.View.create({\n    render: function(buffer) {\n      buffer.push(\"<p>Bye!</p>\");\n    }\n  });\n\n  Ember.run(function() {\n    Ember.$(\"#qunit-fixture\").empty();\n    rootView.appendTo(\"#qunit-fixture\");\n  });\n\n  equal(Ember.$(\"#root-view > h2\").length, 1, \"nodes with '' tagName do not create wrappers\");\n  equal(get(childView, 'parentView'), rootView);\n\n  var children = get(rootView, 'childViews');\n\n  equal(get(children, 'length'), 1, \"there is one child element\");\n  equal(children.objectAt(0), childView, \"the child element skips through the virtual view\");\n});\n\ntest(\"when a virtual view's child views change, the parent's childViews should reflect\", function() {\n  rootView = Ember.View.create({\n    elementId: 'root-view',\n\n    render: function(buffer) {\n      buffer.push(\"<h1>Hi</h1>\");\n      this.appendChild(virtualView);\n    }\n  });\n\n  var virtualView = Ember.View.create({\n    isVirtual: true,\n    tagName: '',\n\n    render: function(buffer) {\n      buffer.push(\"<h2>Virtual</h2>\");\n      this.appendChild(childView);\n    }\n  });\n\n  childView = Ember.View.create({\n    render: function(buffer) {\n      buffer.push(\"<p>Bye!</p>\");\n    }\n  });\n\n  Ember.run(function() {\n    Ember.$(\"#qunit-fixture\").empty();\n    rootView.appendTo(\"#qunit-fixture\");\n  });\n\n  equal(virtualView.get('childViews.length'), 1, \"has childView - precond\");\n  equal(rootView.get('childViews.length'), 1, \"has childView - precond\");\n\n  Ember.run(function() {\n    childView.removeFromParent();\n  });\n\n  equal(virtualView.get('childViews.length'), 0, \"has no childView\");\n  equal(rootView.get('childViews.length'), 0, \"has no childView\");\n});\n\n})();\n//@ sourceURL=ember-views/~tests/views/view/virtual_views_test");minispade.register('ember/~tests/helpers/link_to_test', "(function() {var Router, App, AppView, templates, router, eventDispatcher, container;\nvar get = Ember.get, set = Ember.set;\n\nfunction bootApplication() {\n  router = container.lookup('router:main');\n  Ember.run(App, 'advanceReadiness');\n}\n\n// IE includes the host name\nfunction normalizeUrl(url) {\n  return url.replace(/https?:\\/\\/[^\\/]+/,'');\n}\n\nfunction compile(template) {\n  return Ember.Handlebars.compile(template);\n}\n\nmodule(\"The {{linkTo}} helper\", {\n  setup: function() {\n    Ember.run(function() {\n      App = Ember.Application.create({\n        name: \"App\",\n        rootElement: '#qunit-fixture'\n      });\n\n      App.deferReadiness();\n\n      App.Router.reopen({\n        location: 'none'\n      });\n\n      Router = App.Router;\n\n      Ember.TEMPLATES.app = Ember.Handlebars.compile(\"{{outlet}}\");\n      Ember.TEMPLATES.index = Ember.Handlebars.compile(\"<h3>Home</h3>{{#linkTo about id='about-link'}}About{{/linkTo}}{{#linkTo index id='self-link'}}Self{{/linkTo}}\");\n      Ember.TEMPLATES.about = Ember.Handlebars.compile(\"<h3>About</h3>{{#linkTo index id='home-link'}}Home{{/linkTo}}{{#linkTo about id='self-link'}}Self{{/linkTo}}\");\n      Ember.TEMPLATES.item = Ember.Handlebars.compile(\"<h3>Item</h3><p>{{name}}</p>{{#linkTo index id='home-link'}}Home{{/linkTo}}\");\n\n      AppView = Ember.View.extend({\n        templateName: 'app'\n      });\n\n      container = App.__container__;\n\n      container.register('view:app');\n      container.register('router:main', Router);\n    });\n  },\n\n  teardown: function() {\n    Ember.run(function() { App.destroy(); });\n  }\n});\n\ntest(\"The {{linkTo}} helper moves into the named route\", function() {\n  Router.map(function(match) {\n    this.route(\"about\");\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  equal(Ember.$('h3:contains(Home)', '#qunit-fixture').length, 1, \"The home template was rendered\");\n  equal(Ember.$('#self-link.active', '#qunit-fixture').length, 1, \"The self-link was rendered with active class\");\n  equal(Ember.$('#about-link:not(.active)', '#qunit-fixture').length, 1, \"The other link was rendered without active class\");\n\n  Ember.run(function() {\n    Ember.$('#about-link', '#qunit-fixture').click();\n  });\n\n  equal(Ember.$('h3:contains(About)', '#qunit-fixture').length, 1, \"The about template was rendered\");\n  equal(Ember.$('#self-link.active', '#qunit-fixture').length, 1, \"The self-link was rendered with active class\");\n  equal(Ember.$('#home-link:not(.active)', '#qunit-fixture').length, 1, \"The other link was rendered without active class\");\n});\n\ntest(\"The {{linkTo}} helper supports URL replacement\", function() {\n  var setCount = 0,\n      replaceCount = 0;\n\n  Ember.TEMPLATES.index = Ember.Handlebars.compile(\"<h3>Home</h3>{{#linkTo about id='about-link' replace=true}}About{{/linkTo}}\");\n\n  Router.reopen({\n    location: Ember.NoneLocation.createWithMixins({\n      setURL: function(path) {\n        setCount++;\n        set(this, 'path', path);\n      },\n\n      replaceURL: function(path) {\n        replaceCount++;\n        set(this, 'path', path);\n      }\n    })\n  });\n\n  Router.map(function() {\n    this.route(\"about\");\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  equal(setCount, 0, 'precond: setURL has not been called');\n  equal(replaceCount, 0, 'precond: replaceURL has not been called');\n\n  Ember.run(function() {\n    Ember.$('#about-link', '#qunit-fixture').click();\n  });\n\n  equal(setCount, 0, 'setURL should not be called');\n  equal(replaceCount, 1, 'replaceURL should be called once');\n});\n\ntest(\"The {{linkTo}} helper supports a custom activeClass\", function() {\n  Ember.TEMPLATES.index = Ember.Handlebars.compile(\"<h3>Home</h3>{{#linkTo about id='about-link'}}About{{/linkTo}}{{#linkTo index id='self-link' activeClass='zomg-active'}}Self{{/linkTo}}\");\n\n  Router.map(function() {\n    this.route(\"about\");\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  equal(Ember.$('h3:contains(Home)', '#qunit-fixture').length, 1, \"The home template was rendered\");\n  equal(Ember.$('#self-link.zomg-active', '#qunit-fixture').length, 1, \"The self-link was rendered with active class\");\n  equal(Ember.$('#about-link:not(.active)', '#qunit-fixture').length, 1, \"The other link was rendered without active class\");\n});\n\ntest(\"The {{linkTo}} helper supports leaving off .index for nested routes\", function() {\n  Router.map(function() {\n    this.resource(\"about\", function() {\n      this.route(\"item\");\n    });\n  });\n\n  Ember.TEMPLATES.about = compile(\"<h1>About</h1>{{outlet}}\");\n  Ember.TEMPLATES['about/index'] = compile(\"<div id='index'>Index</div>\");\n  Ember.TEMPLATES['about/item'] = compile(\"<div id='item'>{{#linkTo 'about'}}About{{/linkTo}}</div>\");\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/about/item\");\n  });\n\n  equal(Ember.$('#item a', '#qunit-fixture').attr('href'), '/about');\n});\n\ntest(\"The {{linkTo}} helper supports custom, nested, currentWhen\", function() {\n  Router.map(function(match) {\n    this.resource(\"index\", { path: \"/\" }, function() {\n      this.route(\"about\");\n    });\n\n    this.route(\"item\");\n  });\n\n  Ember.TEMPLATES.index = Ember.Handlebars.compile(\"<h3>Home</h3>{{outlet}}\");\n  Ember.TEMPLATES['index/about'] = Ember.Handlebars.compile(\"{{#linkTo item id='other-link' currentWhen='index'}}ITEM{{/linkTo}}\");\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/about\");\n  });\n\n  equal(Ember.$('#other-link.active', '#qunit-fixture').length, 1, \"The link is active since currentWhen is a parent route\");\n});\n\ntest(\"The {{linkTo}} helper defaults to bubbling\", function() {\n  Ember.TEMPLATES.about = Ember.Handlebars.compile(\"<div {{action 'hide'}}>{{#linkTo 'about.contact' id='about-contact'}}About{{/linkTo}}</div>{{outlet}}\");\n  Ember.TEMPLATES['about/contact'] = Ember.Handlebars.compile(\"<h1 id='contact'>Contact</h1>\");\n\n  Router.map(function() {\n    this.resource(\"about\", function() {\n      this.route(\"contact\");\n    });\n  });\n\n  var hidden = 0;\n\n  App.AboutRoute = Ember.Route.extend({\n    events: {\n      hide: function() {\n        hidden++;\n      }\n    }\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/about\");\n  });\n\n  Ember.run(function() {\n    Ember.$('#about-contact', '#qunit-fixture').click();\n  });\n\n  equal(Ember.$(\"#contact\", \"#qunit-fixture\").text(), \"Contact\", \"precond - the link worked\");\n\n  equal(hidden, 1, \"The link bubbles\");\n});\n\ntest(\"The {{linkTo}} helper supports bubbles=false\", function() {\n  Ember.TEMPLATES.about = Ember.Handlebars.compile(\"<div {{action 'hide'}}>{{#linkTo 'about.contact' id='about-contact' bubbles=false}}About{{/linkTo}}</div>{{outlet}}\");\n  Ember.TEMPLATES['about/contact'] = Ember.Handlebars.compile(\"<h1 id='contact'>Contact</h1>\");\n\n  Router.map(function() {\n    this.resource(\"about\", function() {\n      this.route(\"contact\");\n    });\n  });\n\n  var hidden = 0;\n\n  App.AboutRoute = Ember.Route.extend({\n    events: {\n      hide: function() {\n        hidden++;\n      }\n    }\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/about\");\n  });\n\n  Ember.run(function() {\n    Ember.$('#about-contact', '#qunit-fixture').click();\n  });\n\n  equal(Ember.$(\"#contact\", \"#qunit-fixture\").text(), \"Contact\", \"precond - the link worked\");\n\n  equal(hidden, 0, \"The link didn't bubble\");\n});\n\ntest(\"The {{linkTo}} helper moves into the named route with context\", function() {\n  Router.map(function(match) {\n    this.route(\"about\");\n    this.resource(\"item\", { path: \"/item/:id\" });\n  });\n\n  Ember.TEMPLATES.about = Ember.Handlebars.compile(\"<h3>List</h3><ul>{{#each controller}}<li>{{#linkTo item this}}{{name}}{{/linkTo}}<li>{{/each}}</ul>{{#linkTo index id='home-link'}}Home{{/linkTo}}\");\n\n  var people = {\n    yehuda: \"Yehuda Katz\",\n    tom: \"Tom Dale\",\n    erik: \"Erik Brynroflsson\"\n  };\n\n  App.AboutRoute = Ember.Route.extend({\n    model: function() {\n      return Ember.A([\n        { id: \"yehuda\", name: \"Yehuda Katz\" },\n        { id: \"tom\", name: \"Tom Dale\" },\n        { id: \"erik\", name: \"Erik Brynroflsson\" }\n      ]);\n    }\n  });\n\n  App.ItemRoute = Ember.Route.extend({\n    serialize: function(object) {\n      return { id: object.id };\n    },\n\n    deserialize: function(params) {\n      return { id: params.id, name: people[params.id] };\n    }\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/about\");\n  });\n\n  equal(Ember.$('h3:contains(List)', '#qunit-fixture').length, 1, \"The home template was rendered\");\n  equal(normalizeUrl(Ember.$('#home-link').attr('href')), '/', \"The home link points back at /\");\n\n  Ember.run(function() {\n    Ember.$('li a:contains(Yehuda)', '#qunit-fixture').click();\n  });\n\n  equal(Ember.$('h3:contains(Item)', '#qunit-fixture').length, 1, \"The item template was rendered\");\n  equal(Ember.$('p', '#qunit-fixture').text(), \"Yehuda Katz\", \"The name is correct\");\n\n  Ember.run(function() { Ember.$('#home-link').click(); });\n  Ember.run(function() { Ember.$('#about-link').click(); });\n\n  equal(normalizeUrl(Ember.$('li a:contains(Yehuda)').attr('href')), \"/item/yehuda\");\n  equal(normalizeUrl(Ember.$('li a:contains(Tom)').attr('href')), \"/item/tom\");\n  equal(normalizeUrl(Ember.$('li a:contains(Erik)').attr('href')), \"/item/erik\");\n\n  Ember.run(function() {\n    Ember.$('li a:contains(Erik)', '#qunit-fixture').click();\n  });\n\n  equal(Ember.$('h3:contains(Item)', '#qunit-fixture').length, 1, \"The item template was rendered\");\n  equal(Ember.$('p', '#qunit-fixture').text(), \"Erik Brynroflsson\", \"The name is correct\");\n});\n\ntest(\"The {{linkTo}} helper binds some anchor html tag common attributes\", function() {\n  Ember.TEMPLATES.index = Ember.Handlebars.compile(\"<h3>Home</h3>{{#linkTo index id='self-link' title='title-attr'}}Self{{/linkTo}}\");\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  equal(Ember.$('#self-link', '#qunit-fixture').attr('title'), 'title-attr', \"The self-link contains title attribute\");\n});\n\ntest(\"The {{linkTo}} helper accepts string arguments\", function() {\n  Router.map(function() {\n    this.route('filter', { path: '/filters/:filter' });\n  });\n\n  Ember.TEMPLATES.filter = compile('<p>{{filter}}</p>{{#linkTo filter \"unpopular\" id=\"link\"}}Unpopular{{/linkTo}}');\n  Ember.TEMPLATES.index = compile('');\n\n  bootApplication();\n\n  Ember.run(function() { router.handleURL(\"/filters/popular\"); });\n\n  equal(Ember.$('#link', '#qunit-fixture').attr('href'), \"/filters/unpopular\");\n});\n\ntest(\"The {{linkTo}} helper unwraps controllers\", function() {\n  // The serialize hook is called twice: once to generate the href for the\n  // link and once to generate the URL when the link is clicked.\n  expect(2);\n\n  Router.map(function() {\n    this.route('filter', { path: '/filters/:filter' });\n  });\n\n  var indexObject = { filter: 'popular' };\n\n  App.FilterRoute = Ember.Route.extend({\n    model: function(params) {\n      return indexObject;\n    },\n\n    serialize: function(passedObject) {\n      equal(passedObject, indexObject, \"The unwrapped object is passed\");\n      return { filter: 'popular' };\n    }\n  });\n\n  App.IndexRoute = Ember.Route.extend({\n    model: function() {\n      return indexObject;\n    }\n  });\n\n  Ember.TEMPLATES.filter = compile('<p>{{filter}}</p>');\n  Ember.TEMPLATES.index = compile('{{#linkTo filter this id=\"link\"}}Filter{{/linkTo}}');\n\n  bootApplication();\n\n  Ember.run(function() { router.handleURL(\"/\"); });\n\n  Ember.$('#link', '#qunit-fixture').trigger('click');\n});\n\ntest(\"The {{linkTo}} helper doesn't change view context\", function() {\n  App.IndexView = Ember.View.extend({\n    elementId: 'index',\n    name: 'test'\n  });\n\n  Ember.TEMPLATES.index = Ember.Handlebars.compile(\"{{view.name}}-{{#linkTo index id='self-link'}}Link: {{view.name}}{{/linkTo}}\");\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  equal(Ember.$('#index', '#qunit-fixture').text(), 'test-Link: test', \"accesses correct view\");\n});\n\n})();\n//@ sourceURL=ember/~tests/helpers/link_to_test");minispade.register('ember/~tests/routing/basic_test', "(function() {var Router, App, AppView, templates, router, container, originalTemplates;\nvar get = Ember.get, set = Ember.set;\n\nfunction bootApplication() {\n  router = container.lookup('router:main');\n  Ember.run(App, 'advanceReadiness');\n}\n\nfunction compile(string) {\n  return Ember.Handlebars.compile(string);\n}\n\nmodule(\"Basic Routing\", {\n  setup: function() {\n    Ember.run(function() {\n      App = Ember.Application.create({\n        name: \"App\",\n        rootElement: '#qunit-fixture'\n      });\n\n      App.deferReadiness();\n\n      App.Router.reopen({\n        location: 'none'\n      });\n\n      Router = App.Router;\n\n      App.LoadingRoute = Ember.Route.extend({\n      });\n\n      container = App.__container__;\n\n      originalTemplates = Ember.$.extend({}, Ember.TEMPLATES);\n      Ember.TEMPLATES.application = compile(\"{{outlet}}\");\n      Ember.TEMPLATES.home = compile(\"<h3>Hours</h3>\");\n      Ember.TEMPLATES.homepage = compile(\"<h3>Megatroll</h3><p>{{home}}</p>\");\n    });\n  },\n\n  teardown: function() {\n    Ember.run(function() {\n      App.destroy();\n      App = null;\n\n      Ember.TEMPLATES = originalTemplates;\n    });\n  }\n});\n\ntest(\"The Homepage\", function() {\n  Router.map(function() {\n    this.route(\"home\", { path: \"/\" });\n  });\n\n  App.HomeRoute = Ember.Route.extend({\n  });\n\n  var currentPath;\n\n  App.ApplicationController = Ember.Controller.extend({\n    currentPathDidChange: Ember.observer(function() {\n      currentPath = get(this, 'currentPath');\n    }, 'currentPath')\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  equal(currentPath, 'home');\n  equal(Ember.$('h3:contains(Hours)', '#qunit-fixture').length, 1, \"The home template was rendered\");\n});\n\ntest(\"The Homepage register as activeView\", function() {\n  Router.map(function() {\n    this.route(\"home\", { path: \"/\" });\n    this.route(\"homepage\");\n  });\n\n  App.HomeRoute = Ember.Route.extend({\n  });\n\n  App.HomepageRoute = Ember.Route.extend({\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  ok(router._lookupActiveView('home'), '`home` active view is connected');\n\n  Ember.run(function() {\n    router.handleURL(\"/homepage\");\n  });\n\n  ok(router._lookupActiveView('homepage'), '`homepage` active view is connected');\n  equal(router._lookupActiveView('home'), undefined, '`home` active view is disconnected');\n});\n\ntest(\"The Homepage with explicit template name in renderTemplate\", function() {\n  Router.map(function() {\n    this.route(\"home\", { path: \"/\" });\n  });\n\n  App.HomeRoute = Ember.Route.extend({\n    renderTemplate: function() {\n      this.render('homepage');\n    }\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  equal(Ember.$('h3:contains(Megatroll)', '#qunit-fixture').length, 1, \"The homepage template was rendered\");\n});\n\ntest(\"An alternate template will pull in an alternate controller\", function() {\n  Router.map(function() {\n    this.route(\"home\", { path: \"/\" });\n  });\n\n  App.HomeRoute = Ember.Route.extend({\n    renderTemplate: function() {\n      this.render('homepage');\n    }\n  });\n\n  App.HomepageController = Ember.Controller.extend({\n    home: \"Comes from homepage\"\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  equal(Ember.$('h3:contains(Megatroll) + p:contains(Comes from homepage)', '#qunit-fixture').length, 1, \"The homepage template was rendered\");\n});\n\ntest(\"The template will pull in an alternate controller via key/value\", function() {\n  Router.map(function() {\n    this.route(\"homepage\", { path: \"/\" });\n  });\n\n  App.HomepageRoute = Ember.Route.extend({\n    renderTemplate: function() {\n      this.render({controller: 'home'});\n    }\n  });\n\n  App.HomeController = Ember.Controller.extend({\n    home: \"Comes from home.\"\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  equal(Ember.$('h3:contains(Megatroll) + p:contains(Comes from home.)', '#qunit-fixture').length, 1, \"The homepage template was rendered from data from the HomeController\");\n});\n\ntest(\"The Homepage with explicit template name in renderTemplate and controller\", function() {\n  Router.map(function() {\n    this.route(\"home\", { path: \"/\" });\n  });\n\n  App.HomeController = Ember.Controller.extend({\n    home: \"YES I AM HOME\"\n  });\n\n  App.HomeRoute = Ember.Route.extend({\n    renderTemplate: function() {\n      this.render('homepage');\n    }\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  equal(Ember.$('h3:contains(Megatroll) + p:contains(YES I AM HOME)', '#qunit-fixture').length, 1, \"The homepage template was rendered\");\n});\n\ntest(\"Renders correct view with slash notation\", function() {\n  Ember.TEMPLATES['home/page'] = compile(\"<p>{{view.name}}</p>\");\n\n  Router.map(function() {\n    this.route(\"home\", { path: \"/\" });\n  });\n\n  App.HomeRoute = Ember.Route.extend({\n    renderTemplate: function() {\n      this.render('home/page');\n    }\n  });\n\n  App.HomePageView = Ember.View.extend({\n    name: \"Home/Page\"\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  equal(Ember.$('p:contains(Home/Page)', '#qunit-fixture').length, 1, \"The homepage template was rendered\");\n});\n\ntest('render does not replace templateName if user provided', function() {\n  Router.map(function() {\n    this.route(\"home\", { path: \"/\" });\n  });\n\n  Ember.TEMPLATES.the_real_home_template = Ember.Handlebars.compile(\n    \"<p>THIS IS THE REAL HOME</p>\"\n  );\n\n  App.HomeView = Ember.View.extend({\n    templateName: 'the_real_home_template'\n  });\n  App.HomeController = Ember.Controller.extend();\n  App.HomeRoute = Ember.Route.extend();\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  equal(Ember.$('p', '#qunit-fixture').text(), \"THIS IS THE REAL HOME\", \"The homepage template was rendered\");\n});\n\ntest(\"The Homepage with a `setupController` hook\", function() {\n  Router.map(function() {\n    this.route(\"home\", { path: \"/\" });\n  });\n\n  App.HomeRoute = Ember.Route.extend({\n    setupController: function(controller) {\n      set(controller, 'hours', Ember.A([\n        \"Monday through Friday: 9am to 5pm\",\n        \"Saturday: Noon to Midnight\",\n        \"Sunday: Noon to 6pm\"\n      ]));\n    }\n  });\n\n  Ember.TEMPLATES.home = Ember.Handlebars.compile(\n    \"<ul>{{#each entry in hours}}<li>{{entry}}</li>{{/each}}</ul>\"\n  );\n\n  bootApplication();\n\n  container.register('controller:home', Ember.Controller.extend());\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  equal(Ember.$('ul li', '#qunit-fixture').eq(2).text(), \"Sunday: Noon to 6pm\", \"The template was rendered with the hours context\");\n});\n\ntest(\"The route controller is still set when overriding the setupController hook\", function() {\n  Router.map(function() {\n    this.route(\"home\", { path: \"/\" });\n  });\n\n  App.HomeRoute = Ember.Route.extend({\n    setupController: function(controller) {\n      // no-op\n      // importantly, we are not calling  this._super here\n    }\n  });\n\n  container.register('controller:home', Ember.Controller.extend());\n\n  bootApplication();\n\n  deepEqual(container.lookup('route:home').controller, container.lookup('controller:home'), \"route controller is the home controller\");\n});\n\ntest(\"The default controller's model is still set when overriding the setupController hook\", function() {\n  Router.map(function() {\n    this.route(\"home\", { path: \"/\" });\n  });\n\n  App.HomeRoute = Ember.Route.extend({\n    model: function() {\n      return {\n        isModel: true\n      };\n    },\n\n    setupController: function(controller) {\n      // no-op\n      // importantly, we are not calling this._super here\n    }\n  });\n\n  Ember.TEMPLATES.home = Ember.Handlebars.compile(\n    \"<ul>{{#each entry in hours}}<li>{{entry}}</li>{{/each}}</ul>\"\n  );\n\n  container.register('controller:home', Ember.Controller.extend());\n\n  bootApplication();\n\n  deepEqual(container.lookup('controller:home').get('model'), { isModel: true }, \"model is still set on controller\");\n});\n\ntest(\"The Homepage with a `setupController` hook modifying other controllers\", function() {\n  Router.map(function() {\n    this.route(\"home\", { path: \"/\" });\n  });\n\n  App.HomeRoute = Ember.Route.extend({\n    setupController: function(controller) {\n      set(this.controllerFor('home'), 'hours', Ember.A([\n        \"Monday through Friday: 9am to 5pm\",\n        \"Saturday: Noon to Midnight\",\n        \"Sunday: Noon to 6pm\"\n      ]));\n    }\n  });\n\n  Ember.TEMPLATES.home = Ember.Handlebars.compile(\n    \"<ul>{{#each entry in hours}}<li>{{entry}}</li>{{/each}}</ul>\"\n  );\n\n  bootApplication();\n\n  container.register('controller:home', Ember.Controller.extend());\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  equal(Ember.$('ul li', '#qunit-fixture').eq(2).text(), \"Sunday: Noon to 6pm\", \"The template was rendered with the hours context\");\n});\n\ntest(\"The Homepage getting its controller context via model\", function() {\n  Router.map(function() {\n    this.route(\"home\", { path: \"/\" });\n  });\n\n  App.HomeRoute = Ember.Route.extend({\n    model: function() {\n      return Ember.A([\n        \"Monday through Friday: 9am to 5pm\",\n        \"Saturday: Noon to Midnight\",\n        \"Sunday: Noon to 6pm\"\n      ]);\n    },\n\n    setupController: function(controller, model) {\n      equal(this.controllerFor('home'), controller);\n\n      set(this.controllerFor('home'), 'hours', model);\n    }\n  });\n\n  Ember.TEMPLATES.home = Ember.Handlebars.compile(\n    \"<ul>{{#each entry in hours}}<li>{{entry}}</li>{{/each}}</ul>\"\n  );\n\n  bootApplication();\n\n  container.register('controller:home', Ember.Controller.extend());\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  equal(Ember.$('ul li', '#qunit-fixture').eq(2).text(), \"Sunday: Noon to 6pm\", \"The template was rendered with the hours context\");\n});\n\ntest(\"The Specials Page getting its controller context by deserializing the params hash\", function() {\n  Router.map(function() {\n    this.route(\"home\", { path: \"/\" });\n    this.resource(\"special\", { path: \"/specials/:menu_item_id\" });\n  });\n\n  App.SpecialRoute = Ember.Route.extend({\n    model: function(params) {\n      return Ember.Object.create({\n        menuItemId: params.menu_item_id\n      });\n    },\n\n    setupController: function(controller, model) {\n      set(controller, 'content', model);\n    }\n  });\n\n  Ember.TEMPLATES.special = Ember.Handlebars.compile(\n    \"<p>{{content.menuItemId}}</p>\"\n  );\n\n  bootApplication();\n\n  container.register('controller:special', Ember.Controller.extend());\n\n  Ember.run(function() {\n    router.handleURL(\"/specials/1\");\n  });\n\n  equal(Ember.$('p', '#qunit-fixture').text(), \"1\", \"The model was used to render the template\");\n});\n\ntest(\"The Specials Page defaults to looking models up via `find`\", function() {\n  Router.map(function() {\n    this.route(\"home\", { path: \"/\" });\n    this.resource(\"special\", { path: \"/specials/:menu_item_id\" });\n  });\n\n  App.MenuItem = Ember.Object.extend();\n  App.MenuItem.find = function(id) {\n    return Ember.Object.create({\n      id: id\n    });\n  };\n\n  App.SpecialRoute = Ember.Route.extend({\n    setupController: function(controller, model) {\n      set(controller, 'content', model);\n    }\n  });\n\n  Ember.TEMPLATES.special = Ember.Handlebars.compile(\n    \"<p>{{content.id}}</p>\"\n  );\n\n  bootApplication();\n\n  container.register('controller:special', Ember.Controller.extend());\n\n  Ember.run(function() {\n    router.handleURL(\"/specials/1\");\n  });\n\n  equal(Ember.$('p', '#qunit-fixture').text(), \"1\", \"The model was used to render the template\");\n});\n\ntest(\"The Special Page returning a promise puts the app into a loading state until the promise is resolved\", function() {\n  stop();\n\n  Router.map(function() {\n    this.route(\"home\", { path: \"/\" });\n    this.resource(\"special\", { path: \"/specials/:menu_item_id\" });\n  });\n\n  var menuItem;\n\n  App.MenuItem = Ember.Object.extend(Ember.DeferredMixin);\n  App.MenuItem.find = function(id) {\n    menuItem = App.MenuItem.create({ id: id });\n    return menuItem;\n  };\n\n  App.LoadingRoute = Ember.Route.extend({\n\n  });\n\n  App.SpecialRoute = Ember.Route.extend({\n    setupController: function(controller, model) {\n      set(controller, 'content', model);\n    }\n  });\n\n  Ember.TEMPLATES.special = Ember.Handlebars.compile(\n    \"<p>{{content.id}}</p>\"\n  );\n\n  Ember.TEMPLATES.loading = Ember.Handlebars.compile(\n    \"<p>LOADING!</p>\"\n  );\n\n  bootApplication();\n\n  container.register('controller:special', Ember.Controller.extend());\n\n  Ember.run(function() {\n    router.handleURL(\"/specials/1\");\n  });\n\n  equal(Ember.$('p', '#qunit-fixture').text(), \"LOADING!\", \"The app is in the loading state\");\n\n  Ember.run(function() {\n    menuItem.resolve(menuItem);\n  });\n\n  setTimeout(function() {\n    equal(Ember.$('p', '#qunit-fixture').text(), \"1\", \"The app is now in the specials state\");\n    start();\n  }, 100);\n});\n\ntest(\"The Special page returning an error puts the app into the failure state\", function() {\n  stop();\n\n  Router.map(function() {\n    this.route(\"home\", { path: \"/\" });\n    this.resource(\"special\", { path: \"/specials/:menu_item_id\" });\n  });\n\n  var menuItem;\n\n  App.MenuItem = Ember.Object.extend(Ember.DeferredMixin);\n  App.MenuItem.find = function(id) {\n    menuItem = App.MenuItem.create({ id: id });\n    return menuItem;\n  };\n\n  App.SpecialRoute = Ember.Route.extend({\n    setup: function() {\n      throw 'Setup error';\n    }\n  });\n\n  App.FailureRoute = Ember.Route.extend({\n  });\n\n  Ember.TEMPLATES.failure = Ember.Handlebars.compile(\n    \"<p>FAILURE!</p>\"\n  );\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/specials/1\");\n    menuItem.resolve(menuItem);\n  });\n\n  setTimeout(function() {\n    equal(Ember.$('p', '#qunit-fixture').text(), \"FAILURE!\", \"The app is now in the failure state\");\n    start();\n  }, 100);\n});\n\ntest(\"The Special page returning an error puts the app into a default failure state if none provided\", function() {\n  stop();\n\n  Router.map(function() {\n    this.route(\"home\", { path: \"/\" });\n    this.resource(\"special\", { path: \"/specials/:menu_item_id\" });\n  });\n\n  var lastFailure;\n  Router.reopenClass({\n    defaultFailureHandler: {\n      setup: function(error) {\n        lastFailure = error;\n      }\n    }\n  });\n\n  var menuItem;\n\n  App.MenuItem = Ember.Object.extend(Ember.DeferredMixin);\n  App.MenuItem.find = function(id) {\n    menuItem = App.MenuItem.create({ id: id });\n    return menuItem;\n  };\n\n  App.SpecialRoute = Ember.Route.extend({\n    setup: function() {\n      throw 'Setup error';\n    }\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/specials/1\");\n    menuItem.resolve(menuItem);\n  });\n\n  setTimeout(function() {\n    equal(lastFailure, 'Setup error');\n    start();\n  }, 100);\n});\n\ntest(\"Moving from one page to another triggers the correct callbacks\", function() {\n  Router.map(function() {\n    this.route(\"home\", { path: \"/\" });\n    this.resource(\"special\", { path: \"/specials/:menu_item_id\" });\n  });\n\n  var menuItem;\n\n  App.MenuItem = Ember.Object.extend(Ember.DeferredMixin);\n  App.MenuItem.find = function(id) {\n    menuItem = App.MenuItem.create({ id: id });\n    return menuItem;\n  };\n\n  App.LoadingRoute = Ember.Route.extend({\n\n  });\n\n  App.HomeRoute = Ember.Route.extend({\n\n  });\n\n  App.SpecialRoute = Ember.Route.extend({\n    setupController: function(controller, model) {\n      set(controller, 'content', model);\n    }\n  });\n\n  Ember.TEMPLATES.home = Ember.Handlebars.compile(\n    \"<h3>Home</h3>\"\n  );\n\n  Ember.TEMPLATES.special = Ember.Handlebars.compile(\n    \"<p>{{content.id}}</p>\"\n  );\n\n  Ember.TEMPLATES.loading = Ember.Handlebars.compile(\n    \"<p>LOADING!</p>\"\n  );\n\n  bootApplication();\n\n  container.register('controller:special', Ember.Controller.extend());\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  equal(Ember.$('h3', '#qunit-fixture').text(), \"Home\", \"The app is now in the initial state\");\n\n  Ember.run(function() {\n    router.transitionTo('special', App.MenuItem.create({ id: 1 }));\n  });\n\n  deepEqual(router.location.path, '/specials/1');\n});\n\ntest(\"Nested callbacks are not exited when moving to siblings\", function() {\n  Router.map(function() {\n    this.resource(\"root\", { path: \"/\" }, function() {\n      this.resource(\"special\", { path: \"/specials/:menu_item_id\" });\n    });\n  });\n\n  var currentPath;\n\n  App.ApplicationController = Ember.Controller.extend({\n    currentPathDidChange: Ember.observer(function() {\n      currentPath = get(this, 'currentPath');\n    }, 'currentPath')\n  });\n\n  var menuItem;\n\n  App.MenuItem = Ember.Object.extend(Ember.DeferredMixin);\n  App.MenuItem.find = function(id) {\n    menuItem = App.MenuItem.create({ id: id });\n    return menuItem;\n  };\n\n  App.LoadingRoute = Ember.Route.extend({\n\n  });\n\n  App.RootRoute = Ember.Route.extend({\n    model: function() {\n      rootModel++;\n      return this._super.apply(this, arguments);\n    },\n\n    serialize: function() {\n      rootSerialize++;\n      return this._super.apply(this, arguments);\n    },\n\n    setupController: function() {\n      rootSetup++;\n    },\n\n    renderTemplate: function() {\n      rootRender++;\n    }\n  });\n\n  App.HomeRoute = Ember.Route.extend({\n\n  });\n\n  App.SpecialRoute = Ember.Route.extend({\n    setupController: function(controller, model) {\n      set(controller, 'content', model);\n    }\n  });\n\n  Ember.TEMPLATES['root/index'] = Ember.Handlebars.compile(\n    \"<h3>Home</h3>\"\n  );\n\n  Ember.TEMPLATES.special = Ember.Handlebars.compile(\n    \"<p>{{content.id}}</p>\"\n  );\n\n  Ember.TEMPLATES.loading = Ember.Handlebars.compile(\n    \"<p>LOADING!</p>\"\n  );\n\n  var rootSetup = 0, rootRender = 0, rootModel = 0, rootSerialize = 0;\n\n  Ember.run(function() {\n    bootApplication();\n  });\n\n  container.register('controller:special', Ember.Controller.extend());\n\n  equal(Ember.$('h3', '#qunit-fixture').text(), \"Home\", \"The app is now in the initial state\");\n  equal(rootSetup, 1, \"The root setup was triggered\");\n  equal(rootRender, 1, \"The root render was triggered\");\n  equal(rootSerialize, 0, \"The root serialize was not called\");\n  equal(rootModel, 1, \"The root model was called\");\n\n  router = container.lookup('router:main');\n\n  Ember.run(function() {\n    router.transitionTo('special', App.MenuItem.create({ id: 1 }));\n  });\n  equal(rootSetup, 1, \"The root setup was not triggered again\");\n  equal(rootRender, 1, \"The root render was not triggered again\");\n  equal(rootSerialize, 0, \"The root serialize was not called\");\n\n  // TODO: Should this be changed?\n  equal(rootModel, 1, \"The root model was called again\");\n\n  deepEqual(router.location.path, '/specials/1');\n  equal(currentPath, 'root.special');\n});\n\nasyncTest(\"Events are triggered on the controller if a matching action name is implemented\", function() {\n  Router.map(function() {\n    this.route(\"home\", { path: \"/\" });\n  });\n\n  var model = { name: \"Tom Dale\" };\n  var stateIsNotCalled = true;\n\n  App.HomeRoute = Ember.Route.extend({\n    model: function() {\n      return model;\n    },\n\n    events: {\n      showStuff: function(obj) {\n        stateIsNotCalled = false;\n      }\n    }\n  });\n\n  Ember.TEMPLATES.home = Ember.Handlebars.compile(\n    \"<a {{action showStuff content}}>{{name}}</a>\"\n  );\n\n  var controller = Ember.Controller.extend({\n    showStuff: function(context){\n      ok (stateIsNotCalled, \"an event on the state is not triggered\");\n      deepEqual(context, { name: \"Tom Dale\" }, \"an event with context is passed\");\n      start();\n    }\n  });\n\n  container.register('controller:home', controller);\n\n  bootApplication();\n\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  var actionId = Ember.$(\"#qunit-fixture a\").data(\"ember-action\");\n  var action = Ember.Handlebars.ActionHelper.registeredActions[actionId];\n  var event = new Ember.$.Event(\"click\");\n  action.handler(event);\n});\n\nasyncTest(\"Events are triggered on the current state\", function() {\n  Router.map(function() {\n    this.route(\"home\", { path: \"/\" });\n  });\n\n  var model = { name: \"Tom Dale\" };\n\n  App.HomeRoute = Ember.Route.extend({\n    model: function() {\n      return model;\n    },\n\n    events: {\n      showStuff: function(obj) {\n        ok(this instanceof App.HomeRoute, \"the handler is an App.HomeRoute\");\n        // Using Ember.copy removes any private Ember vars which older IE would be confused by\n        deepEqual(Ember.copy(obj, true), { name: \"Tom Dale\" }, \"the context is correct\");\n        start();\n      }\n    }\n  });\n\n  Ember.TEMPLATES.home = Ember.Handlebars.compile(\n    \"<a {{action showStuff content}}>{{name}}</a>\"\n  );\n\n  bootApplication();\n\n  container.register('controller:home', Ember.Controller.extend());\n\n  //var controller = router._container.controller.home = Ember.Controller.create();\n  //controller.target = router;\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  var actionId = Ember.$(\"#qunit-fixture a\").data(\"ember-action\");\n  var action = Ember.Handlebars.ActionHelper.registeredActions[actionId];\n  var event = new Ember.$.Event(\"click\");\n  action.handler(event);\n});\n\nasyncTest(\"Events are triggered on the current state when routes are nested\", function() {\n  Router.map(function() {\n    this.resource(\"root\", { path: \"/\" }, function() {\n      this.route(\"index\", { path: \"/\" });\n    });\n  });\n\n  var model = { name: \"Tom Dale\" };\n\n  App.RootRoute = Ember.Route.extend({\n    events: {\n      showStuff: function(obj) {\n        ok(this instanceof App.RootRoute, \"the handler is an App.HomeRoute\");\n        // Using Ember.copy removes any private Ember vars which older IE would be confused by\n        deepEqual(Ember.copy(obj, true), { name: \"Tom Dale\" }, \"the context is correct\");\n        start();\n      }\n    }\n  });\n\n  App.RootIndexRoute = Ember.Route.extend({\n    model: function() {\n      return model;\n    }\n  });\n\n  Ember.TEMPLATES['root/index'] = Ember.Handlebars.compile(\n    \"<a {{action showStuff content}}>{{name}}</a>\"\n  );\n\n  bootApplication();\n\n  var actionId = Ember.$(\"#qunit-fixture a\").data(\"ember-action\");\n  var action = Ember.Handlebars.ActionHelper.registeredActions[actionId];\n  var event = new Ember.$.Event(\"click\");\n  action.handler(event);\n});\n\nasyncTest(\"actions can be triggered with multiple arguments\", function() {\n  Router.map(function() {\n    this.resource(\"root\", { path: \"/\" }, function() {\n      this.route(\"index\", { path: \"/\" });\n    });\n  });\n\n  var model1 = { name: \"Tilde\" },\n      model2 = { name: \"Tom Dale\" };\n\n  App.RootRoute = Ember.Route.extend({\n    events: {\n      showStuff: function(obj1, obj2) {\n        ok(this instanceof App.RootRoute, \"the handler is an App.HomeRoute\");\n        // Using Ember.copy removes any private Ember vars which older IE would be confused by\n        deepEqual(Ember.copy(obj1, true), { name: \"Tilde\" }, \"the first context is correct\");\n        deepEqual(Ember.copy(obj2, true), { name: \"Tom Dale\" }, \"the second context is correct\");\n        start();\n      }\n    }\n  });\n\n  App.RootIndexController = Ember.Controller.extend({\n    model1: model1,\n    model2: model2\n  });\n\n  Ember.TEMPLATES['root/index'] = Ember.Handlebars.compile(\n    \"<a {{action showStuff model1 model2}}>{{model1.name}}</a>\"\n  );\n\n  bootApplication();\n\n  var actionId = Ember.$(\"#qunit-fixture a\").data(\"ember-action\");\n  var action = Ember.Handlebars.ActionHelper.registeredActions[actionId];\n  var event = new Ember.$.Event(\"click\");\n  action.handler(event);\n});\n\ntest(\"transitioning multiple times in a single run loop only sets the URL once\", function() {\n  Router.map(function() {\n    this.route(\"root\", { path: \"/\" });\n    this.route(\"foo\");\n    this.route(\"bar\");\n  });\n\n  bootApplication();\n\n  var urlSetCount = 0;\n\n  router.get('location').setURL = function(path) {\n    urlSetCount++;\n    set(this, 'path', path);\n  };\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  equal(urlSetCount, 0);\n\n  Ember.run(function() {\n    router.transitionTo(\"foo\");\n    router.transitionTo(\"bar\");\n  });\n\n  equal(urlSetCount, 1);\n  equal(router.get('location').getURL(), \"/bar\");\n});\n\ntest('navigating away triggers a url property change', function() {\n  var urlPropertyChangeCount = 0;\n\n  Router.map(function() {\n    this.route('root', { path: '/' });\n    this.route('foo', { path: '/foo' });\n    this.route('bar', { path: '/bar' });\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    Ember.addObserver(router, 'url', function() {\n      urlPropertyChangeCount++;\n    });\n  });\n\n  equal(urlPropertyChangeCount, 0);\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  equal(urlPropertyChangeCount, 2);\n\n  Ember.run(function() {\n    // Trigger the callback that would otherwise be triggered\n    // when a user clicks the back or forward button.\n    router.router.transitionTo('foo');\n    router.router.transitionTo('bar');\n  });\n\n  equal(urlPropertyChangeCount, 4, 'triggered url property change');\n});\n\n\ntest(\"using replaceWith calls location.replaceURL if available\", function() {\n  var setCount = 0,\n      replaceCount = 0;\n\n  Router.reopen({\n    location: Ember.NoneLocation.createWithMixins({\n      setURL: function(path) {\n        setCount++;\n        set(this, 'path', path);\n      },\n\n      replaceURL: function(path) {\n        replaceCount++;\n        set(this, 'path', path);\n      }\n    })\n  });\n\n  Router.map(function() {\n    this.route(\"root\", { path: \"/\" });\n    this.route(\"foo\");\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  equal(setCount, 0);\n  equal(replaceCount, 0);\n\n  Ember.run(function() {\n    router.replaceWith(\"foo\");\n  });\n\n  equal(setCount, 0, 'should not call setURL');\n  equal(replaceCount, 1, 'should call replaceURL once');\n  equal(router.get('location').getURL(), \"/foo\");\n});\n\ntest(\"using replaceWith calls setURL if location.replaceURL is not defined\", function() {\n  var setCount = 0;\n\n  Router.reopen({\n    location: Ember.NoneLocation.createWithMixins({\n      setURL: function(path) {\n        setCount++;\n        set(this, 'path', path);\n      }\n    })\n  });\n\n  Router.map(function() {\n    this.route(\"root\", { path: \"/\" });\n    this.route(\"foo\");\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  equal(setCount, 0);\n\n  Ember.run(function() {\n    router.replaceWith(\"foo\");\n  });\n\n  equal(setCount, 1, 'should call setURL once');\n  equal(router.get('location').getURL(), \"/foo\");\n});\n\ntest(\"It is possible to get the model from a parent route\", function() {\n  expect(3);\n\n  Router.map(function() {\n    this.resource(\"post\", { path: \"/posts/:post_id\" }, function() {\n      this.resource(\"comments\");\n    });\n  });\n\n  var post1 = {}, post2 = {}, post3 = {}, currentPost;\n\n  var posts = {\n    1: post1,\n    2: post2,\n    3: post3\n  };\n\n  App.PostRoute = Ember.Route.extend({\n    model: function(params) {\n      return posts[params.post_id];\n    }\n  });\n\n  App.CommentsRoute = Ember.Route.extend({\n    model: function() {\n      equal(this.modelFor('post'), currentPost);\n    }\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    currentPost = post1;\n    router.handleURL(\"/posts/1/comments\");\n  });\n\n  Ember.run(function() {\n    currentPost = post2;\n    router.handleURL(\"/posts/2/comments\");\n  });\n\n  Ember.run(function() {\n    currentPost = post3;\n    router.handleURL(\"/posts/3/comments\");\n  });\n});\n\ntest(\"A redirection hook is provided\", function() {\n  Router.map(function() {\n    this.route(\"choose\", { path: \"/\" });\n    this.route(\"home\");\n  });\n\n  var chooseFollowed = 0, destination;\n\n  App.ChooseRoute = Ember.Route.extend({\n    redirect: function() {\n      if (destination) {\n        this.transitionTo(destination);\n      }\n    },\n\n    setupController: function() {\n      chooseFollowed++;\n    }\n  });\n\n  destination = 'home';\n\n  bootApplication();\n\n  equal(chooseFollowed, 0, \"The choose route wasn't entered since a transition occurred\");\n  equal(Ember.$(\"h3:contains(Hours)\", \"#qunit-fixture\").length, 1, \"The home template was rendered\");\n  equal(router.container.lookup('controller:application').get('currentPath'), 'home');\n});\n\ntest(\"Redirecting from the middle of a route aborts the remainder of the routes\", function() {\n  expect(2);\n\n  Router.map(function() {\n    this.route(\"home\");\n    this.resource(\"foo\", function() {\n      this.resource(\"bar\", function() {\n        this.route(\"baz\");\n      });\n    });\n  });\n\n  App.BarRoute = Ember.Route.extend({\n    redirect: function() {\n      this.transitionTo(\"home\");\n    },\n    setupController: function() {\n      ok(false, \"Should transition before setupController\");\n    }\n  });\n\n  App.BarBazRoute = Ember.Route.extend({\n    enter: function() {\n      ok(false, \"Should abort transition getting to next route\");\n    }\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/foo/bar/baz\");\n  });\n\n  equal(router.container.lookup('controller:application').get('currentPath'), 'home');\n  equal(router.get('location').getURL(), \"/home\");\n});\n\ntest(\"Transitioning from a parent event does not prevent currentPath from being set\", function() {\n  Router.map(function() {\n    this.resource(\"foo\", function() {\n      this.resource(\"bar\", function() {\n        this.route(\"baz\");\n      });\n      this.route(\"qux\");\n    });\n  });\n\n  App.FooRoute = Ember.Route.extend({\n    events: {\n      goToQux: function() {\n        this.transitionTo('foo.qux');\n      }\n    }\n  });\n\n  bootApplication();\n\n  var applicationController = router.container.lookup('controller:application');\n\n  Ember.run(function() {\n    router.handleURL(\"/foo/bar/baz\");\n  });\n\n  equal(applicationController.get('currentPath'), 'foo.bar.baz');\n\n  Ember.run(function() {\n    router.send(\"goToQux\");\n  });\n\n  equal(applicationController.get('currentPath'), 'foo.qux');\n  equal(router.get('location').getURL(), \"/foo/qux\");\n});\n\ntest(\"Generated names can be customized when providing routes with dot notation\", function() {\n  expect(3);\n\n  Ember.TEMPLATES.index = compile(\"<div>Index</div>\");\n  Ember.TEMPLATES.application = compile(\"<h1>Home</h1><div class='main'>{{outlet}}</div>\");\n  Ember.TEMPLATES.foo = compile(\"<div class='middle'>{{outlet}}</div>\");\n  Ember.TEMPLATES.bar = compile(\"<div class='bottom'>{{outlet}}</div>\");\n  Ember.TEMPLATES['bar/baz'] = compile(\"<p>{{name}}Bottom!</p>\");\n\n  Router.map(function() {\n    this.resource(\"foo\", { path: \"/top\" }, function() {\n      this.resource(\"bar\", { path: \"/middle\" }, function() {\n        this.route(\"baz\", { path: \"/bottom\" });\n      });\n    });\n  });\n\n  App.FooRoute = Ember.Route.extend({\n    renderTemplate: function() {\n      ok(true, \"FooBarRoute was called\");\n      return this._super.apply(this, arguments);\n    }\n  });\n\n  App.BarBazRoute = Ember.Route.extend({\n    renderTemplate: function() {\n      ok(true, \"BarBazRoute was called\");\n      return this._super.apply(this, arguments);\n    }\n  });\n\n  App.BarController = Ember.Controller.extend({\n    name: \"Bar\"\n  });\n\n  App.BarBazController = Ember.Controller.extend({\n    name: \"BarBaz\"\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/top/middle/bottom\");\n  });\n\n  equal(Ember.$('.main .middle .bottom p', '#qunit-fixture').text(), \"BarBazBottom!\", \"The templates were rendered into their appropriate parents\");\n});\n\ntest(\"Child routes render into their parent route's template by default\", function() {\n  Ember.TEMPLATES.index = compile(\"<div>Index</div>\");\n  Ember.TEMPLATES.application = compile(\"<h1>Home</h1><div class='main'>{{outlet}}</div>\");\n  Ember.TEMPLATES.top = compile(\"<div class='middle'>{{outlet}}</div>\");\n  Ember.TEMPLATES.middle = compile(\"<div class='bottom'>{{outlet}}</div>\");\n  Ember.TEMPLATES['middle/bottom'] = compile(\"<p>Bottom!</p>\");\n\n  Router.map(function() {\n    this.resource(\"top\", function() {\n      this.resource(\"middle\", function() {\n        this.route(\"bottom\");\n      });\n    });\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/top/middle/bottom\");\n  });\n\n  equal(Ember.$('.main .middle .bottom p', '#qunit-fixture').text(), \"Bottom!\", \"The templates were rendered into their appropriate parents\");\n});\n\ntest(\"Child routes render into specified template\", function() {\n  Ember.TEMPLATES.index = compile(\"<div>Index</div>\");\n  Ember.TEMPLATES.application = compile(\"<h1>Home</h1><div class='main'>{{outlet}}</div>\");\n  Ember.TEMPLATES.top = compile(\"<div class='middle'>{{outlet}}</div>\");\n  Ember.TEMPLATES.middle = compile(\"<div class='bottom'>{{outlet}}</div>\");\n  Ember.TEMPLATES['middle/bottom'] = compile(\"<p>Bottom!</p>\");\n\n  Router.map(function() {\n    this.resource(\"top\", function() {\n      this.resource(\"middle\", function() {\n        this.route(\"bottom\");\n      });\n    });\n  });\n\n  App.MiddleBottomRoute = Ember.Route.extend({\n    renderTemplate: function() {\n      this.render('middle/bottom', { into: 'top' });\n    }\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/top/middle/bottom\");\n  });\n\n  equal(Ember.$('.main .middle .bottom p', '#qunit-fixture').length, 0, \"should not render into the middle template\");\n  equal(Ember.$('.main .middle > p', '#qunit-fixture').text(), \"Bottom!\", \"The template was rendered into the top template\");\n});\n\ntest(\"Rendering into specified template with slash notation\", function() {\n  Ember.TEMPLATES['person/profile'] = compile(\"profile {{outlet}}\");\n  Ember.TEMPLATES['person/details'] = compile(\"details!\");\n\n  Router.map(function() {\n    this.resource(\"home\", { path: '/' });\n  });\n\n  App.HomeRoute = Ember.Route.extend({\n    renderTemplate: function() {\n      this.render('person/profile');\n      this.render('person/details', { into: 'person/profile' });\n    }\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/\");\n  });\n\n  equal(Ember.$('#qunit-fixture:contains(profile details!)').length, 1, \"The templates were rendered\");\n});\n\n\ntest(\"Parent route context change\", function() {\n  var editCount = 0,\n      editedPostIds = Ember.A();\n\n  Ember.TEMPLATES.application = compile(\"{{outlet}}\");\n  Ember.TEMPLATES.posts = compile(\"{{outlet}}\");\n  Ember.TEMPLATES.post = compile(\"{{outlet}}\");\n  Ember.TEMPLATES['post/index'] = compile(\"showing\");\n  Ember.TEMPLATES['post/edit'] = compile(\"editing\");\n\n  Router.map(function() {\n    this.resource(\"posts\", function() {\n      this.resource(\"post\", { path: \"/:postId\" }, function() {\n        this.route(\"edit\");\n      });\n    });\n  });\n\n  App.PostsRoute = Ember.Route.extend({\n    events: {\n      showPost: function(context) {\n        this.transitionTo('post', context);\n      }\n    }\n  });\n\n  App.PostRoute = Ember.Route.extend({\n    model: function(params) {\n      return {id: params.postId};\n    },\n\n    events: {\n      editPost: function(context) {\n        this.transitionTo('post.edit');\n      }\n    }\n  });\n\n  App.PostEditRoute = Ember.Route.extend({\n    model: function(params) {\n      var postId = this.modelFor(\"post\").id;\n      editedPostIds.push(postId);\n      return null;\n    },\n    setup: function() {\n      this._super.apply(this, arguments);\n      editCount++;\n    }\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/posts/1\");\n  });\n\n  Ember.run(function() {\n    router.send('editPost');\n  });\n\n  Ember.run(function() {\n    router.send('showPost', {id: '2'});\n  });\n\n  Ember.run(function() {\n    router.send('editPost');\n  });\n\n  equal(editCount, 2, 'set up the edit route twice without failure');\n  deepEqual(editedPostIds, ['1', '2'], 'modelFor posts.post returns the right context');\n});\n\ntest(\"Calling controllerFor for a non-route controller returns a controller\", function() {\n  var controller;\n\n  App.ApplicationRoute = Ember.Route.extend({\n    setupController: function() {\n      controller = this.controllerFor('nonDefinedRoute', {});\n    }\n  });\n\n  bootApplication();\n\n  ok(controller instanceof Ember.ObjectController, \"controller was able to be retrieved\");\n});\n\ntest(\"Router accounts for rootURL on page load when using history location\", function() {\n  var rootURL = window.location.pathname + '/app',\n      postsTemplateRendered = false,\n      setHistory,\n      HistoryTestLocation;\n\n  setHistory = function(obj, path) {\n    obj.set('history', { state: { path: path } });\n  };\n\n  // Create new implementation that extends HistoryLocation\n  // and set current location to rootURL + '/posts'\n  HistoryTestLocation = Ember.HistoryLocation.extend({\n    initState: function() {\n      var path = rootURL + '/posts';\n\n      setHistory(this, path);\n      this.set('location', {\n        pathname: path\n      });\n    },\n\n    replaceState: function(path) {\n      setHistory(this, path);\n    },\n\n    pushState: function(path) {\n      setHistory(this, path);\n    }\n  });\n\n  Ember.Location.registerImplementation('historyTest', HistoryTestLocation);\n\n  Router.reopen({\n    location: 'historyTest',\n    rootURL: rootURL\n  });\n\n  Router.map(function() {\n    this.resource(\"posts\", { path: '/posts' });\n  });\n\n  App.PostsRoute = Ember.Route.extend({\n    model: function() {},\n    renderTemplate: function() {\n      postsTemplateRendered = true;\n    }\n  });\n\n  bootApplication();\n\n  ok(postsTemplateRendered, \"Posts route successfully stripped from rootURL\");\n\n  // clean after test\n  delete Ember.Location.implementations['historyTest'];\n});\n\ntest(\"Only use route rendered into main outlet for default into property on child\", function() {\n  Ember.TEMPLATES.application = compile(\"{{outlet menu}}{{outlet}}\");\n  Ember.TEMPLATES.posts = compile(\"{{outlet}}\");\n  Ember.TEMPLATES['posts/index'] = compile(\"postsIndex\");\n  Ember.TEMPLATES['posts/menu'] = compile(\"postsMenu\");\n\n  Router.map(function() {\n    this.resource(\"posts\", function() {});\n  });\n\n  App.PostsMenuView = Ember.View.extend({\n    tagName: 'div',\n    templateName: 'posts/menu',\n    classNames: ['posts-menu']\n  });\n\n  App.PostsIndexView = Ember.View.extend({\n    tagName: 'section',\n    classNames: ['posts-index']\n  });\n\n  App.PostsRoute = Ember.Route.extend({\n    renderTemplate: function() {\n      this.render();\n      this.render('postsMenu', {\n        into: 'application',\n        outlet: 'menu'\n      });\n    }\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/posts\");\n  });\n\n  equal(Ember.$('div.posts-menu:contains(postsMenu)', '#qunit-fixture').length, 1, \"The posts/menu template was rendered\");\n  equal(Ember.$('section.posts-index:contains(postsIndex)', '#qunit-fixture').length, 1, \"The posts/index template was rendered\");\n});\n\ntest(\"Generating a URL should not affect currentModel\", function() {\n  Router.map(function() {\n    this.route(\"post\", { path: \"/posts/:post_id\" });\n  });\n\n  var posts = {\n    1: { id: 1 },\n    2: { id: 2 }\n  };\n\n  App.PostRoute = Ember.Route.extend({\n    model: function(params) {\n      return posts[params.post_id];\n    }\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/posts/1\");\n  });\n\n  var route = container.lookup('route:post');\n  equal(route.modelFor('post'), posts[1]);\n\n  var url = router.generate('post', posts[2]);\n  equal(url, \"/posts/2\");\n\n  equal(route.modelFor('post'), posts[1]);\n});\n\n\ntest(\"Generated route should be an instance of App.Route if provided\", function() {\n  var generatedRoute;\n\n  Router.map(function() {\n    this.route('posts');\n  });\n\n  App.Route = Ember.Route.extend();\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.handleURL(\"/posts\");\n  });\n\n  generatedRoute = container.lookup('route:posts');\n\n  ok(generatedRoute instanceof App.Route, 'should extend the correct route');\n\n});\n\ntest(\"Nested index route is not overriden by parent's implicit index route\", function() {\n  Router.map(function() {\n    this.resource('posts', function() {\n      this.route('index', { path: ':category' } );\n    });\n  });\n\n  App.Route = Ember.Route.extend({\n    serialize: function(model) {\n      return { category: model.category };\n    }\n  });\n\n  bootApplication();\n\n  Ember.run(function() {\n    router.transitionTo('posts', { category: 'emberjs' });\n  });\n\n  deepEqual(router.location.path, '/posts/emberjs');\n});\n\n})();\n//@ sourceURL=ember/~tests/routing/basic_test");