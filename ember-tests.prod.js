;(function() {
/*!
 * @overview  Ember - JavaScript Application Framework
 * @copyright Copyright 2011-2017 Tilde Inc. and contributors
 *            Portions Copyright 2006-2011 Strobe Inc.
 *            Portions Copyright 2008-2011 Apple Inc. All rights reserved.
 * @license   Licensed under MIT license
 *            See https://raw.github.com/emberjs/ember.js/master/LICENSE
 * @version   2.12.0-canary-with-backtracking
 */

var enifed, requireModule, Ember;
var mainContext = this; // Used in ember-environment/lib/global.js

(function() {
  var isNode = typeof window === 'undefined' &&
    typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

  if (!isNode) {
    Ember = this.Ember = this.Ember || {};
  }

  if (typeof Ember === 'undefined') { Ember = {}; }

  if (typeof Ember.__loader === 'undefined') {
    var registry = {};
    var seen = {};

    enifed = function(name, deps, callback) {
      var value = { };

      if (!callback) {
        value.deps = [];
        value.callback = deps;
      } else {
        value.deps = deps;
        value.callback = callback;
      }

      registry[name] = value;
    };

    requireModule = function(name) {
      return internalRequire(name, null);
    };

    // setup `require` module
    requireModule['default'] = requireModule;

    requireModule.has = function registryHas(moduleName) {
      return !!registry[moduleName] || !!registry[moduleName + '/index'];
    };

    function missingModule(name, referrerName) {
      if (referrerName) {
        throw new Error('Could not find module ' + name + ' required by: ' + referrerName);
      } else {
        throw new Error('Could not find module ' + name);
      }
    }

    function internalRequire(_name, referrerName) {
      var name = _name;
      var mod = registry[name];

      if (!mod) {
        name = name + '/index';
        mod = registry[name];
      }

      var exports = seen[name];

      if (exports !== undefined) {
        return exports;
      }

      exports = seen[name] = {};

      if (!mod) {
        missingModule(_name, referrerName);
      }

      var deps = mod.deps;
      var callback = mod.callback;
      var reified = new Array(deps.length);

      for (var i = 0; i < deps.length; i++) {
        if (deps[i] === 'exports') {
          reified[i] = exports;
        } else if (deps[i] === 'require') {
          reified[i] = requireModule;
        } else {
          reified[i] = internalRequire(deps[i], name);
        }
      }

      callback.apply(this, reified);

      return exports;
    }

    requireModule._eak_seen = registry;

    Ember.__loader = {
      define: enifed,
      require: requireModule,
      registry: registry
    };
  } else {
    enifed = Ember.__loader.define;
    requireModule = Ember.__loader.require;
  }
})();

function inherits(subClass, superClass) {
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });

  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : defaults(subClass, superClass);
}

function taggedTemplateLiteralLoose(strings, raw) {
  strings.raw = raw;
  return strings;
}

function defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ('value' in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function createClass(Constructor, protoProps, staticProps) {
  if (protoProps) defineProperties(Constructor.prototype, protoProps);
  if (staticProps) defineProperties(Constructor, staticProps);
  return Constructor;
}

function interopExportWildcard(obj, defaults) {
  var newObj = defaults({}, obj);
  delete newObj['default'];
  return newObj;
}

function defaults(obj, defaults) {
  var keys = Object.getOwnPropertyNames(defaults);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var value = Object.getOwnPropertyDescriptor(defaults, key);
    if (value && value.configurable && obj[key] === undefined) {
      Object.defineProperty(obj, key, value);
    }
  }
  return obj;
}

babelHelpers = {
  inherits: inherits,
  taggedTemplateLiteralLoose: taggedTemplateLiteralLoose,
  slice: Array.prototype.slice,
  createClass: createClass,
  interopExportWildcard: interopExportWildcard,
  defaults: defaults
};

enifed('container/container.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | container/container.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'container/container.js should pass ESLint\n\n');
  });
});
enifed('container/index.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | container/index.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'container/index.js should pass ESLint\n\n');
  });
});
enifed('container/registry.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | container/registry.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'container/registry.js should pass ESLint\n\n');
  });
});
enifed('container/tests/container_test', ['exports', 'ember-utils', 'ember-environment', 'ember-metal', 'container/index', 'internal-test-helpers', 'container'], function (exports, _emberUtils, _emberEnvironment, _emberMetal, _containerIndex, _internalTestHelpers, _container) {
  'use strict';

  var originalModelInjections = undefined;

  QUnit.module('Container', {
    setup: function () {
      originalModelInjections = _emberEnvironment.ENV.MODEL_FACTORY_INJECTIONS;
    },
    teardown: function () {
      _emberEnvironment.ENV.MODEL_FACTORY_INJECTIONS = originalModelInjections;
    }
  });

  function lookupFactory(name, container, options) {
    return container[_container.LOOKUP_FACTORY](name, options);
  }

  QUnit.test('A registered factory returns the same instance each time', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostController = _internalTestHelpers.factory();

    registry.register('controller:post', PostController);

    var postController = container.lookup('controller:post');

    ok(postController instanceof PostController, 'The lookup is an instance of the factory');

    equal(postController, container.lookup('controller:post'));
  });

  QUnit.test('A registered factory is returned from lookupFactory', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostController = _internalTestHelpers.factory();

    registry.register('controller:post', PostController);

    var PostControllerFactory = lookupFactory('controller:post', container);

    ok(PostControllerFactory, 'factory is returned');
    ok(PostControllerFactory.create() instanceof PostController, 'The return of factory.create is an instance of PostController');
  });

  QUnit.test('A registered factory is returned from lookupFactory is the same factory each time', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostController = _internalTestHelpers.factory();

    registry.register('controller:post', PostController);

    var Post1 = lookupFactory('controller:post', container);
    var Post2 = lookupFactory('controller:post', container);

    deepEqual(Post1, Post2, 'The return of lookupFactory is always the same');
  });

  QUnit.test('A factory returned from lookupFactory has a debugkey', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostController = _internalTestHelpers.factory();

    registry.register('controller:post', PostController);
    var PostFactory = lookupFactory('controller:post', container);
    equal(PostFactory._debugContainerKey, 'controller:post', 'factory instance receives _debugContainerKey');
  });

  QUnit.test('fallback for to create time injections if factory has no extend', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var AppleController = _internalTestHelpers.factory();
    var PostController = _internalTestHelpers.factory();

    PostController.extend = undefined; // remove extend

    registry.register('controller:apple', AppleController);
    registry.register('controller:post', PostController);
    registry.injection('controller:post', 'apple', 'controller:apple');

    var postController = container.lookup('controller:post');

    equal(postController._debugContainerKey, 'controller:post', 'instance receives _debugContainerKey');
    ok(postController.apple instanceof AppleController, 'instance receives an apple of instance AppleController');
  });

  QUnit.test('The descendants of a factory returned from lookupFactory have a container and debugkey', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostController = _internalTestHelpers.factory();
    var instance = undefined;

    registry.register('controller:post', PostController);
    instance = lookupFactory('controller:post', container).create();

    equal(instance._debugContainerKey, 'controller:post', 'factory instance receives _debugContainerKey');

    ok(instance instanceof PostController, 'factory instance is instance of factory');
  });

  QUnit.test('A registered factory returns a fresh instance if singleton: false is passed as an option', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostController = _internalTestHelpers.factory();

    registry.register('controller:post', PostController);

    var postController1 = container.lookup('controller:post');
    var postController2 = container.lookup('controller:post', { singleton: false });
    var postController3 = container.lookup('controller:post', { singleton: false });
    var postController4 = container.lookup('controller:post');

    equal(postController1.toString(), postController4.toString(), 'Singleton factories looked up normally return the same value');
    notEqual(postController1.toString(), postController2.toString(), 'Singleton factories are not equal to factories looked up with singleton: false');
    notEqual(postController2.toString(), postController3.toString(), 'Two factories looked up with singleton: false are not equal');
    notEqual(postController3.toString(), postController4.toString(), 'A singleton factory looked up after a factory called with singleton: false is not equal');

    ok(postController1 instanceof PostController, 'All instances are instances of the registered factory');
    ok(postController2 instanceof PostController, 'All instances are instances of the registered factory');
    ok(postController3 instanceof PostController, 'All instances are instances of the registered factory');
    ok(postController4 instanceof PostController, 'All instances are instances of the registered factory');
  });

  QUnit.test('A factory type with a registered injection\'s instances receive that injection', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostController = _internalTestHelpers.factory();
    var Store = _internalTestHelpers.factory();

    registry.register('controller:post', PostController);
    registry.register('store:main', Store);

    registry.typeInjection('controller', 'store', 'store:main');

    var postController = container.lookup('controller:post');
    var store = container.lookup('store:main');

    equal(postController.store, store);
  });

  QUnit.test('An individual factory with a registered injection receives the injection', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostController = _internalTestHelpers.factory();
    var Store = _internalTestHelpers.factory();

    registry.register('controller:post', PostController);
    registry.register('store:main', Store);

    registry.injection('controller:post', 'store', 'store:main');

    var postController = container.lookup('controller:post');
    var store = container.lookup('store:main');

    equal(store._debugContainerKey, 'store:main');

    equal(postController._debugContainerKey, 'controller:post');
    equal(postController.store, store, 'has the correct store injected');
  });

  QUnit.test('A factory with both type and individual injections', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostController = _internalTestHelpers.factory();
    var Store = _internalTestHelpers.factory();
    var Router = _internalTestHelpers.factory();

    registry.register('controller:post', PostController);
    registry.register('store:main', Store);
    registry.register('router:main', Router);

    registry.injection('controller:post', 'store', 'store:main');
    registry.typeInjection('controller', 'router', 'router:main');

    var postController = container.lookup('controller:post');
    var store = container.lookup('store:main');
    var router = container.lookup('router:main');

    equal(postController.store, store);
    equal(postController.router, router);
  });

  QUnit.test('A factory with both type and individual factoryInjections', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostController = _internalTestHelpers.factory();
    var Store = _internalTestHelpers.factory();
    var Router = _internalTestHelpers.factory();

    registry.register('controller:post', PostController);
    registry.register('store:main', Store);
    registry.register('router:main', Router);

    registry.factoryInjection('controller:post', 'store', 'store:main');
    registry.factoryTypeInjection('controller', 'router', 'router:main');

    var PostControllerFactory = lookupFactory('controller:post', container);
    var store = container.lookup('store:main');
    var router = container.lookup('router:main');

    equal(PostControllerFactory.store, store, 'PostControllerFactory has the instance of store');
    equal(PostControllerFactory.router, router, 'PostControllerFactory has the route instance');
  });

  QUnit.test('A non-singleton instance is never cached', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostView = _internalTestHelpers.factory();

    registry.register('view:post', PostView, { singleton: false });

    var postView1 = container.lookup('view:post');
    var postView2 = container.lookup('view:post');

    ok(postView1 !== postView2, 'Non-singletons are not cached');
  });

  QUnit.test('A non-instantiated property is not instantiated', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();

    var template = function () {};
    registry.register('template:foo', template, { instantiate: false });
    equal(container.lookup('template:foo'), template);
  });

  QUnit.test('A failed lookup returns undefined', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();

    equal(container.lookup('doesnot:exist'), undefined);
  });

  QUnit.test('An invalid factory throws an error', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();

    registry.register('controller:foo', {});

    throws(function () {
      container.lookup('controller:foo');
    }, /Failed to create an instance of \'controller:foo\'/);
  });

  QUnit.test('Injecting a failed lookup raises an error', function () {
    _emberEnvironment.ENV.MODEL_FACTORY_INJECTIONS = true;

    var registry = new _containerIndex.Registry();
    var container = registry.container();

    var fooInstance = {};
    var fooFactory = {};

    var Foo = {
      create: function (args) {
        return fooInstance;
      },
      extend: function (args) {
        return fooFactory;
      }
    };

    registry.register('model:foo', Foo);
    registry.injection('model:foo', 'store', 'store:main');

    throws(function () {
      container.lookup('model:foo');
    });
  });

  QUnit.test('Injecting a falsy value does not raise an error', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var ApplicationController = _internalTestHelpers.factory();

    registry.register('controller:application', ApplicationController);
    registry.register('user:current', null, { instantiate: false });
    registry.injection('controller:application', 'currentUser', 'user:current');

    strictEqual(container.lookup('controller:application').currentUser, null);
  });

  QUnit.test('The container returns same value each time even if the value is falsy', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();

    registry.register('falsy:value', null, { instantiate: false });

    strictEqual(container.lookup('falsy:value'), container.lookup('falsy:value'));
  });

  QUnit.test('Destroying the container destroys any cached singletons', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostController = _internalTestHelpers.factory();
    var PostView = _internalTestHelpers.factory();
    var template = function () {};

    registry.register('controller:post', PostController);
    registry.register('view:post', PostView, { singleton: false });
    registry.register('template:post', template, { instantiate: false });

    registry.injection('controller:post', 'postView', 'view:post');

    var postController = container.lookup('controller:post');
    var postView = postController.postView;

    ok(postView instanceof PostView, 'The non-singleton was injected');

    container.destroy();

    ok(postController.isDestroyed, 'Singletons are destroyed');
    ok(!postView.isDestroyed, 'Non-singletons are not destroyed');
  });

  QUnit.test('The container can use a registry hook to resolve factories lazily', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostController = _internalTestHelpers.factory();

    registry.resolver = {
      resolve: function (fullName) {
        if (fullName === 'controller:post') {
          return PostController;
        }
      }
    };

    var postController = container.lookup('controller:post');

    ok(postController instanceof PostController, 'The correct factory was provided');
  });

  QUnit.test('The container normalizes names before resolving', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostController = _internalTestHelpers.factory();

    registry.normalizeFullName = function (fullName) {
      return 'controller:post';
    };

    registry.register('controller:post', PostController);
    var postController = container.lookup('controller:normalized');

    ok(postController instanceof PostController, 'Normalizes the name before resolving');
  });

  QUnit.test('The container normalizes names when looking factory up', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostController = _internalTestHelpers.factory();

    registry.normalizeFullName = function (fullName) {
      return 'controller:post';
    };

    registry.register('controller:post', PostController);
    var fact = lookupFactory('controller:normalized', container);

    equal(fact.toString() === PostController.extend().toString(), true, 'Normalizes the name when looking factory up');
  });

  QUnit.test('Options can be registered that should be applied to a given factory', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostView = _internalTestHelpers.factory();

    registry.resolver = {
      resolve: function (fullName) {
        if (fullName === 'view:post') {
          return PostView;
        }
      }
    };

    registry.options('view:post', { instantiate: true, singleton: false });

    var postView1 = container.lookup('view:post');
    var postView2 = container.lookup('view:post');

    ok(postView1 instanceof PostView, 'The correct factory was provided');
    ok(postView2 instanceof PostView, 'The correct factory was provided');

    ok(postView1 !== postView2, 'The two lookups are different');
  });

  QUnit.test('Options can be registered that should be applied to all factories for a given type', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostView = _internalTestHelpers.factory();

    registry.resolver = {
      resolve: function (fullName) {
        if (fullName === 'view:post') {
          return PostView;
        }
      }
    };

    registry.optionsForType('view', { singleton: false });

    var postView1 = container.lookup('view:post');
    var postView2 = container.lookup('view:post');

    ok(postView1 instanceof PostView, 'The correct factory was provided');
    ok(postView2 instanceof PostView, 'The correct factory was provided');

    ok(postView1 !== postView2, 'The two lookups are different');
  });

  QUnit.test('An injected non-singleton instance is never cached', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostView = _internalTestHelpers.factory();
    var PostViewHelper = _internalTestHelpers.factory();

    registry.register('view:post', PostView, { singleton: false });
    registry.register('view_helper:post', PostViewHelper, { singleton: false });
    registry.injection('view:post', 'viewHelper', 'view_helper:post');

    var postView1 = container.lookup('view:post');
    var postView2 = container.lookup('view:post');

    ok(postView1.viewHelper !== postView2.viewHelper, 'Injected non-singletons are not cached');
  });

  QUnit.test('Factory resolves are cached', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostController = _internalTestHelpers.factory();
    var resolveWasCalled = [];
    registry.resolve = function (fullName) {
      resolveWasCalled.push(fullName);
      return PostController;
    };

    deepEqual(resolveWasCalled, []);
    lookupFactory('controller:post', container);
    deepEqual(resolveWasCalled, ['controller:post']);

    lookupFactory('controller:post', container);
    deepEqual(resolveWasCalled, ['controller:post']);
  });

  QUnit.test('factory for non extendables (MODEL) resolves are cached', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostController = _internalTestHelpers.factory();
    var resolveWasCalled = [];
    registry.resolve = function (fullName) {
      resolveWasCalled.push(fullName);
      return PostController;
    };

    deepEqual(resolveWasCalled, []);
    lookupFactory('model:post', container);
    deepEqual(resolveWasCalled, ['model:post']);

    lookupFactory('model:post', container);
    deepEqual(resolveWasCalled, ['model:post']);
  });

  QUnit.test('factory for non extendables resolves are cached', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostController = {};
    var resolveWasCalled = [];

    registry.resolve = function (fullName) {
      resolveWasCalled.push(fullName);
      return PostController;
    };

    deepEqual(resolveWasCalled, []);
    lookupFactory('foo:post', container);
    deepEqual(resolveWasCalled, ['foo:post']);

    lookupFactory('foo:post', container);
    deepEqual(resolveWasCalled, ['foo:post']);
  });

  QUnit.test('The `_onLookup` hook is called on factories when looked up the first time', function () {
    expect(2);

    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var Apple = _internalTestHelpers.factory();

    Apple.reopenClass({
      _onLookup: function (fullName) {
        equal(fullName, 'apple:main', 'calls lazy injection method with the lookup full name');
        equal(this, Apple, 'calls lazy injection method in the factory context');
      }
    });

    registry.register('apple:main', Apple);

    lookupFactory('apple:main', container);
    lookupFactory('apple:main', container);
  });

  QUnit.test('A factory\'s lazy injections are validated when first instantiated', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var Apple = _internalTestHelpers.factory();
    var Orange = _internalTestHelpers.factory();

    Apple.reopenClass({
      _lazyInjections: function () {
        return ['orange:main', 'banana:main'];
      }
    });

    registry.register('apple:main', Apple);
    registry.register('orange:main', Orange);

    throws(function () {
      container.lookup('apple:main');
    }, /Attempting to inject an unknown injection: 'banana:main'/);
  });

  QUnit.test('Lazy injection validations are cached', function () {
    expect(1);

    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var Apple = _internalTestHelpers.factory();
    var Orange = _internalTestHelpers.factory();

    Apple.reopenClass({
      _lazyInjections: function () {
        ok(true, 'should call lazy injection method');
        return ['orange:main'];
      }
    });

    registry.register('apple:main', Apple);
    registry.register('orange:main', Orange);

    container.lookup('apple:main');
    container.lookup('apple:main');
  });

  QUnit.test('An object with its owner pre-set should be returned from ownerInjection', function () {
    var owner = {};
    var registry = new _containerIndex.Registry();
    var container = registry.container({ owner: owner });

    var result = container.ownerInjection();

    equal(result[_emberUtils.OWNER], owner, 'owner is properly included');
  });

  QUnit.test('A deprecated `container` property is appended to every object instantiated from an extendable factory', function () {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostController = _internalTestHelpers.factory();
    registry.register('controller:post', PostController);
    var postController = container.lookup('controller:post');

    expectDeprecation(function () {
      _emberMetal.get(postController, 'container');
    }, 'Using the injected `container` is deprecated. Please use the `getOwner` helper instead to access the owner of this object.');

    expectDeprecation(function () {
      var c = postController.container;
      strictEqual(c, container);
    }, 'Using the injected `container` is deprecated. Please use the `getOwner` helper instead to access the owner of this object.');
  });

  // This is testing that container was passed as an option
  QUnit.test('A deprecated `container` property is appended to every object instantiated from a non-extendable factory, and a fake container is available during instantiation.', function () {
    if (!true) {
      expect(8);
    } else {
      expect(1);
      ok(true, '[SKIPPED] This will be removed when `factoryFor` lands.');
    }

    var owner = {};
    var registry = new _containerIndex.Registry();
    var container = registry.container({ owner: owner });

    // Define a simple non-extendable factory
    function PostController(options) {
      this.container = options.container;
    }

    PostController.create = function (options) {
      ok(options.container, 'fake container has been injected and is available during `create`.');

      expectDeprecation(function () {
        options.container.lookup('abc:one');
      }, 'Using the injected `container` is deprecated. Please use the `getOwner` helper to access the owner of this object and then call `lookup` instead.');

      expectDeprecation(function () {
        options.container.lookupFactory('abc:two');
      }, 'Using the injected `container` is deprecated. Please use the `getOwner` helper to access the owner of this object and then call `_lookupFactory` instead.');

      // non-deprecated usage of `lookup` and `_lookupFactory`
      owner.lookup = function (fullName) {
        equal(fullName, 'abc:one', 'lookup on owner called properly');
      };
      owner._lookupFactory = function (fullName) {
        equal(fullName, 'abc:two', '_lookupFactory on owner called properly');
      };
      var foundOwner = _emberUtils.getOwner(options);
      foundOwner.lookup('abc:one');
      foundOwner._lookupFactory('abc:two');

      return new PostController(options);
    };

    registry.register('controller:post', PostController);

    if (!true) {
      (function () {
        var postController = container.lookup('controller:post');

        expectDeprecation(function () {
          _emberMetal.get(postController, 'container');
        }, 'Using the injected `container` is deprecated. Please use the `getOwner` helper instead to access the owner of this object.');

        expectDeprecation(function () {
          var c = postController.container;
          strictEqual(c, container, 'Injected container is now regular (not fake) container, but access is still deprecated.');
        }, 'Using the injected `container` is deprecated. Please use the `getOwner` helper instead to access the owner of this object.');
      })();
    }
  });

  QUnit.test('An extendable factory can provide `container` upon create, with a deprecation', function (assert) {
    var registry = new _containerIndex.Registry();
    var container = registry.container();

    registry.register('controller:post', _internalTestHelpers.factory());

    var PostController = lookupFactory('controller:post', container);

    var postController = undefined;

    expectDeprecation(function () {
      postController = PostController.create({
        container: 'foo'
      });
    }, /Providing the \`container\` property to .+ is deprecated. Please use \`Ember.setOwner\` or \`owner.ownerInjection\(\)\` instead to provide an owner to the instance being created/);

    expectDeprecation(function () {
      var c = postController.container;
      assert.equal(c, 'foo', 'the `container` provided to `.create`was used');
    }, 'Using the injected `container` is deprecated. Please use the `getOwner` helper instead to access the owner of this object.');
  });

  QUnit.test('lookupFactory passes options through to expandlocallookup', function (assert) {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostController = _internalTestHelpers.factory();

    registry.register('controller:post', PostController);

    registry.expandLocalLookup = function (fullName, options) {
      assert.ok(true, 'expandLocalLookup was called');
      assert.equal(fullName, 'foo:bar');
      assert.deepEqual(options, { source: 'baz:qux' });

      return 'controller:post';
    };

    var PostControllerFactory = lookupFactory('foo:bar', container, { source: 'baz:qux' });

    assert.ok(PostControllerFactory.create() instanceof PostController, 'The return of factory.create is an instance of PostController');
  });

  QUnit.test('lookup passes options through to expandlocallookup', function (assert) {
    var registry = new _containerIndex.Registry();
    var container = registry.container();
    var PostController = _internalTestHelpers.factory();

    registry.register('controller:post', PostController);
    registry.expandLocalLookup = function (fullName, options) {
      assert.ok(true, 'expandLocalLookup was called');
      assert.equal(fullName, 'foo:bar');
      assert.deepEqual(options, { source: 'baz:qux' });

      return 'controller:post';
    };

    var PostControllerLookupResult = container.lookup('foo:bar', { source: 'baz:qux' });

    assert.ok(PostControllerLookupResult instanceof PostController);
  });

  QUnit.test('#[FACTORY_FOR] class is the injected factory', function (assert) {
    var registry = new _containerIndex.Registry();
    var container = registry.container();

    var Component = _internalTestHelpers.factory();
    registry.register('component:foo-bar', Component);

    var factoryCreator = container[_container.FACTORY_FOR]('component:foo-bar');
    if (_emberMetal.isFeatureEnabled('ember-no-double-extend')) {
      assert.deepEqual(factoryCreator.class, Component, 'No double extend');
    } else {
      assert.deepEqual(factoryCreator.class, lookupFactory('component:foo-bar', container), 'Double extended class');
    }
  });

  if (true) {
    QUnit.test('#factoryFor must supply a fullname', function (assert) {
      var registry = new _containerIndex.Registry();
      var container = registry.container();
      assert.throws(function () {
        container.factoryFor('chad-bar');
      }, /Invalid Fullname, expected: 'type:name' got: chad-bar/);
    });

    QUnit.test('#factoryFor returns a factory creator', function (assert) {
      var registry = new _containerIndex.Registry();
      var container = registry.container();

      var Component = _internalTestHelpers.factory();
      registry.register('component:foo-bar', Component);

      var factoryCreator = container.factoryFor('component:foo-bar');
      assert.ok(factoryCreator.create);
      assert.ok(factoryCreator.class);
    });

    QUnit.test('#factoryFor class returns the factory function', function (assert) {
      var registry = new _containerIndex.Registry();
      var container = registry.container();

      var Component = _internalTestHelpers.factory();
      registry.register('component:foo-bar', Component);

      var factoryCreator = container.factoryFor('component:foo-bar');
      assert.deepEqual(factoryCreator.class, Component, 'No double extend');
    });

    QUnit.test('#factoryFor instance have a common parent', function (assert) {
      var registry = new _containerIndex.Registry();
      var container = registry.container();

      var Component = _internalTestHelpers.factory();
      registry.register('component:foo-bar', Component);

      var factoryCreator1 = container.factoryFor('component:foo-bar');
      var factoryCreator2 = container.factoryFor('component:foo-bar');
      var instance1 = factoryCreator1.create({ foo: 'foo' });
      var instance2 = factoryCreator2.create({ bar: 'bar' });

      assert.deepEqual(instance1.constructor, instance2.constructor);
    });

    QUnit.test('#factoryFor created instances come with instance injections', function (assert) {
      var registry = new _containerIndex.Registry();
      var container = registry.container();

      var Component = _internalTestHelpers.factory();
      var Ajax = _internalTestHelpers.factory();
      registry.register('component:foo-bar', Component);
      registry.register('util:ajax', Ajax);
      registry.injection('component:foo-bar', 'ajax', 'util:ajax');

      var componentFactory = container.factoryFor('component:foo-bar');
      var component = componentFactory.create();

      assert.ok(component.ajax);
      assert.ok(component.ajax instanceof Ajax);
    });

    QUnit.test('#factoryFor options passed to create clobber injections', function (assert) {
      var registry = new _containerIndex.Registry();
      var container = registry.container();

      var Component = _internalTestHelpers.factory();
      var Ajax = _internalTestHelpers.factory();
      registry.register('component:foo-bar', Component);
      registry.register('util:ajax', Ajax);
      registry.injection('component:foo-bar', 'ajax', 'util:ajax');

      var componentFactory = container.factoryFor('component:foo-bar');

      var instrance = componentFactory.create({ ajax: 'fetch' });

      assert.equal(instrance.ajax, 'fetch');
    });
  }
});
enifed('container/tests/container_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | container/tests/container_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'container/tests/container_test.js should pass ESLint\n\n');
  });
});
enifed('container/tests/owner_test', ['exports', 'ember-utils'], function (exports, _emberUtils) {
  'use strict';

  QUnit.module('Owner', {});

  QUnit.test('An owner can be set with `setOwner` and retrieved with `getOwner`', function () {
    var owner = {};
    var obj = {};

    strictEqual(_emberUtils.getOwner(obj), undefined, 'owner has not been set');

    _emberUtils.setOwner(obj, owner);

    strictEqual(_emberUtils.getOwner(obj), owner, 'owner has been set');

    strictEqual(obj[_emberUtils.OWNER], owner, 'owner has been set to the OWNER symbol');
  });
});
enifed('container/tests/owner_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | container/tests/owner_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'container/tests/owner_test.js should pass ESLint\n\n');
  });
});
enifed('container/tests/registry_test', ['exports', 'container/index', 'internal-test-helpers'], function (exports, _containerIndex, _internalTestHelpers) {
  'use strict';

  QUnit.module('Registry');

  QUnit.test('A registered factory is returned from resolve', function () {
    var registry = new _containerIndex.Registry();
    var PostController = _internalTestHelpers.factory();

    registry.register('controller:post', PostController);

    var PostControllerFactory = registry.resolve('controller:post');

    ok(PostControllerFactory, 'factory is returned');
    ok(PostControllerFactory.create() instanceof PostController, 'The return of factory.create is an instance of PostController');
  });

  QUnit.test('The registered factory returned from resolve is the same factory each time', function () {
    var registry = new _containerIndex.Registry();
    var PostController = _internalTestHelpers.factory();

    registry.register('controller:post', PostController);

    deepEqual(registry.resolve('controller:post'), registry.resolve('controller:post'), 'The return of resolve is always the same');
  });

  QUnit.test('The registered value returned from resolve is the same value each time even if the value is falsy', function () {
    var registry = new _containerIndex.Registry();

    registry.register('falsy:value', null, { instantiate: false });

    strictEqual(registry.resolve('falsy:value'), registry.resolve('falsy:value'), 'The return of resolve is always the same');
  });

  QUnit.test('The value returned from resolver is the same value as the original value even if the value is falsy', function () {
    var resolver = {
      resolve: function (fullName) {
        if (fullName === 'falsy:value') {
          return null;
        }
      }
    };
    var registry = new _containerIndex.Registry({ resolver: resolver });

    strictEqual(registry.resolve('falsy:value'), null);
  });

  QUnit.test('A registered factory returns true for `has` if an item is registered', function () {
    var registry = new _containerIndex.Registry();
    var PostController = _internalTestHelpers.factory();

    registry.register('controller:post', PostController);

    equal(registry.has('controller:post'), true, 'The `has` method returned true for registered factories');
    equal(registry.has('controller:posts'), false, 'The `has` method returned false for unregistered factories');
  });

  QUnit.test('Throw exception when trying to inject `type:thing` on all type(s)', function () {
    var registry = new _containerIndex.Registry();
    var PostController = _internalTestHelpers.factory();

    registry.register('controller:post', PostController);

    throws(function () {
      registry.typeInjection('controller', 'injected', 'controller:post');
    }, /Cannot inject a 'controller:post' on other controller\(s\)\./);
  });

  QUnit.test('The registry can take a hook to resolve factories lazily', function () {
    var PostController = _internalTestHelpers.factory();
    var resolver = {
      resolve: function (fullName) {
        if (fullName === 'controller:post') {
          return PostController;
        }
      }
    };
    var registry = new _containerIndex.Registry({ resolver: resolver });

    strictEqual(registry.resolve('controller:post'), PostController, 'The correct factory was provided');
  });

  QUnit.test('The registry respects the resolver hook for `has`', function () {
    var PostController = _internalTestHelpers.factory();
    var resolver = {
      resolve: function (fullName) {
        if (fullName === 'controller:post') {
          return PostController;
        }
      }
    };
    var registry = new _containerIndex.Registry({ resolver: resolver });

    ok(registry.has('controller:post'), 'the `has` method uses the resolver hook');
  });

  QUnit.test('The registry normalizes names when resolving', function () {
    var registry = new _containerIndex.Registry();
    var PostController = _internalTestHelpers.factory();

    registry.normalizeFullName = function (fullName) {
      return 'controller:post';
    };

    registry.register('controller:post', PostController);
    var type = registry.resolve('controller:normalized');

    strictEqual(type, PostController, 'Normalizes the name when resolving');
  });

  QUnit.test('The registry normalizes names when checking if the factory is registered', function () {
    var registry = new _containerIndex.Registry();
    var PostController = _internalTestHelpers.factory();

    registry.normalizeFullName = function (fullName) {
      return fullName === 'controller:normalized' ? 'controller:post' : fullName;
    };

    registry.register('controller:post', PostController);
    var isPresent = registry.has('controller:normalized');

    equal(isPresent, true, 'Normalizes the name when checking if the factory or instance is present');
  });

  QUnit.test('validateFullName throws an error if name is incorrect', function () {
    expect(2);

    var registry = new _containerIndex.Registry();
    var PostController = _internalTestHelpers.factory();

    registry.normalize = function (fullName) {
      return 'controller:post';
    };

    registry.register('controller:post', PostController);
    throws(function () {
      registry.validateFullName('post');
    }, /TypeError: Invalid Fullname, expected: 'type:name' got: post/);

    throws(function () {
      registry.validateFullName('route:http://foo.bar.com/baz');
    }, /TypeError: Invalid Fullname, expected: 'type:name' got: route:http:\/\/foo.bar.com\/baz/);
  });

  QUnit.test('The registry normalizes names when injecting', function () {
    var registry = new _containerIndex.Registry();
    var PostController = _internalTestHelpers.factory();
    var user = { name: 'Stef' };

    registry.normalize = function (fullName) {
      return 'controller:post';
    };

    registry.register('controller:post', PostController);
    registry.register('user:post', user, { instantiate: false });
    registry.injection('controller:post', 'user', 'controller:normalized');

    deepEqual(registry.resolve('controller:post'), user, 'Normalizes the name when injecting');
  });

  QUnit.test('cannot register an `undefined` factory', function () {
    var registry = new _containerIndex.Registry();

    throws(function () {
      registry.register('controller:apple', undefined);
    }, '');
  });

  QUnit.test('can re-register a factory', function () {
    var registry = new _containerIndex.Registry();
    var FirstApple = _internalTestHelpers.factory('first');
    var SecondApple = _internalTestHelpers.factory('second');

    registry.register('controller:apple', FirstApple);
    registry.register('controller:apple', SecondApple);

    ok(registry.resolve('controller:apple').create() instanceof SecondApple);
  });

  QUnit.test('cannot re-register a factory if it has been resolved', function () {
    var registry = new _containerIndex.Registry();
    var FirstApple = _internalTestHelpers.factory('first');
    var SecondApple = _internalTestHelpers.factory('second');

    registry.register('controller:apple', FirstApple);
    strictEqual(registry.resolve('controller:apple'), FirstApple);

    throws(function () {
      registry.register('controller:apple', SecondApple);
    }, /Cannot re-register: 'controller:apple', as it has already been resolved\./);

    strictEqual(registry.resolve('controller:apple'), FirstApple);
  });

  QUnit.test('registry.has should not accidentally cause injections on that factory to be run. (Mitigate merely on observing)', function () {
    expect(1);

    var registry = new _containerIndex.Registry();
    var FirstApple = _internalTestHelpers.factory('first');
    var SecondApple = _internalTestHelpers.factory('second');

    SecondApple.extend = function (a, b, c) {
      ok(false, 'should not extend or touch the injected model, merely to inspect existence of another');
    };

    registry.register('controller:apple', FirstApple);
    registry.register('controller:second-apple', SecondApple);
    registry.injection('controller:apple', 'badApple', 'controller:second-apple');

    ok(registry.has('controller:apple'));
  });

  QUnit.test('registry.has should not error for invalid fullNames)', function () {
    expect(1);

    var registry = new _containerIndex.Registry();

    ok(!registry.has('foo:bar:baz'));
  });

  QUnit.test('once resolved, always return the same result', function () {
    expect(1);

    var registry = new _containerIndex.Registry();

    registry.resolver = {
      resolve: function () {
        return 'bar';
      }
    };

    var Bar = registry.resolve('models:bar');

    registry.resolver = {
      resolve: function () {
        return 'not bar';
      }
    };

    equal(registry.resolve('models:bar'), Bar);
  });

  QUnit.test('factory resolves are cached', function () {
    var registry = new _containerIndex.Registry();
    var PostController = _internalTestHelpers.factory();
    var resolveWasCalled = [];

    registry.resolver = {
      resolve: function (fullName) {
        resolveWasCalled.push(fullName);
        return PostController;
      }
    };

    deepEqual(resolveWasCalled, []);
    registry.resolve('controller:post');
    deepEqual(resolveWasCalled, ['controller:post']);

    registry.resolve('controller:post');
    deepEqual(resolveWasCalled, ['controller:post']);
  });

  QUnit.test('factory for non extendables (MODEL) resolves are cached', function () {
    var registry = new _containerIndex.Registry();
    var PostController = _internalTestHelpers.factory();
    var resolveWasCalled = [];

    registry.resolver = {
      resolve: function (fullName) {
        resolveWasCalled.push(fullName);
        return PostController;
      }
    };

    deepEqual(resolveWasCalled, []);
    registry.resolve('model:post');
    deepEqual(resolveWasCalled, ['model:post']);

    registry.resolve('model:post');
    deepEqual(resolveWasCalled, ['model:post']);
  });

  QUnit.test('factory for non extendables resolves are cached', function () {
    var registry = new _containerIndex.Registry();
    var PostController = {};
    var resolveWasCalled = [];

    registry.resolver = {
      resolve: function (fullName) {
        resolveWasCalled.push(fullName);
        return PostController;
      }
    };

    deepEqual(resolveWasCalled, []);
    registry.resolve('foo:post');
    deepEqual(resolveWasCalled, ['foo:post']);

    registry.resolve('foo:post');
    deepEqual(resolveWasCalled, ['foo:post']);
  });

  QUnit.test('registry.container creates a container', function () {
    var registry = new _containerIndex.Registry();
    var PostController = _internalTestHelpers.factory();
    registry.register('controller:post', PostController);

    var container = registry.container();
    var postController = container.lookup('controller:post');

    ok(postController instanceof PostController, 'The lookup is an instance of the registered factory');
  });

  QUnit.test('`describe` will be handled by the resolver, then by the fallback registry, if available', function () {
    var fallback = {
      describe: function (fullName) {
        return fullName + '-fallback';
      }
    };

    var resolver = {
      lookupDescription: function (fullName) {
        return fullName + '-resolver';
      }
    };

    var registry = new _containerIndex.Registry({ fallback: fallback, resolver: resolver });

    equal(registry.describe('controller:post'), 'controller:post-resolver', '`describe` handled by the resolver first.');

    registry.resolver = null;

    equal(registry.describe('controller:post'), 'controller:post-fallback', '`describe` handled by fallback registry next.');

    registry.fallback = null;

    equal(registry.describe('controller:post'), 'controller:post', '`describe` by default returns argument.');
  });

  QUnit.test('`normalizeFullName` will be handled by the resolver, then by the fallback registry, if available', function () {
    var fallback = {
      normalizeFullName: function (fullName) {
        return fullName + '-fallback';
      }
    };

    var resolver = {
      normalize: function (fullName) {
        return fullName + '-resolver';
      }
    };

    var registry = new _containerIndex.Registry({ fallback: fallback, resolver: resolver });

    equal(registry.normalizeFullName('controller:post'), 'controller:post-resolver', '`normalizeFullName` handled by the resolver first.');

    registry.resolver = null;

    equal(registry.normalizeFullName('controller:post'), 'controller:post-fallback', '`normalizeFullName` handled by fallback registry next.');

    registry.fallback = null;

    equal(registry.normalizeFullName('controller:post'), 'controller:post', '`normalizeFullName` by default returns argument.');
  });

  QUnit.test('`makeToString` will be handled by the resolver, then by the fallback registry, if available', function () {
    var fallback = {
      makeToString: function (fullName) {
        return fullName + '-fallback';
      }
    };

    var resolver = {
      makeToString: function (fullName) {
        return fullName + '-resolver';
      }
    };

    var registry = new _containerIndex.Registry({ fallback: fallback, resolver: resolver });

    equal(registry.makeToString('controller:post'), 'controller:post-resolver', '`makeToString` handled by the resolver first.');

    registry.resolver = null;

    equal(registry.makeToString('controller:post'), 'controller:post-fallback', '`makeToString` handled by fallback registry next.');

    registry.fallback = null;

    equal(registry.makeToString('controller:post'), 'controller:post', '`makeToString` by default returns argument.');
  });

  QUnit.test('`resolve` can be handled by a fallback registry', function () {
    var fallback = new _containerIndex.Registry();

    var registry = new _containerIndex.Registry({ fallback: fallback });
    var PostController = _internalTestHelpers.factory();

    fallback.register('controller:post', PostController);

    var PostControllerFactory = registry.resolve('controller:post');

    ok(PostControllerFactory, 'factory is returned');
    ok(PostControllerFactory.create() instanceof PostController, 'The return of factory.create is an instance of PostController');
  });

  QUnit.test('`has` can be handled by a fallback registry', function () {
    var fallback = new _containerIndex.Registry();

    var registry = new _containerIndex.Registry({ fallback: fallback });
    var PostController = _internalTestHelpers.factory();

    fallback.register('controller:post', PostController);

    equal(registry.has('controller:post'), true, 'Fallback registry is checked for registration');
  });

  QUnit.test('`getInjections` includes injections from a fallback registry', function () {
    var fallback = new _containerIndex.Registry();
    var registry = new _containerIndex.Registry({ fallback: fallback });

    equal(registry.getInjections('model:user').length, 0, 'No injections in the primary registry');

    fallback.injection('model:user', 'post', 'model:post');

    equal(registry.getInjections('model:user').length, 1, 'Injections from the fallback registry are merged');
  });

  QUnit.test('`getTypeInjections` includes type injections from a fallback registry', function () {
    var fallback = new _containerIndex.Registry();
    var registry = new _containerIndex.Registry({ fallback: fallback });

    equal(registry.getTypeInjections('model').length, 0, 'No injections in the primary registry');

    fallback.injection('model', 'source', 'source:main');

    equal(registry.getTypeInjections('model').length, 1, 'Injections from the fallback registry are merged');
  });

  QUnit.test('`getFactoryInjections` includes factory injections from a fallback registry', function () {
    var fallback = new _containerIndex.Registry();
    var registry = new _containerIndex.Registry({ fallback: fallback });

    equal(registry.getFactoryInjections('model:user').length, 0, 'No factory injections in the primary registry');

    fallback.factoryInjection('model:user', 'store', 'store:main');

    equal(registry.getFactoryInjections('model:user').length, 1, 'Factory injections from the fallback registry are merged');
  });

  QUnit.test('`getFactoryTypeInjections` includes factory type injections from a fallback registry', function () {
    var fallback = new _containerIndex.Registry();
    var registry = new _containerIndex.Registry({ fallback: fallback });

    equal(registry.getFactoryTypeInjections('model').length, 0, 'No factory type injections in the primary registry');

    fallback.factoryInjection('model', 'store', 'store:main');

    equal(registry.getFactoryTypeInjections('model').length, 1, 'Factory type injections from the fallback registry are merged');
  });

  QUnit.test('`knownForType` contains keys for each item of a given type', function () {
    var registry = new _containerIndex.Registry();

    registry.register('foo:bar-baz', 'baz');
    registry.register('foo:qux-fez', 'fez');

    var found = registry.knownForType('foo');

    deepEqual(found, {
      'foo:bar-baz': true,
      'foo:qux-fez': true
    });
  });

  QUnit.test('`knownForType` includes fallback registry results', function () {
    var fallback = new _containerIndex.Registry();
    var registry = new _containerIndex.Registry({ fallback: fallback });

    registry.register('foo:bar-baz', 'baz');
    registry.register('foo:qux-fez', 'fez');
    fallback.register('foo:zurp-zorp', 'zorp');

    var found = registry.knownForType('foo');

    deepEqual(found, {
      'foo:bar-baz': true,
      'foo:qux-fez': true,
      'foo:zurp-zorp': true
    });
  });

  QUnit.test('`knownForType` is called on the resolver if present', function () {
    expect(3);

    var resolver = {
      knownForType: function (type) {
        ok(true, 'knownForType called on the resolver');
        equal(type, 'foo', 'the type was passed through');

        return { 'foo:yorp': true };
      }
    };

    var registry = new _containerIndex.Registry({
      resolver: resolver
    });
    registry.register('foo:bar-baz', 'baz');

    var found = registry.knownForType('foo');

    deepEqual(found, {
      'foo:yorp': true,
      'foo:bar-baz': true
    });
  });

  QUnit.test('A registry can be created with a deprecated `resolver` function instead of an object', function () {
    expect(2);

    var registry = undefined;

    expectDeprecation(function () {
      registry = new _containerIndex.Registry({
        resolver: function (fullName) {
          return fullName + '-resolved';
        }
      });
    }, 'Passing a `resolver` function into a Registry is deprecated. Please pass in a Resolver object with a `resolve` method.');

    equal(registry.resolve('foo:bar'), 'foo:bar-resolved', '`resolve` still calls the deprecated function');
  });

  QUnit.test('resolver.expandLocalLookup is not required', function (assert) {
    assert.expect(1);

    var registry = new _containerIndex.Registry({
      resolver: {}
    });

    var result = registry.expandLocalLookup('foo:bar', {
      source: 'baz:qux'
    });

    assert.equal(result, null);
  });

  QUnit.test('expandLocalLookup is called on the resolver if present', function (assert) {
    assert.expect(4);

    var resolver = {
      expandLocalLookup: function (targetFullName, sourceFullName) {
        assert.ok(true, 'expandLocalLookup is called on the resolver');
        assert.equal(targetFullName, 'foo:bar', 'the targetFullName was passed through');
        assert.equal(sourceFullName, 'baz:qux', 'the sourceFullName was passed through');

        return 'foo:qux/bar';
      }
    };

    var registry = new _containerIndex.Registry({
      resolver: resolver
    });

    var result = registry.expandLocalLookup('foo:bar', {
      source: 'baz:qux'
    });

    assert.equal(result, 'foo:qux/bar');
  });

  QUnit.test('`expandLocalLookup` is handled by the resolver, then by the fallback registry, if available', function (assert) {
    assert.expect(9);

    var fallbackResolver = {
      expandLocalLookup: function (targetFullName, sourceFullName) {
        assert.ok(true, 'expandLocalLookup is called on the fallback resolver');
        assert.equal(targetFullName, 'foo:bar', 'the targetFullName was passed through');
        assert.equal(sourceFullName, 'baz:qux', 'the sourceFullName was passed through');

        return 'foo:qux/bar-fallback';
      }
    };

    var resolver = {
      expandLocalLookup: function (targetFullName, sourceFullName) {
        assert.ok(true, 'expandLocalLookup is called on the resolver');
        assert.equal(targetFullName, 'foo:bar', 'the targetFullName was passed through');
        assert.equal(sourceFullName, 'baz:qux', 'the sourceFullName was passed through');

        return 'foo:qux/bar-resolver';
      }
    };

    var fallbackRegistry = new _containerIndex.Registry({
      resolver: fallbackResolver
    });

    var registry = new _containerIndex.Registry({
      fallback: fallbackRegistry,
      resolver: resolver
    });

    var result = registry.expandLocalLookup('foo:bar', {
      source: 'baz:qux'
    });

    assert.equal(result, 'foo:qux/bar-resolver', 'handled by the resolver');

    registry.resolver = null;

    result = registry.expandLocalLookup('foo:bar', {
      source: 'baz:qux'
    });

    assert.equal(result, 'foo:qux/bar-fallback', 'handled by the fallback registry');

    registry.fallback = null;

    result = registry.expandLocalLookup('foo:bar', {
      source: 'baz:qux'
    });

    assert.equal(result, null, 'null is returned by default when no resolver or fallback registry is present');
  });

  QUnit.test('resolver.expandLocalLookup result is cached', function (assert) {
    assert.expect(3);
    var result = undefined;

    var resolver = {
      expandLocalLookup: function (targetFullName, sourceFullName) {
        assert.ok(true, 'expandLocalLookup is called on the resolver');

        return 'foo:qux/bar';
      }
    };

    var registry = new _containerIndex.Registry({
      resolver: resolver
    });

    result = registry.expandLocalLookup('foo:bar', {
      source: 'baz:qux'
    });

    assert.equal(result, 'foo:qux/bar');

    result = registry.expandLocalLookup('foo:bar', {
      source: 'baz:qux'
    });

    assert.equal(result, 'foo:qux/bar');
  });

  QUnit.test('resolver.expandLocalLookup cache is busted when any unregister is called', function (assert) {
    assert.expect(4);
    var result = undefined;

    var resolver = {
      expandLocalLookup: function (targetFullName, sourceFullName) {
        assert.ok(true, 'expandLocalLookup is called on the resolver');

        return 'foo:qux/bar';
      }
    };

    var registry = new _containerIndex.Registry({
      resolver: resolver
    });

    result = registry.expandLocalLookup('foo:bar', {
      source: 'baz:qux'
    });

    assert.equal(result, 'foo:qux/bar');

    registry.unregister('foo:bar');

    result = registry.expandLocalLookup('foo:bar', {
      source: 'baz:qux'
    });

    assert.equal(result, 'foo:qux/bar');
  });

  QUnit.test('resolve calls expandLocallookup when it receives options.source', function (assert) {
    assert.expect(3);

    var resolver = {
      resolve: function () {},
      expandLocalLookup: function (targetFullName, sourceFullName) {
        assert.ok(true, 'expandLocalLookup is called on the resolver');
        assert.equal(targetFullName, 'foo:bar', 'the targetFullName was passed through');
        assert.equal(sourceFullName, 'baz:qux', 'the sourceFullName was passed through');

        return 'foo:qux/bar';
      }
    };

    var registry = new _containerIndex.Registry({
      resolver: resolver
    });

    registry.resolve('foo:bar', {
      source: 'baz:qux'
    });
  });

  QUnit.test('has uses expandLocalLookup', function (assert) {
    assert.expect(5);
    var resolvedFullNames = [];
    var result = undefined;

    var resolver = {
      resolve: function (name) {
        resolvedFullNames.push(name);

        return 'yippie!';
      },

      expandLocalLookup: function (targetFullName, sourceFullName) {
        assert.ok(true, 'expandLocalLookup is called on the resolver');

        if (targetFullName === 'foo:bar') {
          return 'foo:qux/bar';
        } else {
          return null;
        }
      }
    };

    var registry = new _containerIndex.Registry({
      resolver: resolver
    });

    result = registry.has('foo:bar', {
      source: 'baz:qux'
    });

    assert.ok(result, 'found foo:bar/qux');

    result = registry.has('foo:baz', {
      source: 'baz:qux'
    });

    assert.ok(!result, 'foo:baz/qux not found');

    assert.deepEqual(['foo:qux/bar'], resolvedFullNames);
  });
});
enifed('container/tests/registry_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | container/tests/registry_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'container/tests/registry_test.js should pass ESLint\n\n');
  });
});
enifed('ember-application/index.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/index.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/index.js should pass ESLint\n\n');
  });
});
enifed('ember-application/initializers/dom-templates.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/initializers/dom-templates.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/initializers/dom-templates.js should pass ESLint\n\n');
  });
});
enifed('ember-application/system/application-instance.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/system/application-instance.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/system/application-instance.js should pass ESLint\n\n');
  });
});
enifed('ember-application/system/application.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/system/application.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/system/application.js should pass ESLint\n\n');
  });
});
enifed('ember-application/system/engine-instance.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/system/engine-instance.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/system/engine-instance.js should pass ESLint\n\n');
  });
});
enifed('ember-application/system/engine-parent.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/system/engine-parent.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/system/engine-parent.js should pass ESLint\n\n');
  });
});
enifed('ember-application/system/engine.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/system/engine.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/system/engine.js should pass ESLint\n\n');
  });
});
enifed('ember-application/system/resolver.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/system/resolver.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/system/resolver.js should pass ESLint\n\n');
  });
});
enifed('ember-application/tests/system/application_instance_test', ['exports', 'ember-application/system/engine', 'ember-application/system/application', 'ember-application/system/application-instance', 'ember-metal', 'ember-views', 'container', 'internal-test-helpers', 'ember-runtime'], function (exports, _emberApplicationSystemEngine, _emberApplicationSystemApplication, _emberApplicationSystemApplicationInstance, _emberMetal, _emberViews, _container, _internalTestHelpers, _emberRuntime) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['-bucket-cache:main'], ['-bucket-cache:main']);

  var application = undefined,
      appInstance = undefined;

  QUnit.module('Ember.ApplicationInstance', {
    setup: function () {
      _emberViews.jQuery('#qunit-fixture').html('<div id=\'one\'><div id=\'one-child\'>HI</div></div><div id=\'two\'>HI</div>');
      application = _emberMetal.run(function () {
        return _emberApplicationSystemApplication.default.create({ rootElement: '#one', router: null });
      });
    },

    teardown: function () {
      _emberViews.jQuery('#qunit-fixture').empty();

      if (appInstance) {
        _emberMetal.run(appInstance, 'destroy');
      }

      if (application) {
        _emberMetal.run(application, 'destroy');
      }
    }
  });

  QUnit.test('an application instance can be created based upon an application', function () {
    appInstance = _emberMetal.run(function () {
      return appInstance = _emberApplicationSystemApplicationInstance.default.create({ application: application });
    });

    ok(appInstance, 'instance should be created');
    equal(appInstance.application, application, 'application should be set to parent');
  });

  QUnit.test('properties (and aliases) are correctly assigned for accessing the container and registry', function () {
    expect(9);

    appInstance = _emberMetal.run(function () {
      return _emberApplicationSystemApplicationInstance.default.create({ application: application });
    });

    ok(appInstance, 'instance should be created');
    ok(appInstance.__container__, '#__container__ is accessible');
    ok(appInstance.__registry__, '#__registry__ is accessible');

    ok(typeof appInstance.container.lookup === 'function', '#container.lookup is available as a function');

    // stub with a no-op to keep deprecation test simple
    appInstance.__container__.lookup = function () {
      ok(true, '#loookup alias is called correctly');
    };

    expectDeprecation(function () {
      appInstance.container.lookup();
    }, /Using `ApplicationInstance.container.lookup` is deprecated. Please use `ApplicationInstance.lookup` instead./);

    ok(typeof appInstance.registry.register === 'function', '#registry.register is available as a function');
    appInstance.__registry__.register = function () {
      ok(true, '#register alias is called correctly');
    };

    expectDeprecation(function () {
      appInstance.registry.register();
    }, /Using `ApplicationInstance.registry.register` is deprecated. Please use `ApplicationInstance.register` instead./);
  });

  QUnit.test('customEvents added to the application before setupEventDispatcher', function (assert) {
    assert.expect(1);

    appInstance = _emberMetal.run(function () {
      return _emberApplicationSystemApplicationInstance.default.create({ application: application });
    });

    application.customEvents = {
      awesome: 'sauce'
    };

    var eventDispatcher = appInstance.lookup('event_dispatcher:main');
    eventDispatcher.setup = function (events) {
      assert.equal(events.awesome, 'sauce');
    };

    appInstance.setupEventDispatcher();
  });

  QUnit.test('customEvents added to the application before setupEventDispatcher', function (assert) {
    assert.expect(1);

    _emberMetal.run(function () {
      return appInstance = _emberApplicationSystemApplicationInstance.default.create({ application: application });
    });

    application.customEvents = {
      awesome: 'sauce'
    };

    var eventDispatcher = appInstance.lookup('event_dispatcher:main');
    eventDispatcher.setup = function (events) {
      assert.equal(events.awesome, 'sauce');
    };

    appInstance.setupEventDispatcher();
  });

  QUnit.test('customEvents added to the application instance before setupEventDispatcher', function (assert) {
    assert.expect(1);

    appInstance = _emberMetal.run(function () {
      return _emberApplicationSystemApplicationInstance.default.create({ application: application });
    });

    appInstance.customEvents = {
      awesome: 'sauce'
    };

    var eventDispatcher = appInstance.lookup('event_dispatcher:main');
    eventDispatcher.setup = function (events) {
      assert.equal(events.awesome, 'sauce');
    };

    appInstance.setupEventDispatcher();
  });

  QUnit.test('unregistering a factory clears all cached instances of that factory', function (assert) {
    assert.expect(3);

    appInstance = _emberMetal.run(function () {
      return _emberApplicationSystemApplicationInstance.default.create({ application: application });
    });

    var PostController = _internalTestHelpers.factory();

    appInstance.register('controller:post', PostController);

    var postController1 = appInstance.lookup('controller:post');
    assert.ok(postController1, 'lookup creates instance');

    appInstance.unregister('controller:post');
    appInstance.register('controller:post', PostController);

    var postController2 = appInstance.lookup('controller:post');
    assert.ok(postController2, 'lookup creates instance');

    assert.notStrictEqual(postController1, postController2, 'lookup creates a brand new instance, because the previous one was reset');
  });

  QUnit.test('can build and boot a registered engine', function (assert) {
    assert.expect(10);

    var ChatEngine = _emberApplicationSystemEngine.default.extend();
    var chatEngineInstance = undefined;

    application.register('engine:chat', ChatEngine);

    _emberMetal.run(function () {
      appInstance = _emberApplicationSystemApplicationInstance.default.create({ application: application });
      appInstance.setupRegistry();
      chatEngineInstance = appInstance.buildChildEngineInstance('chat');
    });

    return chatEngineInstance.boot().then(function () {
      assert.ok(true, 'boot successful');

      var registrations = ['route:basic', 'event_dispatcher:main', 'service:-routing', 'service:-glimmer-environment'];

      registrations.forEach(function (key) {
        assert.strictEqual(chatEngineInstance.resolveRegistration(key), appInstance.resolveRegistration(key), 'Engine and parent app share registrations for \'' + key + '\'');
      });

      var singletons = ['router:main', _container.privatize(_templateObject), '-view-registry:main', '-environment:main'];

      var env = appInstance.lookup('-environment:main');
      singletons.push(env.isInteractive ? 'renderer:-dom' : 'renderer:-inert');

      singletons.forEach(function (key) {
        assert.strictEqual(chatEngineInstance.lookup(key), appInstance.lookup(key), 'Engine and parent app share singleton \'' + key + '\'');
      });
    });
  });

  QUnit.test('can build a registry via Ember.ApplicationInstance.setupRegistry() -- simulates ember-test-helpers', function (assert) {
    var namespace = _emberRuntime.Object.create({
      Resolver: { create: function () {} }
    });

    var registry = _emberApplicationSystemApplication.default.buildRegistry(namespace);

    _emberApplicationSystemApplicationInstance.default.setupRegistry(registry);

    assert.equal(registry.resolve('service:-document'), document);
  });
});
enifed('ember-application/tests/system/application_instance_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/tests/system/application_instance_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/tests/system/application_instance_test.js should pass ESLint\n\n');
  });
});
enifed('ember-application/tests/system/application_test', ['exports', 'ember', 'ember-environment', 'ember-metal', 'ember-application/system/application', 'ember-application/system/resolver', 'ember-routing', 'ember-views', 'ember-runtime', 'ember-template-compiler', 'ember-glimmer', 'container', 'ember-application/tests/test-helpers/registry-check'], function (exports, _ember, _emberEnvironment, _emberMetal, _emberApplicationSystemApplication, _emberApplicationSystemResolver, _emberRouting, _emberViews, _emberRuntime, _emberTemplateCompiler, _emberGlimmer, _container, _emberApplicationTestsTestHelpersRegistryCheck) {
  /*globals EmberDev */
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['-bucket-cache:main'], ['-bucket-cache:main']),
      _templateObject2 = babelHelpers.taggedTemplateLiteralLoose(['template:components/-default'], ['template:components/-default']);

  var trim = _emberViews.jQuery.trim;

  var app = undefined,
      application = undefined,
      originalLookup = undefined,
      originalDebug = undefined,
      originalWarn = undefined;

  QUnit.module('Ember.Application', {
    setup: function () {
      originalLookup = _emberEnvironment.context.lookup;
      originalDebug = _emberMetal.getDebugFunction('debug');
      originalWarn = _emberMetal.getDebugFunction('warn');

      _emberViews.jQuery('#qunit-fixture').html('<div id=\'one\'><div id=\'one-child\'>HI</div></div><div id=\'two\'>HI</div>');
      application = _emberMetal.run(function () {
        return _emberApplicationSystemApplication.default.create({ rootElement: '#one', router: null });
      });
    },

    teardown: function () {
      _emberViews.jQuery('#qunit-fixture').empty();
      _emberMetal.setDebugFunction('debug', originalDebug);
      _emberMetal.setDebugFunction('warn', originalWarn);

      _emberEnvironment.context.lookup = originalLookup;

      if (application) {
        _emberMetal.run(application, 'destroy');
      }

      if (app) {
        _emberMetal.run(app, 'destroy');
      }
    }
  });

  QUnit.test('you can make a new application in a non-overlapping element', function () {
    app = _emberMetal.run(function () {
      return _emberApplicationSystemApplication.default.create({ rootElement: '#two', router: null });
    });

    _emberMetal.run(app, 'destroy');
    ok(true, 'should not raise');
  });

  QUnit.test('you cannot make a new application that is a parent of an existing application', function () {
    expectAssertion(function () {
      _emberMetal.run(function () {
        return _emberApplicationSystemApplication.default.create({ rootElement: '#qunit-fixture' });
      });
    });
  });

  QUnit.test('you cannot make a new application that is a descendant of an existing application', function () {
    expectAssertion(function () {
      _emberMetal.run(function () {
        return _emberApplicationSystemApplication.default.create({ rootElement: '#one-child' });
      });
    });
  });

  QUnit.test('you cannot make a new application that is a duplicate of an existing application', function () {
    expectAssertion(function () {
      _emberMetal.run(function () {
        return _emberApplicationSystemApplication.default.create({ rootElement: '#one' });
      });
    });
  });

  QUnit.test('you cannot make two default applications without a rootElement error', function () {
    expectAssertion(function () {
      _emberMetal.run(function () {
        return _emberApplicationSystemApplication.default.create({ router: false });
      });
    });
  });

  QUnit.test('acts like a namespace', function () {
    var lookup = _emberEnvironment.context.lookup = {};

    app = _emberMetal.run(function () {
      return lookup.TestApp = _emberApplicationSystemApplication.default.create({ rootElement: '#two', router: false });
    });

    _emberRuntime.setNamespaceSearchDisabled(false);
    app.Foo = _emberRuntime.Object.extend();
    equal(app.Foo.toString(), 'TestApp.Foo', 'Classes pick up their parent namespace');
  });

  QUnit.test('includes deprecated access to `application.registry`', function () {
    expect(3);

    ok(typeof application.registry.register === 'function', '#registry.register is available as a function');

    application.__registry__.register = function () {
      ok(true, '#register alias is called correctly');
    };

    expectDeprecation(function () {
      application.registry.register();
    }, /Using `Application.registry.register` is deprecated. Please use `Application.register` instead./);
  });

  QUnit.test('builds a registry', function () {
    strictEqual(application.resolveRegistration('application:main'), application, 'application:main is registered');
    deepEqual(application.registeredOptionsForType('component'), { singleton: false }, 'optionsForType \'component\'');
    deepEqual(application.registeredOptionsForType('view'), { singleton: false }, 'optionsForType \'view\'');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'controller:basic');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, '-view-registry:main');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(application, 'view', '_viewRegistry', '-view-registry:main');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(application, 'route', '_topLevelViewTemplate', 'template:-outlet');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'route:basic');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'event_dispatcher:main');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(application, 'router:main', 'namespace', 'application:main');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(application, 'view:-outlet', 'namespace', 'application:main');

    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'location:auto');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'location:hash');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'location:history');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'location:none');

    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(application, 'controller', 'target', 'router:main');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(application, 'controller', 'namespace', 'application:main');

    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, _container.privatize(_templateObject));
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(application, 'router', '_bucketCache', _container.privatize(_templateObject));
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(application, 'route', '_bucketCache', _container.privatize(_templateObject));

    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(application, 'route', 'router', 'router:main');

    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'component:-text-field');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'component:-text-area');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'component:-checkbox');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'component:link-to');

    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'service:-routing');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(application, 'service:-routing', 'router', 'router:main');

    // DEBUGGING
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'resolver-for-debugging:main');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(application, 'container-debug-adapter:main', 'resolver', 'resolver-for-debugging:main');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(application, 'data-adapter:main', 'containerDebugAdapter', 'container-debug-adapter:main');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'container-debug-adapter:main');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'component-lookup:main');

    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'service:-glimmer-environment');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'service:-dom-changes');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'service:-dom-tree-construction');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(application, 'service:-glimmer-environment', 'appendOperations', 'service:-dom-tree-construction');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(application, 'service:-glimmer-environment', 'updateOperations', 'service:-dom-changes');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(application, 'renderer', 'env', 'service:-glimmer-environment');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'view:-outlet');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'renderer:-dom');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'renderer:-inert');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, _container.privatize(_templateObject2));
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(application, 'template:-outlet');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(application, 'view:-outlet', 'template', 'template:-outlet');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(application, 'template', 'env', 'service:-glimmer-environment');
    deepEqual(application.registeredOptionsForType('helper'), { instantiate: false }, 'optionsForType \'helper\'');
  });

  var originalLogVersion = _emberEnvironment.ENV.LOG_VERSION;

  QUnit.module('Ember.Application initialization', {
    teardown: function () {
      if (app) {
        _emberMetal.run(app, 'destroy');
      }
      _emberGlimmer.setTemplates({});
      _emberEnvironment.ENV.LOG_VERSION = originalLogVersion;
    }
  });

  QUnit.test('initialized application goes to initial route', function () {
    _emberMetal.run(function () {
      app = _emberApplicationSystemApplication.default.create({
        rootElement: '#qunit-fixture'
      });

      app.Router.reopen({
        location: 'none'
      });

      app.register('template:application', _emberTemplateCompiler.compile('{{outlet}}'));

      _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<h1>Hi from index</h1>'));
    });

    equal(_emberViews.jQuery('#qunit-fixture h1').text(), 'Hi from index');
  });

  QUnit.test('ready hook is called before routing begins', function () {
    expect(2);

    _emberMetal.run(function () {
      function registerRoute(application, name, callback) {
        var route = _emberRouting.Route.extend({
          activate: callback
        });

        application.register('route:' + name, route);
      }

      var MyApplication = _emberApplicationSystemApplication.default.extend({
        ready: function () {
          registerRoute(this, 'index', function () {
            ok(true, 'last-minute route is activated');
          });
        }
      });

      app = MyApplication.create({
        rootElement: '#qunit-fixture'
      });

      app.Router.reopen({
        location: 'none'
      });

      registerRoute(app, 'application', function () {
        return ok(true, 'normal route is activated');
      });
    });
  });

  QUnit.test('initialize application via initialize call', function () {
    _emberMetal.run(function () {
      app = _emberApplicationSystemApplication.default.create({
        rootElement: '#qunit-fixture'
      });

      app.Router.reopen({
        location: 'none'
      });

      _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<h1>Hello!</h1>'));
    });

    // This is not a public way to access the container; we just
    // need to make some assertions about the created router
    var router = app.__container__.lookup('router:main');
    equal(router instanceof _emberRouting.Router, true, 'Router was set from initialize call');
    equal(router.location instanceof _emberRouting.NoneLocation, true, 'Location was set from location implementation name');
  });

  QUnit.test('initialize application with stateManager via initialize call from Router class', function () {
    _emberMetal.run(function () {
      app = _emberApplicationSystemApplication.default.create({
        rootElement: '#qunit-fixture'
      });

      app.Router.reopen({
        location: 'none'
      });

      app.register('template:application', _emberTemplateCompiler.compile('<h1>Hello!</h1>'));
    });

    var router = app.__container__.lookup('router:main');
    equal(router instanceof _emberRouting.Router, true, 'Router was set from initialize call');
    equal(_emberViews.jQuery('#qunit-fixture h1').text(), 'Hello!');
  });

  QUnit.test('ApplicationView is inserted into the page', function () {
    _emberMetal.run(function () {
      app = _emberApplicationSystemApplication.default.create({
        rootElement: '#qunit-fixture'
      });

      _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<h1>Hello!</h1>'));

      app.ApplicationController = _emberRuntime.Controller.extend();

      app.Router.reopen({
        location: 'none'
      });
    });

    equal(_emberViews.jQuery('#qunit-fixture h1').text(), 'Hello!');
  });

  QUnit.test('Minimal Application initialized with just an application template', function () {
    _emberViews.jQuery('#qunit-fixture').html('<script type="text/x-handlebars">Hello World</script>');
    app = _emberMetal.run(function () {
      return _emberApplicationSystemApplication.default.create({
        rootElement: '#qunit-fixture'
      });
    });

    equal(trim(_emberViews.jQuery('#qunit-fixture').text()), 'Hello World');
  });

  QUnit.test('enable log of libraries with an ENV var', function () {
    if (EmberDev && EmberDev.runningProdBuild) {
      ok(true, 'Logging does not occur in production builds');
      return;
    }

    var messages = [];

    _emberEnvironment.ENV.LOG_VERSION = true;

    _emberMetal.setDebugFunction('debug', function (message) {
      return messages.push(message);
    });

    _emberMetal.libraries.register('my-lib', '2.0.0a');

    app = _emberMetal.run(function () {
      return _emberApplicationSystemApplication.default.create({
        rootElement: '#qunit-fixture'
      });
    });

    equal(messages[1], 'Ember  : ' + _ember.VERSION);
    equal(messages[2], 'jQuery : ' + _emberViews.jQuery().jquery);
    equal(messages[3], 'my-lib : ' + '2.0.0a');

    _emberMetal.libraries.deRegister('my-lib');
  });

  QUnit.test('disable log version of libraries with an ENV var', function () {
    var logged = false;

    _emberEnvironment.ENV.LOG_VERSION = false;

    _emberMetal.setDebugFunction('debug', function () {
      return logged = true;
    });

    _emberViews.jQuery('#qunit-fixture').empty();

    _emberMetal.run(function () {
      app = _emberApplicationSystemApplication.default.create({
        rootElement: '#qunit-fixture'
      });

      app.Router.reopen({
        location: 'none'
      });
    });

    ok(!logged, 'library version logging skipped');
  });

  QUnit.test('can resolve custom router', function () {
    var CustomRouter = _emberRouting.Router.extend();

    var Resolver = _emberApplicationSystemResolver.default.extend({
      resolveMain: function (parsedName) {
        if (parsedName.type === 'router') {
          return CustomRouter;
        } else {
          return this._super(parsedName);
        }
      }
    });

    app = _emberMetal.run(function () {
      return _emberApplicationSystemApplication.default.create({
        Resolver: Resolver
      });
    });

    ok(app.__container__.lookup('router:main') instanceof CustomRouter, 'application resolved the correct router');
  });

  QUnit.test('can specify custom router', function () {
    app = _emberMetal.run(function () {
      return _emberApplicationSystemApplication.default.create({
        Router: _emberRouting.Router.extend()
      });
    });

    ok(app.__container__.lookup('router:main') instanceof _emberRouting.Router, 'application resolved the correct router');
  });

  QUnit.test('does not leak itself in onLoad._loaded', function () {
    equal(_emberRuntime._loaded.application, undefined);
    var app = _emberMetal.run(_emberApplicationSystemApplication.default, 'create');
    equal(_emberRuntime._loaded.application, app);
    _emberMetal.run(app, 'destroy');
    equal(_emberRuntime._loaded.application, undefined);
  });

  QUnit.test('can build a registry via Ember.Application.buildRegistry() --- simulates ember-test-helpers', function (assert) {
    var namespace = _emberRuntime.Object.create({
      Resolver: { create: function () {} }
    });

    var registry = _emberApplicationSystemApplication.default.buildRegistry(namespace);

    assert.equal(registry.resolve('application:main'), namespace);
  });
});
enifed('ember-application/tests/system/application_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/tests/system/application_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/tests/system/application_test.js should pass ESLint\n\n');
  });
});
enifed('ember-application/tests/system/bootstrap-test', ['exports', 'ember-metal', 'ember-application/system/application', 'ember-routing', 'ember-views', 'ember-glimmer'], function (exports, _emberMetal, _emberApplicationSystemApplication, _emberRouting, _emberViews, _emberGlimmer) {
  'use strict';

  var app = undefined;

  QUnit.module('Ember.Application', {
    teardown: function () {
      if (app) {
        _emberMetal.run(app, 'destroy');
      }

      _emberGlimmer.setTemplates({});
    }
  });

  QUnit.test('templates in script tags are extracted at application creation', function (assert) {
    _emberViews.jQuery('#qunit-fixture').html('\n    <div id="app"></div>\n\n    <script type="text/x-handlebars">Hello {{outlet}}</script>\n    <script type="text/x-handlebars" id="index">World!</script>\n  ');

    var application = _emberApplicationSystemApplication.default.extend();
    application.Router = _emberRouting.Router.extend({
      location: 'none'
    });

    app = _emberMetal.run(function () {
      return application.create({ rootElement: '#app' });
    });

    assert.equal(_emberViews.jQuery('#app').text(), 'Hello World!');
  });
});
enifed('ember-application/tests/system/bootstrap-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/tests/system/bootstrap-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/tests/system/bootstrap-test.js should pass ESLint\n\n');
  });
});
enifed('ember-application/tests/system/dependency_injection/custom_resolver_test', ['exports', 'ember-views', 'ember-metal', 'ember-application/system/application', 'ember-application/system/resolver', 'ember-template-compiler'], function (exports, _emberViews, _emberMetal, _emberApplicationSystemApplication, _emberApplicationSystemResolver, _emberTemplateCompiler) {
  'use strict';

  var application = undefined;

  QUnit.module('Ember.Application Dependency Injection – customResolver', {
    setup: function () {
      var fallbackTemplate = _emberTemplateCompiler.compile('<h1>Fallback</h1>');

      var Resolver = _emberApplicationSystemResolver.default.extend({
        resolveTemplate: function (resolvable) {
          var resolvedTemplate = this._super(resolvable);
          if (resolvedTemplate) {
            return resolvedTemplate;
          }
          if (resolvable.fullNameWithoutType === 'application') {
            return fallbackTemplate;
          } else {
            return;
          }
        }
      });

      application = _emberMetal.run(function () {
        return _emberApplicationSystemApplication.default.create({
          Resolver: Resolver,
          rootElement: '#qunit-fixture'
        });
      });
    },

    teardown: function () {
      _emberMetal.run(application, 'destroy');
    }
  });

  QUnit.test('a resolver can be supplied to application', function () {
    equal(_emberViews.jQuery('h1', application.rootElement).text(), 'Fallback');
  });
});
enifed('ember-application/tests/system/dependency_injection/custom_resolver_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/tests/system/dependency_injection/custom_resolver_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/tests/system/dependency_injection/custom_resolver_test.js should pass ESLint\n\n');
  });
});
enifed('ember-application/tests/system/dependency_injection/default_resolver_test', ['exports', 'ember-environment', 'ember-metal', 'ember-runtime', 'ember-routing', 'ember-application/system/application', 'ember-glimmer', 'ember-template-compiler'], function (exports, _emberEnvironment, _emberMetal, _emberRuntime, _emberRouting, _emberApplicationSystemApplication, _emberGlimmer, _emberTemplateCompiler) {
  /* globals EmberDev */
  'use strict';

  var registry = undefined,
      locator = undefined,
      application = undefined,
      originalLookup = undefined,
      originalInfo = undefined;

  QUnit.module('Ember.Application Dependency Injection - default resolver', {
    setup: function () {
      originalLookup = _emberEnvironment.context.lookup;
      application = _emberMetal.run(_emberApplicationSystemApplication.default, 'create');

      registry = application.__registry__;
      locator = application.__container__;
      originalInfo = _emberMetal.getDebugFunction('info');
    },

    teardown: function () {
      _emberGlimmer.setTemplates({});
      _emberEnvironment.context.lookup = originalLookup;
      _emberMetal.run(application, 'destroy');
      var UserInterfaceNamespace = _emberRuntime.Namespace.NAMESPACES_BY_ID['UserInterface'];
      if (UserInterfaceNamespace) {
        _emberMetal.run(UserInterfaceNamespace, 'destroy');
      }

      _emberMetal.setDebugFunction('info', originalInfo);
    }
  });

  QUnit.test('the default resolver can look things up in other namespaces', function () {
    var UserInterface = _emberEnvironment.context.lookup.UserInterface = _emberRuntime.Namespace.create();
    UserInterface.NavigationController = _emberRuntime.Controller.extend();

    var nav = locator.lookup('controller:userInterface/navigation');

    ok(nav instanceof UserInterface.NavigationController, 'the result should be an instance of the specified class');
  });

  QUnit.test('the default resolver looks up templates in Ember.TEMPLATES', function () {
    var fooTemplate = _emberTemplateCompiler.compile('foo template');
    var fooBarTemplate = _emberTemplateCompiler.compile('fooBar template');
    var fooBarBazTemplate = _emberTemplateCompiler.compile('fooBar/baz template');

    _emberGlimmer.setTemplate('foo', fooTemplate);
    _emberGlimmer.setTemplate('fooBar', fooBarTemplate);
    _emberGlimmer.setTemplate('fooBar/baz', fooBarBazTemplate);

    ignoreDeprecation(function () {
      equal(locator.lookupFactory('template:foo'), fooTemplate, 'resolves template:foo');
      equal(locator.lookupFactory('template:fooBar'), fooBarTemplate, 'resolves template:foo_bar');
      equal(locator.lookupFactory('template:fooBar.baz'), fooBarBazTemplate, 'resolves template:foo_bar.baz');
    });

    if (true) {
      equal(locator.factoryFor('template:foo').class, fooTemplate, 'resolves template:foo');
      equal(locator.factoryFor('template:fooBar').class, fooBarTemplate, 'resolves template:foo_bar');
      equal(locator.factoryFor('template:fooBar.baz').class, fooBarBazTemplate, 'resolves template:foo_bar.baz');
    }
  });

  QUnit.test('the default resolver looks up basic name as no prefix', function () {
    ok(_emberRuntime.Controller.detect(locator.lookup('controller:basic')), 'locator looks up correct controller');
  });

  function detectEqual(first, second, message) {
    ok(first.detect(second), message);
  }

  QUnit.test('the default resolver looks up arbitrary types on the namespace', function () {
    application.FooManager = _emberRuntime.Object.extend({});

    detectEqual(application.FooManager, registry.resolve('manager:foo'), 'looks up FooManager on application');
  });

  QUnit.test('the default resolver resolves models on the namespace', function () {
    application.Post = _emberRuntime.Object.extend({});

    ignoreDeprecation(function () {
      detectEqual(application.Post, locator.lookupFactory('model:post'), 'looks up Post model on application');
    });
    if (true) {
      detectEqual(application.Post, locator.factoryFor('model:post').class, 'looks up Post model on application');
    }
  });

  QUnit.test('the default resolver resolves *:main on the namespace', function () {
    application.FooBar = _emberRuntime.Object.extend({});

    ignoreDeprecation(function () {
      detectEqual(application.FooBar, locator.lookupFactory('foo-bar:main'), 'looks up FooBar type without name on application');
    });
    if (true) {
      detectEqual(application.FooBar, locator.factoryFor('foo-bar:main').class, 'looks up FooBar type without name on application');
    }
  });

  if (true) {
    QUnit.test('the default resolver resolves container-registered helpers', function () {
      var shorthandHelper = _emberGlimmer.helper(function () {});
      var helper = _emberGlimmer.Helper.extend();

      application.register('helper:shorthand', shorthandHelper);
      application.register('helper:complete', helper);

      var lookedUpShorthandHelper = locator.factoryFor('helper:shorthand').class;

      ok(lookedUpShorthandHelper.isHelperInstance, 'shorthand helper isHelper');

      var lookedUpHelper = locator.factoryFor('helper:complete').class;

      ok(lookedUpHelper.isHelperFactory, 'complete helper is factory');
      ok(helper.detect(lookedUpHelper), 'looked up complete helper');
    });
  }

  QUnit.test('the default resolver resolves container-registered helpers via lookupFor', function () {
    var shorthandHelper = _emberGlimmer.helper(function () {});
    var helper = _emberGlimmer.Helper.extend();

    application.register('helper:shorthand', shorthandHelper);
    application.register('helper:complete', helper);

    ignoreDeprecation(function () {
      var lookedUpShorthandHelper = locator.lookupFactory('helper:shorthand');

      ok(lookedUpShorthandHelper.isHelperInstance, 'shorthand helper isHelper');

      var lookedUpHelper = locator.lookupFactory('helper:complete');

      ok(lookedUpHelper.isHelperFactory, 'complete helper is factory');
      ok(helper.detect(lookedUpHelper), 'looked up complete helper');
    });
  });

  QUnit.test('the default resolver resolves helpers on the namespace', function () {
    var ShorthandHelper = _emberGlimmer.helper(function () {});
    var CompleteHelper = _emberGlimmer.Helper.extend();
    var LegacyHTMLBarsBoundHelper = undefined;

    expectDeprecation(function () {
      LegacyHTMLBarsBoundHelper = _emberGlimmer.makeBoundHelper(function () {});
    }, 'Using `Ember.HTMLBars.makeBoundHelper` is deprecated. Please refactor to use `Ember.Helper` or `Ember.Helper.helper`.');

    application.ShorthandHelper = ShorthandHelper;
    application.CompleteHelper = CompleteHelper;
    application.LegacyHtmlBarsBoundHelper = LegacyHTMLBarsBoundHelper; // Must use lowered "tml" in "HTMLBars" for resolver to find this

    var resolvedShorthand = registry.resolve('helper:shorthand');
    var resolvedComplete = registry.resolve('helper:complete');
    var resolvedLegacyHTMLBars = registry.resolve('helper:legacy-html-bars-bound');

    equal(resolvedShorthand, ShorthandHelper, 'resolve fetches the shorthand helper factory');
    equal(resolvedComplete, CompleteHelper, 'resolve fetches the complete helper factory');
    equal(resolvedLegacyHTMLBars, LegacyHTMLBarsBoundHelper, 'resolves legacy HTMLBars bound helper');
  });

  QUnit.test('the default resolver resolves to the same instance, no matter the notation ', function () {
    application.NestedPostController = _emberRuntime.Controller.extend({});

    equal(locator.lookup('controller:nested-post'), locator.lookup('controller:nested_post'), 'looks up NestedPost controller on application');
  });

  QUnit.test('the default resolver throws an error if the fullName to resolve is invalid', function () {
    throws(function () {
      registry.resolve(undefined);
    }, TypeError, /Invalid fullName/);
    throws(function () {
      registry.resolve(null);
    }, TypeError, /Invalid fullName/);
    throws(function () {
      registry.resolve('');
    }, TypeError, /Invalid fullName/);
    throws(function () {
      registry.resolve('');
    }, TypeError, /Invalid fullName/);
    throws(function () {
      registry.resolve(':');
    }, TypeError, /Invalid fullName/);
    throws(function () {
      registry.resolve('model');
    }, TypeError, /Invalid fullName/);
    throws(function () {
      registry.resolve('model:');
    }, TypeError, /Invalid fullName/);
    throws(function () {
      registry.resolve(':type');
    }, TypeError, /Invalid fullName/);
  });

  QUnit.test('the default resolver logs hits if `LOG_RESOLVER` is set', function () {
    if (EmberDev && EmberDev.runningProdBuild) {
      ok(true, 'Logging does not occur in production builds');
      return;
    }

    expect(3);

    application.LOG_RESOLVER = true;
    application.ScoobyDoo = _emberRuntime.Object.extend();
    application.toString = function () {
      return 'App';
    };

    _emberMetal.setDebugFunction('info', function (symbol, name, padding, lookupDescription) {
      equal(symbol, '[✓]', 'proper symbol is printed when a module is found');
      equal(name, 'doo:scooby', 'proper lookup value is logged');
      equal(lookupDescription, 'App.ScoobyDoo');
    });

    registry.resolve('doo:scooby');
  });

  QUnit.test('the default resolver logs misses if `LOG_RESOLVER` is set', function () {
    if (EmberDev && EmberDev.runningProdBuild) {
      ok(true, 'Logging does not occur in production builds');
      return;
    }

    expect(3);

    application.LOG_RESOLVER = true;
    application.toString = function () {
      return 'App';
    };

    _emberMetal.setDebugFunction('info', function (symbol, name, padding, lookupDescription) {
      equal(symbol, '[ ]', 'proper symbol is printed when a module is not found');
      equal(name, 'doo:scooby', 'proper lookup value is logged');
      equal(lookupDescription, 'App.ScoobyDoo');
    });

    registry.resolve('doo:scooby');
  });

  QUnit.test('doesn\'t log without LOG_RESOLVER', function () {
    if (EmberDev && EmberDev.runningProdBuild) {
      ok(true, 'Logging does not occur in production builds');
      return;
    }

    var infoCount = 0;

    application.ScoobyDoo = _emberRuntime.Object.extend();

    _emberMetal.setDebugFunction('info', function (symbol, name) {
      return infoCount = infoCount + 1;
    });

    registry.resolve('doo:scooby');
    registry.resolve('doo:scrappy');
    equal(infoCount, 0, 'Logger.info should not be called if LOG_RESOLVER is not set');
  });

  QUnit.test('lookup description', function () {
    application.toString = function () {
      return 'App';
    };

    equal(registry.describe('controller:foo'), 'App.FooController', 'Type gets appended at the end');
    equal(registry.describe('controller:foo.bar'), 'App.FooBarController', 'dots are removed');
    equal(registry.describe('model:foo'), 'App.Foo', 'models don\'t get appended at the end');
  });

  QUnit.test('assertion for routes without isRouteFactory property', function () {
    application.FooRoute = _emberGlimmer.Component.extend();

    expectAssertion(function () {
      return registry.resolve('route:foo');
    }, /to resolve to an Ember.Route/, 'Should assert');
  });

  QUnit.test('no assertion for routes that extend from Ember.Route', function () {
    expect(0);
    application.FooRoute = _emberRouting.Route.extend();
    registry.resolve('route:foo');
  });

  QUnit.test('deprecation warning for service factories without isServiceFactory property', function () {
    expectDeprecation(/service factories must have an `isServiceFactory` property/);
    application.FooService = _emberRuntime.Object.extend();
    registry.resolve('service:foo');
  });

  QUnit.test('no deprecation warning for service factories that extend from Ember.Service', function () {
    expectNoDeprecation();
    application.FooService = _emberRuntime.Service.extend();
    registry.resolve('service:foo');
  });

  QUnit.test('deprecation warning for component factories without isComponentFactory property', function () {
    expectDeprecation(/component factories must have an `isComponentFactory` property/);
    application.FooComponent = _emberRuntime.Object.extend();
    registry.resolve('component:foo');
  });

  QUnit.test('no deprecation warning for component factories that extend from Ember.Component', function () {
    expectNoDeprecation();
    application.FooView = _emberGlimmer.Component.extend();
    registry.resolve('component:foo');
  });

  QUnit.test('knownForType returns each item for a given type found', function () {
    application.FooBarHelper = 'foo';
    application.BazQuxHelper = 'bar';

    var found = registry.resolver.knownForType('helper');

    // using `Object.keys` and manually confirming values over using `deepEqual`
    // due to an issue in QUnit (through at least 1.20.0) that are unable to properly compare
    // objects with an `undefined` constructor (like ember-metal/empty_object)
    var foundKeys = Object.keys(found);

    deepEqual(foundKeys, ['helper:foo-bar', 'helper:baz-qux']);
    ok(found['helper:foo-bar']);
    ok(found['helper:baz-qux']);
  });

  QUnit.test('knownForType is not required to be present on the resolver', function () {
    delete registry.resolver.knownForType;

    registry.resolver.knownForType('helper', function () {});

    ok(true, 'does not error');
  });
});
enifed('ember-application/tests/system/dependency_injection/default_resolver_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/tests/system/dependency_injection/default_resolver_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/tests/system/dependency_injection/default_resolver_test.js should pass ESLint\n\n');
  });
});
enifed('ember-application/tests/system/dependency_injection/normalization_test', ['exports', 'ember-metal', 'ember-application/system/application'], function (exports, _emberMetal, _emberApplicationSystemApplication) {
  'use strict';

  var application = undefined,
      registry = undefined;

  QUnit.module('Ember.Application Dependency Injection – normalization', {
    setup: function () {
      application = _emberMetal.run(_emberApplicationSystemApplication.default, 'create');
      registry = application.__registry__;
    },

    teardown: function () {
      _emberMetal.run(application, 'destroy');
    }
  });

  QUnit.test('normalization', function () {
    ok(registry.normalize, 'registry#normalize is present');

    equal(registry.normalize('foo:bar'), 'foo:bar');

    equal(registry.normalize('controller:posts'), 'controller:posts');
    equal(registry.normalize('controller:posts_index'), 'controller:postsIndex');
    equal(registry.normalize('controller:posts.index'), 'controller:postsIndex');
    equal(registry.normalize('controller:posts-index'), 'controller:postsIndex');
    equal(registry.normalize('controller:posts.post.index'), 'controller:postsPostIndex');
    equal(registry.normalize('controller:posts_post.index'), 'controller:postsPostIndex');
    equal(registry.normalize('controller:posts.post_index'), 'controller:postsPostIndex');
    equal(registry.normalize('controller:posts.post-index'), 'controller:postsPostIndex');
    equal(registry.normalize('controller:postsIndex'), 'controller:postsIndex');
    equal(registry.normalize('controller:blogPosts.index'), 'controller:blogPostsIndex');
    equal(registry.normalize('controller:blog/posts.index'), 'controller:blog/postsIndex');
    equal(registry.normalize('controller:blog/posts-index'), 'controller:blog/postsIndex');
    equal(registry.normalize('controller:blog/posts.post.index'), 'controller:blog/postsPostIndex');
    equal(registry.normalize('controller:blog/posts_post.index'), 'controller:blog/postsPostIndex');
    equal(registry.normalize('controller:blog/posts_post-index'), 'controller:blog/postsPostIndex');

    equal(registry.normalize('template:blog/posts_index'), 'template:blog/posts_index');
  });

  QUnit.test('normalization is indempotent', function () {
    var examples = ['controller:posts', 'controller:posts.post.index', 'controller:blog/posts.post_index', 'template:foo_bar'];

    examples.forEach(function (example) {
      equal(registry.normalize(registry.normalize(example)), registry.normalize(example));
    });
  });
});
enifed('ember-application/tests/system/dependency_injection/normalization_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/tests/system/dependency_injection/normalization_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/tests/system/dependency_injection/normalization_test.js should pass ESLint\n\n');
  });
});
enifed('ember-application/tests/system/dependency_injection/to_string_test', ['exports', 'ember-utils', 'ember-environment', 'ember-metal', 'ember-application/system/application', 'ember-runtime', 'ember-application/system/resolver'], function (exports, _emberUtils, _emberEnvironment, _emberMetal, _emberApplicationSystemApplication, _emberRuntime, _emberApplicationSystemResolver) {
  'use strict';

  var originalLookup = undefined,
      App = undefined,
      originalModelInjections = undefined;

  QUnit.module('Ember.Application Dependency Injection – toString', {
    setup: function () {
      originalModelInjections = _emberEnvironment.ENV.MODEL_FACTORY_INJECTIONS;
      _emberEnvironment.ENV.MODEL_FACTORY_INJECTIONS = true;

      originalLookup = _emberEnvironment.context.lookup;

      _emberMetal.run(function () {
        App = _emberApplicationSystemApplication.default.create();
        _emberEnvironment.context.lookup = {
          App: App
        };
      });

      App.Post = _emberRuntime.Object.extend();
    },

    teardown: function () {
      _emberEnvironment.context.lookup = originalLookup;
      _emberMetal.run(App, 'destroy');
      _emberEnvironment.ENV.MODEL_FACTORY_INJECTIONS = originalModelInjections;
    }
  });

  QUnit.test('factories', function () {
    var PostFactory = undefined;
    if (true) {
      PostFactory = App.__container__.factoryFor('model:post').class;
    } else {
      PostFactory = App.__container__.lookupFactory('model:post');
    }
    equal(PostFactory.toString(), 'App.Post', 'expecting the model to be post');
  });

  QUnit.test('instances', function () {
    var post = App.__container__.lookup('model:post');
    var guid = _emberUtils.guidFor(post);

    equal(post.toString(), '<App.Post:' + guid + '>', 'expecting the model to be post');
  });

  QUnit.test('with a custom resolver', function () {
    _emberMetal.run(App, 'destroy');

    _emberMetal.run(function () {
      App = _emberApplicationSystemApplication.default.create({
        Resolver: _emberApplicationSystemResolver.default.extend({
          makeToString: function (factory, fullName) {
            return fullName;
          }
        })
      });
    });

    App.register('model:peter', _emberRuntime.Object.extend());

    var peter = App.__container__.lookup('model:peter');
    var guid = _emberUtils.guidFor(peter);

    equal(peter.toString(), '<model:peter:' + guid + '>', 'expecting the supermodel to be peter');
  });
});
// lookup, etc
enifed('ember-application/tests/system/dependency_injection/to_string_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/tests/system/dependency_injection/to_string_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/tests/system/dependency_injection/to_string_test.js should pass ESLint\n\n');
  });
});
enifed('ember-application/tests/system/dependency_injection_test', ['exports', 'ember-environment', 'ember-metal', 'ember-runtime', 'ember-application/system/application'], function (exports, _emberEnvironment, _emberMetal, _emberRuntime, _emberApplicationSystemApplication) {
  'use strict';

  var EmberApplication = _emberApplicationSystemApplication.default;

  var originalLookup = _emberEnvironment.context.lookup;
  var registry = undefined,
      locator = undefined,
      application = undefined,
      originalModelInjections = undefined;

  QUnit.module('Ember.Application Dependency Injection', {
    setup: function () {
      originalModelInjections = _emberEnvironment.ENV.MODEL_FACTORY_INJECTIONS;
      _emberEnvironment.ENV.MODEL_FACTORY_INJECTIONS = true;

      application = _emberMetal.run(EmberApplication, 'create');

      application.Person = _emberRuntime.Object.extend({});
      application.Orange = _emberRuntime.Object.extend({});
      application.Email = _emberRuntime.Object.extend({});
      application.User = _emberRuntime.Object.extend({});
      application.PostIndexController = _emberRuntime.Object.extend({});

      application.register('model:person', application.Person, { singleton: false });
      application.register('model:user', application.User, { singleton: false });
      application.register('fruit:favorite', application.Orange);
      application.register('communication:main', application.Email, { singleton: false });
      application.register('controller:postIndex', application.PostIndexController, { singleton: true });

      registry = application.__registry__;
      locator = application.__container__;

      _emberEnvironment.context.lookup = {};
    },
    teardown: function () {
      _emberMetal.run(application, 'destroy');
      application = locator = null;
      _emberEnvironment.context.lookup = originalLookup;
      _emberEnvironment.ENV.MODEL_FACTORY_INJECTIONS = originalModelInjections;
    }
  });

  QUnit.test('container lookup is normalized', function () {
    var dotNotationController = locator.lookup('controller:post.index');
    var camelCaseController = locator.lookup('controller:postIndex');

    ok(dotNotationController instanceof application.PostIndexController);
    ok(camelCaseController instanceof application.PostIndexController);

    equal(dotNotationController, camelCaseController);
  });

  QUnit.test('registered entities can be looked up later', function () {
    equal(registry.resolve('model:person'), application.Person);
    equal(registry.resolve('model:user'), application.User);
    equal(registry.resolve('fruit:favorite'), application.Orange);
    equal(registry.resolve('communication:main'), application.Email);
    equal(registry.resolve('controller:postIndex'), application.PostIndexController);

    equal(locator.lookup('fruit:favorite'), locator.lookup('fruit:favorite'), 'singleton lookup worked');
    ok(locator.lookup('model:user') !== locator.lookup('model:user'), 'non-singleton lookup worked');
  });

  QUnit.test('injections', function () {
    application.inject('model', 'fruit', 'fruit:favorite');
    application.inject('model:user', 'communication', 'communication:main');

    var user = locator.lookup('model:user');
    var person = locator.lookup('model:person');
    var fruit = locator.lookup('fruit:favorite');

    equal(user.get('fruit'), fruit);
    equal(person.get('fruit'), fruit);

    ok(application.Email.detectInstance(user.get('communication')));
  });
});
enifed('ember-application/tests/system/dependency_injection_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/tests/system/dependency_injection_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/tests/system/dependency_injection_test.js should pass ESLint\n\n');
  });
});
enifed('ember-application/tests/system/engine_initializers_test', ['exports', 'ember-metal', 'ember-application/system/engine'], function (exports, _emberMetal, _emberApplicationSystemEngine) {
  'use strict';

  var MyEngine = undefined,
      myEngine = undefined,
      myEngineInstance = undefined;

  QUnit.module('Ember.Engine initializers', {
    setup: function () {},

    teardown: function () {
      _emberMetal.run(function () {
        if (myEngineInstance) {
          myEngineInstance.destroy();
        }

        if (myEngine) {
          myEngine.destroy();
        }
      });
    }
  });

  QUnit.test('initializers require proper \'name\' and \'initialize\' properties', function () {
    MyEngine = _emberApplicationSystemEngine.default.extend();

    expectAssertion(function () {
      _emberMetal.run(function () {
        MyEngine.initializer({ name: 'initializer' });
      });
    });

    expectAssertion(function () {
      _emberMetal.run(function () {
        MyEngine.initializer({ initialize: function () {} });
      });
    });
  });

  QUnit.test('initializers are passed an Engine', function () {
    MyEngine = _emberApplicationSystemEngine.default.extend();

    MyEngine.initializer({
      name: 'initializer',
      initialize: function (engine) {
        ok(engine instanceof _emberApplicationSystemEngine.default, 'initialize is passed an Engine');
      }
    });

    myEngine = MyEngine.create();
    myEngineInstance = myEngine.buildInstance();
  });

  QUnit.test('initializers can be registered in a specified order', function () {
    var order = [];

    MyEngine = _emberApplicationSystemEngine.default.extend();
    MyEngine.initializer({
      name: 'fourth',
      after: 'third',
      initialize: function (engine) {
        order.push('fourth');
      }
    });

    MyEngine.initializer({
      name: 'second',
      after: 'first',
      before: 'third',
      initialize: function (engine) {
        order.push('second');
      }
    });

    MyEngine.initializer({
      name: 'fifth',
      after: 'fourth',
      before: 'sixth',
      initialize: function (engine) {
        order.push('fifth');
      }
    });

    MyEngine.initializer({
      name: 'first',
      before: 'second',
      initialize: function (engine) {
        order.push('first');
      }
    });

    MyEngine.initializer({
      name: 'third',
      initialize: function (engine) {
        order.push('third');
      }
    });

    MyEngine.initializer({
      name: 'sixth',
      initialize: function (engine) {
        order.push('sixth');
      }
    });

    myEngine = MyEngine.create();
    myEngineInstance = myEngine.buildInstance();

    deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
  });

  QUnit.test('initializers can be registered in a specified order as an array', function () {
    var order = [];

    MyEngine = _emberApplicationSystemEngine.default.extend();

    MyEngine.initializer({
      name: 'third',
      initialize: function (engine) {
        order.push('third');
      }
    });

    MyEngine.initializer({
      name: 'second',
      after: 'first',
      before: ['third', 'fourth'],
      initialize: function (engine) {
        order.push('second');
      }
    });

    MyEngine.initializer({
      name: 'fourth',
      after: ['second', 'third'],
      initialize: function (engine) {
        order.push('fourth');
      }
    });

    MyEngine.initializer({
      name: 'fifth',
      after: 'fourth',
      before: 'sixth',
      initialize: function (engine) {
        order.push('fifth');
      }
    });

    MyEngine.initializer({
      name: 'first',
      before: ['second'],
      initialize: function (engine) {
        order.push('first');
      }
    });

    MyEngine.initializer({
      name: 'sixth',
      initialize: function (engine) {
        order.push('sixth');
      }
    });

    myEngine = MyEngine.create();
    myEngineInstance = myEngine.buildInstance();

    deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
  });

  QUnit.test('initializers can have multiple dependencies', function () {
    var order = [];

    MyEngine = _emberApplicationSystemEngine.default.extend();

    var a = {
      name: 'a',
      before: 'b',
      initialize: function (engine) {
        order.push('a');
      }
    };
    var b = {
      name: 'b',
      initialize: function (engine) {
        order.push('b');
      }
    };
    var c = {
      name: 'c',
      after: 'b',
      initialize: function (engine) {
        order.push('c');
      }
    };
    var afterB = {
      name: 'after b',
      after: 'b',
      initialize: function (engine) {
        order.push('after b');
      }
    };
    var afterC = {
      name: 'after c',
      after: 'c',
      initialize: function (engine) {
        order.push('after c');
      }
    };

    MyEngine.initializer(b);
    MyEngine.initializer(a);
    MyEngine.initializer(afterC);
    MyEngine.initializer(afterB);
    MyEngine.initializer(c);

    myEngine = MyEngine.create();
    myEngineInstance = myEngine.buildInstance();

    ok(order.indexOf(a.name) < order.indexOf(b.name), 'a < b');
    ok(order.indexOf(b.name) < order.indexOf(c.name), 'b < c');
    ok(order.indexOf(b.name) < order.indexOf(afterB.name), 'b < afterB');
    ok(order.indexOf(c.name) < order.indexOf(afterC.name), 'c < afterC');
  });

  QUnit.test('initializers set on Engine subclasses are not shared between engines', function () {
    var firstInitializerRunCount = 0;
    var secondInitializerRunCount = 0;
    var FirstEngine = _emberApplicationSystemEngine.default.extend();

    FirstEngine.initializer({
      name: 'first',
      initialize: function (engine) {
        firstInitializerRunCount++;
      }
    });

    var SecondEngine = _emberApplicationSystemEngine.default.extend();

    SecondEngine.initializer({
      name: 'second',
      initialize: function (engine) {
        secondInitializerRunCount++;
      }
    });

    var firstEngine = FirstEngine.create();
    var firstEngineInstance = firstEngine.buildInstance();

    equal(firstInitializerRunCount, 1, 'first initializer only was run');
    equal(secondInitializerRunCount, 0, 'first initializer only was run');

    var secondEngine = SecondEngine.create();
    var secondEngineInstance = secondEngine.buildInstance();

    equal(firstInitializerRunCount, 1, 'second initializer only was run');
    equal(secondInitializerRunCount, 1, 'second initializer only was run');

    _emberMetal.run(function () {
      firstEngineInstance.destroy();
      secondEngineInstance.destroy();

      firstEngine.destroy();
      secondEngine.destroy();
    });
  });

  QUnit.test('initializers are concatenated', function () {
    var firstInitializerRunCount = 0;
    var secondInitializerRunCount = 0;
    var FirstEngine = _emberApplicationSystemEngine.default.extend();

    FirstEngine.initializer({
      name: 'first',
      initialize: function (engine) {
        firstInitializerRunCount++;
      }
    });

    var SecondEngine = FirstEngine.extend();

    SecondEngine.initializer({
      name: 'second',
      initialize: function (engine) {
        secondInitializerRunCount++;
      }
    });

    var firstEngine = FirstEngine.create();
    var firstEngineInstance = firstEngine.buildInstance();

    equal(firstInitializerRunCount, 1, 'first initializer only was run when base class created');
    equal(secondInitializerRunCount, 0, 'second initializer was not run when first base class created');
    firstInitializerRunCount = 0;

    var secondEngine = SecondEngine.create();
    var secondEngineInstance = secondEngine.buildInstance();

    equal(firstInitializerRunCount, 1, 'first initializer was run when subclass created');
    equal(secondInitializerRunCount, 1, 'second initializers was run when subclass created');

    _emberMetal.run(function () {
      firstEngineInstance.destroy();
      secondEngineInstance.destroy();

      firstEngine.destroy();
      secondEngine.destroy();
    });
  });

  QUnit.test('initializers are per-engine', function () {
    expect(2);

    var FirstEngine = _emberApplicationSystemEngine.default.extend();

    FirstEngine.initializer({
      name: 'abc',
      initialize: function (engine) {}
    });

    expectAssertion(function () {
      FirstEngine.initializer({
        name: 'abc',
        initialize: function (engine) {}
      });
    });

    var SecondEngine = _emberApplicationSystemEngine.default.extend();
    SecondEngine.instanceInitializer({
      name: 'abc',
      initialize: function (engine) {}
    });

    ok(true, 'Two engines can have initializers named the same.');
  });

  QUnit.test('initializers are executed in their own context', function () {
    expect(1);

    MyEngine = _emberApplicationSystemEngine.default.extend();

    MyEngine.initializer({
      name: 'coolInitializer',
      myProperty: 'cool',
      initialize: function (engine) {
        equal(this.myProperty, 'cool', 'should have access to its own context');
      }
    });

    myEngine = MyEngine.create();
    myEngineInstance = myEngine.buildInstance();
  });
});
enifed('ember-application/tests/system/engine_initializers_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/tests/system/engine_initializers_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/tests/system/engine_initializers_test.js should pass ESLint\n\n');
  });
});
enifed('ember-application/tests/system/engine_instance_initializers_test', ['exports', 'ember-metal', 'ember-application/system/engine', 'ember-application/system/engine-instance', 'ember-application/system/engine-parent'], function (exports, _emberMetal, _emberApplicationSystemEngine, _emberApplicationSystemEngineInstance, _emberApplicationSystemEngineParent) {
  'use strict';

  var MyEngine = undefined,
      myEngine = undefined,
      myEngineInstance = undefined;

  function buildEngineInstance(EngineClass) {
    var engineInstance = EngineClass.buildInstance();
    _emberApplicationSystemEngineParent.setEngineParent(engineInstance, {
      lookup: function () {
        return {};
      },
      resolveRegistration: function () {
        return {};
      }
    });
    return engineInstance;
  }

  QUnit.module('Ember.Engine instance initializers', {
    setup: function () {},

    teardown: function () {
      _emberMetal.run(function () {
        if (myEngineInstance) {
          myEngineInstance.destroy();
        }

        if (myEngine) {
          myEngine.destroy();
        }
      });
    }
  });

  QUnit.test('initializers require proper \'name\' and \'initialize\' properties', function () {
    MyEngine = _emberApplicationSystemEngine.default.extend();

    expectAssertion(function () {
      _emberMetal.run(function () {
        MyEngine.instanceInitializer({ name: 'initializer' });
      });
    });

    expectAssertion(function () {
      _emberMetal.run(function () {
        MyEngine.instanceInitializer({ initialize: function () {} });
      });
    });
  });

  QUnit.test('initializers are passed an engine instance', function () {
    MyEngine = _emberApplicationSystemEngine.default.extend();

    MyEngine.instanceInitializer({
      name: 'initializer',
      initialize: function (instance) {
        ok(instance instanceof _emberApplicationSystemEngineInstance.default, 'initialize is passed an engine instance');
      }
    });

    myEngine = MyEngine.create();
    myEngineInstance = buildEngineInstance(myEngine);
    return myEngineInstance.boot();
  });

  QUnit.test('initializers can be registered in a specified order', function () {
    var order = [];

    MyEngine = _emberApplicationSystemEngine.default.extend();

    MyEngine.instanceInitializer({
      name: 'fourth',
      after: 'third',
      initialize: function (engine) {
        order.push('fourth');
      }
    });

    MyEngine.instanceInitializer({
      name: 'second',
      after: 'first',
      before: 'third',
      initialize: function (engine) {
        order.push('second');
      }
    });

    MyEngine.instanceInitializer({
      name: 'fifth',
      after: 'fourth',
      before: 'sixth',
      initialize: function (engine) {
        order.push('fifth');
      }
    });

    MyEngine.instanceInitializer({
      name: 'first',
      before: 'second',
      initialize: function (engine) {
        order.push('first');
      }
    });

    MyEngine.instanceInitializer({
      name: 'third',
      initialize: function (engine) {
        order.push('third');
      }
    });

    MyEngine.instanceInitializer({
      name: 'sixth',
      initialize: function (engine) {
        order.push('sixth');
      }
    });

    myEngine = MyEngine.create();
    myEngineInstance = buildEngineInstance(myEngine);

    return myEngineInstance.boot().then(function () {
      deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
    });
  });

  QUnit.test('initializers can be registered in a specified order as an array', function () {
    var order = [];
    MyEngine = _emberApplicationSystemEngine.default.extend();

    MyEngine.instanceInitializer({
      name: 'third',
      initialize: function (engine) {
        order.push('third');
      }
    });

    MyEngine.instanceInitializer({
      name: 'second',
      after: 'first',
      before: ['third', 'fourth'],
      initialize: function (engine) {
        order.push('second');
      }
    });

    MyEngine.instanceInitializer({
      name: 'fourth',
      after: ['second', 'third'],
      initialize: function (engine) {
        order.push('fourth');
      }
    });

    MyEngine.instanceInitializer({
      name: 'fifth',
      after: 'fourth',
      before: 'sixth',
      initialize: function (engine) {
        order.push('fifth');
      }
    });

    MyEngine.instanceInitializer({
      name: 'first',
      before: ['second'],
      initialize: function (engine) {
        order.push('first');
      }
    });

    MyEngine.instanceInitializer({
      name: 'sixth',
      initialize: function (engine) {
        order.push('sixth');
      }
    });

    myEngine = MyEngine.create();
    myEngineInstance = buildEngineInstance(myEngine);

    return myEngineInstance.boot().then(function () {
      deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
    });
  });

  QUnit.test('initializers can have multiple dependencies', function () {
    var order = [];

    MyEngine = _emberApplicationSystemEngine.default.extend();

    var a = {
      name: 'a',
      before: 'b',
      initialize: function (engine) {
        order.push('a');
      }
    };
    var b = {
      name: 'b',
      initialize: function (engine) {
        order.push('b');
      }
    };
    var c = {
      name: 'c',
      after: 'b',
      initialize: function (engine) {
        order.push('c');
      }
    };
    var afterB = {
      name: 'after b',
      after: 'b',
      initialize: function (engine) {
        order.push('after b');
      }
    };
    var afterC = {
      name: 'after c',
      after: 'c',
      initialize: function (engine) {
        order.push('after c');
      }
    };

    MyEngine.instanceInitializer(b);
    MyEngine.instanceInitializer(a);
    MyEngine.instanceInitializer(afterC);
    MyEngine.instanceInitializer(afterB);
    MyEngine.instanceInitializer(c);

    myEngine = MyEngine.create();
    myEngineInstance = buildEngineInstance(myEngine);

    return myEngineInstance.boot().then(function () {
      ok(order.indexOf(a.name) < order.indexOf(b.name), 'a < b');
      ok(order.indexOf(b.name) < order.indexOf(c.name), 'b < c');
      ok(order.indexOf(b.name) < order.indexOf(afterB.name), 'b < afterB');
      ok(order.indexOf(c.name) < order.indexOf(afterC.name), 'c < afterC');
    });
  });

  QUnit.test('initializers set on Engine subclasses should not be shared between engines', function () {
    var firstInitializerRunCount = 0;
    var secondInitializerRunCount = 0;
    var FirstEngine = _emberApplicationSystemEngine.default.extend();
    var firstEngine = undefined,
        firstEngineInstance = undefined;

    FirstEngine.instanceInitializer({
      name: 'first',
      initialize: function (engine) {
        firstInitializerRunCount++;
      }
    });

    var SecondEngine = _emberApplicationSystemEngine.default.extend();
    var secondEngine = undefined,
        secondEngineInstance = undefined;

    SecondEngine.instanceInitializer({
      name: 'second',
      initialize: function (engine) {
        secondInitializerRunCount++;
      }
    });

    firstEngine = FirstEngine.create();
    firstEngineInstance = buildEngineInstance(firstEngine);

    return firstEngineInstance.boot().then(function () {
      equal(firstInitializerRunCount, 1, 'first initializer only was run');
      equal(secondInitializerRunCount, 0, 'first initializer only was run');

      secondEngine = SecondEngine.create();
      secondEngineInstance = buildEngineInstance(secondEngine);
      return secondEngineInstance.boot();
    }).then(function () {
      equal(firstInitializerRunCount, 1, 'second initializer only was run');
      equal(secondInitializerRunCount, 1, 'second initializer only was run');

      _emberMetal.run(function () {
        firstEngineInstance.destroy();
        secondEngineInstance.destroy();

        firstEngine.destroy();
        secondEngine.destroy();
      });
    });
  });

  QUnit.test('initializers are concatenated', function () {
    var firstInitializerRunCount = 0;
    var secondInitializerRunCount = 0;
    var FirstEngine = _emberApplicationSystemEngine.default.extend();

    FirstEngine.instanceInitializer({
      name: 'first',
      initialize: function (engine) {
        firstInitializerRunCount++;
      }
    });

    var SecondEngine = FirstEngine.extend();

    SecondEngine.instanceInitializer({
      name: 'second',
      initialize: function (engine) {
        secondInitializerRunCount++;
      }
    });

    var firstEngine = FirstEngine.create();
    var firstEngineInstance = buildEngineInstance(firstEngine);

    var secondEngine = undefined,
        secondEngineInstance = undefined;

    return firstEngineInstance.boot().then(function () {
      equal(firstInitializerRunCount, 1, 'first initializer only was run when base class created');
      equal(secondInitializerRunCount, 0, 'second initializer was not run when first base class created');
      firstInitializerRunCount = 0;

      secondEngine = SecondEngine.create();
      secondEngineInstance = buildEngineInstance(secondEngine);
      return secondEngineInstance.boot();
    }).then(function () {
      equal(firstInitializerRunCount, 1, 'first initializer was run when subclass created');
      equal(secondInitializerRunCount, 1, 'second initializers was run when subclass created');

      _emberMetal.run(function () {
        firstEngineInstance.destroy();
        secondEngineInstance.destroy();

        firstEngine.destroy();
        secondEngine.destroy();
      });
    });
  });

  QUnit.test('initializers are per-engine', function () {
    expect(2);

    var FirstEngine = _emberApplicationSystemEngine.default.extend();

    FirstEngine.instanceInitializer({
      name: 'abc',
      initialize: function (engine) {}
    });

    expectAssertion(function () {
      FirstEngine.instanceInitializer({
        name: 'abc',
        initialize: function (engine) {}
      });
    });

    var SecondEngine = _emberApplicationSystemEngine.default.extend();
    SecondEngine.instanceInitializer({
      name: 'abc',
      initialize: function (engine) {}
    });

    ok(true, 'Two engines can have initializers named the same.');
  });

  QUnit.test('initializers are executed in their own context', function () {
    expect(1);

    var MyEngine = _emberApplicationSystemEngine.default.extend();

    MyEngine.instanceInitializer({
      name: 'coolInitializer',
      myProperty: 'cool',
      initialize: function (engine) {
        equal(this.myProperty, 'cool', 'should have access to its own context');
      }
    });

    myEngine = MyEngine.create();
    myEngineInstance = buildEngineInstance(myEngine);

    return myEngineInstance.boot();
  });
});
enifed('ember-application/tests/system/engine_instance_initializers_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/tests/system/engine_instance_initializers_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/tests/system/engine_instance_initializers_test.js should pass ESLint\n\n');
  });
});
enifed('ember-application/tests/system/engine_instance_test', ['exports', 'ember-application/system/engine', 'ember-application/system/engine-instance', 'ember-application/system/engine-parent', 'ember-metal', 'internal-test-helpers'], function (exports, _emberApplicationSystemEngine, _emberApplicationSystemEngineInstance, _emberApplicationSystemEngineParent, _emberMetal, _internalTestHelpers) {
  'use strict';

  var engine = undefined,
      engineInstance = undefined;

  QUnit.module('Ember.EngineInstance', {
    setup: function () {
      _emberMetal.run(function () {
        engine = _emberApplicationSystemEngine.default.create({ router: null });
      });
    },

    teardown: function () {
      if (engineInstance) {
        _emberMetal.run(engineInstance, 'destroy');
      }

      if (engine) {
        _emberMetal.run(engine, 'destroy');
      }
    }
  });

  QUnit.test('an engine instance can be created based upon a base engine', function () {
    _emberMetal.run(function () {
      engineInstance = _emberApplicationSystemEngineInstance.default.create({ base: engine });
    });

    ok(engineInstance, 'instance should be created');
    equal(engineInstance.base, engine, 'base should be set to engine');
  });

  QUnit.test('unregistering a factory clears all cached instances of that factory', function (assert) {
    assert.expect(3);

    engineInstance = _emberMetal.run(function () {
      return _emberApplicationSystemEngineInstance.default.create({ base: engine });
    });

    var PostComponent = _internalTestHelpers.factory();

    engineInstance.register('component:post', PostComponent);

    var postComponent1 = engineInstance.lookup('component:post');
    assert.ok(postComponent1, 'lookup creates instance');

    engineInstance.unregister('component:post');
    engineInstance.register('component:post', PostComponent);

    var postComponent2 = engineInstance.lookup('component:post');
    assert.ok(postComponent2, 'lookup creates instance');

    assert.notStrictEqual(postComponent1, postComponent2, 'lookup creates a brand new instance because previous one was reset');
  });

  QUnit.test('can be booted when its parent has been set', function (assert) {
    assert.expect(3);

    engineInstance = _emberMetal.run(function () {
      return _emberApplicationSystemEngineInstance.default.create({ base: engine });
    });

    expectAssertion(function () {
      engineInstance._bootSync();
    }, 'An engine instance\'s parent must be set via `setEngineParent(engine, parent)` prior to calling `engine.boot()`.');

    _emberApplicationSystemEngineParent.setEngineParent(engineInstance, {});

    // Stub `cloneParentDependencies`, the internals of which are tested along
    // with application instances.
    engineInstance.cloneParentDependencies = function () {
      assert.ok(true, 'parent dependencies are cloned');
    };

    return engineInstance.boot().then(function () {
      assert.ok(true, 'boot successful');
    });
  });

  QUnit.test('can build a child instance of a registered engine', function (assert) {
    var ChatEngine = _emberApplicationSystemEngine.default.extend();
    var chatEngineInstance = undefined;

    engine.register('engine:chat', ChatEngine);

    _emberMetal.run(function () {
      engineInstance = _emberApplicationSystemEngineInstance.default.create({ base: engine });

      // Try to build an unregistered engine.
      throws(function () {
        engineInstance.buildChildEngineInstance('fake');
      }, 'You attempted to mount the engine \'fake\', but it is not registered with its parent.');

      // Build the `chat` engine, registered above.
      chatEngineInstance = engineInstance.buildChildEngineInstance('chat');
    });

    assert.ok(chatEngineInstance, 'child engine instance successfully created');

    assert.strictEqual(_emberApplicationSystemEngineParent.getEngineParent(chatEngineInstance), engineInstance, 'child engine instance is assigned the correct parent');
  });
});
enifed('ember-application/tests/system/engine_instance_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/tests/system/engine_instance_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/tests/system/engine_instance_test.js should pass ESLint\n\n');
  });
});
enifed('ember-application/tests/system/engine_parent_test', ['exports', 'ember-application/system/engine-parent'], function (exports, _emberApplicationSystemEngineParent) {
  'use strict';

  QUnit.module('EngineParent', {});

  QUnit.test('An engine\'s parent can be set with `setEngineParent` and retrieved with `getEngineParent`', function () {
    var engine = {};
    var parent = {};

    strictEqual(_emberApplicationSystemEngineParent.getEngineParent(engine), undefined, 'parent has not been set');

    _emberApplicationSystemEngineParent.setEngineParent(engine, parent);

    strictEqual(_emberApplicationSystemEngineParent.getEngineParent(engine), parent, 'parent has been set');

    strictEqual(engine[_emberApplicationSystemEngineParent.ENGINE_PARENT], parent, 'parent has been set to the ENGINE_PARENT symbol');
  });
});
enifed('ember-application/tests/system/engine_parent_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/tests/system/engine_parent_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/tests/system/engine_parent_test.js should pass ESLint\n\n');
  });
});
enifed('ember-application/tests/system/engine_test', ['exports', 'ember-environment', 'ember-metal', 'ember-application/system/engine', 'ember-runtime', 'container', 'ember-application/tests/test-helpers/registry-check'], function (exports, _emberEnvironment, _emberMetal, _emberApplicationSystemEngine, _emberRuntime, _container, _emberApplicationTestsTestHelpersRegistryCheck) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['-bucket-cache:main'], ['-bucket-cache:main']),
      _templateObject2 = babelHelpers.taggedTemplateLiteralLoose(['template:components/-default'], ['template:components/-default']);

  var engine = undefined;
  var originalLookup = _emberEnvironment.context.lookup;
  var lookup = undefined;

  QUnit.module('Ember.Engine', {
    setup: function () {
      lookup = _emberEnvironment.context.lookup = {};
      engine = _emberMetal.run(function () {
        return _emberApplicationSystemEngine.default.create();
      });
    },

    teardown: function () {
      _emberEnvironment.context.lookup = originalLookup;
      if (engine) {
        _emberMetal.run(engine, 'destroy');
      }
    }
  });

  QUnit.test('acts like a namespace', function () {
    engine = _emberMetal.run(function () {
      return lookup.TestEngine = _emberApplicationSystemEngine.default.create();
    });

    engine.Foo = _emberRuntime.Object.extend();
    equal(engine.Foo.toString(), 'TestEngine.Foo', 'Classes pick up their parent namespace');
  });

  QUnit.test('builds a registry', function () {
    strictEqual(engine.resolveRegistration('application:main'), engine, 'application:main is registered');
    deepEqual(engine.registeredOptionsForType('component'), { singleton: false }, 'optionsForType \'component\'');
    deepEqual(engine.registeredOptionsForType('view'), { singleton: false }, 'optionsForType \'view\'');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(engine, 'controller:basic');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(engine, 'view', '_viewRegistry', '-view-registry:main');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(engine, 'route', '_topLevelViewTemplate', 'template:-outlet');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(engine, 'view:-outlet', 'namespace', 'application:main');

    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(engine, 'controller', 'target', 'router:main');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(engine, 'controller', 'namespace', 'application:main');

    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(engine, 'router', '_bucketCache', _container.privatize(_templateObject));
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(engine, 'route', '_bucketCache', _container.privatize(_templateObject));

    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(engine, 'route', 'router', 'router:main');

    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(engine, 'component:-text-field');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(engine, 'component:-text-area');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(engine, 'component:-checkbox');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(engine, 'component:link-to');

    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(engine, 'service:-routing');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(engine, 'service:-routing', 'router', 'router:main');

    // DEBUGGING
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(engine, 'resolver-for-debugging:main');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(engine, 'container-debug-adapter:main', 'resolver', 'resolver-for-debugging:main');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(engine, 'data-adapter:main', 'containerDebugAdapter', 'container-debug-adapter:main');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(engine, 'container-debug-adapter:main');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(engine, 'component-lookup:main');

    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(engine, 'service:-dom-changes', 'document', 'service:-document');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(engine, 'service:-dom-tree-construction', 'document', 'service:-document');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(engine, 'view:-outlet');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(engine, _container.privatize(_templateObject2));
    _emberApplicationTestsTestHelpersRegistryCheck.verifyRegistration(engine, 'template:-outlet');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(engine, 'view:-outlet', 'template', 'template:-outlet');
    _emberApplicationTestsTestHelpersRegistryCheck.verifyInjection(engine, 'template', 'env', 'service:-glimmer-environment');
    deepEqual(engine.registeredOptionsForType('helper'), { instantiate: false }, 'optionsForType \'helper\'');
  });
});
enifed('ember-application/tests/system/engine_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/tests/system/engine_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/tests/system/engine_test.js should pass ESLint\n\n');
  });
});
enifed('ember-application/tests/system/initializers_test', ['exports', 'ember-metal', 'ember-application/system/application', 'ember-views'], function (exports, _emberMetal, _emberApplicationSystemApplication, _emberViews) {
  'use strict';

  var app = undefined;

  QUnit.module('Ember.Application initializers', {
    teardown: function () {
      if (app) {
        _emberMetal.run(function () {
          return app.destroy();
        });
      }
    }
  });

  QUnit.test('initializers require proper \'name\' and \'initialize\' properties', function () {
    var MyApplication = _emberApplicationSystemApplication.default.extend();

    expectAssertion(function () {
      _emberMetal.run(function () {
        MyApplication.initializer({ name: 'initializer' });
      });
    });

    expectAssertion(function () {
      _emberMetal.run(function () {
        MyApplication.initializer({ initialize: function () {} });
      });
    });
  });

  QUnit.test('initializers that throw errors cause the boot promise to reject with the error', function () {
    QUnit.expect(2);
    QUnit.stop();

    var MyApplication = _emberApplicationSystemApplication.default.extend();

    MyApplication.initializer({
      name: 'initializer',
      initialize: function () {
        throw new Error('boot failure');
      }
    });

    app = MyApplication.create({
      autoboot: false
    });

    try {
      app.boot().then(function (app) {
        QUnit.start();
        ok(false, 'The boot promise should not resolve when there is a boot error');
      }, function (err) {
        QUnit.start();
        ok(err instanceof Error, 'The boot promise should reject with an error');
        equal(err.message, 'boot failure');
      });
    } catch (e) {
      QUnit.start();
      ok(false, 'The boot method should not throw');
      throw e;
    }
  });

  QUnit.test('initializers are passed an App', function () {
    var MyApplication = _emberApplicationSystemApplication.default.extend();

    MyApplication.initializer({
      name: 'initializer',
      initialize: function (App) {
        ok(App instanceof _emberApplicationSystemApplication.default, 'initialize is passed an Application');
      }
    });

    _emberMetal.run(function () {
      app = MyApplication.create({
        router: false,
        rootElement: '#qunit-fixture'
      });
    });
  });

  QUnit.test('initializers can be registered in a specified order', function () {
    var order = [];
    var MyApplication = _emberApplicationSystemApplication.default.extend();
    MyApplication.initializer({
      name: 'fourth',
      after: 'third',
      initialize: function (registry) {
        order.push('fourth');
      }
    });

    MyApplication.initializer({
      name: 'second',
      after: 'first',
      before: 'third',
      initialize: function (registry) {
        order.push('second');
      }
    });

    MyApplication.initializer({
      name: 'fifth',
      after: 'fourth',
      before: 'sixth',
      initialize: function (registry) {
        order.push('fifth');
      }
    });

    MyApplication.initializer({
      name: 'first',
      before: 'second',
      initialize: function (registry) {
        order.push('first');
      }
    });

    MyApplication.initializer({
      name: 'third',
      initialize: function (registry) {
        order.push('third');
      }
    });

    MyApplication.initializer({
      name: 'sixth',
      initialize: function (registry) {
        order.push('sixth');
      }
    });

    _emberMetal.run(function () {
      app = MyApplication.create({
        router: false,
        rootElement: '#qunit-fixture'
      });
    });

    deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
  });

  QUnit.test('initializers can be registered in a specified order as an array', function () {
    var order = [];
    var MyApplication = _emberApplicationSystemApplication.default.extend();

    MyApplication.initializer({
      name: 'third',
      initialize: function (registry) {
        order.push('third');
      }
    });

    MyApplication.initializer({
      name: 'second',
      after: 'first',
      before: ['third', 'fourth'],
      initialize: function (registry) {
        order.push('second');
      }
    });

    MyApplication.initializer({
      name: 'fourth',
      after: ['second', 'third'],
      initialize: function (registry) {
        order.push('fourth');
      }
    });

    MyApplication.initializer({
      name: 'fifth',
      after: 'fourth',
      before: 'sixth',
      initialize: function (registry) {
        order.push('fifth');
      }
    });

    MyApplication.initializer({
      name: 'first',
      before: ['second'],
      initialize: function (registry) {
        order.push('first');
      }
    });

    MyApplication.initializer({
      name: 'sixth',
      initialize: function (registry) {
        order.push('sixth');
      }
    });

    _emberMetal.run(function () {
      app = MyApplication.create({
        router: false,
        rootElement: '#qunit-fixture'
      });
    });

    deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
  });

  QUnit.test('initializers can have multiple dependencies', function () {
    var order = [];
    var a = {
      name: 'a',
      before: 'b',
      initialize: function (registry) {
        order.push('a');
      }
    };
    var b = {
      name: 'b',
      initialize: function (registry) {
        order.push('b');
      }
    };
    var c = {
      name: 'c',
      after: 'b',
      initialize: function (registry) {
        order.push('c');
      }
    };
    var afterB = {
      name: 'after b',
      after: 'b',
      initialize: function (registry) {
        order.push('after b');
      }
    };
    var afterC = {
      name: 'after c',
      after: 'c',
      initialize: function (registry) {
        order.push('after c');
      }
    };

    _emberApplicationSystemApplication.default.initializer(b);
    _emberApplicationSystemApplication.default.initializer(a);
    _emberApplicationSystemApplication.default.initializer(afterC);
    _emberApplicationSystemApplication.default.initializer(afterB);
    _emberApplicationSystemApplication.default.initializer(c);

    _emberMetal.run(function () {
      app = _emberApplicationSystemApplication.default.create({
        router: false,
        rootElement: '#qunit-fixture'
      });
    });

    ok(order.indexOf(a.name) < order.indexOf(b.name), 'a < b');
    ok(order.indexOf(b.name) < order.indexOf(c.name), 'b < c');
    ok(order.indexOf(b.name) < order.indexOf(afterB.name), 'b < afterB');
    ok(order.indexOf(c.name) < order.indexOf(afterC.name), 'c < afterC');
  });

  QUnit.test('initializers set on Application subclasses are not shared between apps', function () {
    var firstInitializerRunCount = 0;
    var secondInitializerRunCount = 0;
    var FirstApp = _emberApplicationSystemApplication.default.extend();

    FirstApp.initializer({
      name: 'first',
      initialize: function (registry) {
        firstInitializerRunCount++;
      }
    });

    var SecondApp = _emberApplicationSystemApplication.default.extend();

    SecondApp.initializer({
      name: 'second',
      initialize: function (registry) {
        secondInitializerRunCount++;
      }
    });

    _emberViews.jQuery('#qunit-fixture').html('<div id="first"></div><div id="second"></div>');

    var firstApp = _emberMetal.run(function () {
      return FirstApp.create({
        router: false,
        rootElement: '#qunit-fixture #first'
      });
    });

    equal(firstInitializerRunCount, 1, 'first initializer only was run');
    equal(secondInitializerRunCount, 0, 'first initializer only was run');

    var secondApp = _emberMetal.run(function () {
      return SecondApp.create({
        router: false,
        rootElement: '#qunit-fixture #second'
      });
    });

    equal(firstInitializerRunCount, 1, 'second initializer only was run');
    equal(secondInitializerRunCount, 1, 'second initializer only was run');

    _emberMetal.run(function () {
      firstApp.destroy();
      secondApp.destroy();
    });
  });

  QUnit.test('initializers are concatenated', function () {
    var firstInitializerRunCount = 0;
    var secondInitializerRunCount = 0;
    var FirstApp = _emberApplicationSystemApplication.default.extend();

    FirstApp.initializer({
      name: 'first',
      initialize: function (registry) {
        firstInitializerRunCount++;
      }
    });

    var SecondApp = FirstApp.extend();
    SecondApp.initializer({
      name: 'second',
      initialize: function (registry) {
        secondInitializerRunCount++;
      }
    });

    _emberViews.jQuery('#qunit-fixture').html('<div id="first"></div><div id="second"></div>');
    var firstApp = _emberMetal.run(function () {
      return FirstApp.create({
        router: false,
        rootElement: '#qunit-fixture #first'
      });
    });
    equal(firstInitializerRunCount, 1, 'first initializer only was run when base class created');
    equal(secondInitializerRunCount, 0, 'first initializer only was run when base class created');
    firstInitializerRunCount = 0;

    var secondApp = _emberMetal.run(function () {
      return SecondApp.create({
        router: false,
        rootElement: '#qunit-fixture #second'
      });
    });

    equal(firstInitializerRunCount, 1, 'first initializer was run when subclass created');
    equal(secondInitializerRunCount, 1, 'second initializers was run when subclass created');
    _emberMetal.run(function () {
      firstApp.destroy();
      secondApp.destroy();
    });
  });

  QUnit.test('initializers are per-app', function () {
    expect(2);

    var FirstApp = _emberApplicationSystemApplication.default.extend();

    FirstApp.initializer({
      name: 'abc',
      initialize: function (app) {}
    });

    expectAssertion(function () {
      FirstApp.initializer({
        name: 'abc',
        initialize: function (app) {}
      });
    });

    var SecondApp = _emberApplicationSystemApplication.default.extend();
    SecondApp.instanceInitializer({
      name: 'abc',
      initialize: function (app) {}
    });

    ok(true, 'Two apps can have initializers named the same.');
  });

  QUnit.test('initializers are executed in their own context', function () {
    expect(1);
    var MyApplication = _emberApplicationSystemApplication.default.extend();

    MyApplication.initializer({
      name: 'coolInitializer',
      myProperty: 'cool',
      initialize: function (application) {
        equal(this.myProperty, 'cool', 'should have access to its own context');
      }
    });

    _emberMetal.run(function () {
      app = MyApplication.create({
        router: false,
        rootElement: '#qunit-fixture'
      });
    });
  });

  QUnit.test('initializers throw a deprecation warning when receiving a second argument', function () {
    expect(1);

    var MyApplication = _emberApplicationSystemApplication.default.extend();

    MyApplication.initializer({
      name: 'deprecated',
      initialize: function (registry, application) {}
    });

    expectDeprecation(function () {
      _emberMetal.run(function () {
        app = MyApplication.create({
          router: false,
          rootElement: '#qunit-fixture'
        });
      });
    }, /The `initialize` method for Application initializer 'deprecated' should take only one argument - `App`, an instance of an `Application`./);
  });
});
enifed('ember-application/tests/system/initializers_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/tests/system/initializers_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/tests/system/initializers_test.js should pass ESLint\n\n');
  });
});
enifed('ember-application/tests/system/instance_initializers_test', ['exports', 'ember-metal', 'ember-application/system/application', 'ember-application/system/application-instance', 'ember-views'], function (exports, _emberMetal, _emberApplicationSystemApplication, _emberApplicationSystemApplicationInstance, _emberViews) {
  'use strict';

  var app = undefined;

  QUnit.module('Ember.Application instance initializers', {
    teardown: function () {
      if (app) {
        _emberMetal.run(function () {
          return app.destroy();
        });
      }
    }
  });

  QUnit.test('initializers require proper \'name\' and \'initialize\' properties', function () {
    var MyApplication = _emberApplicationSystemApplication.default.extend();

    expectAssertion(function () {
      _emberMetal.run(function () {
        MyApplication.instanceInitializer({ name: 'initializer' });
      });
    });

    expectAssertion(function () {
      _emberMetal.run(function () {
        MyApplication.instanceInitializer({ initialize: function () {} });
      });
    });
  });

  QUnit.test('initializers are passed an app instance', function () {
    var MyApplication = _emberApplicationSystemApplication.default.extend();

    MyApplication.instanceInitializer({
      name: 'initializer',
      initialize: function (instance) {
        ok(instance instanceof _emberApplicationSystemApplicationInstance.default, 'initialize is passed an application instance');
      }
    });

    _emberMetal.run(function () {
      app = MyApplication.create({
        router: false,
        rootElement: '#qunit-fixture'
      });
    });
  });

  QUnit.test('initializers can be registered in a specified order', function () {
    var order = [];
    var MyApplication = _emberApplicationSystemApplication.default.extend();
    MyApplication.instanceInitializer({
      name: 'fourth',
      after: 'third',
      initialize: function (registry) {
        order.push('fourth');
      }
    });

    MyApplication.instanceInitializer({
      name: 'second',
      after: 'first',
      before: 'third',
      initialize: function (registry) {
        order.push('second');
      }
    });

    MyApplication.instanceInitializer({
      name: 'fifth',
      after: 'fourth',
      before: 'sixth',
      initialize: function (registry) {
        order.push('fifth');
      }
    });

    MyApplication.instanceInitializer({
      name: 'first',
      before: 'second',
      initialize: function (registry) {
        order.push('first');
      }
    });

    MyApplication.instanceInitializer({
      name: 'third',
      initialize: function (registry) {
        order.push('third');
      }
    });

    MyApplication.instanceInitializer({
      name: 'sixth',
      initialize: function (registry) {
        order.push('sixth');
      }
    });

    _emberMetal.run(function () {
      app = MyApplication.create({
        router: false,
        rootElement: '#qunit-fixture'
      });
    });

    deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
  });

  QUnit.test('initializers can be registered in a specified order as an array', function () {
    var order = [];
    var MyApplication = _emberApplicationSystemApplication.default.extend();

    MyApplication.instanceInitializer({
      name: 'third',
      initialize: function (registry) {
        order.push('third');
      }
    });

    MyApplication.instanceInitializer({
      name: 'second',
      after: 'first',
      before: ['third', 'fourth'],
      initialize: function (registry) {
        order.push('second');
      }
    });

    MyApplication.instanceInitializer({
      name: 'fourth',
      after: ['second', 'third'],
      initialize: function (registry) {
        order.push('fourth');
      }
    });

    MyApplication.instanceInitializer({
      name: 'fifth',
      after: 'fourth',
      before: 'sixth',
      initialize: function (registry) {
        order.push('fifth');
      }
    });

    MyApplication.instanceInitializer({
      name: 'first',
      before: ['second'],
      initialize: function (registry) {
        order.push('first');
      }
    });

    MyApplication.instanceInitializer({
      name: 'sixth',
      initialize: function (registry) {
        order.push('sixth');
      }
    });

    _emberMetal.run(function () {
      app = MyApplication.create({
        router: false,
        rootElement: '#qunit-fixture'
      });
    });

    deepEqual(order, ['first', 'second', 'third', 'fourth', 'fifth', 'sixth']);
  });

  QUnit.test('initializers can have multiple dependencies', function () {
    var order = [];
    var a = {
      name: 'a',
      before: 'b',
      initialize: function (registry) {
        order.push('a');
      }
    };
    var b = {
      name: 'b',
      initialize: function (registry) {
        order.push('b');
      }
    };
    var c = {
      name: 'c',
      after: 'b',
      initialize: function (registry) {
        order.push('c');
      }
    };
    var afterB = {
      name: 'after b',
      after: 'b',
      initialize: function (registry) {
        order.push('after b');
      }
    };
    var afterC = {
      name: 'after c',
      after: 'c',
      initialize: function (registry) {
        order.push('after c');
      }
    };

    _emberApplicationSystemApplication.default.instanceInitializer(b);
    _emberApplicationSystemApplication.default.instanceInitializer(a);
    _emberApplicationSystemApplication.default.instanceInitializer(afterC);
    _emberApplicationSystemApplication.default.instanceInitializer(afterB);
    _emberApplicationSystemApplication.default.instanceInitializer(c);

    _emberMetal.run(function () {
      app = _emberApplicationSystemApplication.default.create({
        router: false,
        rootElement: '#qunit-fixture'
      });
    });

    ok(order.indexOf(a.name) < order.indexOf(b.name), 'a < b');
    ok(order.indexOf(b.name) < order.indexOf(c.name), 'b < c');
    ok(order.indexOf(b.name) < order.indexOf(afterB.name), 'b < afterB');
    ok(order.indexOf(c.name) < order.indexOf(afterC.name), 'c < afterC');
  });

  QUnit.test('initializers set on Application subclasses should not be shared between apps', function () {
    var firstInitializerRunCount = 0;
    var secondInitializerRunCount = 0;
    var FirstApp = _emberApplicationSystemApplication.default.extend();
    var firstApp = undefined,
        secondApp = undefined;

    FirstApp.instanceInitializer({
      name: 'first',
      initialize: function (registry) {
        firstInitializerRunCount++;
      }
    });
    var SecondApp = _emberApplicationSystemApplication.default.extend();
    SecondApp.instanceInitializer({
      name: 'second',
      initialize: function (registry) {
        secondInitializerRunCount++;
      }
    });
    _emberViews.jQuery('#qunit-fixture').html('<div id="first"></div><div id="second"></div>');
    _emberMetal.run(function () {
      firstApp = FirstApp.create({
        router: false,
        rootElement: '#qunit-fixture #first'
      });
    });
    equal(firstInitializerRunCount, 1, 'first initializer only was run');
    equal(secondInitializerRunCount, 0, 'first initializer only was run');
    _emberMetal.run(function () {
      secondApp = SecondApp.create({
        router: false,
        rootElement: '#qunit-fixture #second'
      });
    });
    equal(firstInitializerRunCount, 1, 'second initializer only was run');
    equal(secondInitializerRunCount, 1, 'second initializer only was run');
    _emberMetal.run(function () {
      firstApp.destroy();
      secondApp.destroy();
    });
  });

  QUnit.test('initializers are concatenated', function () {
    var firstInitializerRunCount = 0;
    var secondInitializerRunCount = 0;
    var FirstApp = _emberApplicationSystemApplication.default.extend();
    var firstApp = undefined,
        secondApp = undefined;

    FirstApp.instanceInitializer({
      name: 'first',
      initialize: function (registry) {
        firstInitializerRunCount++;
      }
    });

    var SecondApp = FirstApp.extend();
    SecondApp.instanceInitializer({
      name: 'second',
      initialize: function (registry) {
        secondInitializerRunCount++;
      }
    });

    _emberViews.jQuery('#qunit-fixture').html('<div id="first"></div><div id="second"></div>');
    _emberMetal.run(function () {
      firstApp = FirstApp.create({
        router: false,
        rootElement: '#qunit-fixture #first'
      });
    });
    equal(firstInitializerRunCount, 1, 'first initializer only was run when base class created');
    equal(secondInitializerRunCount, 0, 'first initializer only was run when base class created');
    firstInitializerRunCount = 0;
    _emberMetal.run(function () {
      secondApp = SecondApp.create({
        router: false,
        rootElement: '#qunit-fixture #second'
      });
    });
    equal(firstInitializerRunCount, 1, 'first initializer was run when subclass created');
    equal(secondInitializerRunCount, 1, 'second initializers was run when subclass created');
    _emberMetal.run(function () {
      firstApp.destroy();
      secondApp.destroy();
    });
  });

  QUnit.test('initializers are per-app', function () {
    expect(2);

    var FirstApp = _emberApplicationSystemApplication.default.extend();

    FirstApp.instanceInitializer({
      name: 'abc',
      initialize: function (app) {}
    });

    expectAssertion(function () {
      FirstApp.instanceInitializer({
        name: 'abc',
        initialize: function (app) {}
      });
    });

    var SecondApp = _emberApplicationSystemApplication.default.extend();
    SecondApp.instanceInitializer({
      name: 'abc',
      initialize: function (app) {}
    });

    ok(true, 'Two apps can have initializers named the same.');
  });

  QUnit.test('initializers are run before ready hook', function () {
    expect(2);

    var readyWasCalled = false;

    var MyApplication = _emberApplicationSystemApplication.default.extend({
      ready: function () {
        ok(true, 'ready is called');
        readyWasCalled = true;
      }
    });

    MyApplication.instanceInitializer({
      name: 'initializer',
      initialize: function () {
        ok(!readyWasCalled, 'ready is not yet called');
      }
    });

    _emberMetal.run(function () {
      app = MyApplication.create({
        router: false,
        rootElement: '#qunit-fixture'
      });
    });
  });

  QUnit.test('initializers are executed in their own context', function () {
    expect(1);

    var MyApplication = _emberApplicationSystemApplication.default.extend();

    MyApplication.instanceInitializer({
      name: 'coolInitializer',
      myProperty: 'cool',
      initialize: function (registry, application) {
        equal(this.myProperty, 'cool', 'should have access to its own context');
      }
    });

    _emberMetal.run(function () {
      app = MyApplication.create({
        router: false,
        rootElement: '#qunit-fixture'
      });
    });
  });

  QUnit.test('initializers get an instance on app reset', function () {
    expect(2);

    var MyApplication = _emberApplicationSystemApplication.default.extend();

    MyApplication.instanceInitializer({
      name: 'giveMeAnInstance',
      initialize: function (instance) {
        ok(!!instance, 'Initializer got an instance');
      }
    });

    _emberMetal.run(function () {
      app = MyApplication.create({
        router: false,
        rootElement: '#qunit-fixture'
      });
    });

    _emberMetal.run(app, 'reset');
  });
});
enifed('ember-application/tests/system/instance_initializers_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/tests/system/instance_initializers_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/tests/system/instance_initializers_test.js should pass ESLint\n\n');
  });
});
enifed('ember-application/tests/system/logging_test', ['exports', 'ember-console', 'ember-metal', 'ember-application/system/application', 'ember-runtime', 'ember-routing', 'ember-template-compiler'], function (exports, _emberConsole, _emberMetal, _emberApplicationSystemApplication, _emberRuntime, _emberRouting, _emberTemplateCompiler) {
  /*globals EmberDev */

  'use strict';

  var App = undefined,
      logs = undefined,
      originalLogger = undefined;

  QUnit.module('Ember.Application – logging of generated classes', {
    setup: function () {
      logs = {};

      originalLogger = _emberConsole.default.info;

      _emberConsole.default.info = function () {
        var fullName = arguments[1].fullName;

        logs[fullName] = logs[fullName] || 0;
        logs[fullName]++;
      };

      _emberMetal.run(function () {
        App = _emberApplicationSystemApplication.default.create({
          LOG_ACTIVE_GENERATION: true
        });

        App.Router.reopen({
          location: 'none'
        });

        App.Router.map(function () {
          this.route('posts', { resetNamespace: true });
        });

        App.deferReadiness();
      });
    },

    teardown: function () {
      _emberConsole.default.info = originalLogger;

      _emberMetal.run(App, 'destroy');

      logs = App = null;
    }
  });

  function visit(path) {
    QUnit.stop();

    var promise = _emberMetal.run(function () {
      return new _emberRuntime.RSVP.Promise(function (resolve, reject) {
        var router = App.__container__.lookup('router:main');

        resolve(router.handleURL(path).then(function (value) {
          QUnit.start();
          ok(true, 'visited: `' + path + '`');
          return value;
        }, function (reason) {
          QUnit.start();
          ok(false, 'failed to visit:`' + path + '` reason: `' + QUnit.jsDump.parse(reason));
          throw reason;
        }));
      });
    });

    return {
      then: function (resolve, reject) {
        _emberMetal.run(promise, 'then', resolve, reject);
      }
    };
  }

  QUnit.test('log class generation if logging enabled', function () {
    if (EmberDev && EmberDev.runningProdBuild) {
      ok(true, 'Logging does not occur in production builds');
      return;
    }

    _emberMetal.run(App, 'advanceReadiness');

    visit('/posts').then(function () {
      equal(Object.keys(logs).length, 6, 'expected logs');
    });
  });

  QUnit.test('do NOT log class generation if logging disabled', function () {
    App.reopen({
      LOG_ACTIVE_GENERATION: false
    });

    _emberMetal.run(App, 'advanceReadiness');

    visit('/posts').then(function () {
      equal(Object.keys(logs).length, 0, 'expected no logs');
    });
  });

  QUnit.test('actively generated classes get logged', function () {
    if (EmberDev && EmberDev.runningProdBuild) {
      ok(true, 'Logging does not occur in production builds');
      return;
    }

    _emberMetal.run(App, 'advanceReadiness');

    visit('/posts').then(function () {
      equal(logs['controller:application'], 1, 'expected: ApplicationController was generated');
      equal(logs['controller:posts'], 1, 'expected: PostsController was generated');

      equal(logs['route:application'], 1, 'expected: ApplicationRoute was generated');
      equal(logs['route:posts'], 1, 'expected: PostsRoute was generated');
    });
  });

  QUnit.test('predefined classes do not get logged', function () {
    App.ApplicationController = _emberRuntime.Controller.extend();
    App.PostsController = _emberRuntime.Controller.extend();

    App.ApplicationRoute = _emberRouting.Route.extend();
    App.PostsRoute = _emberRouting.Route.extend();

    _emberMetal.run(App, 'advanceReadiness');

    visit('/posts').then(function () {
      ok(!logs['controller:application'], 'did not expect: ApplicationController was generated');
      ok(!logs['controller:posts'], 'did not expect: PostsController was generated');

      ok(!logs['route:application'], 'did not expect: ApplicationRoute was generated');
      ok(!logs['route:posts'], 'did not expect: PostsRoute was generated');
    });
  });

  QUnit.module('Ember.Application – logging of view lookups', {
    setup: function () {
      logs = {};

      originalLogger = _emberConsole.default.info;

      _emberConsole.default.info = function () {
        var fullName = arguments[1].fullName;

        logs[fullName] = logs[fullName] || 0;
        logs[fullName]++;
      };

      _emberMetal.run(function () {
        App = _emberApplicationSystemApplication.default.create({
          LOG_VIEW_LOOKUPS: true
        });

        App.Router.reopen({
          location: 'none'
        });

        App.Router.map(function () {
          this.route('posts', { resetNamespace: true });
        });

        App.deferReadiness();
      });
    },

    teardown: function () {
      _emberConsole.default.info = originalLogger;

      _emberMetal.run(App, 'destroy');

      logs = App = null;
    }
  });

  QUnit.test('log when template and view are missing when flag is active', function () {
    if (EmberDev && EmberDev.runningProdBuild) {
      ok(true, 'Logging does not occur in production builds');
      return;
    }

    App.register('template:application', _emberTemplateCompiler.compile('{{outlet}}'));
    _emberMetal.run(App, 'advanceReadiness');

    visit('/posts').then(function () {
      equal(logs['template:application'], undefined, 'expected: Should not log template:application since it exists.');
      equal(logs['template:index'], 1, 'expected: Could not find "index" template or view.');
      equal(logs['template:posts'], 1, 'expected: Could not find "posts" template or view.');
    });
  });

  QUnit.test('do not log when template and view are missing when flag is not true', function () {
    App.reopen({
      LOG_VIEW_LOOKUPS: false
    });

    _emberMetal.run(App, 'advanceReadiness');

    visit('/posts').then(function () {
      equal(Object.keys(logs).length, 0, 'expected no logs');
    });
  });

  QUnit.test('do not log which views are used with templates when flag is not true', function () {
    App.reopen({
      LOG_VIEW_LOOKUPS: false
    });

    _emberMetal.run(App, 'advanceReadiness');

    visit('/posts').then(function () {
      equal(Object.keys(logs).length, 0, 'expected no logs');
    });
  });
});
enifed('ember-application/tests/system/logging_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/tests/system/logging_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/tests/system/logging_test.js should pass ESLint\n\n');
  });
});
enifed('ember-application/tests/system/readiness_test', ['exports', 'ember-metal', 'ember-application/system/application'], function (exports, _emberMetal, _emberApplicationSystemApplication) {
  'use strict';

  var jQuery = undefined,
      application = undefined,
      Application = undefined;
  var readyWasCalled = undefined,
      domReady = undefined,
      readyCallbacks = undefined;

  // We are using a small mock of jQuery because jQuery is third-party code with
  // very well-defined semantics, and we want to confirm that a jQuery stub run
  // in a more minimal server environment that implements this behavior will be
  // sufficient for Ember's requirements.

  QUnit.module('Application readiness', {
    setup: function () {
      readyWasCalled = 0;
      readyCallbacks = [];

      var jQueryInstance = {
        ready: function (callback) {
          readyCallbacks.push(callback);
          if (jQuery.isReady) {
            domReady();
          }
        }
      };

      jQuery = function () {
        return jQueryInstance;
      };
      jQuery.isReady = false;

      var domReadyCalled = 0;
      domReady = function () {
        if (domReadyCalled !== 0) {
          return;
        }
        domReadyCalled++;
        for (var i = 0; i < readyCallbacks.length; i++) {
          readyCallbacks[i]();
        }
      };

      Application = _emberApplicationSystemApplication.default.extend({
        $: jQuery,

        ready: function () {
          readyWasCalled++;
        }
      });
    },

    teardown: function () {
      if (application) {
        _emberMetal.run(function () {
          return application.destroy();
        });
      }
    }
  });

  // These tests are confirming that if the callbacks passed into jQuery's ready hook is called
  // synchronously during the application's initialization, we get the same behavior as if
  // it was triggered after initialization.

  QUnit.test('Ember.Application\'s ready event is called right away if jQuery is already ready', function () {
    jQuery.isReady = true;

    _emberMetal.run(function () {
      application = Application.create({ router: false });

      equal(readyWasCalled, 0, 'ready is not called until later');
    });

    equal(readyWasCalled, 1, 'ready was called');

    domReady();

    equal(readyWasCalled, 1, 'application\'s ready was not called again');
  });

  QUnit.test('Ember.Application\'s ready event is called after the document becomes ready', function () {
    _emberMetal.run(function () {
      application = Application.create({ router: false });
    });

    equal(readyWasCalled, 0, 'ready wasn\'t called yet');

    domReady();

    equal(readyWasCalled, 1, 'ready was called now that DOM is ready');
  });

  QUnit.test('Ember.Application\'s ready event can be deferred by other components', function () {
    _emberMetal.run(function () {
      application = Application.create({ router: false });
      application.deferReadiness();
    });

    equal(readyWasCalled, 0, 'ready wasn\'t called yet');

    domReady();

    equal(readyWasCalled, 0, 'ready wasn\'t called yet');

    _emberMetal.run(function () {
      application.advanceReadiness();
      equal(readyWasCalled, 0);
    });

    equal(readyWasCalled, 1, 'ready was called now all readiness deferrals are advanced');
  });

  QUnit.test('Ember.Application\'s ready event can be deferred by other components', function () {
    jQuery.isReady = false;

    _emberMetal.run(function () {
      application = Application.create({ router: false });
      application.deferReadiness();
      equal(readyWasCalled, 0, 'ready wasn\'t called yet');
    });

    domReady();

    equal(readyWasCalled, 0, 'ready wasn\'t called yet');

    _emberMetal.run(function () {
      application.advanceReadiness();
    });

    equal(readyWasCalled, 1, 'ready was called now all readiness deferrals are advanced');

    expectAssertion(function () {
      application.deferReadiness();
    });
  });
});
enifed('ember-application/tests/system/readiness_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/tests/system/readiness_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/tests/system/readiness_test.js should pass ESLint\n\n');
  });
});
enifed('ember-application/tests/system/reset_test', ['exports', 'ember-metal', 'ember-application/system/application', 'ember-runtime', 'ember-routing', 'container'], function (exports, _emberMetal, _emberApplicationSystemApplication, _emberRuntime, _emberRouting, _container) {
  'use strict';

  var application = undefined,
      Application = undefined;

  QUnit.module('Ember.Application - resetting', {
    setup: function () {
      Application = _emberApplicationSystemApplication.default.extend({
        name: 'App',
        rootElement: '#qunit-fixture'
      });
    },
    teardown: function () {
      Application = null;
      if (application) {
        _emberMetal.run(application, 'destroy');
      }
    }
  });

  QUnit.test('Brings its own run-loop if not provided', function () {
    application = _emberMetal.run(Application, 'create');
    application.ready = function () {
      QUnit.start();
      ok(true, 'app booted');
    };

    QUnit.stop();
    application.reset();
  });

  QUnit.test('Does not bring its own run loop if one is already provided', function () {
    expect(3);

    var didBecomeReady = false;

    application = _emberMetal.run(Application, 'create');

    _emberMetal.run(function () {
      application.ready = function () {
        didBecomeReady = true;
      };

      application.reset();

      application.deferReadiness();
      ok(!didBecomeReady, 'app is not ready');
    });

    ok(!didBecomeReady, 'app is not ready');
    _emberMetal.run(application, 'advanceReadiness');
    ok(didBecomeReady, 'app is ready');
  });

  QUnit.test('When an application is reset, new instances of controllers are generated', function () {
    _emberMetal.run(function () {
      application = Application.create();
      application.AcademicController = _emberRuntime.Controller.extend();
    });

    var firstController = application.__container__.lookup('controller:academic');
    var secondController = application.__container__.lookup('controller:academic');

    application.reset();

    var thirdController = application.__container__.lookup('controller:academic');

    strictEqual(firstController, secondController, 'controllers looked up in succession should be the same instance');

    ok(firstController.isDestroying, 'controllers are destroyed when their application is reset');

    notStrictEqual(firstController, thirdController, 'controllers looked up after the application is reset should not be the same instance');
  });

  QUnit.test('When an application is reset, the eventDispatcher is destroyed and recreated', function () {
    var eventDispatcherWasSetup = undefined,
        eventDispatcherWasDestroyed = undefined;

    eventDispatcherWasSetup = 0;
    eventDispatcherWasDestroyed = 0;

    var mock_event_dispatcher = {
      create: function () {
        return {
          setup: function () {
            eventDispatcherWasSetup++;
          },
          destroy: function () {
            eventDispatcherWasDestroyed++;
          }
        };
      }
    };

    // this is pretty awful. We should make this less Global-ly.
    var originalRegister = _container.Registry.prototype.register;
    _container.Registry.prototype.register = function (name, type, options) {
      if (name === 'event_dispatcher:main') {
        return mock_event_dispatcher;
      } else {
        return originalRegister.call(this, name, type, options);
      }
    };

    try {
      _emberMetal.run(function () {
        application = Application.create();

        equal(eventDispatcherWasSetup, 0);
        equal(eventDispatcherWasDestroyed, 0);
      });

      equal(eventDispatcherWasSetup, 1);
      equal(eventDispatcherWasDestroyed, 0);

      application.reset();

      equal(eventDispatcherWasDestroyed, 1);
      equal(eventDispatcherWasSetup, 2, 'setup called after reset');
    } catch (error) {
      _container.Registry.prototype.register = originalRegister;
    }

    _container.Registry.prototype.register = originalRegister;
  });

  QUnit.test('When an application is reset, the router URL is reset to `/`', function () {
    var location = undefined,
        router = undefined;

    _emberMetal.run(function () {
      application = Application.create();
      application.Router = _emberRouting.Router.extend({
        location: 'none'
      });

      application.Router.map(function () {
        this.route('one');
        this.route('two');
      });
    });

    router = application.__container__.lookup('router:main');

    location = router.get('location');

    _emberMetal.run(function () {
      location.handleURL('/one');
    });

    application.reset();

    var applicationController = application.__container__.lookup('controller:application');
    router = application.__container__.lookup('router:main');
    location = router.get('location');

    equal(location.getURL(), '');

    equal(_emberMetal.get(applicationController, 'currentPath'), 'index');

    location = application.__container__.lookup('router:main').get('location');
    _emberMetal.run(function () {
      location.handleURL('/one');
    });

    equal(_emberMetal.get(applicationController, 'currentPath'), 'one');
  });

  QUnit.test('When an application with advance/deferReadiness is reset, the app does correctly become ready after reset', function () {
    var readyCallCount;

    readyCallCount = 0;

    _emberMetal.run(function () {
      application = Application.create({
        ready: function () {
          readyCallCount++;
        }
      });

      application.deferReadiness();
      equal(readyCallCount, 0, 'ready has not yet been called');
    });

    _emberMetal.run(function () {
      application.advanceReadiness();
    });

    equal(readyCallCount, 1, 'ready was called once');

    application.reset();

    equal(readyCallCount, 2, 'ready was called twice');
  });

  QUnit.test('With ember-data like initializer and constant', function () {
    var DS = {
      Store: _emberRuntime.Object.extend({
        init: function () {
          if (!_emberMetal.get(DS, 'defaultStore')) {
            _emberMetal.set(DS, 'defaultStore', this);
          }

          this._super.apply(this, arguments);
        },
        willDestroy: function () {
          if (_emberMetal.get(DS, 'defaultStore') === this) {
            _emberMetal.set(DS, 'defaultStore', null);
          }
        }
      })
    };

    Application.initializer({
      name: 'store',
      initialize: function (application) {
        application.unregister('store:main');
        application.register('store:main', application.Store);

        application.__container__.lookup('store:main');
      }
    });

    _emberMetal.run(function () {
      application = Application.create();
      application.Store = DS.Store;
    });

    ok(DS.defaultStore, 'has defaultStore');

    application.reset();

    ok(DS.defaultStore, 'still has defaultStore');
    ok(application.__container__.lookup('store:main'), 'store is still present');
  });
});
enifed('ember-application/tests/system/reset_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/tests/system/reset_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/tests/system/reset_test.js should pass ESLint\n\n');
  });
});
enifed('ember-application/tests/system/visit_test', ['exports', 'ember-runtime', 'ember-metal', 'ember-application/system/application', 'ember-application/system/application-instance', 'ember-application/system/engine', 'ember-routing', 'ember-glimmer', 'ember-template-compiler', 'ember-views'], function (exports, _emberRuntime, _emberMetal, _emberApplicationSystemApplication, _emberApplicationSystemApplicationInstance, _emberApplicationSystemEngine, _emberRouting, _emberGlimmer, _emberTemplateCompiler, _emberViews) {
  'use strict';

  var App = null;
  var instance = null;
  var instances = [];

  function createApplication(integration) {
    App = _emberApplicationSystemApplication.default.extend().create({
      autoboot: false,
      rootElement: '#qunit-fixture',
      LOG_TRANSITIONS: true,
      LOG_TRANSITIONS_INTERNAL: true,
      LOG_ACTIVE_GENERATION: true
    });

    App.Router = _emberRouting.Router.extend({
      location: 'none'
    });

    if (integration) {
      App.instanceInitializer({
        name: 'auto-cleanup',
        initialize: function (_instance) {
          instances.push(_instance);
        }
      });
    } else {
      App.instanceInitializer({
        name: 'auto-cleanup',
        initialize: function (_instance) {
          if (instance) {
            _emberMetal.run(instance, 'destroy');
          }

          instance = _instance;
        }
      });
    }

    return App;
  }

  function expectAsyncError() {
    _emberRuntime.RSVP.off('error');
  }

  QUnit.module('Ember.Application - visit()', {
    teardown: function () {
      _emberRuntime.RSVP.on('error', _emberRuntime.onerrorDefault);

      if (instance) {
        _emberMetal.run(instance, 'destroy');
        instance = null;
      }

      if (App) {
        _emberMetal.run(App, 'destroy');
        App = null;
      }
    }
  });

  // This tests whether the application is "autobooted" by registering an
  // instance initializer and asserting it never gets run. Since this is
  // inherently testing that async behavior *doesn't* happen, we set a
  // 500ms timeout to verify that when autoboot is set to false, the
  // instance initializer that would normally get called on DOM ready
  // does not fire.
  QUnit.test('Applications with autoboot set to false do not autoboot', function (assert) {
    function delay(time) {
      return new _emberRuntime.RSVP.Promise(function (resolve) {
        return _emberMetal.run.later(resolve, time);
      });
    }

    var appBooted = 0;
    var instanceBooted = 0;

    _emberMetal.run(function () {
      createApplication();

      App.initializer({
        name: 'assert-no-autoboot',
        initialize: function () {
          appBooted++;
        }
      });

      App.instanceInitializer({
        name: 'assert-no-autoboot',
        initialize: function () {
          instanceBooted++;
        }
      });
    });

    // Continue after 500ms
    return delay(500).then(function () {
      assert.ok(appBooted === 0, '500ms elapsed without app being booted');
      assert.ok(instanceBooted === 0, '500ms elapsed without instances being booted');

      return _emberMetal.run(App, 'boot');
    }).then(function () {
      assert.ok(appBooted === 1, 'app should boot when manually calling `app.boot()`');
      assert.ok(instanceBooted === 0, 'no instances should be booted automatically when manually calling `app.boot()');
    });
  });

  QUnit.test('calling visit() on an app without first calling boot() should boot the app', function (assert) {
    var appBooted = 0;
    var instanceBooted = 0;

    _emberMetal.run(function () {
      createApplication();

      App.initializer({
        name: 'assert-no-autoboot',
        initialize: function () {
          appBooted++;
        }
      });

      App.instanceInitializer({
        name: 'assert-no-autoboot',
        initialize: function () {
          instanceBooted++;
        }
      });
    });

    return _emberMetal.run(App, 'visit', '/').then(function () {
      assert.ok(appBooted === 1, 'the app should be booted`');
      assert.ok(instanceBooted === 1, 'an instances should be booted');
    });
  });

  QUnit.test('calling visit() on an already booted app should not boot it again', function (assert) {
    var appBooted = 0;
    var instanceBooted = 0;

    _emberMetal.run(function () {
      createApplication();

      App.initializer({
        name: 'assert-no-autoboot',
        initialize: function () {
          appBooted++;
        }
      });

      App.instanceInitializer({
        name: 'assert-no-autoboot',
        initialize: function () {
          instanceBooted++;
        }
      });
    });

    return _emberMetal.run(App, 'boot').then(function () {
      assert.ok(appBooted === 1, 'the app should be booted');
      assert.ok(instanceBooted === 0, 'no instances should be booted');

      return _emberMetal.run(App, 'visit', '/');
    }).then(function () {
      assert.ok(appBooted === 1, 'the app should not be booted again');
      assert.ok(instanceBooted === 1, 'an instance should be booted');

      return _emberMetal.run(App, 'visit', '/');
    }).then(function () {
      assert.ok(appBooted === 1, 'the app should not be booted again');
      assert.ok(instanceBooted === 2, 'another instance should be booted');
    });
  });

  QUnit.test('visit() rejects on application boot failure', function (assert) {
    _emberMetal.run(function () {
      createApplication();

      App.initializer({
        name: 'error',
        initialize: function () {
          throw new Error('boot failure');
        }
      });
    });

    expectAsyncError();

    return _emberMetal.run(App, 'visit', '/').then(function () {
      assert.ok(false, 'It should not resolve the promise');
    }, function (error) {
      assert.ok(error instanceof Error, 'It should reject the promise with the boot error');
      assert.equal(error.message, 'boot failure');
    });
  });

  QUnit.test('visit() rejects on instance boot failure', function (assert) {
    _emberMetal.run(function () {
      createApplication();

      App.instanceInitializer({
        name: 'error',
        initialize: function () {
          throw new Error('boot failure');
        }
      });
    });

    expectAsyncError();

    return _emberMetal.run(App, 'visit', '/').then(function () {
      assert.ok(false, 'It should not resolve the promise');
    }, function (error) {
      assert.ok(error instanceof Error, 'It should reject the promise with the boot error');
      assert.equal(error.message, 'boot failure');
    });
  });

  QUnit.test('visit() follows redirects', function (assert) {
    _emberMetal.run(function () {
      createApplication();

      App.Router.map(function () {
        this.route('a');
        this.route('b', { path: '/b/:b' });
        this.route('c', { path: '/c/:c' });
      });

      App.register('route:a', _emberRouting.Route.extend({
        afterModel: function () {
          this.replaceWith('b', 'zomg');
        }
      }));

      App.register('route:b', _emberRouting.Route.extend({
        afterModel: function (params) {
          this.transitionTo('c', params.b);
        }
      }));
    });

    return _emberMetal.run(App, 'visit', '/a').then(function (instance) {
      assert.ok(instance instanceof _emberApplicationSystemApplicationInstance.default, 'promise is resolved with an ApplicationInstance');
      assert.equal(instance.getURL(), '/c/zomg', 'It should follow all redirects');
    });
  });

  QUnit.test('visit() rejects if an error occured during a transition', function (assert) {
    _emberMetal.run(function () {
      createApplication();

      App.Router.map(function () {
        this.route('a');
        this.route('b', { path: '/b/:b' });
        this.route('c', { path: '/c/:c' });
      });

      App.register('route:a', _emberRouting.Route.extend({
        afterModel: function () {
          this.replaceWith('b', 'zomg');
        }
      }));

      App.register('route:b', _emberRouting.Route.extend({
        afterModel: function (params) {
          this.transitionTo('c', params.b);
        }
      }));

      App.register('route:c', _emberRouting.Route.extend({
        afterModel: function (params) {
          throw new Error('transition failure');
        }
      }));
    });

    expectAsyncError();

    return _emberMetal.run(App, 'visit', '/a').then(function () {
      assert.ok(false, 'It should not resolve the promise');
    }, function (error) {
      assert.ok(error instanceof Error, 'It should reject the promise with the boot error');
      assert.equal(error.message, 'transition failure');
    });
  });

  QUnit.test('visit() chain', function (assert) {
    _emberMetal.run(function () {
      createApplication();

      App.Router.map(function () {
        this.route('a');
        this.route('b');
        this.route('c');
      });
    });

    return _emberMetal.run(App, 'visit', '/').then(function (instance) {
      assert.ok(instance instanceof _emberApplicationSystemApplicationInstance.default, 'promise is resolved with an ApplicationInstance');
      assert.equal(instance.getURL(), '/');

      return instance.visit('/a');
    }).then(function (instance) {
      assert.ok(instance instanceof _emberApplicationSystemApplicationInstance.default, 'promise is resolved with an ApplicationInstance');
      assert.equal(instance.getURL(), '/a');

      return instance.visit('/b');
    }).then(function (instance) {
      assert.ok(instance instanceof _emberApplicationSystemApplicationInstance.default, 'promise is resolved with an ApplicationInstance');
      assert.equal(instance.getURL(), '/b');

      return instance.visit('/c');
    }).then(function (instance) {
      assert.ok(instance instanceof _emberApplicationSystemApplicationInstance.default, 'promise is resolved with an ApplicationInstance');
      assert.equal(instance.getURL(), '/c');
    });
  });

  QUnit.test('visit() returns a promise that resolves when the view has rendered', function (assert) {
    _emberMetal.run(function () {
      createApplication();

      App.register('template:application', _emberTemplateCompiler.compile('<h1>Hello world</h1>'));
    });

    assert.strictEqual(_emberViews.jQuery('#qunit-fixture').children().length, 0, 'there are no elements in the fixture element');

    return _emberMetal.run(App, 'visit', '/').then(function (instance) {
      assert.ok(instance instanceof _emberApplicationSystemApplicationInstance.default, 'promise is resolved with an ApplicationInstance');
      assert.equal(_emberViews.jQuery('#qunit-fixture > .ember-view h1').text(), 'Hello world', 'the application was rendered once the promise resolves');
    });
  });

  QUnit.test('visit() returns a promise that resolves without rendering when shouldRender is set to false', function (assert) {
    assert.expect(3);

    _emberMetal.run(function () {
      createApplication();

      App.register('template:application', _emberTemplateCompiler.compile('<h1>Hello world</h1>'));
    });

    assert.strictEqual(_emberViews.jQuery('#qunit-fixture').children().length, 0, 'there are no elements in the fixture element');

    return _emberMetal.run(App, 'visit', '/', { shouldRender: false }).then(function (instance) {
      assert.ok(instance instanceof _emberApplicationSystemApplicationInstance.default, 'promise is resolved with an ApplicationInstance');
      assert.strictEqual(_emberViews.jQuery('#qunit-fixture').children().length, 0, 'there are still no elements in the fixture element after visit');
    });
  });

  QUnit.test('visit() renders a template when shouldRender is set to true', function (assert) {
    assert.expect(3);

    _emberMetal.run(function () {
      createApplication();

      App.register('template:application', _emberTemplateCompiler.compile('<h1>Hello world</h1>'));
    });

    assert.strictEqual(_emberViews.jQuery('#qunit-fixture').children().length, 0, 'there are no elements in the fixture element');

    return _emberMetal.run(App, 'visit', '/', { shouldRender: true }).then(function (instance) {
      assert.ok(instance instanceof _emberApplicationSystemApplicationInstance.default, 'promise is resolved with an ApplicationInstance');
      assert.strictEqual(_emberViews.jQuery('#qunit-fixture').children().length, 1, 'there is 1 element in the fixture element after visit');
    });
  });

  QUnit.test('visit() returns a promise that resolves without rendering when shouldRender is set to false with Engines', function (assert) {
    assert.expect(3);

    _emberMetal.run(function () {
      createApplication();

      App.register('template:application', _emberTemplateCompiler.compile('<h1>Hello world</h1>'));

      // Register engine
      var BlogEngine = _emberApplicationSystemEngine.default.extend();
      App.register('engine:blog', BlogEngine);

      // Register engine route map
      var BlogMap = function () {};
      App.register('route-map:blog', BlogMap);

      App.Router.map(function () {
        this.mount('blog');
      });
    });

    assert.strictEqual(_emberViews.jQuery('#qunit-fixture').children().length, 0, 'there are no elements in the fixture element');

    return _emberMetal.run(App, 'visit', '/blog', { shouldRender: false }).then(function (instance) {
      assert.ok(instance instanceof _emberApplicationSystemApplicationInstance.default, 'promise is resolved with an ApplicationInstance');
      assert.strictEqual(_emberViews.jQuery('#qunit-fixture').children().length, 0, 'there are still no elements in the fixture element after visit');
    });
  });

  QUnit.test('visit() on engine resolves engine component', function (assert) {
    assert.expect(2);

    _emberMetal.run(function () {
      createApplication();

      // Register engine
      var BlogEngine = _emberApplicationSystemEngine.default.extend({
        init: function () {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          this._super.apply(this, args);
          this.register('template:application', _emberTemplateCompiler.compile('{{cache-money}}'));
          this.register('template:components/cache-money', _emberTemplateCompiler.compile('\n          <p>Dis cache money</p>\n        '));
          this.register('component:cache-money', _emberGlimmer.Component.extend({}));
        }
      });
      App.register('engine:blog', BlogEngine);

      // Register engine route map
      var BlogMap = function () {};
      App.register('route-map:blog', BlogMap);

      App.Router.map(function () {
        this.mount('blog');
      });
    });

    assert.strictEqual(_emberViews.jQuery('#qunit-fixture').children().length, 0, 'there are no elements in the fixture element');

    return _emberMetal.run(App, 'visit', '/blog', { shouldRender: true }).then(function (instance) {
      assert.strictEqual(_emberViews.jQuery('#qunit-fixture').find('p').text(), 'Dis cache money', 'Engine component is resolved');
    });
  });

  QUnit.test('visit() on engine resolves engine helper', function (assert) {
    assert.expect(2);

    _emberMetal.run(function () {
      createApplication();

      // Register engine
      var BlogEngine = _emberApplicationSystemEngine.default.extend({
        init: function () {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          this._super.apply(this, args);
          this.register('template:application', _emberTemplateCompiler.compile('{{swag}}'));
          this.register('helper:swag', _emberGlimmer.helper(function () {
            return 'turnt up';
          }));
        }
      });
      App.register('engine:blog', BlogEngine);

      // Register engine route map
      var BlogMap = function () {};
      App.register('route-map:blog', BlogMap);

      App.Router.map(function () {
        this.mount('blog');
      });
    });

    assert.strictEqual(_emberViews.jQuery('#qunit-fixture').children().length, 0, 'there are no elements in the fixture element');

    return _emberMetal.run(App, 'visit', '/blog', { shouldRender: true }).then(function (instance) {
      assert.strictEqual(_emberViews.jQuery('#qunit-fixture').text(), 'turnt up', 'Engine component is resolved');
    });
  });

  QUnit.module('Ember.Application - visit() Integration Tests', {
    teardown: function () {
      if (instances) {
        _emberMetal.run(instances, 'forEach', function (i) {
          return i.destroy();
        });
        instances = [];
      }

      if (App) {
        _emberMetal.run(App, 'destroy');
        App = null;
      }
    }
  });

  QUnit.test('Ember Islands-style setup', function (assert) {
    var xFooInitCalled = false;
    var xFooDidInsertElementCalled = false;

    var xBarInitCalled = false;
    var xBarDidInsertElementCalled = false;

    _emberMetal.run(function () {
      createApplication(true);

      App.Router.map(function () {
        this.route('show', { path: '/:component_name' });
      });

      App.register('route:show', _emberRouting.Route.extend({
        queryParams: {
          data: { refreshModel: true }
        },

        model: function (params) {
          return {
            componentName: params.component_name,
            componentData: params.data ? JSON.parse(params.data) : undefined
          };
        }
      }));

      var Counter = _emberRuntime.Object.extend({
        value: 0,

        increment: function () {
          this.incrementProperty('value');
        }
      });

      App.register('service:isolated-counter', Counter);
      App.register('service:shared-counter', Counter.create(), { instantiate: false });

      App.register('template:show', _emberTemplateCompiler.compile('{{component model.componentName model=model.componentData}}'));

      App.register('template:components/x-foo', _emberTemplateCompiler.compile('\n      <h1>X-Foo</h1>\n      <p>Hello {{model.name}}, I have been clicked {{isolatedCounter.value}} times ({{sharedCounter.value}} times combined)!</p>\n    '));

      App.register('component:x-foo', _emberGlimmer.Component.extend({
        tagName: 'x-foo',

        isolatedCounter: _emberRuntime.inject.service(),
        sharedCounter: _emberRuntime.inject.service(),

        init: function () {
          this._super();
          xFooInitCalled = true;
        },

        didInsertElement: function () {
          xFooDidInsertElementCalled = true;
        },

        click: function () {
          this.get('isolatedCounter').increment();
          this.get('sharedCounter').increment();
        }
      }));

      App.register('template:components/x-bar', _emberTemplateCompiler.compile('\n      <h1>X-Bar</h1>\n      <button {{action "incrementCounter"}}>Join {{counter.value}} others in clicking me!</button>\n    '));

      App.register('component:x-bar', _emberGlimmer.Component.extend({
        counter: _emberRuntime.inject.service('shared-counter'),

        actions: {
          incrementCounter: function () {
            this.get('counter').increment();
          }
        },

        init: function () {
          this._super();
          xBarInitCalled = true;
        },

        didInsertElement: function () {
          xBarDidInsertElementCalled = true;
        }
      }));
    });

    var $foo = _emberViews.jQuery('<div />').appendTo('#qunit-fixture');
    var $bar = _emberViews.jQuery('<div />').appendTo('#qunit-fixture');

    var data = encodeURIComponent(JSON.stringify({ name: 'Godfrey' }));

    return _emberRuntime.RSVP.all([_emberMetal.run(App, 'visit', '/x-foo?data=' + data, { rootElement: $foo[0] }), _emberMetal.run(App, 'visit', '/x-bar', { rootElement: $bar[0] })]).then(function () {
      assert.ok(xFooInitCalled);
      assert.ok(xFooDidInsertElementCalled);

      assert.ok(xBarInitCalled);
      assert.ok(xBarDidInsertElementCalled);

      assert.equal($foo.find('h1').text(), 'X-Foo');
      assert.equal($foo.find('p').text(), 'Hello Godfrey, I have been clicked 0 times (0 times combined)!');
      assert.ok($foo.text().indexOf('X-Bar') === -1);

      assert.equal($bar.find('h1').text(), 'X-Bar');
      assert.equal($bar.find('button').text(), 'Join 0 others in clicking me!');
      assert.ok($bar.text().indexOf('X-Foo') === -1);

      _emberMetal.run(function () {
        return $foo.find('x-foo').click();
      });

      assert.equal($foo.find('p').text(), 'Hello Godfrey, I have been clicked 1 times (1 times combined)!');
      assert.equal($bar.find('button').text(), 'Join 1 others in clicking me!');

      _emberMetal.run(function () {
        $bar.find('button').click();
        $bar.find('button').click();
      });

      assert.equal($foo.find('p').text(), 'Hello Godfrey, I have been clicked 1 times (3 times combined)!');
      assert.equal($bar.find('button').text(), 'Join 3 others in clicking me!');
    });
  });

  QUnit.skip('Test setup', function (assert) {});

  QUnit.skip('iframe setup', function (assert) {});
});
enifed('ember-application/tests/system/visit_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/tests/system/visit_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/tests/system/visit_test.js should pass ESLint\n\n');
  });
});
enifed('ember-application/tests/test-helpers/registry-check', ['exports'], function (exports) {
  'use strict';

  exports.verifyRegistration = verifyRegistration;
  exports.verifyInjection = verifyInjection;

  function verifyRegistration(owner, fullName) {
    ok(owner.resolveRegistration(fullName), 'has registration: ' + fullName);
  }

  function verifyInjection(owner, fullName, property, injectionName) {
    var registry = owner.__registry__;
    var injections = undefined;

    if (fullName.indexOf(':') === -1) {
      injections = registry.getTypeInjections(fullName);
    } else {
      injections = registry.getInjections(registry.normalize(fullName));
    }

    var normalizedName = registry.normalize(injectionName);
    var hasInjection = false;
    var injection = undefined;

    for (var i = 0, l = injections.length; i < l; i++) {
      injection = injections[i];
      if (injection.property === property && injection.fullName === normalizedName) {
        hasInjection = true;
        break;
      }
    }

    ok(hasInjection, 'has injection: ' + fullName + '.' + property + ' = ' + injectionName);
  }
});
enifed('ember-application/tests/test-helpers/registry-check.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/tests/test-helpers/registry-check.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/tests/test-helpers/registry-check.js should pass ESLint\n\n');
  });
});
enifed('ember-application/utils/validate-type.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-application/utils/validate-type.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-application/utils/validate-type.js should pass ESLint\n\n');
  });
});
enifed('ember-debug/deprecate.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-debug/deprecate.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-debug/deprecate.js should pass ESLint\n\n');
  });
});
enifed('ember-debug/handlers.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-debug/handlers.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-debug/handlers.js should pass ESLint\n\n');
  });
});
enifed('ember-debug/index.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-debug/index.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-debug/index.js should pass ESLint\n\n');
  });
});
enifed('ember-debug/tests/handlers-test', ['exports', 'ember-debug/handlers'], function (exports, _emberDebugHandlers) {
  'use strict';

  QUnit.module('ember-debug/handlers', {
    teardown: function () {
      delete _emberDebugHandlers.HANDLERS.blarz;
    }
  });

  QUnit.test('calls handler on `invoke` when `falsey`', function (assert) {
    assert.expect(2);

    function handler(message) {
      assert.ok(true, 'called handler');
      assert.equal(message, 'Foo bar');
    }

    _emberDebugHandlers.registerHandler('blarz', handler);

    _emberDebugHandlers.invoke('blarz', 'Foo bar', false);
  });

  QUnit.test('does not call handler on `invoke` when `truthy`', function (assert) {
    assert.expect(0);

    function handler() {
      assert.ok(false, 'called handler');
    }

    _emberDebugHandlers.registerHandler('blarz', handler);

    _emberDebugHandlers.invoke('blarz', 'Foo bar', true);
  });

  QUnit.test('calling `invoke` without handlers does not throw an error', function (assert) {
    assert.expect(0);

    _emberDebugHandlers.invoke('blarz', 'Foo bar', false);
  });

  QUnit.test('invoking `next` argument calls the next handler', function (assert) {
    assert.expect(2);

    function handler1(message, options, next) {
      assert.ok(true, 'called handler1');
    }

    function handler2(message, options, next) {
      assert.ok(true, 'called handler2');
      next(message, options);
    }

    _emberDebugHandlers.registerHandler('blarz', handler1);
    _emberDebugHandlers.registerHandler('blarz', handler2);

    _emberDebugHandlers.invoke('blarz', 'Foo', false);
  });

  QUnit.test('invoking `next` when no other handlers exists does not error', function (assert) {
    assert.expect(1);

    function handler(message, options, next) {
      assert.ok(true, 'called handler1');

      next(message, options);
    }

    _emberDebugHandlers.registerHandler('blarz', handler);

    _emberDebugHandlers.invoke('blarz', 'Foo', false);
  });

  QUnit.test('handlers are called in the proper order', function (assert) {
    assert.expect(11);

    var expectedMessage = 'This is the message';
    var expectedOptions = { id: 'foo-bar' };
    var expected = ['first', 'second', 'third', 'fourth', 'fifth'];
    var actualCalls = [];

    function generateHandler(item) {
      return function (message, options, next) {
        assert.equal(message, expectedMessage, 'message supplied to ' + item + ' handler is correct');
        assert.equal(options, expectedOptions, 'options supplied to ' + item + ' handler is correct');

        actualCalls.push(item);

        next(message, options);
      };
    }

    expected.forEach(function (item) {
      return _emberDebugHandlers.registerHandler('blarz', generateHandler(item));
    });

    _emberDebugHandlers.invoke('blarz', expectedMessage, false, expectedOptions);

    assert.deepEqual(actualCalls, expected.reverse(), 'handlers were called in proper order');
  });

  QUnit.test('not invoking `next` prevents further handlers from being called', function (assert) {
    assert.expect(1);

    function handler1(message, options, next) {
      assert.ok(false, 'called handler1');
    }

    function handler2(message, options, next) {
      assert.ok(true, 'called handler2');
    }

    _emberDebugHandlers.registerHandler('blarz', handler1);
    _emberDebugHandlers.registerHandler('blarz', handler2);

    _emberDebugHandlers.invoke('blarz', 'Foo', false);
  });

  QUnit.test('handlers can call `next` with custom message and/or options', function (assert) {
    assert.expect(4);

    var initialMessage = 'initial message';
    var initialOptions = { id: 'initial-options' };

    var handler2Message = 'Handler2 Message';
    var handler2Options = { id: 'handler-2' };

    function handler1(message, options, next) {
      assert.equal(message, handler2Message, 'handler2 message provided to handler1');
      assert.equal(options, handler2Options, 'handler2 options provided to handler1');
    }

    function handler2(message, options, next) {
      assert.equal(message, initialMessage, 'initial message provided to handler2');
      assert.equal(options, initialOptions, 'initial options proivided to handler2');

      next(handler2Message, handler2Options);
    }

    _emberDebugHandlers.registerHandler('blarz', handler1);
    _emberDebugHandlers.registerHandler('blarz', handler2);

    _emberDebugHandlers.invoke('blarz', initialMessage, false, initialOptions);
  });
});
enifed('ember-debug/tests/handlers-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-debug/tests/handlers-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-debug/tests/handlers-test.js should pass ESLint\n\n');
  });
});
enifed('ember-debug/tests/main_test', ['exports', 'ember-environment', 'ember-runtime', 'ember-debug/handlers', 'ember-debug/deprecate', 'ember-debug/warn', 'ember-metal'], function (exports, _emberEnvironment, _emberRuntime, _emberDebugHandlers, _emberDebugDeprecate, _emberDebugWarn, _emberMetal) {
  'use strict';

  var originalEnvValue = undefined;
  var originalDeprecateHandler = undefined;

  QUnit.module('ember-debug', {
    setup: function () {
      originalEnvValue = _emberEnvironment.ENV.RAISE_ON_DEPRECATION;
      originalDeprecateHandler = _emberDebugHandlers.HANDLERS.deprecate;

      _emberEnvironment.ENV.RAISE_ON_DEPRECATION = true;
    },

    teardown: function () {
      _emberDebugHandlers.HANDLERS.deprecate = originalDeprecateHandler;

      _emberEnvironment.ENV.RAISE_ON_DEPRECATION = originalEnvValue;
    }
  });

  QUnit.test('Ember.deprecate does not throw if RAISE_ON_DEPRECATION is false', function (assert) {
    assert.expect(1);

    _emberEnvironment.ENV.RAISE_ON_DEPRECATION = false;

    try {
      assert.ok(true, 'Ember.deprecate did not throw');
    } catch (e) {
      assert.ok(false, 'Expected deprecate not to throw but it did: ' + e.message);
    }
  });

  QUnit.test('Ember.deprecate resets deprecation level to RAISE if ENV.RAISE_ON_DEPRECATION is set', function (assert) {
    assert.expect(2);

    _emberEnvironment.ENV.RAISE_ON_DEPRECATION = false;

    try {
      assert.ok(true, 'Ember.deprecate did not throw');
    } catch (e) {
      assert.ok(false, 'Expected deprecate not to throw but it did: ' + e.message);
    }

    _emberEnvironment.ENV.RAISE_ON_DEPRECATION = true;

    assert.throws(function () {}, /Should throw/);
  });

  QUnit.test('When ENV.RAISE_ON_DEPRECATION is true, it is still possible to silence a deprecation by id', function (assert) {
    assert.expect(3);

    _emberEnvironment.ENV.RAISE_ON_DEPRECATION = true;
    _emberDebugDeprecate.registerHandler(function (message, options, next) {
      if (!options || options.id !== 'my-deprecation') {
        next.apply(undefined, arguments);
      }
    });

    try {
      assert.ok(true, 'Did not throw when level is set by id');
    } catch (e) {
      assert.ok(false, 'Expected deprecate not to throw but it did: ' + e.message);
    }

    assert.throws(function () {}, /Should throw with no matching id/);

    assert.throws(function () {}, /Should throw with non-matching id/);
  });

  QUnit.test('Ember.deprecate throws deprecation if second argument is falsy', function () {
    expect(3);
  });

  QUnit.test('Ember.deprecate does not invoke a function as the second argument', function () {
    expect(1);

    ok(true, 'deprecations were not thrown');
  });

  QUnit.test('Ember.deprecate does not throw deprecations if second argument is truthy', function () {
    expect(1);

    ok(true, 'deprecations were not thrown');
  });

  QUnit.test('Ember.assert throws if second argument is falsy', function () {
    expect(3);
  });

  QUnit.test('Ember.assert does not throw if second argument is a function', function (assert) {
    assert.expect(1);

    ok(true, 'assertions were not thrown');
  });

  QUnit.test('Ember.assert does not throw if second argument is truthy', function () {
    expect(1);

    ok(true, 'assertions were not thrown');
  });

  QUnit.test('Ember.assert does not throw if second argument is an object', function () {
    expect(1);
    var Igor = _emberRuntime.Object.extend();

    ok(true, 'assertions were not thrown');
  });

  QUnit.test('Ember.deprecate does not throw a deprecation at log and silence levels', function () {
    expect(4);
    var id = 'ABC';
    var until = 'forever';
    var shouldThrow = false;

    _emberDebugDeprecate.registerHandler(function (message, options, next) {
      if (options && options.id === id) {
        if (shouldThrow) {
          throw new Error(message);
        }
      }
    });

    try {
      ok(true, 'Deprecation did not throw');
    } catch (e) {
      ok(false, 'Deprecation was thrown despite being added to blacklist');
    }

    try {
      ok(true, 'Deprecation did not throw');
    } catch (e) {
      ok(false, 'Deprecation was thrown despite being added to blacklist');
    }

    shouldThrow = true;

    throws(function () {});

    throws(function () {});
  });

  QUnit.test('Ember.deprecate without options triggers a deprecation', function (assert) {
    assert.expect(4);

    _emberDebugDeprecate.registerHandler(function (message) {
      if (message === _emberDebugDeprecate.missingOptionsDeprecation) {
        assert.ok(true, 'proper deprecation is triggered when options is missing');
      } else if (message === 'foo') {
        assert.ok(true, 'original deprecation is still triggered');
      }
    });
  });

  QUnit.test('Ember.deprecate without options.id triggers a deprecation', function (assert) {
    assert.expect(2);

    _emberDebugDeprecate.registerHandler(function (message) {
      if (message === _emberDebugDeprecate.missingOptionsIdDeprecation) {
        assert.ok(true, 'proper deprecation is triggered when options.id is missing');
      } else if (message === 'foo') {
        assert.ok(true, 'original deprecation is still triggered');
      }
    });
  });

  QUnit.test('Ember.deprecate without options.until triggers a deprecation', function (assert) {
    assert.expect(2);

    _emberDebugDeprecate.registerHandler(function (message) {
      if (message === _emberDebugDeprecate.missingOptionsUntilDeprecation) {
        assert.ok(true, 'proper deprecation is triggered when options.until is missing');
      } else if (message === 'foo') {
        assert.ok(true, 'original deprecation is still triggered');
      }
    });
  });

  QUnit.test('warn without options triggers a deprecation', function (assert) {
    assert.expect(2);

    _emberDebugDeprecate.registerHandler(function (message) {
      assert.equal(message, _emberDebugWarn.missingOptionsDeprecation, 'deprecation is triggered when options is missing');
    });

    _emberDebugWarn.registerHandler(function (message) {
      assert.equal(message, 'foo', 'original warning is triggered');
    });
  });

  QUnit.test('warn without options.id triggers a deprecation', function (assert) {
    assert.expect(2);

    _emberDebugDeprecate.registerHandler(function (message) {
      assert.equal(message, _emberDebugWarn.missingOptionsIdDeprecation, 'deprecation is triggered when options is missing');
    });

    _emberDebugWarn.registerHandler(function (message) {
      assert.equal(message, 'foo', 'original warning is triggered');
    });
  });
});
enifed('ember-debug/tests/main_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-debug/tests/main_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-debug/tests/main_test.js should pass ESLint\n\n');
  });
});
enifed('ember-debug/tests/warn_if_using_stripped_feature_flags_test', ['exports', 'ember-environment', 'ember-metal', 'ember-debug/index'], function (exports, _emberEnvironment, _emberMetal, _emberDebugIndex) {
  'use strict';

  var oldWarn = undefined,
      oldRunInDebug = undefined,
      origEnvFeatures = undefined,
      origEnableOptional = undefined,
      features = undefined,
      knownFeatures = undefined;

  function confirmWarns(expectedMsg) {
    var featuresWereStripped = true;

    _emberMetal.setDebugFunction('warn', function (msg, test) {
      if (!test) {
        equal(msg, expectedMsg);
      }
    });

    _emberMetal.setDebugFunction('runInDebug', function (func) {
      func();
    });

    // Should trigger our 1 warning
    _emberDebugIndex._warnIfUsingStrippedFeatureFlags(features, knownFeatures, featuresWereStripped);

    // Shouldn't trigger any warnings now that we're "in canary"
    featuresWereStripped = false;
    _emberDebugIndex._warnIfUsingStrippedFeatureFlags(features, knownFeatures, featuresWereStripped);
  }

  QUnit.module('ember-debug - _warnIfUsingStrippedFeatureFlags', {
    setup: function () {
      oldWarn = _emberMetal.getDebugFunction('warn');
      oldRunInDebug = _emberMetal.getDebugFunction('runInDebug');
      origEnvFeatures = _emberEnvironment.ENV.FEATURES;
      origEnableOptional = _emberEnvironment.ENV.ENABLE_OPTIONAL_FEATURES;

      knownFeatures = {
        'fred': null,
        'barney': null,
        'wilma': null
      };
    },

    teardown: function () {
      _emberMetal.setDebugFunction('warn', oldWarn);
      _emberMetal.setDebugFunction('runInDebug', oldRunInDebug);
      _emberEnvironment.ENV.FEATURES = origEnvFeatures;
      _emberEnvironment.ENV.ENABLE_OPTIONAL_FEATURES = origEnableOptional;
    }
  });

  QUnit.test('Setting Ember.ENV.ENABLE_OPTIONAL_FEATURES truthy in non-canary, debug build causes a warning', function () {
    expect(1);

    _emberEnvironment.ENV.ENABLE_OPTIONAL_FEATURES = true;
    features = {};

    confirmWarns('Ember.ENV.ENABLE_OPTIONAL_FEATURES is only available in canary builds.');
  });

  QUnit.test('Enabling a known FEATURE flag in non-canary, debug build causes a warning', function () {
    expect(1);

    _emberEnvironment.ENV.ENABLE_OPTIONAL_FEATURES = false;
    features = {
      'fred': true,
      'barney': false,
      'wilma': null
    };

    confirmWarns('FEATURE["fred"] is set as enabled, but FEATURE flags are only available in canary builds.');
  });

  QUnit.test('Enabling an unknown FEATURE flag in non-canary debug build does not cause a warning', function () {
    expect(0);

    _emberEnvironment.ENV.ENABLE_OPTIONAL_FEATURES = false;
    features = {
      'some-ember-data-feature-flag': true
    };

    confirmWarns('FEATURE["fred"] is set as enabled, but FEATURE flags are only available in canary builds.');
  });

  QUnit.test('`ENV.FEATURES` being undefined does not cause an error', function () {
    expect(0);

    _emberEnvironment.ENV.ENABLE_OPTIONAL_FEATURES = false;
    features = undefined;

    confirmWarns();
  });
});
enifed('ember-debug/tests/warn_if_using_stripped_feature_flags_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-debug/tests/warn_if_using_stripped_feature_flags_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-debug/tests/warn_if_using_stripped_feature_flags_test.js should pass ESLint\n\n');
  });
});
enifed('ember-debug/warn.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-debug/warn.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-debug/warn.js should pass ESLint\n\n');
  });
});
enifed('ember-dev/test-helper/assertion', ['exports', 'ember-dev/test-helper/utils'], function (exports, _emberDevTestHelperUtils) {
  'use strict';

  exports.default = AssertionAssert;

  /* globals QUnit */

  var BREAK = {};

  /**
    This assertion class is used to test assertions made using Ember.assert.
    It injects two helpers onto `window`:
  
    - expectAssertion(func: Function, [expectedMessage: String | RegExp])
  
    This function calls `func` and asserts that `Ember.assert` is invoked during
    the execution. Moreover, it takes a String or a RegExp as a second optional
    argument that can be used to test if a specific assertion message was
    generated.
  
    - ignoreAssertion(func: Function)
  
    This function calls `func` and disables `Ember.assert` during the execution.
    In particular, this prevents `Ember.assert` from throw errors that would
    disrupt the control flow.
  */
  function AssertionAssert(env) {
    this.env = env;
  }

  AssertionAssert.prototype = {
    reset: function reset() {},
    assert: function assert() {},

    inject: function inject() {
      var _this = this;

      var expectAssertion = function expectAssertion(func, expectedMessage) {
        if (_this.env.runningProdBuild) {
          QUnit.ok(true, 'Assertions disabled in production builds.');
          return;
        }

        var sawCall = undefined;
        var actualMessage = undefined;

        // The try-catch statement is used to "exit" `func` as soon as
        // the first useful assertion has been produced.
        try {
          _emberDevTestHelperUtils.callWithStub(_this.env, 'assert', func, function (message, test) {
            sawCall = true;
            if (_emberDevTestHelperUtils.checkTest(test)) {
              return;
            }
            actualMessage = message;
            throw BREAK;
          });
        } catch (e) {
          if (e !== BREAK) {
            throw e;
          }
        }

        assert(sawCall, actualMessage, expectedMessage);
      };

      var ignoreAssertion = function ignoreAssertion(func) {
        _emberDevTestHelperUtils.callWithStub(_this.env, 'assert', func);
      };

      window.expectAssertion = expectAssertion;
      window.ignoreAssertion = ignoreAssertion;
    },

    restore: function restore() {
      window.expectAssertion = null;
      window.ignoreAssertion = null;
    }
  };

  function assert(sawCall, actualMessage, expectedMessage) {
    // Run assertions in an order that is useful when debugging a test failure.
    if (!sawCall) {
      QUnit.ok(false, 'Expected Ember.assert to be called (Not called with any value).');
    } else if (!actualMessage) {
      QUnit.ok(false, 'Expected a failing Ember.assert (Ember.assert called, but without a failing test).');
    } else {
      if (expectedMessage) {
        if (expectedMessage instanceof RegExp) {
          QUnit.ok(expectedMessage.test(actualMessage), 'Expected failing Ember.assert: \'' + expectedMessage + '\', but got \'' + actualMessage + '\'.');
        } else {
          QUnit.equal(actualMessage, expectedMessage, 'Expected failing Ember.assert: \'' + expectedMessage + '\', but got \'' + actualMessage + '\'.');
        }
      } else {
        // Positive assertion that assert was called
        QUnit.ok(true, 'Expected a failing Ember.assert.');
      }
    }
  }
});
enifed('ember-dev/test-helper/debug', ['exports', 'ember-dev/test-helper/method-call-tracker'], function (exports, _emberDevTestHelperMethodCallTracker) {
  'use strict';

  var _createClass = (function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  })();

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }

  var DebugAssert = (function () {
    function DebugAssert(methodName, env) {
      _classCallCheck(this, DebugAssert);

      this.methodName = methodName;
      this.env = env;
    }

    _createClass(DebugAssert, [{
      key: 'inject',
      value: function inject() {}
    }, {
      key: 'restore',
      value: function restore() {
        this.reset();
      }
    }, {
      key: 'reset',
      value: function reset() {
        if (this.tracker) {
          this.tracker.restoreMethod();
        }

        this.tracker = null;
      }
    }, {
      key: 'assert',
      value: function assert() {
        if (this.tracker) {
          this.tracker.assert();
        }
      }

      // Run an expectation callback within the context of a new tracker, optionally
      // accepting a function to run, which asserts immediately
    }, {
      key: 'runExpectation',
      value: function runExpectation(func, callback) {
        var originalTracker = undefined;

        // When helpers are passed a callback, they get a new tracker context
        if (func) {
          originalTracker = this.tracker;
          this.tracker = null;
        }

        if (!this.tracker) {
          this.tracker = new _emberDevTestHelperMethodCallTracker.default(this.env, this.methodName);
        }

        // Yield to caller with tracker instance
        callback(this.tracker);

        // Once the given callback is invoked, the pending assertions should be
        // flushed immediately
        if (func) {
          func();
          this.assert();
          this.reset();

          this.tracker = originalTracker;
        }
      }
    }]);

    return DebugAssert;
  })();

  exports.default = DebugAssert;
});
enifed('ember-dev/test-helper/deprecation', ['exports', 'ember-dev/test-helper/debug', 'ember-dev/test-helper/utils'], function (exports, _emberDevTestHelperDebug, _emberDevTestHelperUtils) {
  'use strict';

  var _createClass = (function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  })();

  var _get = function get(_x, _x2, _x3) {
    var _again = true;_function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);if (parent === null) {
          return undefined;
        } else {
          _x = parent;_x2 = property;_x3 = receiver;_again = true;desc = parent = undefined;continue _function;
        }
      } else if ('value' in desc) {
        return desc.value;
      } else {
        var getter = desc.get;if (getter === undefined) {
          return undefined;
        }return getter.call(receiver);
      }
    }
  };

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
      throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : babelHelpers.defaults(subClass, superClass);
  }

  var DeprecationAssert = (function (_DebugAssert) {
    _inherits(DeprecationAssert, _DebugAssert);

    function DeprecationAssert(env) {
      _classCallCheck(this, DeprecationAssert);

      _get(Object.getPrototypeOf(DeprecationAssert.prototype), 'constructor', this).call(this, 'deprecate', env);
    }

    _createClass(DeprecationAssert, [{
      key: 'inject',
      value: function inject() {
        var _this = this;

        // Expects no deprecation to happen within a function, or if no function is
        // passed, from the time of calling until the end of the test.
        //
        // expectNoDeprecation(function() {
        //   fancyNewThing();
        // });
        //
        // expectNoDeprecation();
        // Ember.deprecate("Old And Busted");
        //
        var expectNoDeprecation = function expectNoDeprecation(func) {
          if (typeof func !== 'function') {
            func = null;
          }

          _this.runExpectation(func, function (tracker) {
            if (tracker.isExpectingCalls()) {
              throw new Error("expectNoDeprecation was called after expectDeprecation was called!");
            }

            tracker.expectNoCalls();
          });
        };

        // Expect a deprecation to happen within a function, or if no function
        // is pass, from the time of calling until the end of the test. Can be called
        // multiple times to assert deprecations with different specific messages
        // were fired.
        //
        // expectDeprecation(function() {
        //   Ember.deprecate("Old And Busted");
        // }, /* optionalStringOrRegex */);
        //
        // expectDeprecation(/* optionalStringOrRegex */);
        // Ember.deprecate("Old And Busted");
        //
        var expectDeprecation = function expectDeprecation(func, message) {
          if (typeof func !== 'function') {
            message = func;
            func = null;
          }

          _this.runExpectation(func, function (tracker) {
            if (tracker.isExpectingNoCalls()) {
              throw new Error("expectDeprecation was called after expectNoDeprecation was called!");
            }

            tracker.expectCall(message);
          });
        };

        var ignoreDeprecation = function ignoreDeprecation(func) {
          _emberDevTestHelperUtils.callWithStub(_this.env, 'deprecate', func);
        };

        window.expectNoDeprecation = expectNoDeprecation;
        window.expectDeprecation = expectDeprecation;
        window.ignoreDeprecation = ignoreDeprecation;
      }
    }, {
      key: 'restore',
      value: function restore() {
        _get(Object.getPrototypeOf(DeprecationAssert.prototype), 'restore', this).call(this);
        window.expectDeprecation = null;
        window.expectNoDeprecation = null;
        window.ignoreDeprecation = null;
      }
    }]);

    return DeprecationAssert;
  })(_emberDevTestHelperDebug.default);

  exports.default = DeprecationAssert;
});
enifed("ember-dev/test-helper/index", ["exports", "ember-dev/test-helper/deprecation", "ember-dev/test-helper/warning", "ember-dev/test-helper/remaining-view", "ember-dev/test-helper/remaining-template", "ember-dev/test-helper/assertion", "ember-dev/test-helper/run-loop", "ember-dev/test-helper/utils"], function (exports, _emberDevTestHelperDeprecation, _emberDevTestHelperWarning, _emberDevTestHelperRemainingView, _emberDevTestHelperRemainingTemplate, _emberDevTestHelperAssertion, _emberDevTestHelperRunLoop, _emberDevTestHelperUtils) {
  "use strict";

  var EmberDevTestHelperAssert = _emberDevTestHelperUtils.buildCompositeAssert([_emberDevTestHelperDeprecation.default, _emberDevTestHelperWarning.default, _emberDevTestHelperRemainingView.default, _emberDevTestHelperRemainingTemplate.default, _emberDevTestHelperAssertion.default, _emberDevTestHelperRunLoop.default]);

  exports.default = EmberDevTestHelperAssert;
});
enifed('ember-dev/test-helper/method-call-tracker', ['exports', 'ember-dev/test-helper/utils'], function (exports, _emberDevTestHelperUtils) {
  /* globals QUnit */

  'use strict';

  var MethodCallTracker = function MethodCallTracker(env, methodName) {
    this._env = env;
    this._methodName = methodName;
    this._isExpectingNoCalls = false;
    this._expecteds = [];
    this._actuals = [];
  };

  MethodCallTracker.prototype = {
    stubMethod: function stubMethod() {
      var _this = this;

      if (this._originalMethod) {
        // Method is already stubbed
        return;
      }

      var env = this._env;
      var methodName = this._methodName;

      this._originalMethod = env.getDebugFunction(methodName);

      env.setDebugFunction(methodName, function (message, test) {
        var resultOfTest = _emberDevTestHelperUtils.checkTest(test);

        _this._actuals.push([message, resultOfTest]);
      });
    },

    restoreMethod: function restoreMethod() {
      if (this._originalMethod) {
        this._env.setDebugFunction(this._methodName, this._originalMethod);
      }
    },

    expectCall: function expectCall(message) {
      this.stubMethod();
      this._expecteds.push(message || /.*/);
    },

    expectNoCalls: function expectNoCalls() {
      this.stubMethod();
      this._isExpectingNoCalls = true;
    },

    isExpectingNoCalls: function isExpectingNoCalls() {
      return this._isExpectingNoCalls;
    },

    isExpectingCalls: function isExpectingCalls() {
      return !this._isExpectingNoCalls && this._expecteds.length;
    },

    assert: function assert() {
      var env = this._env;
      var methodName = this._methodName;
      var isExpectingNoCalls = this._isExpectingNoCalls;
      var expecteds = this._expecteds;
      var actuals = this._actuals;
      var o = undefined,
          i = undefined;

      if (!isExpectingNoCalls && expecteds.length === 0 && actuals.length === 0) {
        return;
      }

      if (env.runningProdBuild) {
        QUnit.ok(true, 'calls to Ember.' + methodName + ' disabled in production builds.');
        return;
      }

      if (isExpectingNoCalls) {
        var actualMessages = [];
        for (i = 0; i < actuals.length; i++) {
          if (!actuals[i][1]) {
            actualMessages.push(actuals[i][0]);
          }
        }
        QUnit.ok(actualMessages.length === 0, 'Expected no Ember.' + methodName + ' calls, got ' + actuals.length + ': ' + actualMessages.join(', '));
        return;
      }

      var expected = undefined,
          actual = undefined,
          match = undefined;

      for (o = 0; o < expecteds.length; o++) {
        expected = expecteds[o];
        for (i = 0; i < actuals.length; i++) {
          actual = actuals[i];
          if (!actual[1]) {
            if (expected instanceof RegExp) {
              if (expected.test(actual[0])) {
                match = actual;
                break;
              }
            } else {
              if (expected === actual[0]) {
                match = actual;
                break;
              }
            }
          }
        }

        if (!actual) {
          QUnit.ok(false, 'Received no Ember.' + methodName + ' calls at all, expecting: ' + expected);
        } else if (match && !match[1]) {
          QUnit.ok(true, 'Received failing Ember.' + methodName + ' call with message: ' + match[0]);
        } else if (match && match[1]) {
          QUnit.ok(false, 'Expected failing Ember.' + methodName + ' call, got succeeding with message: ' + match[0]);
        } else if (actual[1]) {
          QUnit.ok(false, 'Did not receive failing Ember.' + methodName + ' call matching \'' + expected + '\', last was success with \'' + actual[0] + '\'');
        } else if (!actual[1]) {
          QUnit.ok(false, 'Did not receive failing Ember.' + methodName + ' call matching \'' + expected + '\', last was failure with \'' + actual[0] + '\'');
        }
      }
    }
  };

  exports.default = MethodCallTracker;
});
enifed("ember-dev/test-helper/remaining-template", ["exports"], function (exports) {
  /* globals QUnit */

  "use strict";

  var RemainingTemplateAssert = function RemainingTemplateAssert(env) {
    this.env = env;
  };

  RemainingTemplateAssert.prototype = {
    reset: function reset() {},
    inject: function inject() {},
    assert: function assert() {
      if (this.env.Ember && this.env.Ember.TEMPLATES) {
        var templateNames = [],
            name;
        for (name in this.env.Ember.TEMPLATES) {
          if (this.env.Ember.TEMPLATES[name] != null) {
            templateNames.push(name);
          }
        }

        if (templateNames.length > 0) {
          QUnit.deepEqual(templateNames, [], "Ember.TEMPLATES should be empty");
          this.env.Ember.TEMPLATES = {};
        }
      }
    },
    restore: function restore() {}
  };

  exports.default = RemainingTemplateAssert;
});
enifed("ember-dev/test-helper/remaining-view", ["exports"], function (exports) {
  /* globals QUnit */

  "use strict";

  var RemainingViewAssert = function RemainingViewAssert(env) {
    this.env = env;
  };

  RemainingViewAssert.prototype = {
    reset: function reset() {},
    inject: function inject() {},
    assert: function assert() {
      if (this.env.Ember && this.env.Ember.View) {
        var viewIds = [],
            id;
        for (id in this.env.Ember.View.views) {
          if (this.env.Ember.View.views[id] != null) {
            viewIds.push(id);
          }
        }

        if (viewIds.length > 0) {
          QUnit.deepEqual(viewIds, [], "Ember.View.views should be empty");
          this.env.Ember.View.views = [];
        }
      }
    },
    restore: function restore() {}
  };

  exports.default = RemainingViewAssert;
});
enifed("ember-dev/test-helper/run-loop", ["exports"], function (exports) {
  /* globals QUnit */

  "use strict";

  function RunLoopAssertion(env) {
    this.env = env;
  }

  RunLoopAssertion.prototype = {
    reset: function reset() {},
    inject: function inject() {},
    assert: function assert() {
      var run = this.env.Ember.run;

      if (run.currentRunLoop) {
        QUnit.ok(false, "Should not be in a run loop at end of test");
        while (run.currentRunLoop) {
          run.end();
        }
      }

      if (run.hasScheduledTimers()) {
        QUnit.ok(false, "Ember run should not have scheduled timers at end of test");
        run.cancelTimers();
      }
    },
    restore: function restore() {}
  };

  exports.default = RunLoopAssertion;
});
enifed("ember-dev/test-helper/setup-qunit", ["exports"], function (exports) {
  "use strict";

  exports.default = setupQUnit;

  /* globals QUnit */
  function setupQUnit(assertion, _qunitGlobal) {
    var qunitGlobal = QUnit;

    if (_qunitGlobal) {
      qunitGlobal = _qunitGlobal;
    }

    var originalModule = qunitGlobal.module;

    qunitGlobal.module = function (name, _options) {
      var options = _options || {};
      var originalSetup = options.setup || function () {};
      var originalTeardown = options.teardown || function () {};

      options.setup = function () {
        assertion.reset();
        assertion.inject();

        originalSetup.apply(this, arguments);
      };

      options.teardown = function () {
        originalTeardown.apply(this, arguments);

        assertion.assert();
        assertion.restore();
      };

      return originalModule(name, options);
    };
  }
});
enifed('ember-dev/test-helper/utils', ['exports'], function (exports) {
  'use strict';

  exports.buildCompositeAssert = buildCompositeAssert;
  exports.callWithStub = callWithStub;
  exports.checkTest = checkTest;

  function callForEach(prop, func) {
    return function () {
      for (var i = 0, l = this[prop].length; i < l; i++) {
        this[prop][i][func]();
      }
    };
  }

  function buildCompositeAssert(assertClasses) {
    function Composite(env) {
      this.asserts = assertClasses.map(function (Assert) {
        return new Assert(env);
      });
    }

    Composite.prototype = {
      reset: callForEach('asserts', 'reset'),
      inject: callForEach('asserts', 'inject'),
      assert: callForEach('asserts', 'assert'),
      restore: callForEach('asserts', 'restore')
    };

    return Composite;
  }

  function noop() {}

  function callWithStub(env, name, func) {
    var debugStub = arguments.length <= 3 || arguments[3] === undefined ? noop : arguments[3];

    var originalFunc = env.getDebugFunction(name);
    try {
      env.setDebugFunction(name, debugStub);
      func();
    } finally {
      env.setDebugFunction(name, originalFunc);
    }
  }

  function checkTest(test) {
    return typeof test === 'function' ? test() : test;
  }
});
enifed('ember-dev/test-helper/warning', ['exports', 'ember-dev/test-helper/debug', 'ember-dev/test-helper/utils'], function (exports, _emberDevTestHelperDebug, _emberDevTestHelperUtils) {
  'use strict';

  var _createClass = (function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ('value' in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  })();

  var _get = function get(_x, _x2, _x3) {
    var _again = true;_function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;_again = false;if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);if (parent === null) {
          return undefined;
        } else {
          _x = parent;_x2 = property;_x3 = receiver;_again = true;desc = parent = undefined;continue _function;
        }
      } else if ('value' in desc) {
        return desc.value;
      } else {
        var getter = desc.get;if (getter === undefined) {
          return undefined;
        }return getter.call(receiver);
      }
    }
  };

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
      throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : babelHelpers.defaults(subClass, superClass);
  }

  var WarningAssert = (function (_DebugAssert) {
    _inherits(WarningAssert, _DebugAssert);

    function WarningAssert(env) {
      _classCallCheck(this, WarningAssert);

      _get(Object.getPrototypeOf(WarningAssert.prototype), 'constructor', this).call(this, 'warn', env);
    }

    _createClass(WarningAssert, [{
      key: 'inject',
      value: function inject() {
        var _this = this;

        // Expects no warning to happen within a function, or if no function is
        // passed, from the time of calling until the end of the test.
        //
        // expectNoWarning(function() {
        //   fancyNewThing();
        // });
        //
        // expectNoWarning();
        // Ember.warn("Oh snap, didn't expect that");
        //
        var expectNoWarning = function expectNoWarning(func) {
          if (typeof func !== 'function') {
            func = null;
          }

          _this.runExpectation(func, function (tracker) {
            if (tracker.isExpectingCalls()) {
              throw new Error("expectNoWarning was called after expectWarning was called!");
            }

            tracker.expectNoCalls();
          });
        };

        // Expect a warning to happen within a function, or if no function is
        // passed, from the time of calling until the end of the test. Can be called
        // multiple times to assert warnings with different specific messages
        // happened.
        //
        // expectWarning(function() {
        //   Ember.warn("Times they are a-changin'");
        // }, /* optionalStringOrRegex */);
        //
        // expectWarning(/* optionalStringOrRegex */);
        // Ember.warn("Times definitely be changin'");
        //
        var expectWarning = function expectWarning(fn, message) {
          if (typeof fn !== 'function') {
            message = fn;
            fn = null;
          }

          _this.runExpectation(fn, function (tracker) {
            if (tracker.isExpectingNoCalls()) {
              throw new Error("expectWarning was called after expectNoWarning was called!");
            }

            tracker.expectCall(message);
          });
        };

        var ignoreWarning = function ignoreWarning(func) {
          _emberDevTestHelperUtils.callWithStub(_this.env, 'warn', func);
        };

        window.expectNoWarning = expectNoWarning;
        window.expectWarning = expectWarning;
        window.ignoreWarning = ignoreWarning;
      }
    }, {
      key: 'restore',
      value: function restore() {
        _get(Object.getPrototypeOf(WarningAssert.prototype), 'restore', this).call(this);
        window.expectWarning = null;
        window.expectNoWarning = null;
        window.ignoreWarning = null;
      }
    }]);

    return WarningAssert;
  })(_emberDevTestHelperDebug.default);

  exports.default = WarningAssert;
});
enifed('ember-extension-support/container_debug_adapter.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-extension-support/container_debug_adapter.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-extension-support/container_debug_adapter.js should pass ESLint\n\n');
  });
});
enifed('ember-extension-support/data_adapter.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-extension-support/data_adapter.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-extension-support/data_adapter.js should pass ESLint\n\n');
  });
});
enifed('ember-extension-support/index.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-extension-support/index.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-extension-support/index.js should pass ESLint\n\n');
  });
});
enifed('ember-extension-support/tests/container_debug_adapter_test', ['exports', 'ember-metal', 'ember-runtime', 'ember-extension-support/index', 'ember-application'], function (exports, _emberMetal, _emberRuntime, _emberExtensionSupportIndex, _emberApplication) {
  'use strict';

  var adapter = undefined,
      App = undefined,
      appInstance = undefined;

  function boot() {
    _emberMetal.run(App, 'advanceReadiness');
  }

  QUnit.module('Container Debug Adapter', {
    setup: function () {
      _emberMetal.run(function () {
        App = _emberApplication.Application.create(); // ES6TODO: this comes from the ember-application package NOT ember-runtime.
        App.toString = function () {
          return 'App';
        };
        App.deferReadiness();
      });
      boot();
      _emberMetal.run(function () {
        appInstance = App.__deprecatedInstance__;
        adapter = appInstance.lookup('container-debug-adapter:main');
      });
    },
    teardown: function () {
      _emberMetal.run(function () {
        adapter.destroy();
        appInstance.destroy();
        App.destroy();
        App = appInstance = adapter = null;
      });
    }
  });

  QUnit.test('the default ContainerDebugAdapter cannot catalog certain entries by type', function () {
    equal(adapter.canCatalogEntriesByType('model'), false, 'canCatalogEntriesByType should return false for model');
    equal(adapter.canCatalogEntriesByType('template'), false, 'canCatalogEntriesByType should return false for template');
  });

  QUnit.test('the default ContainerDebugAdapter can catalog typical entries by type', function () {
    equal(adapter.canCatalogEntriesByType('controller'), true, 'canCatalogEntriesByType should return true for controller');
    equal(adapter.canCatalogEntriesByType('route'), true, 'canCatalogEntriesByType should return true for route');
    equal(adapter.canCatalogEntriesByType('view'), true, 'canCatalogEntriesByType should return true for view');
  });

  QUnit.test('the default ContainerDebugAdapter catalogs controller entries', function () {
    App.PostController = _emberRuntime.Controller.extend();
    var controllerClasses = adapter.catalogEntriesByType('controller');

    equal(controllerClasses.length, 1, 'found 1 class');
    equal(controllerClasses[0], 'post', 'found the right class');
  });
});
// Must be required to export Ember.ContainerDebugAdapter.
enifed('ember-extension-support/tests/container_debug_adapter_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-extension-support/tests/container_debug_adapter_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-extension-support/tests/container_debug_adapter_test.js should pass ESLint\n\n');
  });
});
enifed('ember-extension-support/tests/data_adapter_test', ['exports', 'ember-metal', 'ember-runtime', 'ember-extension-support/data_adapter', 'ember-application'], function (exports, _emberMetal, _emberRuntime, _emberExtensionSupportData_adapter, _emberApplication) {
  'use strict';

  var adapter = undefined,
      App = undefined;
  var Model = _emberRuntime.Object.extend();

  var DataAdapter = _emberExtensionSupportData_adapter.default.extend({
    detect: function (klass) {
      return klass !== Model && Model.detect(klass);
    }
  });

  QUnit.module('Data Adapter', {
    setup: function () {
      _emberMetal.run(function () {
        App = _emberApplication.Application.create();
        App.toString = function () {
          return 'App';
        };
        App.deferReadiness();
        App.register('data-adapter:main', DataAdapter);
      });
    },
    teardown: function () {
      _emberMetal.run(function () {
        adapter.destroy();
        App.destroy();
      });
    }
  });

  QUnit.test('Model types added with DefaultResolver', function () {
    App.Post = Model.extend();

    adapter = App.__container__.lookup('data-adapter:main');
    adapter.reopen({
      getRecords: function () {
        return _emberRuntime.A([1, 2, 3]);
      },
      columnsForType: function () {
        return [{ name: 'title', desc: 'Title' }];
      }
    });

    _emberMetal.run(App, 'advanceReadiness');

    function modelTypesAdded(types) {
      equal(types.length, 1);
      var postType = types[0];
      equal(postType.name, 'post', 'Correctly sets the name');
      equal(postType.count, 3, 'Correctly sets the record count');
      strictEqual(postType.object, App.Post, 'Correctly sets the object');
      deepEqual(postType.columns, [{ name: 'title', desc: 'Title' }], 'Correctly sets the columns');
    }

    _emberMetal.run(adapter, 'watchModelTypes', modelTypesAdded);
  });

  QUnit.test('getRecords gets a model name as second argument', function () {
    App.Post = Model.extend();

    adapter = App.__container__.lookup('data-adapter:main');
    adapter.reopen({
      getRecords: function (klass, name) {
        equal(name, 'post');
        return _emberRuntime.A();
      }
    });

    adapter.watchModelTypes(function () {});
  });

  QUnit.test('Model types added with custom container-debug-adapter', function () {
    var PostClass = Model.extend();
    var StubContainerDebugAdapter = _emberApplication.Resolver.extend({
      canCatalogEntriesByType: function (type) {
        return true;
      },
      catalogEntriesByType: function (type) {
        return [PostClass];
      }
    });
    App.register('container-debug-adapter:main', StubContainerDebugAdapter);

    adapter = App.__container__.lookup('data-adapter:main');
    adapter.reopen({
      getRecords: function () {
        return _emberRuntime.A([1, 2, 3]);
      },
      columnsForType: function () {
        return [{ name: 'title', desc: 'Title' }];
      }
    });

    _emberMetal.run(App, 'advanceReadiness');

    function modelTypesAdded(types) {
      equal(types.length, 1);
      var postType = types[0];

      equal(postType.name, PostClass.toString(), 'Correctly sets the name');
      equal(postType.count, 3, 'Correctly sets the record count');
      strictEqual(postType.object, PostClass, 'Correctly sets the object');
      deepEqual(postType.columns, [{ name: 'title', desc: 'Title' }], 'Correctly sets the columns');
    }

    _emberMetal.run(adapter, 'watchModelTypes', modelTypesAdded);
  });

  QUnit.test('Model Types Updated', function () {
    App.Post = Model.extend();

    adapter = App.__container__.lookup('data-adapter:main');
    var records = _emberRuntime.A([1, 2, 3]);
    adapter.reopen({
      getRecords: function () {
        return records;
      }
    });

    _emberMetal.run(App, 'advanceReadiness');

    function modelTypesAdded() {
      _emberMetal.run(function () {
        records.pushObject(4);
      });
    }

    function modelTypesUpdated(types) {
      var postType = types[0];
      equal(postType.count, 4, 'Correctly updates the count');
    }

    _emberMetal.run(adapter, 'watchModelTypes', modelTypesAdded, modelTypesUpdated);
  });

  QUnit.test('Records Added', function () {
    expect(8);
    var countAdded = 1;

    App.Post = Model.extend();

    var post = App.Post.create();
    var recordList = _emberRuntime.A([post]);

    adapter = App.__container__.lookup('data-adapter:main');
    adapter.reopen({
      getRecords: function () {
        return recordList;
      },
      getRecordColor: function () {
        return 'blue';
      },
      getRecordColumnValues: function () {
        return { title: 'Post ' + countAdded };
      },
      getRecordKeywords: function () {
        return ['Post ' + countAdded];
      }
    });

    function recordsAdded(records) {
      var record = records[0];
      equal(record.color, 'blue', 'Sets the color correctly');
      deepEqual(record.columnValues, { title: 'Post ' + countAdded }, 'Sets the column values correctly');
      deepEqual(record.searchKeywords, ['Post ' + countAdded], 'Sets search keywords correctly');
      strictEqual(record.object, post, 'Sets the object to the record instance');
    }

    adapter.watchRecords(App.Post, recordsAdded);
    countAdded++;
    post = App.Post.create();
    recordList.pushObject(post);
  });

  QUnit.test('Observes and releases a record correctly', function () {
    var updatesCalled = 0;
    App.Post = Model.extend();

    var post = App.Post.create({ title: 'Post' });
    var recordList = _emberRuntime.A([post]);

    adapter = App.__container__.lookup('data-adapter:main');
    adapter.reopen({
      getRecords: function () {
        return recordList;
      },
      observeRecord: function (record, recordUpdated) {
        var self = this;
        function callback() {
          recordUpdated(self.wrapRecord(record));
        }
        _emberMetal.addObserver(record, 'title', callback);
        return function () {
          _emberMetal.removeObserver(record, 'title', callback);
        };
      },
      getRecordColumnValues: function (record) {
        return { title: _emberMetal.get(record, 'title') };
      }
    });

    function recordsAdded() {
      _emberMetal.set(post, 'title', 'Post Modified');
    }

    function recordsUpdated(records) {
      updatesCalled++;
      equal(records[0].columnValues.title, 'Post Modified');
    }

    var release = adapter.watchRecords(App.Post, recordsAdded, recordsUpdated);
    release();
    _emberMetal.set(post, 'title', 'New Title');
    equal(updatesCalled, 1, 'Release function removes observers');
  });
});
enifed('ember-extension-support/tests/data_adapter_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-extension-support/tests/data_adapter_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-extension-support/tests/data_adapter_test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/component.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/component.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/component.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/components/checkbox.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/components/checkbox.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/components/checkbox.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/components/link-to.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/components/link-to.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/components/link-to.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/components/text_area.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/components/text_area.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/components/text_area.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/components/text_field.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/components/text_field.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/components/text_field.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/dom.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/dom.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/dom.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/environment.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/environment.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/environment.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/helper.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/helpers/-class.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/helpers/-class.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/helpers/-class.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/helpers/-html-safe.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/helpers/-html-safe.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/helpers/-html-safe.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/helpers/-input-type.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/helpers/-input-type.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/helpers/-input-type.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/helpers/-normalize-class.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/helpers/-normalize-class.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/helpers/-normalize-class.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/helpers/action.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/helpers/action.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/helpers/action.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/helpers/component.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/helpers/component.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/helpers/component.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/helpers/concat.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/helpers/concat.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/helpers/concat.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/helpers/each-in.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/helpers/each-in.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/helpers/each-in.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/helpers/get.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/helpers/get.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/helpers/get.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/helpers/hash.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/helpers/hash.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/helpers/hash.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/helpers/if-unless.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/helpers/if-unless.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/helpers/if-unless.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/helpers/loc.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/helpers/loc.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/helpers/loc.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/helpers/log.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/helpers/log.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/helpers/log.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/helpers/mut.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/helpers/mut.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/helpers/mut.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/helpers/query-param.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/helpers/query-param.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/helpers/query-param.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/helpers/readonly.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/helpers/readonly.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/helpers/readonly.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/helpers/unbound.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/helpers/unbound.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/helpers/unbound.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/index.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/index.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/index.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/make-bound-helper.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/make-bound-helper.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/make-bound-helper.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/modifiers/action.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/modifiers/action.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/modifiers/action.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/protocol-for-url.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/protocol-for-url.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/protocol-for-url.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/renderer.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/renderer.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/renderer.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/setup-registry.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/setup-registry.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/setup-registry.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/syntax.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/syntax.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/syntax.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/syntax/-in-element.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/syntax/-in-element.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/syntax/-in-element.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/syntax/-text-area.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/syntax/-text-area.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/syntax/-text-area.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/syntax/-with-dynamic-vars.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/syntax/-with-dynamic-vars.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/syntax/-with-dynamic-vars.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/syntax/abstract-manager.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/syntax/abstract-manager.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/syntax/abstract-manager.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/syntax/curly-component.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/syntax/curly-component.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/syntax/curly-component.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/syntax/dynamic-component.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/syntax/dynamic-component.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/syntax/dynamic-component.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/syntax/input.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/syntax/input.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/syntax/input.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/syntax/mount.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/syntax/mount.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/syntax/mount.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/syntax/outlet.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/syntax/outlet.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/syntax/outlet.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/syntax/render.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/syntax/render.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/syntax/render.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/template.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/template.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/template.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/template_registry.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/template_registry.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/template_registry.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/application/actions-test', ['exports', 'ember-runtime', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/helpers'], function (exports, _emberRuntime, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsHelpers) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Application test: actions', (function (_ApplicationTest) {
    babelHelpers.inherits(_class, _ApplicationTest);

    function _class() {
      _ApplicationTest.apply(this, arguments);
    }

    _class.prototype['@test actions in top level template application template target application controller'] = function testActionsInTopLevelTemplateApplicationTemplateTargetApplicationController(assert) {
      var _this = this;

      assert.expect(1);

      this.registerController('application', _emberRuntime.Controller.extend({
        actions: {
          handleIt: function (arg) {
            assert.ok(true, 'controller received action properly');
          }
        }
      }));

      this.registerTemplate('application', '<button id="handle-it" {{action "handleIt"}}>Click!</button>');

      return this.visit('/').then(function () {
        _this.runTask(function () {
          return _this.$('#handle-it').click();
        });
      });
    };

    _class.prototype['@test actions in nested outlet template target their controller'] = function testActionsInNestedOutletTemplateTargetTheirController(assert) {
      var _this2 = this;

      assert.expect(1);

      this.registerController('application', _emberRuntime.Controller.extend({
        actions: {
          handleIt: function (arg) {
            assert.ok(false, 'application controller should not have received action!');
          }
        }
      }));

      this.registerController('index', _emberRuntime.Controller.extend({
        actions: {
          handleIt: function (arg) {
            assert.ok(true, 'controller received action properly');
          }
        }
      }));

      this.registerTemplate('index', '<button id="handle-it" {{action "handleIt"}}>Click!</button>');

      return this.visit('/').then(function () {
        _this2.runTask(function () {
          return _this2.$('#handle-it').click();
        });
      });
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.ApplicationTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Rendering test: non-interactive actions', (function (_RenderingTest) {
    babelHelpers.inherits(_class2, _RenderingTest);

    function _class2() {
      _RenderingTest.apply(this, arguments);
    }

    _class2.prototype.getBootOptions = function getBootOptions() {
      return { isInteractive: false };
    };

    _class2.prototype['@test doesn\'t attatch actions'] = function testDoesnTAttatchActions(assert) {
      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          actions: {
            fire: function () {
              assert.ok(false);
            }
          }
        }),
        template: '<button {{action \'fire\'}}>Fire!</button>'
      });

      this.render('{{foo-bar tagName=""}}');

      this.assertHTML('<button>Fire!</button>');

      this.$('button').click();
    };

    return _class2;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/application/actions-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/application/actions-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/application/actions-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/application/engine-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/abstract-test-case', 'ember-glimmer/tests/utils/helpers', 'ember-runtime', 'ember-glimmer', 'ember-application', 'ember-routing'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsAbstractTestCase, _emberGlimmerTestsUtilsHelpers, _emberRuntime, _emberGlimmer, _emberApplication, _emberRouting) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n      <h1>{{contextType}}</h1>\n      {{ambiguous-curlies}}\n\n      {{outlet}}\n    '], ['\n      <h1>{{contextType}}</h1>\n      {{ambiguous-curlies}}\n\n      {{outlet}}\n    ']),
      _templateObject2 = babelHelpers.taggedTemplateLiteralLoose(['\n        <p>Component!</p>\n      '], ['\n        <p>Component!</p>\n      ']),
      _templateObject3 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{ambiguous-curlies}}\n    '], ['\n      {{ambiguous-curlies}}\n    ']),
      _templateObject4 = babelHelpers.taggedTemplateLiteralLoose(['\n      <h1>Application</h1>\n      {{my-component ambiguous-curlies="Local Data!"}}\n      {{outlet}}\n    '], ['\n      <h1>Application</h1>\n      {{my-component ambiguous-curlies="Local Data!"}}\n      {{outlet}}\n    ']),
      _templateObject5 = babelHelpers.taggedTemplateLiteralLoose(['\n          <h1>Engine</h1>\n          {{my-component}}\n          {{outlet}}\n        '], ['\n          <h1>Engine</h1>\n          {{my-component}}\n          {{outlet}}\n        ']),
      _templateObject6 = babelHelpers.taggedTemplateLiteralLoose(['\n          <p>Component!</p>\n        '], ['\n          <p>Component!</p>\n        ']);

  _emberGlimmerTestsUtilsTestCase.moduleFor('Application test: engine rendering', (function (_ApplicationTest) {
babelHelpers.inherits(_class, _ApplicationTest);

    function _class() {
      _ApplicationTest.apply(this, arguments);
    }

    _class.prototype.setupAppAndRoutableEngine = function setupAppAndRoutableEngine() {
      var hooks = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

      var self = this;

      this.application.register('template:application', _emberGlimmerTestsUtilsHelpers.compile('Application{{outlet}}'));

      this.router.map(function () {
        this.mount('blog');
      });
      this.application.register('route-map:blog', function () {
        this.route('post', function () {
          this.route('comments');
          this.route('likes');
        });
        this.route('category', { path: 'category/:id' });
        this.route('author', { path: 'author/:id' });
      });
      this.registerRoute('application', _emberRouting.Route.extend({
        model: function () {
          hooks.push('application - application');
        }
      }));

      this.registerEngine('blog', _emberApplication.Engine.extend({
        init: function () {
          this._super.apply(this, arguments);
          this.register('controller:application', _emberRuntime.Controller.extend({
            queryParams: ['lang'],
            lang: ''
          }));
          this.register('controller:category', _emberRuntime.Controller.extend({
            queryParams: ['type']
          }));
          this.register('controller:authorKtrl', _emberRuntime.Controller.extend({
            queryParams: ['official']
          }));
          this.register('template:application', _emberGlimmerTestsUtilsHelpers.compile('Engine{{lang}}{{outlet}}'));
          this.register('route:application', _emberRouting.Route.extend({
            model: function () {
              hooks.push('engine - application');
            }
          }));
          this.register('route:author', _emberRouting.Route.extend({
            controllerName: 'authorKtrl'
          }));

          if (self._additionalEngineRegistrations) {
            self._additionalEngineRegistrations.call(this);
          }
        }
      }));
    };

    _class.prototype.setupAppAndRoutelessEngine = function setupAppAndRoutelessEngine(hooks) {
      this.setupRoutelessEngine(hooks);

      this.registerEngine('chat-engine', _emberApplication.Engine.extend({
        init: function () {
          this._super.apply(this, arguments);
          this.register('template:application', _emberGlimmerTestsUtilsHelpers.compile('Engine'));
          this.register('controller:application', _emberRuntime.Controller.extend({
            init: function () {
              this._super.apply(this, arguments);
              hooks.push('engine - application');
            }
          }));
        }
      }));
    };

    _class.prototype.setupAppAndRoutableEngineWithPartial = function setupAppAndRoutableEngineWithPartial(hooks) {
      this.application.register('template:application', _emberGlimmerTestsUtilsHelpers.compile('Application{{outlet}}'));

      this.router.map(function () {
        this.mount('blog');
      });
      this.application.register('route-map:blog', function () {});
      this.registerRoute('application', _emberRouting.Route.extend({
        model: function () {
          hooks.push('application - application');
        }
      }));

      this.registerEngine('blog', _emberApplication.Engine.extend({
        init: function () {
          this._super.apply(this, arguments);
          this.register('template:foo', _emberGlimmerTestsUtilsHelpers.compile('foo partial'));
          this.register('template:application', _emberGlimmerTestsUtilsHelpers.compile('Engine{{outlet}} {{partial "foo"}}'));
          this.register('route:application', _emberRouting.Route.extend({
            model: function () {
              hooks.push('engine - application');
            }
          }));
        }
      }));
    };

    _class.prototype.setupRoutelessEngine = function setupRoutelessEngine(hooks) {
      this.application.register('template:application', _emberGlimmerTestsUtilsHelpers.compile('Application{{mount "chat-engine"}}'));
      this.registerRoute('application', _emberRouting.Route.extend({
        model: function () {
          hooks.push('application - application');
        }
      }));
    };

    _class.prototype.setupAppAndRoutlessEngineWithPartial = function setupAppAndRoutlessEngineWithPartial(hooks) {
      this.setupRoutelessEngine(hooks);

      this.registerEngine('chat-engine', _emberApplication.Engine.extend({
        init: function () {
          this._super.apply(this, arguments);
          this.register('template:foo', _emberGlimmerTestsUtilsHelpers.compile('foo partial'));
          this.register('template:application', _emberGlimmerTestsUtilsHelpers.compile('Engine {{partial "foo"}}'));
          this.register('controller:application', _emberRuntime.Controller.extend({
            init: function () {
              this._super.apply(this, arguments);
              hooks.push('engine - application');
            }
          }));
        }
      }));
    };

    _class.prototype.additionalEngineRegistrations = function additionalEngineRegistrations(callback) {
      this._additionalEngineRegistrations = callback;
    };

    _class.prototype.setupEngineWithAttrs = function setupEngineWithAttrs(hooks) {
      this.application.register('template:application', _emberGlimmerTestsUtilsHelpers.compile('Application{{mount "chat-engine"}}'));

      this.registerEngine('chat-engine', _emberApplication.Engine.extend({
        init: function () {
          this._super.apply(this, arguments);
          this.register('template:components/foo-bar', _emberGlimmerTestsUtilsHelpers.compile('{{partial "troll"}}'));
          this.register('template:troll', _emberGlimmerTestsUtilsHelpers.compile('{{attrs.wat}}'));
          this.register('controller:application', _emberRuntime.Controller.extend({
            contextType: 'Engine'
          }));
          this.register('template:application', _emberGlimmerTestsUtilsHelpers.compile('Engine {{foo-bar wat=contextType}}'));
        }
      }));
    };

    _class.prototype.stringsEndWith = function stringsEndWith(str, suffix) {
      return str.indexOf(suffix, str.length - suffix.length) !== -1;
    };

    _class.prototype['@test attrs in an engine'] = function testAttrsInAnEngine() {
      var _this = this;

      this.setupEngineWithAttrs([]);

      return this.visit('/').then(function () {
        _this.assertText('ApplicationEngine Engine');
      });
    };

    _class.prototype['@test sharing a template between engine and application has separate refinements'] = function testSharingATemplateBetweenEngineAndApplicationHasSeparateRefinements() {
      var _this2 = this;

      this.assert.expect(1);

      var sharedTemplate = _emberGlimmerTestsUtilsHelpers.compile(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject));

      this.application.register('template:application', sharedTemplate);
      this.registerController('application', _emberRuntime.Controller.extend({
        contextType: 'Application',
        'ambiguous-curlies': 'Controller Data!'
      }));

      this.router.map(function () {
        this.mount('blog');
      });
      this.application.register('route-map:blog', function () {});

      this.registerEngine('blog', _emberApplication.Engine.extend({
        init: function () {
          this._super.apply(this, arguments);

          this.register('controller:application', _emberRuntime.Controller.extend({
            contextType: 'Engine'
          }));
          this.register('template:application', sharedTemplate);
          this.register('template:components/ambiguous-curlies', _emberGlimmerTestsUtilsHelpers.compile(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2)));
        }
      }));

      return this.visit('/blog').then(function () {
        _this2.assertText('ApplicationController Data!EngineComponent!');
      });
    };

    _class.prototype['@test sharing a layout between engine and application has separate refinements'] = function testSharingALayoutBetweenEngineAndApplicationHasSeparateRefinements() {
      var _this3 = this;

      this.assert.expect(1);

      var sharedLayout = _emberGlimmerTestsUtilsHelpers.compile(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject3));

      var sharedComponent = _emberGlimmer.Component.extend({
        layout: sharedLayout
      });

      this.application.register('template:application', _emberGlimmerTestsUtilsHelpers.compile(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject4)));

      this.application.register('component:my-component', sharedComponent);

      this.router.map(function () {
        this.mount('blog');
      });
      this.application.register('route-map:blog', function () {});

      this.registerEngine('blog', _emberApplication.Engine.extend({
        init: function () {
          this._super.apply(this, arguments);
          this.register('template:application', _emberGlimmerTestsUtilsHelpers.compile(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject5)));
          this.register('component:my-component', sharedComponent);
          this.register('template:components/ambiguous-curlies', _emberGlimmerTestsUtilsHelpers.compile(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject6)));
        }
      }));

      return this.visit('/blog').then(function () {
        _this3.assertText('ApplicationLocal Data!EngineComponent!');
      });
    };

    _class.prototype['@test visit() with `shouldRender: true` returns a promise that resolves when application and engine templates have rendered'] = function testVisitWithShouldRenderTrueReturnsAPromiseThatResolvesWhenApplicationAndEngineTemplatesHaveRendered(assert) {
      var _this4 = this;

      assert.expect(2);

      var hooks = [];

      this.setupAppAndRoutableEngine(hooks);

      return this.visit('/blog', { shouldRender: true }).then(function () {
        _this4.assertText('ApplicationEngine');

        _this4.assert.deepEqual(hooks, ['application - application', 'engine - application'], 'the expected model hooks were fired');
      });
    };

    _class.prototype['@test visit() with `shouldRender: false` returns a promise that resolves without rendering'] = function testVisitWithShouldRenderFalseReturnsAPromiseThatResolvesWithoutRendering(assert) {
      var _this5 = this;

      assert.expect(2);

      var hooks = [];

      this.setupAppAndRoutableEngine(hooks);

      return this.visit('/blog', { shouldRender: false }).then(function () {
        _this5.assertText('');

        _this5.assert.deepEqual(hooks, ['application - application', 'engine - application'], 'the expected model hooks were fired');
      });
    };

    _class.prototype['@test visit() with `shouldRender: true` returns a promise that resolves when application and routeless engine templates have rendered'] = function testVisitWithShouldRenderTrueReturnsAPromiseThatResolvesWhenApplicationAndRoutelessEngineTemplatesHaveRendered(assert) {
      var _this6 = this;

      assert.expect(2);

      var hooks = [];

      this.setupAppAndRoutelessEngine(hooks);

      return this.visit('/', { shouldRender: true }).then(function () {
        _this6.assertText('ApplicationEngine');

        _this6.assert.deepEqual(hooks, ['application - application', 'engine - application'], 'the expected hooks were fired');
      });
    };

    _class.prototype['@test visit() with partials in routable engine'] = function testVisitWithPartialsInRoutableEngine(assert) {
      var _this7 = this;

      assert.expect(2);

      var hooks = [];

      this.setupAppAndRoutableEngineWithPartial(hooks);

      return this.visit('/blog', { shouldRender: true }).then(function () {
        _this7.assertText('ApplicationEngine foo partial');

        _this7.assert.deepEqual(hooks, ['application - application', 'engine - application'], 'the expected hooks were fired');
      });
    };

    _class.prototype['@test visit() with partials in non-routable engine'] = function testVisitWithPartialsInNonRoutableEngine(assert) {
      var _this8 = this;

      assert.expect(2);

      var hooks = [];

      this.setupAppAndRoutlessEngineWithPartial(hooks);

      return this.visit('/', { shouldRender: true }).then(function () {
        _this8.assertText('ApplicationEngine foo partial');

        _this8.assert.deepEqual(hooks, ['application - application', 'engine - application'], 'the expected hooks were fired');
      });
    };

    _class.prototype['@test deactivate should be called on Engine Routes before destruction'] = function testDeactivateShouldBeCalledOnEngineRoutesBeforeDestruction(assert) {
      var _this9 = this;

      assert.expect(3);

      this.setupAppAndRoutableEngine();

      this.registerEngine('blog', _emberApplication.Engine.extend({
        init: function () {
          this._super.apply(this, arguments);
          this.register('template:application', _emberGlimmerTestsUtilsHelpers.compile('Engine{{outlet}}'));
          this.register('route:application', _emberRouting.Route.extend({
            deactivate: function () {
              assert.notOk(this.isDestroyed, 'Route is not destroyed');
              assert.notOk(this.isDestroying, 'Route is not being destroyed');
            }
          }));
        }
      }));

      return this.visit('/blog').then(function () {
        _this9.assertText('ApplicationEngine');
      });
    };

    _class.prototype['@test engine should lookup and use correct controller'] = function testEngineShouldLookupAndUseCorrectController(assert) {
      var _this10 = this;

      this.setupAppAndRoutableEngine();

      return this.visit('/blog?lang=English').then(function () {
        _this10.assertText('ApplicationEngineEnglish');
      });
    };

    _class.prototype['@test error substate route works for the application route of an Engine'] = function testErrorSubstateRouteWorksForTheApplicationRouteOfAnEngine(assert) {
      var _this11 = this;

      assert.expect(2);

      this.setupAppAndRoutableEngine();
      this.application.__registry__.resolver.moduleBasedResolver = true;
      this.additionalEngineRegistrations(function () {
        this.register('template:application_error', _emberGlimmerTestsUtilsHelpers.compile('Error! {{model.message}}'));
        this.register('route:post', _emberRouting.Route.extend({
          model: function () {
            return _emberRuntime.RSVP.reject(new Error('Oh, noes!'));
          }
        }));
      });

      return this.visit('/').then(function () {
        _this11.assertText('Application');
        return _this11.transitionTo('blog.post');
      }).catch(function () {
        _this11.assertText('ApplicationError! Oh, noes!');
      });
    };

    _class.prototype['@test error route works for the application route of an Engine'] = function testErrorRouteWorksForTheApplicationRouteOfAnEngine(assert) {
      var _this12 = this;

      assert.expect(2);

      this.setupAppAndRoutableEngine();
      this.application.__registry__.resolver.moduleBasedResolver = true;
      this.additionalEngineRegistrations(function () {
        this.register('template:error', _emberGlimmerTestsUtilsHelpers.compile('Error! {{model.message}}'));
        this.register('route:post', _emberRouting.Route.extend({
          model: function () {
            return _emberRuntime.RSVP.reject(new Error('Oh, noes!'));
          }
        }));
      });

      return this.visit('/').then(function () {
        _this12.assertText('Application');
        return _this12.transitionTo('blog.post');
      }).catch(function () {
        _this12.assertText('ApplicationEngineError! Oh, noes!');
      });
    };

    _class.prototype['@test error substate route works for a child route of an Engine'] = function testErrorSubstateRouteWorksForAChildRouteOfAnEngine(assert) {
      var _this13 = this;

      assert.expect(2);

      this.setupAppAndRoutableEngine();
      this.application.__registry__.resolver.moduleBasedResolver = true;
      this.additionalEngineRegistrations(function () {
        this.register('template:post_error', _emberGlimmerTestsUtilsHelpers.compile('Error! {{model.message}}'));
        this.register('route:post', _emberRouting.Route.extend({
          model: function () {
            return _emberRuntime.RSVP.reject(new Error('Oh, noes!'));
          }
        }));
      });

      return this.visit('/').then(function () {
        _this13.assertText('Application');
        return _this13.transitionTo('blog.post');
      }).catch(function () {
        _this13.assertText('ApplicationEngineError! Oh, noes!');
      });
    };

    _class.prototype['@test error route works for a child route of an Engine'] = function testErrorRouteWorksForAChildRouteOfAnEngine(assert) {
      var _this14 = this;

      assert.expect(2);

      this.setupAppAndRoutableEngine();
      this.application.__registry__.resolver.moduleBasedResolver = true;
      this.additionalEngineRegistrations(function () {
        this.register('template:post.error', _emberGlimmerTestsUtilsHelpers.compile('Error! {{model.message}}'));
        this.register('route:post.comments', _emberRouting.Route.extend({
          model: function () {
            return _emberRuntime.RSVP.reject(new Error('Oh, noes!'));
          }
        }));
      });

      return this.visit('/').then(function () {
        _this14.assertText('Application');
        return _this14.transitionTo('blog.post.comments');
      }).catch(function () {
        _this14.assertText('ApplicationEngineError! Oh, noes!');
      });
    };

    _class.prototype['@test loading substate route works for the application route of an Engine'] = function testLoadingSubstateRouteWorksForTheApplicationRouteOfAnEngine(assert) {
      var _this15 = this;

      assert.expect(3);

      var resolveLoading = undefined;

      this.setupAppAndRoutableEngine();
      this.application.__registry__.resolver.moduleBasedResolver = true;
      this.additionalEngineRegistrations(function () {
        this.register('template:application_loading', _emberGlimmerTestsUtilsHelpers.compile('Loading'));
        this.register('template:post', _emberGlimmerTestsUtilsHelpers.compile('Post'));
        this.register('route:post', _emberRouting.Route.extend({
          model: function () {
            return new _emberRuntime.RSVP.Promise(function (resolve) {
              resolveLoading = resolve;
            });
          }
        }));
      });

      return this.visit('/').then(function () {
        _this15.assertText('Application');
        var transition = _this15.transitionTo('blog.post');

        _this15.runTaskNext(function () {
          _this15.assertText('ApplicationLoading');
          resolveLoading();
        });

        return transition.then(function () {
          _this15.runTaskNext(function () {
            return _this15.assertText('ApplicationEnginePost');
          });
        });
      });
    };

    _class.prototype['@test loading route works for the application route of an Engine'] = function testLoadingRouteWorksForTheApplicationRouteOfAnEngine(assert) {
      var _this16 = this;

      assert.expect(3);

      var resolveLoading = undefined;

      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('template:loading', _emberGlimmerTestsUtilsHelpers.compile('Loading'));
        this.register('template:post', _emberGlimmerTestsUtilsHelpers.compile('Post'));
        this.register('route:post', _emberRouting.Route.extend({
          model: function () {
            return new _emberRuntime.RSVP.Promise(function (resolve) {
              resolveLoading = resolve;
            });
          }
        }));
      });

      return this.visit('/').then(function () {
        _this16.assertText('Application');
        var transition = _this16.transitionTo('blog.post');

        _this16.runTaskNext(function () {
          _this16.assertText('ApplicationEngineLoading');
          resolveLoading();
        });

        return transition.then(function () {
          _this16.runTaskNext(function () {
            return _this16.assertText('ApplicationEnginePost');
          });
        });
      });
    };

    _class.prototype['@test loading substate route works for a child route of an Engine'] = function testLoadingSubstateRouteWorksForAChildRouteOfAnEngine(assert) {
      var _this17 = this;

      assert.expect(3);

      var resolveLoading = undefined;

      this.setupAppAndRoutableEngine();
      this.application.__registry__.resolver.moduleBasedResolver = true;
      this.additionalEngineRegistrations(function () {
        this.register('template:post', _emberGlimmerTestsUtilsHelpers.compile('{{outlet}}'));
        this.register('template:post.comments', _emberGlimmerTestsUtilsHelpers.compile('Comments'));
        this.register('template:post.likes_loading', _emberGlimmerTestsUtilsHelpers.compile('Loading'));
        this.register('template:post.likes', _emberGlimmerTestsUtilsHelpers.compile('Likes'));
        this.register('route:post.likes', _emberRouting.Route.extend({
          model: function () {
            return new _emberRuntime.RSVP.Promise(function (resolve) {
              resolveLoading = resolve;
            });
          }
        }));
      });

      return this.visit('/blog/post/comments').then(function () {
        _this17.assertText('ApplicationEngineComments');
        var transition = _this17.transitionTo('blog.post.likes');

        _this17.runTaskNext(function () {
          _this17.assertText('ApplicationEngineLoading');
          resolveLoading();
        });

        return transition.then(function () {
          _this17.runTaskNext(function () {
            return _this17.assertText('ApplicationEngineLikes');
          });
        });
      });
    };

    _class.prototype['@test loading route works for a child route of an Engine'] = function testLoadingRouteWorksForAChildRouteOfAnEngine(assert) {
      var _this18 = this;

      assert.expect(3);

      var resolveLoading = undefined;

      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('template:post', _emberGlimmerTestsUtilsHelpers.compile('{{outlet}}'));
        this.register('template:post.comments', _emberGlimmerTestsUtilsHelpers.compile('Comments'));
        this.register('template:post.loading', _emberGlimmerTestsUtilsHelpers.compile('Loading'));
        this.register('template:post.likes', _emberGlimmerTestsUtilsHelpers.compile('Likes'));
        this.register('route:post.likes', _emberRouting.Route.extend({
          model: function () {
            return new _emberRuntime.RSVP.Promise(function (resolve) {
              resolveLoading = resolve;
            });
          }
        }));
      });

      return this.visit('/blog/post/comments').then(function () {
        _this18.assertText('ApplicationEngineComments');
        var transition = _this18.transitionTo('blog.post.likes');

        _this18.runTaskNext(function () {
          _this18.assertText('ApplicationEngineLoading');
          resolveLoading();
        });

        return transition.then(function () {
          _this18.runTaskNext(function () {
            return _this18.assertText('ApplicationEngineLikes');
          });
        });
      });
    };

    _class.prototype['@test query params don\'t have stickiness by default between model'] = function testQueryParamsDonTHaveStickinessByDefaultBetweenModel(assert) {
      var _this19 = this;

      assert.expect(1);
      var tmpl = '{{#link-to "blog.category" 1337}}Category 1337{{/link-to}}';
      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('template:category', _emberGlimmerTestsUtilsHelpers.compile(tmpl));
      });

      return this.visit('/blog/category/1?type=news').then(function () {
        var suffix = '/blog/category/1337';
        var href = _this19.element.querySelector('a').href;

        // check if link ends with the suffix
        assert.ok(_this19.stringsEndWith(href, suffix));
      });
    };

    _class.prototype['@test query params in customized controllerName have stickiness by default between model'] = function testQueryParamsInCustomizedControllerNameHaveStickinessByDefaultBetweenModel(assert) {
      var _this20 = this;

      assert.expect(2);
      var tmpl = '{{#link-to "blog.author" 1337 class="author-1337"}}Author 1337{{/link-to}}{{#link-to "blog.author" 1 class="author-1"}}Author 1{{/link-to}}';
      this.setupAppAndRoutableEngine();
      this.additionalEngineRegistrations(function () {
        this.register('template:author', _emberGlimmerTestsUtilsHelpers.compile(tmpl));
      });

      return this.visit('/blog/author/1?official=true').then(function () {
        var suffix1 = '/blog/author/1?official=true';
        var href1 = _this20.element.querySelector('.author-1').href;
        var suffix1337 = '/blog/author/1337';
        var href1337 = _this20.element.querySelector('.author-1337').href;

        // check if link ends with the suffix
        assert.ok(_this20.stringsEndWith(href1, suffix1));
        assert.ok(_this20.stringsEndWith(href1337, suffix1337));
      });
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.ApplicationTest));
});
enifed('ember-glimmer/tests/integration/application/engine-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/application/engine-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/application/engine-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/application/rendering-test', ['exports', 'ember-runtime', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/abstract-test-case', 'ember-routing', 'ember-metal', 'ember-glimmer'], function (exports, _emberRuntime, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsAbstractTestCase, _emberRouting, _emberMetal, _emberGlimmer) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n      <ul>\n        {{#each model as |item|}}\n          <li>{{item}}</li>\n        {{/each}}\n      </ul>\n    '], ['\n      <ul>\n        {{#each model as |item|}}\n          <li>{{item}}</li>\n        {{/each}}\n      </ul>\n    ']),
      _templateObject2 = babelHelpers.taggedTemplateLiteralLoose(['\n          <ul>\n            <li>red</li>\n            <li>yellow</li>\n            <li>blue</li>\n          </ul>\n        '], ['\n          <ul>\n            <li>red</li>\n            <li>yellow</li>\n            <li>blue</li>\n          </ul>\n        ']),
      _templateObject3 = babelHelpers.taggedTemplateLiteralLoose(['\n      <nav>{{outlet "nav"}}</nav>\n      <main>{{outlet}}</main>\n    '], ['\n      <nav>{{outlet "nav"}}</nav>\n      <main>{{outlet}}</main>\n    ']),
      _templateObject4 = babelHelpers.taggedTemplateLiteralLoose(['\n      <a href="http://emberjs.com/">Ember</a>\n    '], ['\n      <a href="http://emberjs.com/">Ember</a>\n    ']),
      _templateObject5 = babelHelpers.taggedTemplateLiteralLoose(['\n          <nav>\n            <a href="http://emberjs.com/">Ember</a>\n          </nav>\n          <main>\n            <ul>\n              <li>red</li>\n              <li>yellow</li>\n              <li>blue</li>\n            </ul>\n          </main>\n        '], ['\n          <nav>\n            <a href="http://emberjs.com/">Ember</a>\n          </nav>\n          <main>\n            <ul>\n              <li>red</li>\n              <li>yellow</li>\n              <li>blue</li>\n            </ul>\n          </main>\n        ']);

  _emberGlimmerTestsUtilsTestCase.moduleFor('Application test: rendering', (function (_ApplicationTest) {
babelHelpers.inherits(_class, _ApplicationTest);

    function _class() {
      _ApplicationTest.apply(this, arguments);
    }

    _class.prototype['@test it can render the application template'] = function testItCanRenderTheApplicationTemplate(assert) {
      var _this = this;

      this.registerTemplate('application', 'Hello world!');

      return this.visit('/').then(function () {
        _this.assertText('Hello world!');
      });
    };

    _class.prototype['@test it can access the model provided by the route'] = function testItCanAccessTheModelProvidedByTheRoute(assert) {
      var _this2 = this;

      this.registerRoute('application', _emberRouting.Route.extend({
        model: function () {
          return ['red', 'yellow', 'blue'];
        }
      }));

      this.registerTemplate('application', _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject));

      return this.visit('/').then(function () {
        _this2.assertComponentElement(_this2.firstChild, {
          content: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2)
        });
      });
    };

    _class.prototype['@test it can render a nested route'] = function testItCanRenderANestedRoute(assert) {
      var _this3 = this;

      this.router.map(function () {
        this.route('lists', function () {
          this.route('colors', function () {
            this.route('favorite');
          });
        });
      });

      // The "favorite" route will inherit the model
      this.registerRoute('lists.colors', _emberRouting.Route.extend({
        model: function () {
          return ['red', 'yellow', 'blue'];
        }
      }));

      this.registerTemplate('lists.colors.favorite', _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject));

      return this.visit('/lists/colors/favorite').then(function () {
        _this3.assertComponentElement(_this3.firstChild, {
          content: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2)
        });
      });
    };

    _class.prototype['@test it can render into named outlets'] = function testItCanRenderIntoNamedOutlets(assert) {
      var _this4 = this;

      this.router.map(function () {
        this.route('colors');
      });

      this.registerTemplate('application', _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject3));

      this.registerTemplate('nav', _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject4));

      this.registerRoute('application', _emberRouting.Route.extend({
        renderTemplate: function () {
          this.render();
          this.render('nav', {
            into: 'application',
            outlet: 'nav'
          });
        }
      }));

      this.registerRoute('colors', _emberRouting.Route.extend({
        model: function () {
          return ['red', 'yellow', 'blue'];
        }
      }));

      this.registerTemplate('colors', _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject));

      return this.visit('/colors').then(function () {
        _this4.assertComponentElement(_this4.firstChild, {
          content: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject5)
        });
      });
    };

    _class.prototype['@test it can render into named outlets'] = function testItCanRenderIntoNamedOutlets(assert) {
      var _this5 = this;

      this.router.map(function () {
        this.route('colors');
      });

      this.registerTemplate('application', _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject3));

      this.registerTemplate('nav', _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject4));

      this.registerRoute('application', _emberRouting.Route.extend({
        renderTemplate: function () {
          this.render();
          this.render('nav', {
            into: 'application',
            outlet: 'nav'
          });
        }
      }));

      this.registerRoute('colors', _emberRouting.Route.extend({
        model: function () {
          return ['red', 'yellow', 'blue'];
        }
      }));

      this.registerTemplate('colors', _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject));

      return this.visit('/colors').then(function () {
        _this5.assertComponentElement(_this5.firstChild, {
          content: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject5)
        });
      });
    };

    _class.prototype['@test it should update the outlets when switching between routes'] = function testItShouldUpdateTheOutletsWhenSwitchingBetweenRoutes(assert) {
      var _this6 = this;

      this.router.map(function () {
        this.route('a');
        this.route('b', function () {
          this.route('c');
          this.route('d');
        });
      });

      this.registerTemplate('a', 'A{{outlet}}');
      this.registerTemplate('b', 'B{{outlet}}');
      this.registerTemplate('b.c', 'C');
      this.registerTemplate('b.d', 'D');

      return this.visit('/b/c').then(function () {
        // this.assertComponentElement(this.firstChild, { content: 'BC' });
        _this6.assertText('BC');
        return _this6.visit('/a');
      }).then(function () {
        // this.assertComponentElement(this.firstChild, { content: 'A' });
        _this6.assertText('A');
        return _this6.visit('/b/d');
      }).then(function () {
        _this6.assertText('BD');
        // this.assertComponentElement(this.firstChild, { content: 'BD' });
      });
    };

    _class.prototype['@test it should produce a stable DOM when the model changes'] = function testItShouldProduceAStableDOMWhenTheModelChanges(assert) {
      var _this7 = this;

      this.router.map(function () {
        this.route('color', { path: '/colors/:color' });
      });

      this.registerRoute('color', _emberRouting.Route.extend({
        model: function (params) {
          return params.color;
        }
      }));

      this.registerTemplate('color', 'color: {{model}}');

      return this.visit('/colors/red').then(function () {
        _this7.assertComponentElement(_this7.firstChild, { content: 'color: red' });
        _this7.takeSnapshot();
        return _this7.visit('/colors/green');
      }).then(function () {
        _this7.assertComponentElement(_this7.firstChild, { content: 'color: green' });
        _this7.assertInvariants();
      });
    };

    _class.prototype['@test it should have the right controller in scope for the route template'] = function testItShouldHaveTheRightControllerInScopeForTheRouteTemplate() {
      var _this8 = this;

      this.router.map(function () {
        this.route('a');
        this.route('b');
      });

      this.registerController('a', _emberRuntime.Controller.extend({
        value: 'a'
      }));

      this.registerController('b', _emberRuntime.Controller.extend({
        value: 'b'
      }));

      this.registerTemplate('a', '{{value}}');
      this.registerTemplate('b', '{{value}}');

      return this.visit('/a').then(function () {
        _this8.assertText('a');
        return _this8.visit('/b');
      }).then(function () {
        return _this8.assertText('b');
      });
    };

    _class.prototype['@test it should update correctly when the controller changes'] = function testItShouldUpdateCorrectlyWhenTheControllerChanges(assert) {
      var _this9 = this;

      this.router.map(function () {
        this.route('color', { path: '/colors/:color' });
      });

      this.registerRoute('color', _emberRouting.Route.extend({
        model: function (params) {
          return { color: params.color };
        },

        renderTemplate: function (controller, model) {
          this.render({ controller: model.color, model: model });
        }
      }));

      this.registerController('red', _emberRuntime.Controller.extend({
        color: 'red'
      }));

      this.registerController('green', _emberRuntime.Controller.extend({
        color: 'green'
      }));

      this.registerTemplate('color', 'model color: {{model.color}}, controller color: {{color}}');

      return this.visit('/colors/red').then(function () {
        _this9.assertComponentElement(_this9.firstChild, { content: 'model color: red, controller color: red' });
        _this9.takeSnapshot();
        return _this9.visit('/colors/green');
      }).then(function () {
        _this9.assertComponentElement(_this9.firstChild, { content: 'model color: green, controller color: green' });
        _this9.assertInvariants();
      });
    };

    _class.prototype['@test it should produce a stable DOM when two routes render the same template'] = function testItShouldProduceAStableDOMWhenTwoRoutesRenderTheSameTemplate(assert) {
      var _this10 = this;

      this.router.map(function () {
        this.route('a');
        this.route('b');
      });

      this.registerRoute('a', _emberRouting.Route.extend({
        model: function () {
          return 'A';
        },

        renderTemplate: function (controller, model) {
          this.render('common', { controller: 'common', model: model });
        }
      }));

      this.registerRoute('b', _emberRouting.Route.extend({
        model: function () {
          return 'B';
        },

        renderTemplate: function (controller, model) {
          this.render('common', { controller: 'common', model: model });
        }
      }));

      this.registerController('common', _emberRuntime.Controller.extend({
        prefix: 'common'
      }));

      this.registerTemplate('common', '{{prefix}} {{model}}');

      return this.visit('/a').then(function () {
        _this10.assertComponentElement(_this10.firstChild, { content: 'common A' });
        _this10.takeSnapshot();
        return _this10.visit('/b');
      }).then(function () {
        _this10.assertComponentElement(_this10.firstChild, { content: 'common B' });
        _this10.assertInvariants();
      });
    };

    // Regression test, glimmer child outlets tried to assume the first element.
    // but the if put-args clobbered the args used by did-create-element.
    // I wish there was a way to assert that the OutletComponentManager did not
    // receive a didCreateElement.

    _class.prototype['@test a child outlet is always a fragment'] = function testAChildOutletIsAlwaysAFragment() {
      var _this11 = this;

      this.registerTemplate('application', '{{outlet}}');
      this.registerTemplate('index', '{{#if true}}1{{/if}}<div>2</div>');
      return this.visit('/').then(function () {
        _this11.assertComponentElement(_this11.firstChild, { content: '1<div>2</div>' });
      });
    };

    _class.prototype['@test it allows a transition during route activate'] = function testItAllowsATransitionDuringRouteActivate(assert) {
      var _this12 = this;

      this.router.map(function () {
        this.route('a');
      });

      this.registerRoute('index', _emberRouting.Route.extend({
        activate: function () {
          this.transitionTo('a');
        }
      }));

      this.registerTemplate('a', 'Hello from A!');

      return this.visit('/').then(function () {
        _this12.assertComponentElement(_this12.firstChild, {
          content: 'Hello from A!'
        });
      });
    };

    _class.prototype['@test it emits a useful backtracking re-render assertion message'] = function testItEmitsAUsefulBacktrackingReRenderAssertionMessage(assert) {
      var _this13 = this;

      this.router.map(function () {
        this.route('routeWithError');
      });

      this.registerRoute('routeWithError', _emberRouting.Route.extend({
        model: function () {
          return { name: 'Alex' };
        }
      }));

      this.registerTemplate('routeWithError', 'Hi {{model.name}} {{x-foo person=model}}');

      this.registerComponent('x-foo', {
        ComponentClass: _emberGlimmer.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            this.set('person.name', 'Ben');
          }
        }),
        template: 'Hi {{person.name}} from component'
      });

      var expectedBacktrackingMessage = /modified "model\.name" twice on \[object Object\] in a single render\. It was rendered in "template:routeWithError" and modified in "component:x-foo"/;

      if (true) {
        expectDeprecation(expectedBacktrackingMessage);
        return this.visit('/routeWithError');
      } else {
        return this.visit('/').then(function () {
          expectAssertion(function () {
            _this13.visit('/routeWithError');
          }, expectedBacktrackingMessage);
        });
      }
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.ApplicationTest));
});
enifed('ember-glimmer/tests/integration/application/rendering-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/application/rendering-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/application/rendering-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/binding_integration_test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/helpers', 'ember-metal'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsHelpers, _emberMetal) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Binding integration tests', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test should accept bindings as a string or an Ember.binding'] = function testShouldAcceptBindingsAsAStringOrAnEmberBinding() {
      var _this = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        twoWayTestBinding: _emberMetal.Binding.from('direction'),
        stringTestBinding: 'direction',
        twoWayObjectTestBinding: _emberMetal.Binding.from('displacement.distance'),
        stringObjectTestBinding: 'displacement.distance'
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: 'two way: {{twoWayTest}}, string: {{stringTest}}, object: {{twoWayObjectTest}}, string object: {{stringObjectTest}}'
      });

      expectDeprecation(function () {
        _this.render('{{foo-bar direction=direction displacement=displacement}}', {
          direction: 'down',
          displacement: {
            distance: 10
          }
        });
      }, /`Ember\.Binding` is deprecated/);

      this.assertText('two way: down, string: down, object: 10, string object: 10');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'direction', 'up');
      });

      this.assertText('two way: up, string: up, object: 10, string object: 10');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'displacement.distance', 20);
      });

      this.assertText('two way: up, string: up, object: 20, string object: 20');

      this.runTask(function () {
        _emberMetal.set(_this.context, 'direction', 'right');
        _emberMetal.set(_this.context, 'displacement.distance', 30);
      });

      this.assertText('two way: right, string: right, object: 30, string object: 30');

      this.runTask(function () {
        _emberMetal.set(_this.context, 'direction', 'down');
        _emberMetal.set(_this.context, 'displacement', { distance: 10 });
      });

      this.assertText('two way: down, string: down, object: 10, string object: 10');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/binding_integration_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/binding_integration_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/binding_integration_test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/components/append-test', ['exports', 'ember-metal', 'ember-views', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/helpers', 'ember-glimmer/tests/utils/abstract-test-case'], function (exports, _emberMetal, _emberViews, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsHelpers, _emberGlimmerTestsUtilsAbstractTestCase) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#if showFooBar}}\n        {{foo-bar}}\n      {{else}}\n        {{baz-qux}}\n      {{/if}}\n    '], ['\n      {{#if showFooBar}}\n        {{foo-bar}}\n      {{else}}\n        {{baz-qux}}\n      {{/if}}\n    ']);

  var AbstractAppendTest = (function (_RenderingTest) {
babelHelpers.inherits(AbstractAppendTest, _RenderingTest);

    function AbstractAppendTest() {
      _RenderingTest.call(this);

      this.components = [];
      this.ids = [];
    }

    AbstractAppendTest.prototype.teardown = function teardown() {
      var _this = this;

      this.component = null;

      this.components.forEach(function (component) {
        _this.runTask(function () {
          return component.destroy();
        });
      });

      this.ids.forEach(function (id) {
        var $element = _emberViews.jQuery(id).remove();
        _this.assert.strictEqual($element.length, 0, 'Should not leak element: #' + id);
      });

      _RenderingTest.prototype.teardown.call(this);
    };

    /* abstract append(component): Element; */

    AbstractAppendTest.prototype.didAppend = function didAppend(component) {
      this.components.push(component);
      this.ids.push(component.elementId);
    };

    AbstractAppendTest.prototype['@test lifecycle hooks during component append'] = function testLifecycleHooksDuringComponentAppend(assert) {
      var _this3 = this;

      var hooks = [];

      var oldRegisterComponent = this.registerComponent;
      var componentsByName = {};

      // TODO: refactor/combine with other life-cycle tests
      this.registerComponent = function (name, _options) {
        function pushHook(hookName) {
          hooks.push([name, hookName]);
        }

        var options = {
          ComponentClass: _options.ComponentClass.extend({
            init: function () {
              var _this2 = this,
                  _arguments = arguments;

              expectDeprecation(function () {
                _this2._super.apply(_this2, _arguments);
              }, /didInitAttrs called/);
              if (name in componentsByName) {
                throw new TypeError('Component named: ` ' + name + ' ` already registered');
              }
              componentsByName[name] = this;
              pushHook('init');
              this.on('init', function () {
                return pushHook('on(init)');
              });
            },

            didInitAttrs: function (options) {
              pushHook('didInitAttrs', options);
            },

            didReceiveAttrs: function () {
              pushHook('didReceiveAttrs');
            },

            willInsertElement: function () {
              pushHook('willInsertElement');
            },

            willRender: function () {
              pushHook('willRender');
            },

            didInsertElement: function () {
              pushHook('didInsertElement');
            },

            didRender: function () {
              pushHook('didRender');
            },

            didUpdateAttrs: function () {
              pushHook('didUpdateAttrs');
            },

            willUpdate: function () {
              pushHook('willUpdate');
            },

            didUpdate: function () {
              pushHook('didUpdate');
            },

            willDestroyElement: function () {
              pushHook('willDestroyElement');
            },

            willClearRender: function () {
              pushHook('willClearRender');
            },

            didDestroyElement: function () {
              pushHook('didDestroyElement');
            },

            willDestroy: function () {
              pushHook('willDestroy');
              this._super.apply(this, arguments);
            }
          }),
          template: _options.template
        };

        oldRegisterComponent.call(this, name, options);
      };

      this.registerComponent('x-parent', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          layoutName: 'components/x-parent'
        }),

        template: '[parent: {{foo}}]{{#x-child bar=foo}}[yielded: {{foo}}]{{/x-child}}'
      });

      this.registerComponent('x-child', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          tagName: ''
        }),

        template: '[child: {{bar}}]{{yield}}'
      });

      var XParent = undefined;

      if (true) {
        XParent = this.owner.factoryFor('component:x-parent');
      } else {
        XParent = this.owner._lookupFactory('component:x-parent');
      }

      this.component = XParent.create({ foo: 'zomg' });

      assert.deepEqual(hooks, [['x-parent', 'init'], ['x-parent', 'didInitAttrs'], ['x-parent', 'didReceiveAttrs'], ['x-parent', 'on(init)']], 'creation of x-parent');

      hooks.length = 0;

      this.element = this.append(this.component);

      assert.deepEqual(hooks, [['x-parent', 'willInsertElement'], ['x-child', 'init'], ['x-child', 'didInitAttrs'], ['x-child', 'didReceiveAttrs'], ['x-child', 'on(init)'], ['x-child', 'willRender'], ['x-child', 'willInsertElement'], ['x-child', 'didInsertElement'], ['x-child', 'didRender'], ['x-parent', 'didInsertElement'], ['x-parent', 'didRender']], 'appending of x-parent');

      hooks.length = 0;

      this.runTask(function () {
        return componentsByName['x-parent'].rerender();
      });

      assert.deepEqual(hooks, [['x-parent', 'willUpdate'], ['x-parent', 'willRender'], ['x-parent', 'didUpdate'], ['x-parent', 'didRender']], 'rerender x-parent');

      hooks.length = 0;

      this.runTask(function () {
        return componentsByName['x-child'].rerender();
      });

      assert.deepEqual(hooks, [['x-parent', 'willUpdate'], ['x-parent', 'willRender'], ['x-child', 'willUpdate'], ['x-child', 'willRender'], ['x-child', 'didUpdate'], ['x-child', 'didRender'], ['x-parent', 'didUpdate'], ['x-parent', 'didRender']], 'rerender x-child');

      hooks.length = 0;

      this.runTask(function () {
        return _emberMetal.set(_this3.component, 'foo', 'wow');
      });

      assert.deepEqual(hooks, [['x-parent', 'willUpdate'], ['x-parent', 'willRender'], ['x-child', 'didUpdateAttrs'], ['x-child', 'didReceiveAttrs'], ['x-child', 'willUpdate'], ['x-child', 'willRender'], ['x-child', 'didUpdate'], ['x-child', 'didRender'], ['x-parent', 'didUpdate'], ['x-parent', 'didRender']], 'set foo = wow');

      hooks.length = 0;

      this.runTask(function () {
        return _emberMetal.set(_this3.component, 'foo', 'zomg');
      });

      assert.deepEqual(hooks, [['x-parent', 'willUpdate'], ['x-parent', 'willRender'], ['x-child', 'didUpdateAttrs'], ['x-child', 'didReceiveAttrs'], ['x-child', 'willUpdate'], ['x-child', 'willRender'], ['x-child', 'didUpdate'], ['x-child', 'didRender'], ['x-parent', 'didUpdate'], ['x-parent', 'didRender']], 'set foo = zomg');

      hooks.length = 0;

      this.runTask(function () {
        return _this3.component.destroy();
      });

      assert.deepEqual(hooks, [['x-parent', 'willDestroyElement'], ['x-parent', 'willClearRender'], ['x-child', 'willDestroyElement'], ['x-child', 'willClearRender'], ['x-child', 'didDestroyElement'], ['x-parent', 'didDestroyElement'], ['x-parent', 'willDestroy'], ['x-child', 'willDestroy']], 'destroy');
    };

    AbstractAppendTest.prototype['@test appending, updating and destroying a single component'] = function testAppendingUpdatingAndDestroyingASingleComponent(assert) {
      var _this4 = this;

      var willDestroyCalled = 0;

      this.registerComponent('x-parent', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          layoutName: 'components/x-parent',
          willDestroyElement: function () {
            willDestroyCalled++;
          }
        }),

        template: '[parent: {{foo}}]{{#x-child bar=foo}}[yielded: {{foo}}]{{/x-child}}'
      });

      this.registerComponent('x-child', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          tagName: ''
        }),

        template: '[child: {{bar}}]{{yield}}'
      });

      var XParent = undefined;

      if (true) {
        XParent = this.owner.factoryFor('component:x-parent');
      } else {
        XParent = this.owner._lookupFactory('component:x-parent');
      }

      this.component = XParent.create({ foo: 'zomg' });

      assert.ok(!this.component.element, 'precond - should not have an element');

      this.element = this.append(this.component);

      var componentElement = this.component.element;

      this.assertComponentElement(componentElement, { content: '[parent: zomg][child: zomg][yielded: zomg]' });

      assert.equal(componentElement.parentElement, this.element, 'It should be attached to the target');

      this.runTask(function () {
        return _this4.rerender();
      });

      this.assertComponentElement(componentElement, { content: '[parent: zomg][child: zomg][yielded: zomg]' });

      assert.equal(componentElement.parentElement, this.element, 'It should be attached to the target');

      this.runTask(function () {
        return _emberMetal.set(_this4.component, 'foo', 'wow');
      });

      this.assertComponentElement(componentElement, { content: '[parent: wow][child: wow][yielded: wow]' });

      assert.equal(componentElement.parentElement, this.element, 'It should be attached to the target');

      this.runTask(function () {
        return _emberMetal.set(_this4.component, 'foo', 'zomg');
      });

      this.assertComponentElement(componentElement, { content: '[parent: zomg][child: zomg][yielded: zomg]' });

      assert.equal(componentElement.parentElement, this.element, 'It should be attached to the target');

      this.runTask(function () {
        return _this4.component.destroy();
      });

      if (this.isHTMLBars) {
        // Bug in Glimmer – component should not have .element at this point
        assert.ok(!this.component.element, 'It should not have an element');
      }

      assert.ok(!componentElement.parentElement, 'The component element should be detached');

      this.assert.equal(willDestroyCalled, 1);
    };

    AbstractAppendTest.prototype['@test appending, updating and destroying multiple components'] = function testAppendingUpdatingAndDestroyingMultipleComponents(assert) {
      var _this5 = this;

      var willDestroyCalled = 0;

      this.registerComponent('x-first', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          layoutName: 'components/x-first',

          willDestroyElement: function () {
            willDestroyCalled++;
          }
        }),

        template: 'x-first {{foo}}!'
      });

      this.registerComponent('x-second', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          layoutName: 'components/x-second',

          willDestroyElement: function () {
            willDestroyCalled++;
          }
        }),

        template: 'x-second {{bar}}!'
      });

      var First = undefined,
          Second = undefined;

      if (true) {
        First = this.owner.factoryFor('component:x-first');
        Second = this.owner.factoryFor('component:x-second');
      } else {
        First = this.owner._lookupFactory('component:x-first');
        Second = this.owner._lookupFactory('component:x-second');
      }

      var first = First.create({ foo: 'foo' });
      var second = Second.create({ bar: 'bar' });

      this.assert.ok(!first.element, 'precond - should not have an element');
      this.assert.ok(!second.element, 'precond - should not have an element');

      var wrapper1 = undefined,
          wrapper2 = undefined;

      this.runTask(function () {
        return wrapper1 = _this5.append(first);
      });
      this.runTask(function () {
        return wrapper2 = _this5.append(second);
      });

      var componentElement1 = first.element;
      var componentElement2 = second.element;

      this.assertComponentElement(componentElement1, { content: 'x-first foo!' });
      this.assertComponentElement(componentElement2, { content: 'x-second bar!' });

      assert.equal(componentElement1.parentElement, wrapper1, 'The first component should be attached to the target');
      assert.equal(componentElement2.parentElement, wrapper2, 'The second component should be attached to the target');

      this.runTask(function () {
        return _emberMetal.set(first, 'foo', 'FOO');
      });

      this.assertComponentElement(componentElement1, { content: 'x-first FOO!' });
      this.assertComponentElement(componentElement2, { content: 'x-second bar!' });

      assert.equal(componentElement1.parentElement, wrapper1, 'The first component should be attached to the target');
      assert.equal(componentElement2.parentElement, wrapper2, 'The second component should be attached to the target');

      this.runTask(function () {
        return _emberMetal.set(second, 'bar', 'BAR');
      });

      this.assertComponentElement(componentElement1, { content: 'x-first FOO!' });
      this.assertComponentElement(componentElement2, { content: 'x-second BAR!' });

      assert.equal(componentElement1.parentElement, wrapper1, 'The first component should be attached to the target');
      assert.equal(componentElement2.parentElement, wrapper2, 'The second component should be attached to the target');

      this.runTask(function () {
        _emberMetal.set(first, 'foo', 'foo');
        _emberMetal.set(second, 'bar', 'bar');
      });

      this.assertComponentElement(componentElement1, { content: 'x-first foo!' });
      this.assertComponentElement(componentElement2, { content: 'x-second bar!' });

      assert.equal(componentElement1.parentElement, wrapper1, 'The first component should be attached to the target');
      assert.equal(componentElement2.parentElement, wrapper2, 'The second component should be attached to the target');

      this.runTask(function () {
        first.destroy();
        second.destroy();
      });

      if (this.isHTMLBars) {
        // Bug in Glimmer – component should not have .element at this point
        assert.ok(!first.element, 'The first component should not have an element');
        assert.ok(!second.element, 'The second component should not have an element');
      }

      assert.ok(!componentElement1.parentElement, 'The first component element should be detached');
      assert.ok(!componentElement2.parentElement, 'The second component element should be detached');

      this.assert.equal(willDestroyCalled, 2);
    };

    AbstractAppendTest.prototype['@test can appendTo while rendering'] = function testCanAppendToWhileRendering(assert) {
      var _this6 = this;

      var owner = this.owner;

      var append = function (component) {
        return _this6.append(component);
      };

      var element1 = undefined,
          element2 = undefined;
      this.registerComponent('first-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          layout: _emberGlimmerTestsUtilsHelpers.compile('component-one'),

          didInsertElement: function () {
            element1 = this.element;

            var SecondComponent = undefined;
            if (true) {
              SecondComponent = owner.factoryFor('component:second-component');
            } else {
              SecondComponent = owner._lookupFactory('component:second-component');
            }

            append(SecondComponent.create());
          }
        })
      });

      this.registerComponent('second-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          layout: _emberGlimmerTestsUtilsHelpers.compile('component-two'),

          didInsertElement: function () {
            element2 = this.element;
          }
        })
      });

      var FirstComponent = undefined;

      if (true) {
        FirstComponent = this.owner.factoryFor('component:first-component');
      } else {
        FirstComponent = this.owner._lookupFactory('component:first-component');
      }

      this.runTask(function () {
        return append(FirstComponent.create());
      });

      this.assertComponentElement(element1, { content: 'component-one' });
      this.assertComponentElement(element2, { content: 'component-two' });
    };

    AbstractAppendTest.prototype['@test can appendTo and remove while rendering'] = function testCanAppendToAndRemoveWhileRendering(assert) {
      var _this7 = this;

      var owner = this.owner;

      var append = function (component) {
        return _this7.append(component);
      };

      var element1 = undefined,
          element2 = undefined,
          element3 = undefined,
          element4 = undefined,
          component1 = undefined,
          component2 = undefined;
      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          layout: _emberGlimmerTestsUtilsHelpers.compile('foo-bar'),

          init: function () {
            this._super.apply(this, arguments);
            component1 = this;
          },

          didInsertElement: function () {
            element1 = this.element;
            var OtherRoot = undefined;

            if (true) {
              OtherRoot = owner.factoryFor('component:other-root');
            } else {
              OtherRoot = owner._lookupFactory('component:other-root');
            }

            this._instance = OtherRoot.create({
              didInsertElement: function () {
                element2 = this.element;
              }
            });

            append(this._instance);
          },

          willDestroy: function () {
            this._instance.destroy();
          }
        })
      });

      this.registerComponent('baz-qux', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          layout: _emberGlimmerTestsUtilsHelpers.compile('baz-qux'),

          init: function () {
            this._super.apply(this, arguments);
            component2 = this;
          },

          didInsertElement: function () {
            element3 = this.element;
            var OtherRoot = undefined;

            if (true) {
              OtherRoot = owner.factoryFor('component:other-root');
            } else {
              OtherRoot = owner._lookupFactory('component:other-root');
            }

            this._instance = OtherRoot.create({
              didInsertElement: function () {
                element4 = this.element;
              }
            });

            append(this._instance);
          },

          willDestroy: function () {
            this._instance.destroy();
          }
        })
      });

      var instantiatedRoots = 0;
      var destroyedRoots = 0;
      this.registerComponent('other-root', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          layout: _emberGlimmerTestsUtilsHelpers.compile('fake-thing: {{counter}}'),
          init: function () {
            this._super.apply(this, arguments);
            this.counter = instantiatedRoots++;
          },
          willDestroy: function () {
            destroyedRoots++;
            this._super.apply(this, arguments);
          }
        })
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject), { showFooBar: true });

      this.assertComponentElement(element1, {});
      this.assertComponentElement(element2, { content: 'fake-thing: 0' });
      assert.equal(instantiatedRoots, 1);

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'showFooBar', false);
      });

      assert.equal(instantiatedRoots, 2);
      assert.equal(destroyedRoots, 1);

      this.assertComponentElement(element3, {});
      this.assertComponentElement(element4, { content: 'fake-thing: 1' });

      this.runTask(function () {
        component1.destroy();
        component2.destroy();
      });

      assert.equal(instantiatedRoots, 2);
      assert.equal(destroyedRoots, 2);
    };

    return AbstractAppendTest;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest);

  _emberGlimmerTestsUtilsTestCase.moduleFor('append: no arguments (attaching to document.body)', (function (_AbstractAppendTest) {
babelHelpers.inherits(_class, _AbstractAppendTest);

    function _class() {
      _AbstractAppendTest.apply(this, arguments);
    }

    _class.prototype.append = function append(component) {
      this.runTask(function () {
        return component.append();
      });
      this.didAppend(component);
      return document.body;
    };

    return _class;
  })(AbstractAppendTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('appendTo: a selector', (function (_AbstractAppendTest2) {
babelHelpers.inherits(_class2, _AbstractAppendTest2);

    function _class2() {
      _AbstractAppendTest2.apply(this, arguments);
    }

    _class2.prototype.append = function append(component) {
      this.runTask(function () {
        return component.appendTo('#qunit-fixture');
      });
      this.didAppend(component);
      return _emberViews.jQuery('#qunit-fixture')[0];
    };

    _class2.prototype['@test raises an assertion when the target does not exist in the DOM'] = function testRaisesAnAssertionWhenTheTargetDoesNotExistInTheDOM(assert) {
      var _this8 = this;

      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          layoutName: 'components/foo-bar'
        }),
        template: 'FOO BAR!'
      });

      var FooBar = undefined;

      if (true) {
        FooBar = this.owner.factoryFor('component:foo-bar');
      } else {
        FooBar = this.owner._lookupFactory('component:foo-bar');
      }

      this.component = FooBar.create();

      assert.ok(!this.component.element, 'precond - should not have an element');

      this.runTask(function () {
        expectAssertion(function () {
          _this8.component.appendTo('#does-not-exist-in-dom');
        }, /You tried to append to \(#does-not-exist-in-dom\) but that isn't in the DOM/);
      });

      assert.ok(!this.component.element, 'component should not have an element');
    };

    return _class2;
  })(AbstractAppendTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('appendTo: an element', (function (_AbstractAppendTest3) {
babelHelpers.inherits(_class3, _AbstractAppendTest3);

    function _class3() {
      _AbstractAppendTest3.apply(this, arguments);
    }

    _class3.prototype.append = function append(component) {
      var element = _emberViews.jQuery('#qunit-fixture')[0];
      this.runTask(function () {
        return component.appendTo(element);
      });
      this.didAppend(component);
      return element;
    };

    return _class3;
  })(AbstractAppendTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('appendTo: with multiple components', (function (_AbstractAppendTest4) {
babelHelpers.inherits(_class4, _AbstractAppendTest4);

    function _class4() {
      _AbstractAppendTest4.apply(this, arguments);
    }

    _class4.prototype.append = function append(component) {
      this.runTask(function () {
        return component.appendTo('#qunit-fixture');
      });
      this.didAppend(component);
      return _emberViews.jQuery('#qunit-fixture')[0];
    };

    return _class4;
  })(AbstractAppendTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('renderToElement: no arguments (defaults to a body context)', (function (_AbstractAppendTest5) {
babelHelpers.inherits(_class5, _AbstractAppendTest5);

    function _class5() {
      _AbstractAppendTest5.apply(this, arguments);
    }

    _class5.prototype.append = function append(component) {
      expectDeprecation(/Using the `renderToElement` is deprecated in favor of `appendTo`. Called in/);
      var wrapper = undefined;

      this.runTask(function () {
        return wrapper = component.renderToElement();
      });
      this.didAppend(component);

      this.assert.equal(wrapper.tagName, 'BODY', 'wrapper is a body element');
      this.assert.notEqual(wrapper, document.body, 'wrapper is not document.body');
      this.assert.ok(!wrapper.parentNode, 'wrapper is detached');

      return wrapper;
    };

    return _class5;
  })(AbstractAppendTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('renderToElement: a div', (function (_AbstractAppendTest6) {
babelHelpers.inherits(_class6, _AbstractAppendTest6);

    function _class6() {
      _AbstractAppendTest6.apply(this, arguments);
    }

    _class6.prototype.append = function append(component) {
      expectDeprecation(/Using the `renderToElement` is deprecated in favor of `appendTo`. Called in/);
      var wrapper = undefined;

      this.runTask(function () {
        return wrapper = component.renderToElement('div');
      });
      this.didAppend(component);

      this.assert.equal(wrapper.tagName, 'DIV', 'wrapper is a body element');
      this.assert.ok(!wrapper.parentNode, 'wrapper is detached');

      return wrapper;
    };

    return _class6;
  })(AbstractAppendTest));
});
enifed('ember-glimmer/tests/integration/components/append-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/components/append-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/components/append-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/components/attribute-bindings-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/helpers', 'ember-glimmer/tests/utils/abstract-test-case', 'ember-metal'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsHelpers, _emberGlimmerTestsUtilsAbstractTestCase, _emberMetal) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n      {{foo-bar hasFoo=true foo=foo hasBar=false bar=bar}}\n      {{foo-bar hasFoo=false foo=foo hasBar=true bar=bar}}\n      {{foo-bar hasFoo=true foo=foo hasBar=true bar=bar}}\n      {{foo-bar hasFoo=false foo=foo hasBar=false bar=bar}}\n    '], ['\n      {{foo-bar hasFoo=true foo=foo hasBar=false bar=bar}}\n      {{foo-bar hasFoo=false foo=foo hasBar=true bar=bar}}\n      {{foo-bar hasFoo=true foo=foo hasBar=true bar=bar}}\n      {{foo-bar hasFoo=false foo=foo hasBar=false bar=bar}}\n    ']);

  _emberGlimmerTestsUtilsTestCase.moduleFor('Attribute bindings integration', (function (_RenderingTest) {
babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test it can have attribute bindings'] = function testItCanHaveAttributeBindings() {
      var _this = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        attributeBindings: ['foo:data-foo', 'bar:data-bar']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar foo=foo bar=bar}}', { foo: 'foo', bar: 'bar' });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'data-foo': 'foo', 'data-bar': 'bar' }, content: 'hello' });

      this.runTask(function () {
        return _this.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'data-foo': 'foo', 'data-bar': 'bar' }, content: 'hello' });

      this.runTask(function () {
        _emberMetal.set(_this.context, 'foo', 'FOO');
        _emberMetal.set(_this.context, 'bar', undefined);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'data-foo': 'FOO' }, content: 'hello' });

      this.runTask(function () {
        _emberMetal.set(_this.context, 'foo', 'foo');
        _emberMetal.set(_this.context, 'bar', 'bar');
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'data-foo': 'foo', 'data-bar': 'bar' }, content: 'hello' });
    };

    _class.prototype['@test it can have attribute bindings with attrs'] = function testItCanHaveAttributeBindingsWithAttrs() {
      var _this2 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        attributeBindings: ['attrs.foo:data-foo', 'attrs.baz.bar:data-bar']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar foo=model.foo baz=model.baz}}', {
        model: { foo: undefined, baz: { bar: 'bar' } }
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'data-bar': 'bar' } });

      this.runTask(function () {
        return _this2.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'data-bar': 'bar' } });

      this.runTask(function () {
        _emberMetal.set(_this2.context, 'model.foo', 'foo');
        _emberMetal.set(_this2.context, 'model.baz.bar', undefined);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'data-foo': 'foo' }, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'model', {
          foo: undefined, baz: { bar: 'bar' }
        });
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'data-bar': 'bar' } });
    };

    _class.prototype['@test it can have attribute bindings with a nested path'] = function testItCanHaveAttributeBindingsWithANestedPath() {
      var _this3 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        attributeBindings: ['foo.bar:data-foo-bar']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar foo=foo}}', { foo: { bar: 'foo-bar' } });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'data-foo-bar': 'foo-bar' }, content: 'hello' });

      this.runTask(function () {
        return _this3.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'data-foo-bar': 'foo-bar' }, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'foo.bar', 'FOO-BAR');
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'data-foo-bar': 'FOO-BAR' }, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'foo.bar', undefined);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: {}, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'foo', undefined);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: {}, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'foo', { bar: 'foo-bar' });
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'data-foo-bar': 'foo-bar' }, content: 'hello' });
    };

    _class.prototype['@test handles non-microsyntax attributeBindings'] = function testHandlesNonMicrosyntaxAttributeBindings() {
      var _this4 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        attributeBindings: ['type']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar type=submit}}', {
        submit: 'submit'
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { type: 'submit' }, content: 'hello' });

      this.runTask(function () {
        return _this4.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { type: 'submit' }, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'submit', 'password');
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { type: 'password' }, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'submit', null);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: {}, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'submit', 'submit');
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { type: 'submit' }, content: 'hello' });
    };

    _class.prototype['@test non-microsyntax attributeBindings cannot contain nested paths'] = function testNonMicrosyntaxAttributeBindingsCannotContainNestedPaths() {
      var _this5 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        attributeBindings: ['foo.bar']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      expectAssertion(function () {
        _this5.render('{{foo-bar foo=foo}}', { foo: { bar: 'foo-bar' } });
      }, /Illegal attributeBinding: 'foo.bar' is not a valid attribute name./);
    };

    _class.prototype['@test normalizes attributeBindings for property names'] = function testNormalizesAttributeBindingsForPropertyNames() {
      var _this6 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        attributeBindings: ['tiTLe']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar tiTLe=name}}', {
        name: 'qux'
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { title: 'qux' }, content: 'hello' });

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this6.context, 'name', null);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: {}, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this6.context, 'name', 'qux');
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { title: 'qux' }, content: 'hello' });
    };

    _class.prototype['@test normalizes attributeBindings for attribute names'] = function testNormalizesAttributeBindingsForAttributeNames() {
      var _this7 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        attributeBindings: ['foo:data-FOO']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar foo=foo}}', {
        foo: 'qux'
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'data-foo': 'qux' }, content: 'hello' });

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'foo', null);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: {}, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'foo', 'qux');
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'data-foo': 'qux' }, content: 'hello' });
    };

    _class.prototype['@test attributeBindings handles null/undefined'] = function testAttributeBindingsHandlesNullUndefined() {
      var _this8 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        attributeBindings: ['fizz', 'bar']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar fizz=fizz bar=bar}}', {
        fizz: null,
        bar: undefined
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: {}, content: 'hello' });

      this.runTask(function () {
        return _this8.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: {}, content: 'hello' });

      this.runTask(function () {
        _emberMetal.set(_this8.context, 'fizz', 'fizz');
        _emberMetal.set(_this8.context, 'bar', 'bar');
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { fizz: 'fizz', bar: 'bar' }, content: 'hello' });

      this.runTask(function () {
        _emberMetal.set(_this8.context, 'fizz', null);
        _emberMetal.set(_this8.context, 'bar', undefined);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: {}, content: 'hello' });
    };

    _class.prototype['@test attributeBindings handles number value'] = function testAttributeBindingsHandlesNumberValue() {
      var _this9 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        attributeBindings: ['size']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar size=size}}', {
        size: 21
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { size: '21' }, content: 'hello' });

      this.runTask(function () {
        return _this9.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { size: '21' }, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this9.context, 'size', 0);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { size: '0' }, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this9.context, 'size', 21);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { size: '21' }, content: 'hello' });
    };

    _class.prototype['@test handles internal and external changes'] = function testHandlesInternalAndExternalChanges() {
      var _this10 = this;

      var component = undefined;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        attributeBindings: ['type'],
        type: 'password',
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar}}');

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { type: 'password' }, content: 'hello' });

      this.runTask(function () {
        return _this10.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { type: 'password' }, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(component, 'type', 'checkbox');
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { type: 'checkbox' }, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(component, 'type', 'password');
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { type: 'password' }, content: 'hello' });
    };

    _class.prototype['@test can set attributeBindings on component with a different tagName'] = function testCanSetAttributeBindingsOnComponentWithADifferentTagName() {
      var _this11 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: 'input',
        attributeBindings: ['type', 'isDisabled:disabled']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent });

      this.render('{{foo-bar type=type isDisabled=disabled}}', {
        type: 'password',
        disabled: false
      });

      this.assertComponentElement(this.firstChild, { tagName: 'input', attrs: { type: 'password' } });

      this.runTask(function () {
        return _this11.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'input', attrs: { type: 'password' } });

      this.runTask(function () {
        _emberMetal.set(_this11.context, 'type', 'checkbox');
        _emberMetal.set(_this11.context, 'disabled', true);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'input', attrs: { type: 'checkbox', disabled: '' } });

      this.runTask(function () {
        _emberMetal.set(_this11.context, 'type', 'password');
        _emberMetal.set(_this11.context, 'disabled', false);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'input', attrs: { type: 'password' } });
    };

    _class.prototype['@test should allow namespaced attributes in micro syntax'] = function testShouldAllowNamespacedAttributesInMicroSyntax() {
      var _this12 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        attributeBindings: ['xlinkHref:xlink:href']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent });

      this.render('{{foo-bar type=type xlinkHref=xlinkHref}}', {
        xlinkHref: '/foo.png'
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'xlink:href': '/foo.png' } });

      this.runTask(function () {
        return _this12.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'xlink:href': '/foo.png' } });

      this.runTask(function () {
        return _emberMetal.set(_this12.context, 'xlinkHref', '/lol.png');
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'xlink:href': '/lol.png' } });

      this.runTask(function () {
        return _emberMetal.set(_this12.context, 'xlinkHref', '/foo.png');
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'xlink:href': '/foo.png' } });
    };

    // This comes into play when using the {{#each}} helper. If the
    // passed array item is a String, it will be converted into a
    // String object instead of a normal string.

    _class.prototype['@test should allow for String objects'] = function testShouldAllowForStringObjects() {
      var _this13 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        attributeBindings: ['foo']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent });

      this.render('{{foo-bar foo=foo}}', {
        foo: (function () {
          return this;
        }).call('bar')
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'foo': 'bar' } });

      this.runTask(function () {
        return _this13.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'foo': 'bar' } });

      this.runTask(function () {
        return _emberMetal.set(_this13.context, 'foo', (function () {
          return this;
        }).call('baz'));
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'foo': 'baz' } });

      this.runTask(function () {
        return _emberMetal.set(_this13.context, 'foo', (function () {
          return this;
        }).call('bar'));
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'foo': 'bar' } });
    };

    _class.prototype['@test can set id initially via attributeBindings '] = function testCanSetIdInitiallyViaAttributeBindings() {
      var _this14 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        attributeBindings: ['specialSauce:id']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent });

      this.render('{{foo-bar specialSauce=sauce}}', {
        sauce: 'special-sauce'
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'id': 'special-sauce' } });

      this.runTask(function () {
        return _this14.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'id': 'special-sauce' } });

      this.runTask(function () {
        return _emberMetal.set(_this14.context, 'sauce', 'foo');
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'id': 'special-sauce' } });

      this.runTask(function () {
        return _emberMetal.set(_this14.context, 'sauce', 'special-sauce');
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'id': 'special-sauce' } });
    };

    _class.prototype['@test attributeBindings are overwritten'] = function testAttributeBindingsAreOverwritten() {
      var _this15 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        attributeBindings: ['href'],
        href: 'a href'
      });

      var FizzBarComponent = FooBarComponent.extend({
        attributeBindings: ['newHref:href']
      });

      this.registerComponent('fizz-bar', { ComponentClass: FizzBarComponent });

      this.render('{{fizz-bar newHref=href}}', {
        href: 'dog.html'
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { href: 'dog.html' } });

      this.runTask(function () {
        return _this15.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { href: 'dog.html' } });

      this.runTask(function () {
        return _emberMetal.set(_this15.context, 'href', 'cat.html');
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { href: 'cat.html' } });
    };

    _class.prototype['@test it can set attribute bindings in the constructor'] = function testItCanSetAttributeBindingsInTheConstructor() {
      var _this16 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super();

          var bindings = [];

          if (this.get('hasFoo')) {
            bindings.push('foo:data-foo');
          }

          if (this.get('hasBar')) {
            bindings.push('bar:data-bar');
          }

          this.attributeBindings = bindings;
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject), { foo: 'foo', bar: 'bar' });

      this.assertComponentElement(this.nthChild(0), { tagName: 'div', attrs: { 'data-foo': 'foo' }, content: 'hello' });
      this.assertComponentElement(this.nthChild(1), { tagName: 'div', attrs: { 'data-bar': 'bar' }, content: 'hello' });
      this.assertComponentElement(this.nthChild(2), { tagName: 'div', attrs: { 'data-foo': 'foo', 'data-bar': 'bar' }, content: 'hello' });
      this.assertComponentElement(this.nthChild(3), { tagName: 'div', attrs: {}, content: 'hello' });

      this.runTask(function () {
        return _this16.rerender();
      });

      this.assertComponentElement(this.nthChild(0), { tagName: 'div', attrs: { 'data-foo': 'foo' }, content: 'hello' });
      this.assertComponentElement(this.nthChild(1), { tagName: 'div', attrs: { 'data-bar': 'bar' }, content: 'hello' });
      this.assertComponentElement(this.nthChild(2), { tagName: 'div', attrs: { 'data-foo': 'foo', 'data-bar': 'bar' }, content: 'hello' });
      this.assertComponentElement(this.nthChild(3), { tagName: 'div', attrs: {}, content: 'hello' });

      this.runTask(function () {
        _emberMetal.set(_this16.context, 'foo', 'FOO');
        _emberMetal.set(_this16.context, 'bar', undefined);
      });

      this.assertComponentElement(this.nthChild(0), { tagName: 'div', attrs: { 'data-foo': 'FOO' }, content: 'hello' });
      this.assertComponentElement(this.nthChild(1), { tagName: 'div', attrs: {}, content: 'hello' });
      this.assertComponentElement(this.nthChild(2), { tagName: 'div', attrs: { 'data-foo': 'FOO' }, content: 'hello' });
      this.assertComponentElement(this.nthChild(3), { tagName: 'div', attrs: {}, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this16.context, 'bar', 'BAR');
      });

      this.assertComponentElement(this.nthChild(0), { tagName: 'div', attrs: { 'data-foo': 'FOO' }, content: 'hello' });
      this.assertComponentElement(this.nthChild(1), { tagName: 'div', attrs: { 'data-bar': 'BAR' }, content: 'hello' });
      this.assertComponentElement(this.nthChild(2), { tagName: 'div', attrs: { 'data-foo': 'FOO', 'data-bar': 'BAR' }, content: 'hello' });
      this.assertComponentElement(this.nthChild(3), { tagName: 'div', attrs: {}, content: 'hello' });

      this.runTask(function () {
        _emberMetal.set(_this16.context, 'foo', 'foo');
        _emberMetal.set(_this16.context, 'bar', 'bar');
      });

      this.assertComponentElement(this.nthChild(0), { tagName: 'div', attrs: { 'data-foo': 'foo' }, content: 'hello' });
      this.assertComponentElement(this.nthChild(1), { tagName: 'div', attrs: { 'data-bar': 'bar' }, content: 'hello' });
      this.assertComponentElement(this.nthChild(2), { tagName: 'div', attrs: { 'data-foo': 'foo', 'data-bar': 'bar' }, content: 'hello' });
      this.assertComponentElement(this.nthChild(3), { tagName: 'div', attrs: {}, content: 'hello' });
    };

    _class.prototype['@test it should not allow attributeBindings to be set'] = function testItShouldNotAllowAttributeBindingsToBeSet() {
      var _this17 = this;

      this.registerComponent('foo-bar', { template: 'hello' });

      expectAssertion(function () {
        _this17.render('{{foo-bar attributeBindings="one two"}}');
      }, /Setting 'attributeBindings' via template helpers is not allowed/);
    };

    _class.prototype['@test asserts if an attributeBinding is setup on class'] = function testAssertsIfAnAttributeBindingIsSetupOnClass() {
      var _this18 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        attributeBindings: ['class']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      expectAssertion(function () {
        _this18.render('{{foo-bar}}');
      }, /You cannot use class as an attributeBinding, use classNameBindings instead./i);
    };

    _class.prototype['@test blacklists href bindings based on protocol'] = function testBlacklistsHrefBindingsBasedOnProtocol() {
      /* jshint scripturl:true */

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: 'a',
        attributeBindings: ['href']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar href=xss}}', {
        xss: 'javascript:alert(\'foo\')'
      });

      this.assertComponentElement(this.firstChild, { tagName: 'a', attrs: { href: 'unsafe:javascript:alert(\'foo\')' } });
    };

    _class.prototype['@test it can bind the role attribute (issue #14007)'] = function testItCanBindTheRoleAttributeIssue14007() {
      var _this19 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({ attributeBindings: ['role'] });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar role=role}}', { role: 'button' });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { role: 'button' } });

      this.runTask(function () {
        return _this19.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { role: 'button' } });

      this.runTask(function () {
        return _emberMetal.set(_this19.context, 'role', 'combobox');
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { role: 'combobox' } });

      this.runTask(function () {
        return _emberMetal.set(_this19.context, 'role', null);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div' });
    };

    _class.prototype['@test component with an `id` attribute binding of undefined'] = function testComponentWithAnIdAttributeBindingOfUndefined() {
      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          attributeBindings: ['id'],

          id: undefined
        })
      });

      this.registerComponent('baz-qux', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          attributeBindings: ['somethingUndefined:id'],

          somethingUndefined: undefined
        })
      });
      this.render('{{foo-bar}}{{baz-qux}}');

      this.assertComponentElement(this.nthChild(0), { content: '' });
      this.assertComponentElement(this.nthChild(1), { content: '' });

      this.assert.ok(this.nthChild(0).id.match(/ember\d+/), 'a valid `id` was used');
      this.assert.ok(this.nthChild(1).id.match(/ember\d+/), 'a valid `id` was used');
    };

    _class.prototype['@test component with an `id` attribute binding of null'] = function testComponentWithAnIdAttributeBindingOfNull() {
      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          attributeBindings: ['id'],

          id: null
        })
      });

      this.registerComponent('baz-qux', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          attributeBindings: ['somethingNull:id'],

          somethingNull: null
        })
      });
      this.render('{{foo-bar}}{{baz-qux}}');

      this.assertComponentElement(this.nthChild(0), { content: '' });
      this.assertComponentElement(this.nthChild(1), { content: '' });

      this.assert.ok(this.nthChild(0).id.match(/ember\d+/), 'a valid `id` was used');
      this.assert.ok(this.nthChild(1).id.match(/ember\d+/), 'a valid `id` was used');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/components/attribute-bindings-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/components/attribute-bindings-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/components/attribute-bindings-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/components/attrs-lookup-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/helpers', 'ember-metal', 'ember-glimmer/tests/utils/test-helpers'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsHelpers, _emberMetal, _emberGlimmerTestsUtilsTestHelpers) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Components test: attrs lookup', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test it should be able to lookup attrs without `attrs.` - template access'] = function testItShouldBeAbleToLookupAttrsWithoutAttrsTemplateAccess() {
      var _this = this;

      this.registerComponent('foo-bar', { template: '{{first}}' });

      this.render('{{foo-bar first=firstAttr}}', {
        firstAttr: 'first attr'
      });

      this.assertText('first attr');

      this.runTask(function () {
        return _this.rerender();
      });

      this.assertText('first attr');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'firstAttr', 'second attr');
      });

      this.assertText('second attr');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'firstAttr', 'first attr');
      });

      this.assertText('first attr');
    };

    _class.prototype['@test it should be able to lookup attrs without `attrs.` - component access'] = function testItShouldBeAbleToLookupAttrsWithoutAttrsComponentAccess(assert) {
      var _this2 = this;

      var instance = undefined;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          instance = this;
        }
      });
      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: '{{first}}' });

      this.render('{{foo-bar first=firstAttr}}', {
        firstAttr: 'first attr'
      });

      assert.equal(instance.get('first'), 'first attr');

      this.runTask(function () {
        return _this2.rerender();
      });

      assert.equal(instance.get('first'), 'first attr');

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'firstAttr', 'second attr');
      });

      assert.equal(instance.get('first'), 'second attr');

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'firstAttr', 'first attr');
      });

      this.assertText('first attr');
    };

    _class.prototype['@test should be able to modify a provided attr into local state #11571 / #11559'] = function testShouldBeAbleToModifyAProvidedAttrIntoLocalState1157111559(assert) {
      var _this3 = this;

      var instance = undefined;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          instance = this;
        },

        didReceiveAttrs: function () {
          this.set('first', this.get('first').toUpperCase());
        }
      });
      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: '{{first}}' });

      this.render('{{foo-bar first="first attr"}}');

      assert.equal(instance.get('first'), 'FIRST ATTR', 'component lookup uses local state');
      this.assertText('FIRST ATTR');

      this.runTask(function () {
        return _this3.rerender();
      });

      assert.equal(instance.get('first'), 'FIRST ATTR', 'component lookup uses local state during rerender');
      this.assertText('FIRST ATTR');

      // This is testing that passing string literals for use as initial values,
      // so there is no update step
    };

    _class.prototype['@test should be able to access unspecified attr #12035'] = function testShouldBeAbleToAccessUnspecifiedAttr12035(assert) {
      var _this4 = this;

      var instance = undefined;
      var wootVal = 'yes';

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          instance = this;
        },

        didReceiveAttrs: function () {
          assert.equal(this.get('woot'), wootVal, 'found attr in didReceiveAttrs');
        }
      });
      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent });

      this.render('{{foo-bar woot=woot}}', {
        woot: wootVal
      });

      assert.equal(instance.get('woot'), 'yes', 'component found attr');

      this.runTask(function () {
        return _this4.rerender();
      });

      assert.equal(instance.get('woot'), 'yes', 'component found attr after rerender');

      this.runTask(function () {
        wootVal = 'nope';
        _emberMetal.set(_this4.context, 'woot', wootVal);
      });

      assert.equal(instance.get('woot'), 'nope', 'component found attr after attr change');

      this.runTask(function () {
        wootVal = 'yes';
        _emberMetal.set(_this4.context, 'woot', wootVal);
      });

      assert.equal(instance.get('woot'), 'yes', 'component found attr after reset');
    };

    _class.prototype['@test getAttr() should return the same value as get()'] = function testGetAttrShouldReturnTheSameValueAsGet(assert) {
      var _this5 = this;

      assert.expect(33);

      var instance = undefined;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          instance = this;
        },

        didReceiveAttrs: function () {
          var rootFirstPositional = this.get('firstPositional');
          var rootFirst = this.get('first');
          var rootSecond = this.get('second');
          var attrFirstPositional = this.getAttr('firstPositional');
          var attrFirst = this.getAttr('first');
          var attrSecond = this.getAttr('second');

          equal(rootFirstPositional, attrFirstPositional, 'root property matches attrs value');
          equal(rootFirst, attrFirst, 'root property matches attrs value');
          equal(rootSecond, attrSecond, 'root property matches attrs value');
        }
      });

      FooBarComponent.reopenClass({
        positionalParams: ['firstPositional']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent });

      this.render('{{foo-bar firstPositional first=first second=second}}', {
        firstPositional: 'firstPositional',
        first: 'first',
        second: 'second'
      });

      assert.equal(instance.get('firstPositional'), 'firstPositional', 'matches known value');
      assert.equal(instance.get('first'), 'first', 'matches known value');
      assert.equal(instance.get('second'), 'second', 'matches known value');

      this.runTask(function () {
        return _this5.rerender();
      });

      assert.equal(instance.get('firstPositional'), 'firstPositional', 'matches known value');
      assert.equal(instance.get('first'), 'first', 'matches known value');
      assert.equal(instance.get('second'), 'second', 'matches known value');

      this.runTask(function () {
        _emberMetal.set(_this5.context, 'first', 'third');
      });

      assert.equal(instance.get('firstPositional'), 'firstPositional', 'matches known value');
      assert.equal(instance.get('first'), 'third', 'matches known value');
      assert.equal(instance.get('second'), 'second', 'matches known value');

      this.runTask(function () {
        _emberMetal.set(_this5.context, 'second', 'fourth');
      });

      assert.equal(instance.get('firstPositional'), 'firstPositional', 'matches known value');
      assert.equal(instance.get('first'), 'third', 'matches known value');
      assert.equal(instance.get('second'), 'fourth', 'matches known value');

      this.runTask(function () {
        _emberMetal.set(_this5.context, 'firstPositional', 'fifth');
      });

      assert.equal(instance.get('firstPositional'), 'fifth', 'matches known value');
      assert.equal(instance.get('first'), 'third', 'matches known value');
      assert.equal(instance.get('second'), 'fourth', 'matches known value');

      this.runTask(function () {
        _emberMetal.set(_this5.context, 'firstPositional', 'firstPositional');
        _emberMetal.set(_this5.context, 'first', 'first');
        _emberMetal.set(_this5.context, 'second', 'second');
      });

      assert.equal(instance.get('firstPositional'), 'firstPositional', 'matches known value');
      assert.equal(instance.get('first'), 'first', 'matches known value');
      assert.equal(instance.get('second'), 'second', 'matches known value');
    };

    _class.prototype['@test bound computed properties can be overriden in extensions, set during init, and passed in as attrs'] = function testBoundComputedPropertiesCanBeOverridenInExtensionsSetDuringInitAndPassedInAsAttrs() {
      var FooClass = _emberGlimmerTestsUtilsHelpers.Component.extend({
        attributeBindings: ['style'],
        style: _emberMetal.computed('height', 'color', function () {
          var height = this.get('height');
          var color = this.get('color');
          return 'height: ' + height + 'px; background-color: ' + color + ';';
        }),
        color: 'red',
        height: 20
      });

      var BarClass = FooClass.extend({
        init: function () {
          this._super.apply(this, arguments);
          this.height = 150;
        },
        color: 'yellow'
      });

      this.registerComponent('x-foo', { ComponentClass: FooClass });
      this.registerComponent('x-bar', { ComponentClass: BarClass });

      this.render('{{x-foo}}{{x-bar}}{{x-bar color="green"}}');

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { style: _emberGlimmerTestsUtilsTestHelpers.styles('height: 20px; background-color: red;') } });
      this.assertComponentElement(this.nthChild(1), { tagName: 'div', attrs: { style: _emberGlimmerTestsUtilsTestHelpers.styles('height: 150px; background-color: yellow;') } });
      this.assertComponentElement(this.nthChild(2), { tagName: 'div', attrs: { style: _emberGlimmerTestsUtilsTestHelpers.styles('height: 150px; background-color: green;') } });

      this.assertStableRerender();

      // No U-R
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/components/attrs-lookup-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/components/attrs-lookup-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/components/attrs-lookup-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/components/class-bindings-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/helpers', 'ember-glimmer/tests/utils/test-helpers', 'ember-metal', 'ember-glimmer/tests/utils/abstract-test-case'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsHelpers, _emberGlimmerTestsUtilsTestHelpers, _emberMetal, _emberGlimmerTestsUtilsAbstractTestCase) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n      {{foo-bar foo=foo bindIsEnabled=true isEnabled=isEnabled bindIsHappy=false isHappy=isHappy}}\n      {{foo-bar foo=foo bindIsEnabled=false isEnabled=isEnabled bindIsHappy=true isHappy=isHappy}}\n      {{foo-bar foo=foo bindIsEnabled=true isEnabled=isEnabled bindIsHappy=true isHappy=isHappy}}\n      {{foo-bar foo=foo bindIsEnabled=false isEnabled=isEnabled bindIsHappy=false isHappy=isHappy}}\n    '], ['\n      {{foo-bar foo=foo bindIsEnabled=true isEnabled=isEnabled bindIsHappy=false isHappy=isHappy}}\n      {{foo-bar foo=foo bindIsEnabled=false isEnabled=isEnabled bindIsHappy=true isHappy=isHappy}}\n      {{foo-bar foo=foo bindIsEnabled=true isEnabled=isEnabled bindIsHappy=true isHappy=isHappy}}\n      {{foo-bar foo=foo bindIsEnabled=false isEnabled=isEnabled bindIsHappy=false isHappy=isHappy}}\n    ']);

  _emberGlimmerTestsUtilsTestCase.moduleFor('ClassNameBindings integration', (function (_RenderingTest) {
babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test it can have class name bindings on the class definition'] = function testItCanHaveClassNameBindingsOnTheClassDefinition() {
      var _this = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        classNameBindings: ['foo', 'isEnabled:enabled', 'isHappy:happy:sad']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar foo=foo isEnabled=isEnabled isHappy=isHappy}}', { foo: 'foo', isEnabled: true, isHappy: false });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo enabled sad') }, content: 'hello' });

      this.runTask(function () {
        return _this.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo enabled sad') }, content: 'hello' });

      this.runTask(function () {
        _emberMetal.set(_this.context, 'foo', 'FOO');
        _emberMetal.set(_this.context, 'isEnabled', false);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view FOO sad') }, content: 'hello' });

      this.runTask(function () {
        _emberMetal.set(_this.context, 'foo', undefined);
        _emberMetal.set(_this.context, 'isHappy', true);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view happy') }, content: 'hello' });

      this.runTask(function () {
        _emberMetal.set(_this.context, 'foo', 'foo');
        _emberMetal.set(_this.context, 'isEnabled', true);
        _emberMetal.set(_this.context, 'isHappy', false);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo enabled sad') }, content: 'hello' });
    };

    _class.prototype['@test attrs in classNameBindings'] = function testAttrsInClassNameBindings() {
      var _this2 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        classNameBindings: ['attrs.joker:purple:green', 'attrs.batman.robin:black:red']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar joker=model.wat batman=model.super}}', {
        model: { wat: false, super: { robin: true } }
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view green black') }, content: 'hello' });

      this.runTask(function () {
        return _this2.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view green black') }, content: 'hello' });

      this.runTask(function () {
        _emberMetal.set(_this2.context, 'model.wat', true);
        _emberMetal.set(_this2.context, 'model.super.robin', false);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view purple red') }, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'model', {
          wat: false, super: { robin: true }
        });
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view green black') }, content: 'hello' });
    };

    _class.prototype['@test it can have class name bindings in the template'] = function testItCanHaveClassNameBindingsInTheTemplate() {
      var _this3 = this;

      this.registerComponent('foo-bar', { template: 'hello' });

      this.render('{{foo-bar classNameBindings="model.someInitiallyTrueProperty model.someInitiallyFalseProperty model.someInitiallyUndefinedProperty :static model.isBig:big model.isOpen:open:closed model.isUp::down model.bar:isTruthy:isFalsy"}}', {
        model: {
          someInitiallyTrueProperty: true,
          someInitiallyFalseProperty: false,
          isBig: true,
          isOpen: false,
          isUp: true,
          bar: true
        }
      });

      this.assertComponentElement(this.firstChild, {
        attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view some-initially-true-property static big closed isTruthy') },
        content: 'hello'
      });

      this.runTask(function () {
        return _this3.rerender();
      });

      this.assertComponentElement(this.firstChild, {
        attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view some-initially-true-property static big closed isTruthy') },
        content: 'hello'
      });

      this.runTask(function () {
        _emberMetal.set(_this3.context, 'model.someInitiallyTrueProperty', false);
        _emberMetal.set(_this3.context, 'model.someInitiallyFalseProperty', true);
        _emberMetal.set(_this3.context, 'model.someInitiallyUndefinedProperty', true);
        _emberMetal.set(_this3.context, 'model.isBig', false);
        _emberMetal.set(_this3.context, 'model.isOpen', true);
        _emberMetal.set(_this3.context, 'model.isUp', false);
        _emberMetal.set(_this3.context, 'model.bar', false);
      });

      this.assertComponentElement(this.firstChild, {
        attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view some-initially-false-property some-initially-undefined-property static open down isFalsy') },
        content: 'hello'
      });

      this.runTask(function () {
        _emberMetal.set(_this3.context, 'model', {
          someInitiallyTrueProperty: true,
          someInitiallyFalseProperty: false,
          someInitiallyUndefinedProperty: undefined,
          isBig: true,
          isOpen: false,
          isUp: true,
          bar: true
        });
      });

      this.assertComponentElement(this.firstChild, {
        attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view some-initially-true-property static big closed isTruthy') },
        content: 'hello'
      });
    };

    _class.prototype['@test it can have class name bindings with nested paths'] = function testItCanHaveClassNameBindingsWithNestedPaths() {
      var _this4 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        classNameBindings: ['foo.bar', 'is.enabled:enabled', 'is.happy:happy:sad']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar foo=foo is=is}}', { foo: { bar: 'foo-bar' }, is: { enabled: true, happy: false } });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo-bar enabled sad') }, content: 'hello' });

      this.runTask(function () {
        return _this4.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo-bar enabled sad') }, content: 'hello' });

      this.runTask(function () {
        _emberMetal.set(_this4.context, 'foo.bar', 'FOO-BAR');
        _emberMetal.set(_this4.context, 'is.enabled', false);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view FOO-BAR sad') }, content: 'hello' });

      this.runTask(function () {
        _emberMetal.set(_this4.context, 'foo.bar', null);
        _emberMetal.set(_this4.context, 'is.happy', true);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view happy') }, content: 'hello' });

      this.runTask(function () {
        _emberMetal.set(_this4.context, 'foo', null);
        _emberMetal.set(_this4.context, 'is', null);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view sad') }, content: 'hello' });

      this.runTask(function () {
        _emberMetal.set(_this4.context, 'foo', { bar: 'foo-bar' });
        _emberMetal.set(_this4.context, 'is', { enabled: true, happy: false });
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo-bar enabled sad') }, content: 'hello' });
    };

    _class.prototype['@test it should dasherize the path when the it resolves to true'] = function testItShouldDasherizeThePathWhenTheItResolvesToTrue() {
      var _this5 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        classNameBindings: ['fooBar', 'nested.fooBarBaz']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar fooBar=fooBar nested=nested}}', { fooBar: true, nested: { fooBarBaz: false } });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo-bar') }, content: 'hello' });

      this.runTask(function () {
        return _this5.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo-bar') }, content: 'hello' });

      this.runTask(function () {
        _emberMetal.set(_this5.context, 'fooBar', false);
        _emberMetal.set(_this5.context, 'nested.fooBarBaz', true);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo-bar-baz') }, content: 'hello' });

      this.runTask(function () {
        _emberMetal.set(_this5.context, 'fooBar', 'FOO-BAR');
        _emberMetal.set(_this5.context, 'nested.fooBarBaz', null);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view FOO-BAR') }, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'nested', null);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view FOO-BAR') }, content: 'hello' });

      this.runTask(function () {
        _emberMetal.set(_this5.context, 'fooBar', true);
        _emberMetal.set(_this5.context, 'nested', { fooBarBaz: false });
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo-bar') }, content: 'hello' });
    };

    _class.prototype['@test const bindings can be set as attrs'] = function testConstBindingsCanBeSetAsAttrs() {
      var _this6 = this;

      this.registerComponent('foo-bar', { template: 'hello' });
      this.render('{{foo-bar classNameBindings="foo:enabled:disabled"}}', {
        foo: true
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view enabled') }, content: 'hello' });

      this.runTask(function () {
        return _this6.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view enabled') }, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this6.context, 'foo', false);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view disabled') }, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this6.context, 'foo', true);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view enabled') }, content: 'hello' });
    };

    _class.prototype['@test :: class name syntax works with an empty true class'] = function testClassNameSyntaxWorksWithAnEmptyTrueClass() {
      var _this7 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        classNameBindings: ['isEnabled::not-enabled']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar isEnabled=enabled}}', {
        enabled: false
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view not-enabled') }, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'enabled', true);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view') }, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'enabled', false);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view not-enabled') }, content: 'hello' });
    };

    _class.prototype['@test uses all provided static class names (issue #11193)'] = function testUsesAllProvidedStaticClassNamesIssue11193() {
      var _this8 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        classNameBindings: [':class-one', ':class-two']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar}}', {
        enabled: false
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view class-one class-two') }, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this8.context, 'enabled', true);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view class-one class-two') }, content: 'hello' });
    };

    _class.prototype['@test Providing a binding with a space in it asserts'] = function testProvidingABindingWithASpaceInItAsserts() {
      var _this9 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        classNameBindings: 'i:think:i am:so:clever'
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      expectAssertion(function () {
        _this9.render('{{foo-bar}}');
      }, /classNameBindings must not have spaces in them/i);
    };

    _class.prototype['@test it can set class name bindings in the constructor'] = function testItCanSetClassNameBindingsInTheConstructor() {
      var _this10 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        classNameBindings: ['foo'],

        init: function () {
          this._super();

          var bindings = this.classNameBindings = this.classNameBindings.slice();

          if (this.get('bindIsEnabled')) {
            bindings.push('isEnabled:enabled');
          }

          if (this.get('bindIsHappy')) {
            bindings.push('isHappy:happy:sad');
          }
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject), { foo: 'foo', isEnabled: true, isHappy: false });

      this.assertComponentElement(this.nthChild(0), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo enabled') }, content: 'hello' });
      this.assertComponentElement(this.nthChild(1), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo sad') }, content: 'hello' });
      this.assertComponentElement(this.nthChild(2), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo enabled sad') }, content: 'hello' });
      this.assertComponentElement(this.nthChild(3), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo') }, content: 'hello' });

      this.runTask(function () {
        return _this10.rerender();
      });

      this.assertComponentElement(this.nthChild(0), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo enabled') }, content: 'hello' });
      this.assertComponentElement(this.nthChild(1), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo sad') }, content: 'hello' });
      this.assertComponentElement(this.nthChild(2), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo enabled sad') }, content: 'hello' });
      this.assertComponentElement(this.nthChild(3), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo') }, content: 'hello' });

      this.runTask(function () {
        _emberMetal.set(_this10.context, 'foo', 'FOO');
        _emberMetal.set(_this10.context, 'isEnabled', false);
      });

      this.assertComponentElement(this.nthChild(0), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view FOO') }, content: 'hello' });
      this.assertComponentElement(this.nthChild(1), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view FOO sad') }, content: 'hello' });
      this.assertComponentElement(this.nthChild(2), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view FOO sad') }, content: 'hello' });
      this.assertComponentElement(this.nthChild(3), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view FOO') }, content: 'hello' });

      this.runTask(function () {
        _emberMetal.set(_this10.context, 'foo', undefined);
        _emberMetal.set(_this10.context, 'isHappy', true);
      });

      this.assertComponentElement(this.nthChild(0), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view') }, content: 'hello' });
      this.assertComponentElement(this.nthChild(1), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view happy') }, content: 'hello' });
      this.assertComponentElement(this.nthChild(2), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view happy') }, content: 'hello' });
      this.assertComponentElement(this.nthChild(3), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view') }, content: 'hello' });

      this.runTask(function () {
        _emberMetal.set(_this10.context, 'foo', 'foo');
        _emberMetal.set(_this10.context, 'isEnabled', true);
        _emberMetal.set(_this10.context, 'isHappy', false);
      });

      this.assertComponentElement(this.nthChild(0), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo enabled') }, content: 'hello' });
      this.assertComponentElement(this.nthChild(1), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo sad') }, content: 'hello' });
      this.assertComponentElement(this.nthChild(2), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo enabled sad') }, content: 'hello' });
      this.assertComponentElement(this.nthChild(3), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo') }, content: 'hello' });
    };

    _class.prototype['@test using a computed property for classNameBindings triggers an assertion'] = function testUsingAComputedPropertyForClassNameBindingsTriggersAnAssertion() {
      var _this11 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        classNameBindings: _emberMetal.computed(function () {
          return ['isHappy:happy:sad'];
        })
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      expectAssertion(function () {
        _this11.render('{{foo-bar}}');
      }, /Only arrays are allowed/);
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('ClassBinding integration', (function (_RenderingTest2) {
babelHelpers.inherits(_class2, _RenderingTest2);

    function _class2() {
      _RenderingTest2.apply(this, arguments);
    }

    _class2.prototype['@test it should apply classBinding without condition always'] = function testItShouldApplyClassBindingWithoutConditionAlways() {
      var _this12 = this;

      this.registerComponent('foo-bar', { template: 'hello' });

      this.render('{{foo-bar classBinding=":foo"}}');

      this.assertComponentElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo  ember-view') } });

      this.runTask(function () {
        return _this12.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo  ember-view') } });
    };

    _class2.prototype['@test it should merge classBinding with class'] = function testItShouldMergeClassBindingWithClass() {
      var _this13 = this;

      this.registerComponent('foo-bar', { template: 'hello' });

      this.render('{{foo-bar classBinding="birdman:respeck" class="myName"}}', { birdman: true });

      this.assertComponentElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('respeck myName ember-view') } });

      this.runTask(function () {
        return _this13.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('respeck myName ember-view') } });
    };

    _class2.prototype['@test it should apply classBinding with only truthy condition'] = function testItShouldApplyClassBindingWithOnlyTruthyCondition() {
      var _this14 = this;

      this.registerComponent('foo-bar', { template: 'hello' });

      this.render('{{foo-bar classBinding="myName:respeck"}}', { myName: true });

      this.assertComponentElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('respeck  ember-view') } });

      this.runTask(function () {
        return _this14.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('respeck  ember-view') } });
    };

    _class2.prototype['@test it should apply classBinding with only falsy condition'] = function testItShouldApplyClassBindingWithOnlyFalsyCondition() {
      var _this15 = this;

      this.registerComponent('foo-bar', { template: 'hello' });

      this.render('{{foo-bar classBinding="myName::shade"}}', { myName: false });

      this.assertComponentElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('shade  ember-view') } });

      this.runTask(function () {
        return _this15.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('shade  ember-view') } });
    };

    _class2.prototype['@test it should apply nothing when classBinding is falsy but only supplies truthy class'] = function testItShouldApplyNothingWhenClassBindingIsFalsyButOnlySuppliesTruthyClass() {
      var _this16 = this;

      this.registerComponent('foo-bar', { template: 'hello' });

      this.render('{{foo-bar classBinding="myName:respeck"}}', { myName: false });

      this.assertComponentElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view') } });

      this.runTask(function () {
        return _this16.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view') } });
    };

    _class2.prototype['@test it should apply nothing when classBinding is truthy but only supplies falsy class'] = function testItShouldApplyNothingWhenClassBindingIsTruthyButOnlySuppliesFalsyClass() {
      var _this17 = this;

      this.registerComponent('foo-bar', { template: 'hello' });

      this.render('{{foo-bar classBinding="myName::shade"}}', { myName: true });

      this.assertComponentElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view') } });

      this.runTask(function () {
        return _this17.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view') } });
    };

    _class2.prototype['@test it should apply classBinding with falsy condition'] = function testItShouldApplyClassBindingWithFalsyCondition() {
      var _this18 = this;

      this.registerComponent('foo-bar', { template: 'hello' });

      this.render('{{foo-bar classBinding="swag:fresh:scrub"}}', { swag: false });

      this.assertComponentElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('scrub  ember-view') } });

      this.runTask(function () {
        return _this18.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('scrub  ember-view') } });
    };

    _class2.prototype['@test it should apply classBinding with truthy condition'] = function testItShouldApplyClassBindingWithTruthyCondition() {
      var _this19 = this;

      this.registerComponent('foo-bar', { template: 'hello' });

      this.render('{{foo-bar classBinding="swag:fresh:scrub"}}', { swag: true });

      this.assertComponentElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('fresh  ember-view') } });

      this.runTask(function () {
        return _this19.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('fresh  ember-view') } });
    };

    return _class2;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/components/class-bindings-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/components/class-bindings-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/components/class-bindings-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/components/contextual-components-test', ['exports', 'ember-utils', 'ember-glimmer/tests/utils/helpers', 'ember-glimmer/tests/utils/abstract-test-case', 'ember-glimmer/tests/utils/test-case', 'ember-metal', 'ember-runtime/system/native_array'], function (exports, _emberUtils, _emberGlimmerTestsUtilsHelpers, _emberGlimmerTestsUtilsAbstractTestCase, _emberGlimmerTestsUtilsTestCase, _emberMetal, _emberRuntimeSystemNative_array) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n      {{component (component "-looked-up") "Hodari" greeting="Hodi"}}'], ['\n      {{component (component "-looked-up") "Hodari" greeting="Hodi"}}']),
      _templateObject2 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{component (component "-looked-up" "Hodari" greeting="Hodi")\n                  greeting="Hola"}}'], ['\n      {{component (component "-looked-up" "Hodari" greeting="Hodi")\n                  greeting="Hola"}}']),
      _templateObject3 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#with (hash comp=(component "-looked-up" greeting=model.greeting)) as |my|}}\n        {{#my.comp}}{{/my.comp}}\n      {{/with}}'], ['\n      {{#with (hash comp=(component "-looked-up" greeting=model.greeting)) as |my|}}\n        {{#my.comp}}{{/my.comp}}\n      {{/with}}']),
      _templateObject4 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#with (component "-looked-up" greeting="Hola" name="Dolores" age=33) as |first|}}\n        {{#with (component first greeting="Hej" name="Sigmundur") as |second|}}\n          {{component second greeting=model.greeting}}\n        {{/with}}\n      {{/with}}'], ['\n      {{#with (component "-looked-up" greeting="Hola" name="Dolores" age=33) as |first|}}\n        {{#with (component first greeting="Hej" name="Sigmundur") as |second|}}\n          {{component second greeting=model.greeting}}\n        {{/with}}\n      {{/with}}']),
      _templateObject5 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#with (hash lookedup=(component "-looked-up")) as |object|}}\n        {{object.lookedup}}\n      {{/with}}'], ['\n      {{#with (hash lookedup=(component "-looked-up")) as |object|}}\n        {{object.lookedup}}\n      {{/with}}']),
      _templateObject6 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#with (hash lookedup=(component "-looked-up")) as |object|}}\n        {{object.lookedup expectedText=model.expectedText}}\n      {{/with}}'], ['\n      {{#with (hash lookedup=(component "-looked-up")) as |object|}}\n        {{object.lookedup expectedText=model.expectedText}}\n      {{/with}}']),
      _templateObject7 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#with (hash lookedup=(component "-looked-up" expectedText=model.expectedText)) as |object|}}\n        {{object.lookedup}}\n      {{/with}}'], ['\n      {{#with (hash lookedup=(component "-looked-up" expectedText=model.expectedText)) as |object|}}\n        {{object.lookedup}}\n      {{/with}}']),
      _templateObject8 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#with (hash lookedup=(component "-looked-up")) as |object|}}\n        {{object.lookedup model.expectedText "Hola"}}\n      {{/with}}'], ['\n      {{#with (hash lookedup=(component "-looked-up")) as |object|}}\n        {{object.lookedup model.expectedText "Hola"}}\n      {{/with}}']),
      _templateObject9 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#with (hash my-component=(component \'my-component\' first)) as |c|}}\n        {{c.my-component}}\n      {{/with}}'], ['\n      {{#with (hash my-component=(component \'my-component\' first)) as |c|}}\n        {{c.my-component}}\n      {{/with}}']),
      _templateObject10 = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#my-component my-attr=myProp as |api|}}\n          {{api.my-nested-component}}\n        {{/my-component}}\n        <br>\n        <button onclick={{action \'changeValue\'}}>Change value</button>'], ['\n        {{#my-component my-attr=myProp as |api|}}\n          {{api.my-nested-component}}\n        {{/my-component}}\n        <br>\n        <button onclick={{action \'changeValue\'}}>Change value</button>']),
      _templateObject11 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#select-box as |sb|}}\n        {{sb.option label="Foo"}}\n        {{sb.option}}\n      {{/select-box}}'], ['\n      {{#select-box as |sb|}}\n        {{sb.option label="Foo"}}\n        {{sb.option}}\n      {{/select-box}}']),
      _templateObject12 = babelHelpers.taggedTemplateLiteralLoose(['\n        <button {{action (action (mut val) 10)}} class="my-button">\n          Change to 10\n        </button>'], ['\n        <button {{action (action (mut val) 10)}} class="my-button">\n          Change to 10\n        </button>']),
      _templateObject13 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{component (component "change-button" model.val2)}}\n      <span class="value">{{model.val2}}</span>'], ['\n      {{component (component "change-button" model.val2)}}\n      <span class="value">{{model.val2}}</span>']),
      _templateObject14 = babelHelpers.taggedTemplateLiteralLoose(['\n        message: {{message}}{{inner-component message=message}}\n        <button onclick={{action "change"}} />'], ['\n        message: {{message}}{{inner-component message=message}}\n        <button onclick={{action "change"}} />']),
      _templateObject15 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#with (hash ctxCmp=(component "my-comp" isOpen=isOpen)) as |thing|}}\n        {{#thing.ctxCmp}}This is a contextual component{{/thing.ctxCmp}}\n      {{/with}}\n    '], ['\n      {{#with (hash ctxCmp=(component "my-comp" isOpen=isOpen)) as |thing|}}\n        {{#thing.ctxCmp}}This is a contextual component{{/thing.ctxCmp}}\n      {{/with}}\n    ']),
      _templateObject16 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#with (hash ctxCmp=(component compName isOpen=isOpen)) as |thing|}}\n        {{#thing.ctxCmp}}This is a contextual component{{/thing.ctxCmp}}\n      {{/with}}\n    '], ['\n      {{#with (hash ctxCmp=(component compName isOpen=isOpen)) as |thing|}}\n        {{#thing.ctxCmp}}This is a contextual component{{/thing.ctxCmp}}\n      {{/with}}\n    ']),
      _templateObject17 = babelHelpers.taggedTemplateLiteralLoose(['\n          <button {{action (action (mut val) 10)}} class="my-button">\n            Change to 10\n          </button>'], ['\n          <button {{action (action (mut val) 10)}} class="my-button">\n            Change to 10\n          </button>']);

  _emberGlimmerTestsUtilsTestCase.moduleFor('Components test: contextual components', (function (_RenderingTest) {
babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test renders with component helper'] = function testRendersWithComponentHelper() {
      var _this = this;

      var expectedText = 'Hodi';

      this.registerComponent('-looked-up', {
        template: expectedText
      });

      this.render('{{component (component "-looked-up")}}');

      this.assertText(expectedText);

      this.runTask(function () {
        return _this.rerender();
      });

      this.assertText(expectedText);
    };

    _class.prototype['@test renders with component helper with invocation params, hash'] = function testRendersWithComponentHelperWithInvocationParamsHash() {
      var _this2 = this;

      this.registerComponent('-looked-up', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: ['name']
        }),
        template: '{{greeting}} {{name}}'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject));

      this.assertText('Hodi Hodari');

      this.runTask(function () {
        return _this2.rerender();
      });

      this.assertText('Hodi Hodari');
    };

    _class.prototype['@test GH#13742 keeps nested rest positional parameters if rendered with no positional parameters'] = function testGH13742KeepsNestedRestPositionalParametersIfRenderedWithNoPositionalParameters() {
      var _this3 = this;

      this.registerComponent('-looked-up', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: '{{#each params as |p|}}{{p}}{{/each}}'
      });

      this.render('{{component (component "-looked-up" model.greeting model.name)}}', {
        model: {
          greeting: 'Gabon ',
          name: 'Zack'
        }
      });

      this.assertText('Gabon Zack');

      this.runTask(function () {
        return _this3.rerender();
      });

      this.assertText('Gabon Zack');

      this.runTask(function () {
        return _this3.context.set('model.greeting', 'Good morning ');
      });

      this.assertText('Good morning Zack');

      this.runTask(function () {
        return _this3.context.set('model.name', 'Matthew');
      });

      this.assertText('Good morning Matthew');

      this.runTask(function () {
        return _this3.context.set('model', { greeting: 'Gabon ', name: 'Zack' });
      });

      this.assertText('Gabon Zack');
    };

    // Take a look at this one. Seems to pass even when currying isn't implemented.

    _class.prototype['@test overwrites nested rest positional parameters if rendered with positional parameters'] = function testOverwritesNestedRestPositionalParametersIfRenderedWithPositionalParameters() {
      var _this4 = this;

      this.registerComponent('-looked-up', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: '{{#each params as |p|}}{{p}}{{/each}}'
      });

      this.render('{{component (component "-looked-up" model.greeting model.name) model.name model.greeting}}', {
        model: {
          greeting: 'Gabon ',
          name: 'Zack'
        }
      });

      this.assertText('ZackGabon ');

      this.runTask(function () {
        return _this4.rerender();
      });

      this.assertText('ZackGabon ');

      this.runTask(function () {
        return _this4.context.set('model.greeting', 'Good morning ');
      });

      this.assertText('ZackGood morning ');

      this.runTask(function () {
        return _this4.context.set('model.name', 'Matthew');
      });

      this.assertText('MatthewGood morning ');

      this.runTask(function () {
        return _this4.context.set('model', { greeting: 'Gabon ', name: 'Zack' });
      });

      this.assertText('ZackGabon ');
    };

    _class.prototype['@test GH#13742  keeps nested rest positional parameters if nested and rendered with no positional parameters'] = function testGH13742KeepsNestedRestPositionalParametersIfNestedAndRenderedWithNoPositionalParameters() {
      var _this5 = this;

      this.registerComponent('-looked-up', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: '{{#each params as |p|}}{{p}}{{/each}}'
      });

      this.render('{{component (component (component "-looked-up" model.greeting model.name))}}', {
        model: {
          greeting: 'Gabon ',
          name: 'Zack'
        }
      });

      this.assertText('Gabon Zack');

      this.runTask(function () {
        return _this5.rerender();
      });

      this.assertText('Gabon Zack');

      this.runTask(function () {
        return _this5.context.set('model.greeting', 'Good morning ');
      });

      this.assertText('Good morning Zack');

      this.runTask(function () {
        return _this5.context.set('model.name', 'Matthew');
      });

      this.assertText('Good morning Matthew');

      this.runTask(function () {
        return _this5.context.set('model', { greeting: 'Gabon ', name: 'Zack' });
      });

      this.assertText('Gabon Zack');
    };

    _class.prototype['@test overwrites nested rest positional parameters if nested with new pos params and rendered with no positional parameters'] = function testOverwritesNestedRestPositionalParametersIfNestedWithNewPosParamsAndRenderedWithNoPositionalParameters() {
      var _this6 = this;

      this.registerComponent('-looked-up', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: '{{#each params as |p|}}{{p}}{{/each}}'
      });

      this.render('{{component (component (component "-looked-up" model.greeting model.name) model.name model.greeting)}}', {
        model: {
          greeting: 'Gabon ',
          name: 'Zack'
        }
      });

      this.assertText('ZackGabon ');

      this.runTask(function () {
        return _this6.rerender();
      });

      this.assertText('ZackGabon ');

      this.runTask(function () {
        return _this6.context.set('model.greeting', 'Good morning ');
      });

      this.assertText('ZackGood morning ');

      this.runTask(function () {
        return _this6.context.set('model.name', 'Matthew');
      });

      this.assertText('MatthewGood morning ');

      this.runTask(function () {
        return _this6.context.set('model', { greeting: 'Gabon ', name: 'Zack' });
      });

      this.assertText('ZackGabon ');
    };

    _class.prototype['@test renders with component helper with curried params, hash'] = function testRendersWithComponentHelperWithCurriedParamsHash() {
      var _this7 = this;

      this.registerComponent('-looked-up', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: ['name']
        }),
        template: '{{greeting}} {{name}}'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2));

      this.assertText('Hola Hodari');

      this.runTask(function () {
        return _this7.rerender();
      });

      this.assertText('Hola Hodari');
    };

    _class.prototype['@test updates when component path is bound'] = function testUpdatesWhenComponentPathIsBound() {
      var _this8 = this;

      this.registerComponent('-mandarin', {
        template: 'ni hao'
      });

      this.registerComponent('-hindi', {
        template: 'Namaste'
      });

      this.render('{{component (component model.lookupComponent)}}', {
        model: {
          lookupComponent: '-mandarin'
        }
      });

      this.assertText('ni hao');

      this.runTask(function () {
        return _this8.rerender();
      });

      this.assertText('ni hao');

      this.runTask(function () {
        return _this8.context.set('model.lookupComponent', '-hindi');
      });

      this.assertText('Namaste');

      this.runTask(function () {
        return _this8.context.set('model', { lookupComponent: '-mandarin' });
      });

      this.assertText('ni hao');
    };

    _class.prototype['@test updates when curried hash argument is bound'] = function testUpdatesWhenCurriedHashArgumentIsBound() {
      var _this9 = this;

      this.registerComponent('-looked-up', {
        template: '{{greeting}}'
      });

      this.render('{{component (component "-looked-up" greeting=model.greeting)}}', {
        model: {
          greeting: 'Hodi'
        }
      });

      this.assertText('Hodi');

      this.runTask(function () {
        return _this9.rerender();
      });

      this.assertText('Hodi');

      this.runTask(function () {
        return _this9.context.set('model.greeting', 'Hola');
      });

      this.assertText('Hola');

      this.runTask(function () {
        return _this9.context.set('model', { greeting: 'Hodi' });
      });

      this.assertText('Hodi');
    };

    _class.prototype['@test updates when curried hash arguments is bound in block form'] = function testUpdatesWhenCurriedHashArgumentsIsBoundInBlockForm() {
      var _this10 = this;

      this.registerComponent('-looked-up', {
        template: '{{greeting}}'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject3), {
        model: {
          greeting: 'Hodi'
        }
      });

      this.assertText('Hodi');

      this.runTask(function () {
        return _this10.rerender();
      });

      this.assertText('Hodi');

      this.runTask(function () {
        return _this10.context.set('model.greeting', 'Hola');
      });

      this.assertText('Hola');

      this.runTask(function () {
        return _this10.context.set('model', { greeting: 'Hodi' });
      });

      this.assertText('Hodi');
    };

    _class.prototype['@test nested components overwrite named positional parameters'] = function testNestedComponentsOverwriteNamedPositionalParameters() {
      var _this11 = this;

      this.registerComponent('-looked-up', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: ['name', 'age']
        }),
        template: '{{name}} {{age}}'
      });

      this.render('{{component (component (component "-looked-up" "Sergio" 29) "Marvin" 21) "Hodari"}}');

      this.assertText('Hodari 21');

      this.runTask(function () {
        return _this11.rerender();
      });

      this.assertText('Hodari 21');
    };

    _class.prototype['@test nested components overwrite hash parameters'] = function testNestedComponentsOverwriteHashParameters() {
      var _this12 = this;

      this.registerComponent('-looked-up', {
        template: '{{greeting}} {{name}} {{age}}'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject4), {
        model: {
          greeting: 'Hodi'
        }
      });

      this.assertText('Hodi Sigmundur 33');

      this.runTask(function () {
        return _this12.rerender();
      });

      this.assertText('Hodi Sigmundur 33');

      this.runTask(function () {
        return _this12.context.set('model.greeting', 'Kaixo');
      });

      this.assertText('Kaixo Sigmundur 33');

      this.runTask(function () {
        return _this12.context.set('model', { greeting: 'Hodi' });
      });

      this.assertText('Hodi Sigmundur 33');
    };

    _class.prototype['@test bound outer named parameters get updated in the right scope'] = function testBoundOuterNamedParametersGetUpdatedInTheRightScope() {
      var _this13 = this;

      this.registerComponent('-inner-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: ['comp']
        }),
        template: '{{component comp "Inner"}}'
      });

      this.registerComponent('-looked-up', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: ['name', 'age']
        }),
        template: '{{name}} {{age}}'
      });

      this.render('{{component "-inner-component" (component "-looked-up" model.outerName model.outerAge)}}', {
        model: {
          outerName: 'Outer',
          outerAge: 28
        }
      });

      this.assertText('Inner 28');

      this.runTask(function () {
        return _this13.rerender();
      });

      this.assertText('Inner 28');

      this.runTask(function () {
        return _this13.context.set('model.outerAge', 29);
      });

      this.assertText('Inner 29');

      this.runTask(function () {
        return _this13.context.set('model.outerName', 'Not outer');
      });

      this.assertText('Inner 29');

      this.runTask(function () {
        _this13.context.set('model', {
          outerName: 'Outer',
          outerAge: 28
        });
      });

      this.assertText('Inner 28');
    };

    _class.prototype['@test bound outer hash parameters get updated in the right scope'] = function testBoundOuterHashParametersGetUpdatedInTheRightScope() {
      var _this14 = this;

      this.registerComponent('-inner-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: ['comp']
        }),
        template: '{{component comp name="Inner"}}'
      });

      this.registerComponent('-looked-up', {
        template: '{{name}} {{age}}'
      });

      this.render('{{component "-inner-component" (component "-looked-up" name=model.outerName age=model.outerAge)}}', {
        model: {
          outerName: 'Outer',
          outerAge: 28
        }
      });

      this.assertText('Inner 28');

      this.runTask(function () {
        return _this14.rerender();
      });

      this.assertText('Inner 28');

      this.runTask(function () {
        return _this14.context.set('model.outerAge', 29);
      });

      this.assertText('Inner 29');

      this.runTask(function () {
        return _this14.context.set('model.outerName', 'Not outer');
      });

      this.assertText('Inner 29');

      this.runTask(function () {
        _this14.context.set('model', {
          outerName: 'Outer',
          outerAge: 28
        });
      });

      this.assertText('Inner 28');
    };

    _class.prototype['@test conflicting positional and hash parameters raise and assertion if in the same component context'] = function testConflictingPositionalAndHashParametersRaiseAndAssertionIfInTheSameComponentContext() {
      var _this15 = this;

      this.registerComponent('-looked-up', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: ['name']
        }),
        template: '{{greeting}} {{name}}'
      });

      expectAssertion(function () {
        _this15.render('{{component (component "-looked-up" "Hodari" name="Sergio") "Hodari" greeting="Hodi"}}');
      }, 'You cannot specify both a positional param (at position 0) and the hash argument `name`.');
    };

    _class.prototype['@test conflicting positional and hash parameters does not raise an assertion if rerendered'] = function testConflictingPositionalAndHashParametersDoesNotRaiseAnAssertionIfRerendered() {
      var _this16 = this;

      // In some cases, rerendering with a positional param used to cause an
      // assertion. This test checks it does not.
      this.registerComponent('-looked-up', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: ['name']
        }),
        template: '{{greeting}} {{name}}'
      });

      this.render('{{component (component "-looked-up" model.name greeting="Hodi")}}', {
        model: {
          name: 'Hodari'
        }
      });

      this.assertText('Hodi Hodari');

      this.runTask(function () {
        return _this16.rerender();
      });

      this.assertText('Hodi Hodari');

      this.runTask(function () {
        return _this16.context.set('model.name', 'Sergio');
      });

      this.assertText('Hodi Sergio');

      this.runTask(function () {
        return _this16.context.set('model', { name: 'Hodari' });
      });

      this.assertText('Hodi Hodari');
    };

    _class.prototype['@test conflicting positional and hash parameters does not raise an assertion if in different component context'] = function testConflictingPositionalAndHashParametersDoesNotRaiseAnAssertionIfInDifferentComponentContext() {
      var _this17 = this;

      this.registerComponent('-looked-up', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: ['name']
        }),
        template: '{{greeting}} {{name}}'
      });

      this.render('{{component (component "-looked-up" "Hodari") name="Sergio" greeting="Hodi"}}');

      this.assertText('Hodi Sergio');

      this.runTask(function () {
        return _this17.rerender();
      });

      this.assertText('Hodi Sergio');
    };

    _class.prototype['@test raises an asserton when component path is null'] = function testRaisesAnAssertonWhenComponentPathIsNull() {
      var _this18 = this;

      expectAssertion(function () {
        _this18.render('{{component (component lookupComponent)}}');
      });
    };

    _class.prototype['@test raises an assertion when component path is not a component name (static)'] = function testRaisesAnAssertionWhenComponentPathIsNotAComponentNameStatic() {
      var _this19 = this;

      expectAssertion(function () {
        _this19.render('{{component (component "not-a-component")}}');
      }, 'The component helper cannot be used without a valid component name. You used "not-a-component" via (component "not-a-component")');
    };

    _class.prototype['@test raises an assertion when component path is not a component name (dynamic)'] = function testRaisesAnAssertionWhenComponentPathIsNotAComponentNameDynamic() {
      var _this20 = this;

      expectAssertion(function () {
        _this20.render('{{component (component compName)}}', {
          compName: 'not-a-component'
        });
      }, /The component helper cannot be used without a valid component name. You used "not-a-component" via \(component .*\)/);
    };

    _class.prototype['@test renders with dot path'] = function testRendersWithDotPath() {
      var _this21 = this;

      var expectedText = 'Hodi';
      this.registerComponent('-looked-up', {
        template: expectedText
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject5));

      this.assertText(expectedText);

      this.runTask(function () {
        return _this21.rerender();
      });

      this.assertText(expectedText);
    };

    _class.prototype['@test renders with dot path and attr'] = function testRendersWithDotPathAndAttr() {
      var _this22 = this;

      var expectedText = 'Hodi';
      this.registerComponent('-looked-up', {
        template: '{{expectedText}}'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject6), {
        model: {
          expectedText: expectedText
        }
      });

      this.assertText(expectedText);

      this.runTask(function () {
        return _this22.rerender();
      });

      this.assertText(expectedText);

      this.runTask(function () {
        return _this22.context.set('model.expectedText', 'Hola');
      });

      this.assertText('Hola');

      this.runTask(function () {
        return _this22.context.set('model', { expectedText: expectedText });
      });

      this.assertText(expectedText);
    };

    _class.prototype['@test renders with dot path and curried over attr'] = function testRendersWithDotPathAndCurriedOverAttr() {
      var _this23 = this;

      var expectedText = 'Hodi';
      this.registerComponent('-looked-up', {
        template: '{{expectedText}}'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject7), {
        model: {
          expectedText: expectedText
        }
      });

      this.assertText(expectedText);

      this.runTask(function () {
        return _this23.rerender();
      });

      this.assertText(expectedText);

      this.runTask(function () {
        return _this23.context.set('model.expectedText', 'Hola');
      });

      this.assertText('Hola');

      this.runTask(function () {
        return _this23.context.set('model', { expectedText: expectedText });
      });

      this.assertText(expectedText);
    };

    _class.prototype['@test renders with dot path and with rest positional parameters'] = function testRendersWithDotPathAndWithRestPositionalParameters() {
      var _this24 = this;

      this.registerComponent('-looked-up', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: '{{params}}'
      });

      var expectedText = 'Hodi';

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject8), {
        model: {
          expectedText: expectedText
        }
      });

      this.assertText(expectedText + ',Hola');

      this.runTask(function () {
        return _this24.rerender();
      });

      this.assertText(expectedText + ',Hola');

      this.runTask(function () {
        return _this24.context.set('model.expectedText', 'Kaixo');
      });

      this.assertText('Kaixo,Hola');

      this.runTask(function () {
        return _this24.context.set('model', { expectedText: expectedText });
      });

      this.assertText(expectedText + ',Hola');
    };

    _class.prototype['@test renders with dot path and rest parameter does not leak'] = function testRendersWithDotPathAndRestParameterDoesNotLeak(assert) {
      // In the original implementation, positional parameters were not handled
      // correctly causing the first positional parameter to be the contextual
      // component itself.
      var value = false;

      this.registerComponent('my-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didReceiveAttrs: function () {
            value = this.getAttr('value');
          }
        }).reopenClass({
          positionalParams: ['value']
        })
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject9), { first: 'first' });

      assert.equal(value, 'first', 'value is the expected parameter');
    };

    _class.prototype['@test renders with dot path and updates attributes'] = function testRendersWithDotPathAndUpdatesAttributes(assert) {
      var _this25 = this;

      this.registerComponent('my-nested-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didReceiveAttrs: function () {
            this.set('myProp', this.getAttr('my-parent-attr'));
          }
        }),
        template: '<span id="nested-prop">{{myProp}}</span>'
      });

      this.registerComponent('my-component', {
        template: '{{yield (hash my-nested-component=(component "my-nested-component" my-parent-attr=my-attr))}}'
      });

      this.registerComponent('my-action-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          actions: {
            changeValue: function () {
              this.incrementProperty('myProp');
            }
          }
        }),
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject10)
      });

      this.render('{{my-action-component myProp=model.myProp}}', {
        model: {
          myProp: 1
        }
      });

      assert.equal(this.$('#nested-prop').text(), '1');

      this.runTask(function () {
        return _this25.rerender();
      });

      assert.equal(this.$('#nested-prop').text(), '1');

      this.runTask(function () {
        return _this25.$('button').click();
      });

      assert.equal(this.$('#nested-prop').text(), '2');

      this.runTask(function () {
        return _this25.$('button').click();
      });

      assert.equal(this.$('#nested-prop').text(), '3');

      this.runTask(function () {
        return _this25.context.set('model', { myProp: 1 });
      });

      assert.equal(this.$('#nested-prop').text(), '1');
    };

    _class.prototype['@test adding parameters to a contextual component\'s instance does not add it to other instances'] = function testAddingParametersToAContextualComponentSInstanceDoesNotAddItToOtherInstances() {
      var _this26 = this;

      // If parameters and attributes are not handled correctly, setting a value
      // in an invokation can leak to others invocation.
      this.registerComponent('select-box', {
        template: '{{yield (hash option=(component "select-box-option"))}}'
      });

      this.registerComponent('select-box-option', {
        template: '{{label}}'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject11));

      this.assertText('Foo');

      this.runTask(function () {
        return _this26.rerender();
      });

      this.assertText('Foo');
    };

    _class.prototype['@test parameters in a contextual component are mutable when value is a param'] = function testParametersInAContextualComponentAreMutableWhenValueIsAParam(assert) {
      var _this27 = this;

      // This checks that a `(mut)` is added to parameters and attributes to
      // contextual components when it is a param.

      this.registerComponent('change-button', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: ['val']
        }),
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject12)
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject13), {
        model: {
          val2: 8
        }
      });

      assert.equal(this.$('.value').text(), '8');

      this.runTask(function () {
        return _this27.rerender();
      });

      assert.equal(this.$('.value').text(), '8');

      this.runTask(function () {
        return _this27.$('.my-button').click();
      });

      assert.equal(this.$('.value').text(), '10');

      this.runTask(function () {
        return _this27.context.set('model', { val2: 8 });
      });

      assert.equal(this.$('.value').text(), '8');
    };

    _class.prototype['@test tagless blockless components render'] = function testTaglessBlocklessComponentsRender(assert) {
      var _this28 = this;

      this.registerComponent('my-comp', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({ tagName: '' })
      });

      this.render('{{my-comp}}');

      this.runTask(function () {
        return _this28.rerender();
      });

      assert.equal(this.$().text(), '');
    };

    _class.prototype['@test GH#13494 tagless blockless component with property binding'] = function testGH13494TaglessBlocklessComponentWithPropertyBinding(assert) {
      var _this29 = this;

      this.registerComponent('outer-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          message: 'hello',
          actions: {
            change: function () {
              this.set('message', 'goodbye');
            }
          }
        }),
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject14)
      });

      this.registerComponent('inner-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          tagName: ''
        })
      });

      this.render('{{outer-component}}');

      assert.equal(this.$().text(), 'message: hello');

      this.runTask(function () {
        return _this29.rerender();
      });

      assert.equal(this.$().text(), 'message: hello');

      this.runTask(function () {
        return _this29.$('button').click();
      });

      assert.equal(this.$().text(), 'message: goodbye');

      this.runTask(function () {
        return _this29.rerender();
      });

      assert.equal(this.$().text(), 'message: goodbye');
    };

    _class.prototype['@test GH#13982 contextual component ref is stable even when bound params change'] = function testGH13982ContextualComponentRefIsStableEvenWhenBoundParamsChange(assert) {
      var _this30 = this;

      var instance = undefined,
          previousInstance = undefined;
      var initCount = 0;

      this.registerComponent('my-comp', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super();
            previousInstance = instance;
            instance = this;
            initCount++;
          },
          isOpen: undefined
        }),
        template: '{{if isOpen "open" "closed"}}'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject15), {
        isOpen: true
      });

      assert.ok(!_emberMetal.isEmpty(instance), 'a instance was created');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'open', 'the componet text is "open"');

      this.runTask(function () {
        return _this30.rerender();
      });

      assert.ok(!_emberMetal.isEmpty(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'open', 'the componet text is "open"');

      this.runTask(function () {
        return _this30.context.set('isOpen', false);
      });

      assert.ok(!_emberMetal.isEmpty(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'closed', 'the component text is "closed"');

      this.runTask(function () {
        return _this30.rerender();
      });

      assert.ok(!_emberMetal.isEmpty(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'closed', 'the component text is "closed"');

      this.runTask(function () {
        return _this30.context.set('isOpen', true);
      });

      assert.ok(!_emberMetal.isEmpty(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'open', 'the componet text is "open"');
    };

    _class.prototype['@test GH#13982 contextual component ref is stable even when bound params change (bound name param)'] = function testGH13982ContextualComponentRefIsStableEvenWhenBoundParamsChangeBoundNameParam(assert) {
      var _this31 = this;

      var instance = undefined,
          previousInstance = undefined;
      var initCount = 0;

      this.registerComponent('my-comp', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super();
            previousInstance = instance;
            instance = this;
            initCount++;
          },
          isOpen: undefined
        }),
        template: '{{if isOpen "open" "closed"}}'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject16), {
        compName: 'my-comp',
        isOpen: true
      });

      assert.ok(!_emberMetal.isEmpty(instance), 'a instance was created');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'open', 'the componet text is "open"');

      this.runTask(function () {
        return _this31.rerender();
      });

      assert.ok(!_emberMetal.isEmpty(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'open', 'the componet text is "open"');

      this.runTask(function () {
        return _this31.context.set('isOpen', false);
      });

      assert.ok(!_emberMetal.isEmpty(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'closed', 'the component text is "closed"');

      this.runTask(function () {
        return _this31.rerender();
      });

      assert.ok(!_emberMetal.isEmpty(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'closed', 'the component text is "closed"');

      this.runTask(function () {
        return _this31.context.set('isOpen', true);
      });

      assert.ok(!_emberMetal.isEmpty(instance), 'the component instance exists');
      assert.equal(previousInstance, undefined, 'no previous component exists');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'open', 'the componet text is "open"');
    };

    _class.prototype['@test GH#13982 contextual component ref is recomputed when component name param changes'] = function testGH13982ContextualComponentRefIsRecomputedWhenComponentNameParamChanges(assert) {
      var _this32 = this;

      var instance = undefined,
          previousInstance = undefined;
      var initCount = 0;

      this.registerComponent('my-comp', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super();
            previousInstance = instance;
            instance = this;
            initCount++;
          },
          isOpen: undefined
        }),
        template: 'my-comp: {{if isOpen "open" "closed"}}'
      });

      this.registerComponent('your-comp', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super();
            previousInstance = instance;
            instance = this;
            initCount++;
          },
          isOpen: undefined
        }),
        template: 'your-comp: {{if isOpen "open" "closed"}}'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject16), {
        compName: 'my-comp',
        isOpen: true
      });

      assert.ok(!_emberMetal.isEmpty(instance), 'a instance was created');
      assert.equal(previousInstance, undefined, 'there is no previous instance');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'my-comp: open');

      this.runTask(function () {
        return _this32.rerender();
      });

      assert.ok(!_emberMetal.isEmpty(instance), 'a instance exists after rerender');
      assert.equal(previousInstance, undefined, 'there is no previous instance after rerender');
      assert.equal(initCount, 1, 'the component was constructed exactly 1 time');
      assert.equal(this.$().text(), 'my-comp: open');

      this.runTask(function () {
        return _this32.context.set('compName', 'your-comp');
      });

      assert.ok(!_emberMetal.isEmpty(instance), 'an instance was created after component name changed');
      assert.ok(!_emberMetal.isEmpty(previousInstance), 'a previous instance now exists');
      assert.notEqual(instance, previousInstance, 'the instance and previous instance are not the same object');
      assert.equal(initCount, 2, 'the component was constructed exactly 2 times');
      assert.equal(this.$().text(), 'your-comp: open');

      this.runTask(function () {
        return _this32.rerender();
      });

      assert.ok(!_emberMetal.isEmpty(instance), 'an instance was created after component name changed (rerender)');
      assert.ok(!_emberMetal.isEmpty(previousInstance), 'a previous instance now exists (rerender)');
      assert.notEqual(instance, previousInstance, 'the instance and previous instance are not the same object (rerender)');
      assert.equal(initCount, 2, 'the component was constructed exactly 2 times (rerender)');
      assert.equal(this.$().text(), 'your-comp: open');

      this.runTask(function () {
        return _this32.context.set('compName', 'my-comp');
      });

      assert.ok(!_emberMetal.isEmpty(instance), 'an instance was created after component name changed');
      assert.ok(!_emberMetal.isEmpty(previousInstance), 'a previous instance still exists');
      assert.notEqual(instance, previousInstance, 'the instance and previous instance are not the same object');
      assert.equal(initCount, 3, 'the component was constructed exactly 3 times (rerender)');
      assert.equal(this.$().text(), 'my-comp: open');
    };

    _class.prototype['@test GH#14508 rest positional params are received when passed as named parameter'] = function testGH14508RestPositionalParamsAreReceivedWhenPassedAsNamedParameter() {
      var _this33 = this;

      this.registerComponent('my-link', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: '{{#each params as |p|}}{{p}}{{/each}}'
      });

      this.render('{{component (component "my-link") params=allParams}}', {
        allParams: _emberRuntimeSystemNative_array.A(['a', 'b'])
      });

      this.assertText('ab');

      this.runTask(function () {
        return _this33.rerender();
      });

      this.assertText('ab');

      this.runTask(function () {
        return _this33.context.get('allParams').pushObject('c');
      });

      this.assertText('abc');

      this.runTask(function () {
        return _this33.context.get('allParams').popObject();
      });

      this.assertText('ab');

      this.runTask(function () {
        return _this33.context.get('allParams').clear();
      });

      this.assertText('');

      this.runTask(function () {
        return _this33.context.set('allParams', _emberRuntimeSystemNative_array.A(['1', '2']));
      });

      this.assertText('12');

      this.runTask(function () {
        return _this33.context.set('allParams', _emberRuntimeSystemNative_array.A(['a', 'b']));
      });

      this.assertText('ab');
    };

    _class.prototype['@test GH#14508 rest positional params are received when passed as named parameter with dot notation'] = function testGH14508RestPositionalParamsAreReceivedWhenPassedAsNamedParameterWithDotNotation() {
      var _this34 = this;

      this.registerComponent('my-link', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: 'params'
        }),
        template: '{{#each params as |p|}}{{p}}{{/each}}'
      });

      this.render('{{#with (hash link=(component "my-link")) as |c|}}{{c.link params=allParams}}{{/with}}', {
        allParams: _emberRuntimeSystemNative_array.A(['a', 'b'])
      });

      this.assertText('ab');

      this.runTask(function () {
        return _this34.rerender();
      });

      this.assertText('ab');

      this.runTask(function () {
        return _this34.context.get('allParams').pushObject('c');
      });

      this.assertText('abc');

      this.runTask(function () {
        return _this34.context.get('allParams').popObject();
      });

      this.assertText('ab');

      this.runTask(function () {
        return _this34.context.get('allParams').clear();
      });

      this.assertText('');

      this.runTask(function () {
        return _this34.context.set('allParams', _emberRuntimeSystemNative_array.A(['1', '2']));
      });

      this.assertText('12');

      this.runTask(function () {
        return _this34.context.set('allParams', _emberRuntimeSystemNative_array.A(['a', 'b']));
      });

      this.assertText('ab');
    };

    _class.prototype['@test GH#14632 give useful warning when calling contextual components with input as a name'] = function testGH14632GiveUsefulWarningWhenCallingContextualComponentsWithInputAsAName() {
      var _this35 = this;

      expectAssertion(function () {
        _this35.render('{{component (component "input" type="text")}}');
      }, 'You cannot use the input helper as a contextual helper. Please extend Ember.TextField or Ember.Checkbox to use it as a contextual component.');
    };

    _class.prototype['@test GH#14632 give useful warning when calling contextual components with textarea as a name'] = function testGH14632GiveUsefulWarningWhenCallingContextualComponentsWithTextareaAsAName() {
      var _this36 = this;

      expectAssertion(function () {
        _this36.render('{{component (component "textarea" type="text")}}');
      }, 'You cannot use the textarea helper as a contextual helper. Please extend Ember.TextArea to use it as a contextual component.');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));

  var ContextualComponentMutableParamsTest = (function (_RenderingTest2) {
babelHelpers.inherits(ContextualComponentMutableParamsTest, _RenderingTest2);

    function ContextualComponentMutableParamsTest() {
      _RenderingTest2.apply(this, arguments);
    }

    ContextualComponentMutableParamsTest.prototype.render = function render(templateStr) {
      var context = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      _RenderingTest2.prototype.render.call(this, templateStr + '<span class="value">{{model.val2}}</span>', _emberUtils.assign(context, { model: { val2: 8 } }));
    };

    return ContextualComponentMutableParamsTest;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest);

  var MutableParamTestGenerator = (function () {
    function MutableParamTestGenerator(cases) {
      this.cases = cases;
    }

    MutableParamTestGenerator.prototype.generate = function generate(_ref2) {
      var _ref;

      var title = _ref2.title;
      var setup = _ref2.setup;

      return _ref = {}, _ref['@test parameters in a contextual component are mutable when value is a ' + title] = function (assert) {
        var _this37 = this;

        this.registerComponent('change-button', {
          ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
            positionalParams: ['val']
          }),
          template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject17)
        });

        setup.call(this, assert);

        assert.equal(this.$('.value').text(), '8');

        this.runTask(function () {
          return _this37.rerender();
        });

        assert.equal(this.$('.value').text(), '8');

        this.runTask(function () {
          return _this37.$('.my-button').click();
        });

        assert.equal(this.$('.value').text(), '10');

        this.runTask(function () {
          return _this37.context.set('model', { val2: 8 });
        });

        assert.equal(this.$('.value').text(), '8');
      }, _ref;
    };

    return MutableParamTestGenerator;
  })();

  _emberGlimmerTestsUtilsAbstractTestCase.applyMixins(ContextualComponentMutableParamsTest, new MutableParamTestGenerator([{
    title: 'param',
    setup: function () {
      this.render('{{component (component "change-button" model.val2)}}');
    }
  }, {
    title: 'nested param',
    setup: function () {
      this.registerComponent('my-comp', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: ['components']
        }),
        template: '{{component components.comp}}'
      });

      this.render('{{my-comp (hash comp=(component "change-button" model.val2))}}');
    }
  }, {
    title: 'hash value',
    setup: function () {
      this.registerComponent('my-comp', {
        template: '{{component component}}'
      });

      this.render('{{my-comp component=(component "change-button" val=model.val2)}}');
    }
  }, {
    title: 'nested hash value',
    setup: function () {
      this.registerComponent('my-comp', {
        template: '{{component components.button}}'
      });

      this.render('{{my-comp components=(hash button=(component "change-button" val=model.val2))}}');
    }
  }]));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Components test: contextual components -- mutable params', ContextualComponentMutableParamsTest);
});
enifed('ember-glimmer/tests/integration/components/contextual-components-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/components/contextual-components-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/components/contextual-components-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/components/curly-components-test', ['exports', 'ember-metal', 'ember-runtime', 'ember-glimmer/tests/utils/helpers', 'ember-glimmer/tests/utils/abstract-test-case', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/test-helpers'], function (exports, _emberMetal, _emberRuntime, _emberGlimmerTestsUtilsHelpers, _emberGlimmerTestsUtilsAbstractTestCase, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsTestHelpers) {
  /* globals EmberDev */
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n      {{foo-bar class="bar baz"}}\n      {{foo-bar classNames="bar baz"}}\n      {{foo-bar}}\n    '], ['\n      {{foo-bar class="bar baz"}}\n      {{foo-bar classNames="bar baz"}}\n      {{foo-bar}}\n    ']),
      _templateObject2 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#if cond1}}\n        {{#foo-bar id=1}}\n          {{#if cond2}}\n            {{#foo-bar id=2}}{{/foo-bar}}\n            {{#if cond3}}\n              {{#foo-bar id=3}}\n                {{#if cond4}}\n                  {{#foo-bar id=4}}\n                    {{#if cond5}}\n                      {{#foo-bar id=5}}{{/foo-bar}}\n                      {{#foo-bar id=6}}{{/foo-bar}}\n                      {{#foo-bar id=7}}{{/foo-bar}}\n                    {{/if}}\n                    {{#foo-bar id=8}}{{/foo-bar}}\n                  {{/foo-bar}}\n                {{/if}}\n              {{/foo-bar}}\n            {{/if}}\n          {{/if}}\n        {{/foo-bar}}\n      {{/if}}'], ['\n      {{#if cond1}}\n        {{#foo-bar id=1}}\n          {{#if cond2}}\n            {{#foo-bar id=2}}{{/foo-bar}}\n            {{#if cond3}}\n              {{#foo-bar id=3}}\n                {{#if cond4}}\n                  {{#foo-bar id=4}}\n                    {{#if cond5}}\n                      {{#foo-bar id=5}}{{/foo-bar}}\n                      {{#foo-bar id=6}}{{/foo-bar}}\n                      {{#foo-bar id=7}}{{/foo-bar}}\n                    {{/if}}\n                    {{#foo-bar id=8}}{{/foo-bar}}\n                  {{/foo-bar}}\n                {{/if}}\n              {{/foo-bar}}\n            {{/if}}\n          {{/if}}\n        {{/foo-bar}}\n      {{/if}}']),
      _templateObject3 = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#if isStream}}\n          true\n        {{else}}\n          false\n        {{/if}}\n      '], ['\n        {{#if isStream}}\n          true\n        {{else}}\n          false\n        {{/if}}\n      ']),
      _templateObject4 = babelHelpers.taggedTemplateLiteralLoose(['\n        Args: {{this.attrs.value}} | {{attrs.value}} | {{value}}\n        {{#each this.attrs.items as |item|}}\n          {{item}}\n        {{/each}}\n        {{#each attrs.items as |item|}}\n          {{item}}\n        {{/each}}\n        {{#each items as |item|}}\n          {{item}}\n        {{/each}}\n      '], ['\n        Args: {{this.attrs.value}} | {{attrs.value}} | {{value}}\n        {{#each this.attrs.items as |item|}}\n          {{item}}\n        {{/each}}\n        {{#each attrs.items as |item|}}\n          {{item}}\n        {{/each}}\n        {{#each items as |item|}}\n          {{item}}\n        {{/each}}\n      ']),
      _templateObject5 = babelHelpers.taggedTemplateLiteralLoose(['Args: lul | lul | lul111'], ['Args: lul | lul | lul111']),
      _templateObject6 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#with-block someProp=prop}}\n        In template\n      {{/with-block}}'], ['\n      {{#with-block someProp=prop}}\n        In template\n      {{/with-block}}']),
      _templateObject7 = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#each names as |name|}}\n          {{name}}\n        {{/each}}'], ['\n        {{#each names as |name|}}\n          {{name}}\n        {{/each}}']),
      _templateObject8 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{sample-component "Foo" 4 "Bar" elementId="args-3"}}\n      {{sample-component "Foo" 4 "Bar" 5 "Baz" elementId="args-5"}}'], ['\n      {{sample-component "Foo" 4 "Bar" elementId="args-3"}}\n      {{sample-component "Foo" 4 "Bar" 5 "Baz" elementId="args-5"}}']),
      _templateObject9 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{sample-component "one" "two" elementId="two-positional"}}\n      {{sample-component "one" second="two" elementId="one-positional"}}\n      {{sample-component first="one" second="two" elementId="no-positional"}}'], ['\n      {{sample-component "one" "two" elementId="two-positional"}}\n      {{sample-component "one" second="two" elementId="one-positional"}}\n      {{sample-component first="one" second="two" elementId="no-positional"}}']),
      _templateObject10 = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#each n as |name|}}\n          {{name}}\n        {{/each}}'], ['\n        {{#each n as |name|}}\n          {{name}}\n        {{/each}}']),
      _templateObject11 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#with-template name="with-block"}}\n        [In block - {{name}}]\n      {{/with-template}}\n      {{with-template name="without-block"}}'], ['\n      {{#with-template name="with-block"}}\n        [In block - {{name}}]\n      {{/with-template}}\n      {{with-template name="without-block"}}']),
      _templateObject12 = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#if hasBlock}}\n          {{yield}}\n        {{else}}\n          No Block!\n        {{/if}}'], ['\n        {{#if hasBlock}}\n          {{yield}}\n        {{else}}\n          No Block!\n        {{/if}}']),
      _templateObject13 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#with-block}}\n        In template\n      {{/with-block}}'], ['\n      {{#with-block}}\n        In template\n      {{/with-block}}']),
      _templateObject14 = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#if hasBlockParams}}\n          {{yield this}} - In Component\n        {{else}}\n          {{yield}} No Block!\n        {{/if}}'], ['\n        {{#if hasBlockParams}}\n          {{yield this}} - In Component\n        {{else}}\n          {{yield}} No Block!\n        {{/if}}']),
      _templateObject15 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#with-block as |something|}}\n        In template\n      {{/with-block}}'], ['\n      {{#with-block as |something|}}\n        In template\n      {{/with-block}}']),
      _templateObject16 = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#if hasBlockParams}}\n          {{yield this}}\n        {{else}}\n          {{yield}} No Block Param!\n        {{/if}}'], ['\n        {{#if hasBlockParams}}\n          {{yield this}}\n        {{else}}\n          {{yield}} No Block Param!\n        {{/if}}']),
      _templateObject17 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#with-block}}\n        In block\n      {{/with-block}}'], ['\n      {{#with-block}}\n        In block\n      {{/with-block}}']),
      _templateObject18 = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#if predicate}}\n          Yes:{{yield someValue}}\n        {{else}}\n          No:{{yield to="inverse"}}\n        {{/if}}'], ['\n        {{#if predicate}}\n          Yes:{{yield someValue}}\n        {{else}}\n          No:{{yield to="inverse"}}\n        {{/if}}']),
      _templateObject19 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#my-if predicate=activated someValue=42 as |result|}}\n        Hello{{result}}\n      {{else}}\n        Goodbye\n      {{/my-if}}'], ['\n      {{#my-if predicate=activated someValue=42 as |result|}}\n        Hello{{result}}\n      {{else}}\n        Goodbye\n      {{/my-if}}']),
      _templateObject20 = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#if (hasBlock "inverse")}}\n          Yes\n        {{else}}\n          No\n        {{/if}}'], ['\n        {{#if (hasBlock "inverse")}}\n          Yes\n        {{else}}\n          No\n        {{/if}}']),
      _templateObject21 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#check-inverse}}{{/check-inverse}}\n      {{#check-inverse}}{{else}}{{/check-inverse}}'], ['\n      {{#check-inverse}}{{/check-inverse}}\n      {{#check-inverse}}{{else}}{{/check-inverse}}']),
      _templateObject22 = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#if (hasBlock)}}\n          Yes\n        {{else}}\n          No\n        {{/if}}'], ['\n        {{#if (hasBlock)}}\n          Yes\n        {{else}}\n          No\n        {{/if}}']),
      _templateObject23 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{check-block}}\n      {{#check-block}}{{/check-block}}'], ['\n      {{check-block}}\n      {{#check-block}}{{/check-block}}']),
      _templateObject24 = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#if (hasBlockParams "inverse")}}\n          Yes\n        {{else}}\n          No\n        {{/if}}'], ['\n        {{#if (hasBlockParams "inverse")}}\n          Yes\n        {{else}}\n          No\n        {{/if}}']),
      _templateObject25 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#check-inverse}}{{/check-inverse}}\n      {{#check-inverse as |something|}}{{/check-inverse}}'], ['\n      {{#check-inverse}}{{/check-inverse}}\n      {{#check-inverse as |something|}}{{/check-inverse}}']),
      _templateObject26 = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#if (hasBlockParams)}}\n          Yes\n        {{else}}\n          No\n        {{/if}}'], ['\n        {{#if (hasBlockParams)}}\n          Yes\n        {{else}}\n          No\n        {{/if}}']),
      _templateObject27 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#check-block}}{{/check-block}}\n      {{#check-block as |something|}}{{/check-block}}'], ['\n      {{#check-block}}{{/check-block}}\n      {{#check-block as |something|}}{{/check-block}}']),
      _templateObject28 = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#if hasBlock}}\n          Yes\n        {{else}}\n          No\n        {{/if}}'], ['\n        {{#if hasBlock}}\n          Yes\n        {{else}}\n          No\n        {{/if}}']),
      _templateObject29 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#check-params}}{{/check-params}}\n      {{#check-params as |foo|}}{{/check-params}}'], ['\n      {{#check-params}}{{/check-params}}\n      {{#check-params as |foo|}}{{/check-params}}']),
      _templateObject30 = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#if hasBlockParams}}\n          Yes\n        {{else}}\n          No\n        {{/if}}'], ['\n        {{#if hasBlockParams}}\n          Yes\n        {{else}}\n          No\n        {{/if}}']),
      _templateObject31 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{check-attr}}\n      {{#check-attr}}{{/check-attr}}'], ['\n      {{check-attr}}\n      {{#check-attr}}{{/check-attr}}']),
      _templateObject32 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#check-attr}}{{/check-attr}}\n      {{#check-attr}}{{else}}{{/check-attr}}'], ['\n      {{#check-attr}}{{/check-attr}}\n      {{#check-attr}}{{else}}{{/check-attr}}']),
      _templateObject33 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#check-attr}}{{/check-attr}}\n      {{#check-attr as |something|}}{{/check-attr}}'], ['\n      {{#check-attr}}{{/check-attr}}\n      {{#check-attr as |something|}}{{/check-attr}}']),
      _templateObject34 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{check-helper}}\n      {{#check-helper}}{{/check-helper}}'], ['\n      {{check-helper}}\n      {{#check-helper}}{{/check-helper}}']),
      _templateObject35 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#check-helper}}{{/check-helper}}\n      {{#check-helper}}{{else}}{{/check-helper}}'], ['\n      {{#check-helper}}{{/check-helper}}\n      {{#check-helper}}{{else}}{{/check-helper}}']),
      _templateObject36 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#check-helper}}{{/check-helper}}\n      {{#check-helper as |something|}}{{/check-helper}}'], ['\n      {{#check-helper}}{{/check-helper}}\n      {{#check-helper as |something|}}{{/check-helper}}']),
      _templateObject37 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#x-outer}}\n        {{#if showInner}}\n          {{x-inner}}\n        {{/if}}\n      {{/x-outer}}'], ['\n      {{#x-outer}}\n        {{#if showInner}}\n          {{x-inner}}\n        {{/if}}\n      {{/x-outer}}']),
      _templateObject38 = babelHelpers.taggedTemplateLiteralLoose(['\n        In layout. {{#each items as |item|}}\n          [{{child-non-block item=item}}]\n        {{/each}}'], ['\n        In layout. {{#each items as |item|}}\n          [{{child-non-block item=item}}]\n        {{/each}}']),
      _templateObject39 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#some-clicky-thing classNames="baz"}}\n        Click Me\n      {{/some-clicky-thing}}'], ['\n      {{#some-clicky-thing classNames="baz"}}\n        Click Me\n      {{/some-clicky-thing}}']),
      _templateObject40 = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#each blahzz as |p|}}\n          {{p}}\n        {{/each}}\n        - {{yield}}'], ['\n        {{#each blahzz as |p|}}\n          {{p}}\n        {{/each}}\n        - {{yield}}']),
      _templateObject41 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#some-clicky-thing blahzz="baz"}}\n        Click Me\n      {{/some-clicky-thing}}'], ['\n      {{#some-clicky-thing blahzz="baz"}}\n        Click Me\n      {{/some-clicky-thing}}']),
      _templateObject42 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#x-select value=value as |select|}}\n        {{#x-option value="1" select=select}}1{{/x-option}}\n        {{#x-option value="2" select=select}}2{{/x-option}}\n      {{/x-select}}\n    '], ['\n      {{#x-select value=value as |select|}}\n        {{#x-option value="1" select=select}}1{{/x-option}}\n        {{#x-option value="2" select=select}}2{{/x-option}}\n      {{/x-select}}\n    ']),
      _templateObject43 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#list-items items=items as |thing|}}\n        |{{thing}}|\n\n        {{#if editMode}}\n          Remove {{thing}}\n        {{/if}}\n      {{/list-items}}\n    '], ['\n      {{#list-items items=items as |thing|}}\n        |{{thing}}|\n\n        {{#if editMode}}\n          Remove {{thing}}\n        {{/if}}\n      {{/list-items}}\n    ']);

  _emberGlimmerTestsUtilsTestCase.moduleFor('Components test: curly components', (function (_RenderingTest) {
babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test it can render a basic component'] = function testItCanRenderABasicComponent() {
      var _this = this;

      this.registerComponent('foo-bar', { template: 'hello' });

      this.render('{{foo-bar}}');

      this.assertComponentElement(this.firstChild, { content: 'hello' });

      this.runTask(function () {
        return _this.rerender();
      });

      this.assertComponentElement(this.firstChild, { content: 'hello' });
    };

    _class.prototype['@test it can render a template only component'] = function testItCanRenderATemplateOnlyComponent() {
      var _this2 = this;

      this.registerComponent('foo-bar', { template: 'hello' });

      this.render('{{foo-bar}}');

      this.assertComponentElement(this.firstChild, { content: 'hello' });

      this.runTask(function () {
        return _this2.rerender();
      });

      this.assertComponentElement(this.firstChild, { content: 'hello' });
    };

    _class.prototype['@test it can have a custom id and it is not bound'] = function testItCanHaveACustomIdAndItIsNotBound() {
      var _this3 = this;

      this.registerComponent('foo-bar', { template: '{{id}} {{elementId}}' });

      this.render('{{foo-bar id=customId}}', {
        customId: 'bizz'
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { id: 'bizz' }, content: 'bizz bizz' });

      this.runTask(function () {
        return _this3.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { id: 'bizz' }, content: 'bizz bizz' });

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'customId', 'bar');
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { id: 'bizz' }, content: 'bar bizz' });

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'customId', 'bizz');
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { id: 'bizz' }, content: 'bizz bizz' });
    };

    _class.prototype['@test elementId cannot change'] = function testElementIdCannotChange(assert) {
      var component = undefined;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        elementId: 'blahzorz',
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: '{{elementId}}' });

      this.render('{{foo-bar}}');

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { id: 'blahzorz' }, content: 'blahzorz' });

      if (EmberDev && !EmberDev.runningProdBuild) {
        var willThrow = function () {
          return _emberMetal.run(null, _emberMetal.set, component, 'elementId', 'herpyderpy');
        };

        assert.throws(willThrow, /Changing a view's elementId after creation is not allowed/);

        this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { id: 'blahzorz' }, content: 'blahzorz' });
      }
    };

    _class.prototype['@test can specify template with `layoutName` property'] = function testCanSpecifyTemplateWithLayoutNameProperty() {
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        elementId: 'blahzorz',
        layoutName: 'fizz-bar',
        init: function () {
          this._super.apply(this, arguments);
          this.local = 'hey';
        }
      });

      this.registerTemplate('fizz-bar', 'FIZZ BAR {{local}}');

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent });

      this.render('{{foo-bar}}');

      this.assertText('FIZZ BAR hey');
    };

    _class.prototype['@test can specify template with `defaultLayout` property [DEPRECATED]'] = function testCanSpecifyTemplateWithDefaultLayoutPropertyDEPRECATED() {
      expectDeprecation(/Specifying `defaultLayout` to .* is deprecated. Please use `layout` instead/);
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        elementId: 'blahzorz',
        defaultLayout: _emberGlimmerTestsUtilsHelpers.compile('much wat {{lulz}}'),
        init: function () {
          this._super.apply(this, arguments);
          this.lulz = 'hey';
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent });

      this.render('{{foo-bar}}');

      this.assertText('much wat hey');
    };

    _class.prototype['@test layout takes precedence over defaultLayout'] = function testLayoutTakesPrecedenceOverDefaultLayout() {
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        elementId: 'blahzorz',
        layout: _emberGlimmerTestsUtilsHelpers.compile('so much layout wat {{lulz}}'),
        defaultLayout: _emberGlimmerTestsUtilsHelpers.compile('much wat {{lulz}}'),
        init: function () {
          this._super.apply(this, arguments);
          this.lulz = 'hey';
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent });

      this.render('{{foo-bar}}');

      this.assertText('so much layout wat hey');
    };

    _class.prototype['@test layout supports computed property'] = function testLayoutSupportsComputedProperty() {
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        elementId: 'blahzorz',
        layout: _emberMetal.computed(function () {
          return _emberGlimmerTestsUtilsHelpers.compile('so much layout wat {{lulz}}');
        }),
        init: function () {
          this._super.apply(this, arguments);
          this.lulz = 'heyo';
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent });

      this.render('{{foo-bar}}');

      this.assertText('so much layout wat heyo');
    };

    _class.prototype['@test passing undefined elementId results in a default elementId'] = function testPassingUndefinedElementIdResultsInADefaultElementId(assert) {
      var _this4 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: 'h1'
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'something' });

      this.render('{{foo-bar id=somethingUndefined}}');

      var foundId = this.$('h1').attr('id');
      assert.ok(/^ember/.test(foundId), 'Has a reasonable id attribute (found id=' + foundId + ').');

      this.runTask(function () {
        return _this4.rerender();
      });

      var newFoundId = this.$('h1').attr('id');
      assert.ok(/^ember/.test(newFoundId), 'Has a reasonable id attribute (found id=' + newFoundId + ').');

      assert.equal(foundId, newFoundId);
    };

    _class.prototype['@test id is an alias for elementId'] = function testIdIsAnAliasForElementId(assert) {
      var _this5 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: 'h1'
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'something' });

      this.render('{{foo-bar id="custom-id"}}');

      var foundId = this.$('h1').attr('id');
      assert.equal(foundId, 'custom-id');

      this.runTask(function () {
        return _this5.rerender();
      });

      var newFoundId = this.$('h1').attr('id');
      assert.equal(newFoundId, 'custom-id');

      assert.equal(foundId, newFoundId);
    };

    _class.prototype['@test cannot pass both id and elementId at the same time'] = function testCannotPassBothIdAndElementIdAtTheSameTime(assert) {
      var _this6 = this;

      this.registerComponent('foo-bar', { template: '' });

      expectAssertion(function () {
        _this6.render('{{foo-bar id="zomg" elementId="lol"}}');
      }, /You cannot invoke a component with both 'id' and 'elementId' at the same time./);
    };

    _class.prototype['@test it can have a custom tagName'] = function testItCanHaveACustomTagName() {
      var _this7 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: 'foo-bar'
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar}}');

      this.assertComponentElement(this.firstChild, { tagName: 'foo-bar', content: 'hello' });

      this.runTask(function () {
        return _this7.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'foo-bar', content: 'hello' });
    };

    _class.prototype['@test it can have a custom tagName set in the constructor'] = function testItCanHaveACustomTagNameSetInTheConstructor() {
      var _this8 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super();
          this.tagName = 'foo-bar';
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar}}');

      this.assertComponentElement(this.firstChild, { tagName: 'foo-bar', content: 'hello' });

      this.runTask(function () {
        return _this8.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'foo-bar', content: 'hello' });
    };

    _class.prototype['@test it can have a custom tagName from the invocation'] = function testItCanHaveACustomTagNameFromTheInvocation() {
      var _this9 = this;

      this.registerComponent('foo-bar', { template: 'hello' });

      this.render('{{foo-bar tagName="foo-bar"}}');

      this.assertComponentElement(this.firstChild, { tagName: 'foo-bar', content: 'hello' });

      this.runTask(function () {
        return _this9.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'foo-bar', content: 'hello' });
    };

    _class.prototype['@test tagName can not be a computed property'] = function testTagNameCanNotBeAComputedProperty(assert) {
      var _this10 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: _emberMetal.computed(function () {
          return 'foo-bar';
        })
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      expectAssertion(function () {
        _this10.render('{{foo-bar}}');
      }, /You cannot use a computed property for the component's `tagName` \(<\(.+>\)\./);
    };

    _class.prototype['@test class is applied before didInsertElement'] = function testClassIsAppliedBeforeDidInsertElement(assert) {
      var componentClass = undefined;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        didInsertElement: function () {
          componentClass = this.element.className;
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar class="foo-bar"}}');

      assert.equal(componentClass, 'foo-bar ember-view');
    };

    _class.prototype['@test it can have custom classNames'] = function testItCanHaveCustomClassNames() {
      var _this11 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        classNames: ['foo', 'bar']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar}}');

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo bar') }, content: 'hello' });

      this.runTask(function () {
        return _this11.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo bar') }, content: 'hello' });
    };

    _class.prototype['@test should not apply falsy class name'] = function testShouldNotApplyFalsyClassName() {
      var _this12 = this;

      this.registerComponent('foo-bar', { template: 'hello' });

      this.render('{{foo-bar class=somethingFalsy}}', {
        somethingFalsy: false
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { class: 'ember-view' }, content: 'hello' });

      this.runTask(function () {
        return _this12.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { class: 'ember-view' }, content: 'hello' });
    };

    _class.prototype['@test should apply classes of the dasherized property name when bound property specified is true'] = function testShouldApplyClassesOfTheDasherizedPropertyNameWhenBoundPropertySpecifiedIsTrue() {
      var _this13 = this;

      this.registerComponent('foo-bar', { template: 'hello' });

      this.render('{{foo-bar class=model.someTruth}}', {
        model: { someTruth: true }
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { class: _emberGlimmerTestsUtilsTestHelpers.classes('ember-view some-truth') }, content: 'hello' });

      this.runTask(function () {
        return _this13.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { class: _emberGlimmerTestsUtilsTestHelpers.classes('ember-view some-truth') }, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this13.context, 'model.someTruth', false);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { class: _emberGlimmerTestsUtilsTestHelpers.classes('ember-view') }, content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this13.context, 'model', { someTruth: true });
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { class: _emberGlimmerTestsUtilsTestHelpers.classes('ember-view some-truth') }, content: 'hello' });
    };

    _class.prototype['@test class property on components can be dynamic'] = function testClassPropertyOnComponentsCanBeDynamic() {
      var _this14 = this;

      this.registerComponent('foo-bar', { template: 'hello' });

      this.render('{{foo-bar class=(if fooBar "foo-bar")}}', {
        fooBar: true
      });

      this.assertComponentElement(this.firstChild, { content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo-bar') } });

      this.runTask(function () {
        return _this14.rerender();
      });

      this.assertComponentElement(this.firstChild, { content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo-bar') } });

      this.runTask(function () {
        return _emberMetal.set(_this14.context, 'fooBar', false);
      });

      this.assertComponentElement(this.firstChild, { content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view') } });

      this.runTask(function () {
        return _emberMetal.set(_this14.context, 'fooBar', true);
      });

      this.assertComponentElement(this.firstChild, { content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo-bar') } });
    };

    _class.prototype['@test it can have custom classNames from constructor'] = function testItCanHaveCustomClassNamesFromConstructor() {
      var _this15 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super();
          this.classNames = this.classNames.slice();
          this.classNames.push('foo', 'bar', 'outside-' + this.get('extraClass'));
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar extraClass="baz"}}');

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo bar outside-baz') }, content: 'hello' });

      this.runTask(function () {
        return _this15.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo bar outside-baz') }, content: 'hello' });
    };

    _class.prototype['@test it can set custom classNames from the invocation'] = function testItCanSetCustomClassNamesFromTheInvocation() {
      var _this16 = this;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        classNames: ['foo']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject));

      this.assertComponentElement(this.nthChild(0), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo bar baz') }, content: 'hello' });
      this.assertComponentElement(this.nthChild(1), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo bar baz') }, content: 'hello' });
      this.assertComponentElement(this.nthChild(2), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo') }, content: 'hello' });

      this.runTask(function () {
        return _this16.rerender();
      });

      this.assertComponentElement(this.nthChild(0), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo bar baz') }, content: 'hello' });
      this.assertComponentElement(this.nthChild(1), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo bar baz') }, content: 'hello' });
      this.assertComponentElement(this.nthChild(2), { tagName: 'div', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view foo') }, content: 'hello' });
    };

    _class.prototype['@test it has an element'] = function testItHasAnElement() {
      var _this17 = this;

      var instance = undefined;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super();
          instance = this;
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar}}');

      var element1 = instance.element;

      this.assertComponentElement(element1, { content: 'hello' });

      this.runTask(function () {
        return _this17.rerender();
      });

      var element2 = instance.element;

      this.assertComponentElement(element2, { content: 'hello' });

      this.assertSameNode(element2, element1);
    };

    _class.prototype['@test it has a jQuery proxy to the element'] = function testItHasAJQueryProxyToTheElement(assert) {
      var _this18 = this;

      var instance = undefined;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super();
          instance = this;
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{foo-bar}}');

      var element1 = instance.$()[0];

      this.assertComponentElement(element1, { content: 'hello' });

      this.runTask(function () {
        return _this18.rerender();
      });

      var element2 = instance.$()[0];

      this.assertComponentElement(element2, { content: 'hello' });

      this.assertSameNode(element2, element1);
    };

    _class.prototype['@test it scopes the jQuery proxy to the component element'] = function testItScopesTheJQueryProxyToTheComponentElement(assert) {
      var _this19 = this;

      var instance = undefined;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super();
          instance = this;
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: '<span class="inner">inner</span>' });

      this.render('<span class="outer">outer</span>{{foo-bar}}');

      var $span = instance.$('span');

      assert.equal($span.length, 1);
      assert.equal($span.attr('class'), 'inner');

      this.runTask(function () {
        return _this19.rerender();
      });

      $span = instance.$('span');

      assert.equal($span.length, 1);
      assert.equal($span.attr('class'), 'inner');
    };

    _class.prototype['@test an empty component does not have childNodes'] = function testAnEmptyComponentDoesNotHaveChildNodes(assert) {
      var _this20 = this;

      var fooBarInstance = undefined;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: 'input',
        init: function () {
          this._super();
          fooBarInstance = this;
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: '' });

      this.render('{{foo-bar}}');

      this.assertComponentElement(this.firstChild, { tagName: 'input' });

      assert.strictEqual(fooBarInstance.element.childNodes.length, 0);

      this.runTask(function () {
        return _this20.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'input' });

      assert.strictEqual(fooBarInstance.element.childNodes.length, 0);
    };

    _class.prototype['@test it has the right parentView and childViews'] = function testItHasTheRightParentViewAndChildViews(assert) {
      var _this21 = this;

      var fooBarInstance = undefined,
          fooBarBazInstance = undefined;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super();
          fooBarInstance = this;
        }
      });

      var FooBarBazComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super();
          fooBarBazInstance = this;
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'foo-bar {{foo-bar-baz}}' });
      this.registerComponent('foo-bar-baz', { ComponentClass: FooBarBazComponent, template: 'foo-bar-baz' });

      this.render('{{foo-bar}}');
      this.assertText('foo-bar foo-bar-baz');

      assert.equal(fooBarInstance.parentView, this.component);
      assert.equal(fooBarBazInstance.parentView, fooBarInstance);

      assert.deepEqual(this.component.childViews, [fooBarInstance]);
      assert.deepEqual(fooBarInstance.childViews, [fooBarBazInstance]);

      this.runTask(function () {
        return _this21.rerender();
      });
      this.assertText('foo-bar foo-bar-baz');

      assert.equal(fooBarInstance.parentView, this.component);
      assert.equal(fooBarBazInstance.parentView, fooBarInstance);

      assert.deepEqual(this.component.childViews, [fooBarInstance]);
      assert.deepEqual(fooBarInstance.childViews, [fooBarBazInstance]);
    };

    _class.prototype['@test it renders passed named arguments'] = function testItRendersPassedNamedArguments() {
      var _this22 = this;

      this.registerComponent('foo-bar', {
        template: '{{foo}}'
      });

      this.render('{{foo-bar foo=model.bar}}', {
        model: {
          bar: 'Hola'
        }
      });

      this.assertText('Hola');

      this.runTask(function () {
        return _this22.rerender();
      });

      this.assertText('Hola');

      this.runTask(function () {
        return _this22.context.set('model.bar', 'Hello');
      });

      this.assertText('Hello');

      this.runTask(function () {
        return _this22.context.set('model', { bar: 'Hola' });
      });

      this.assertText('Hola');
    };

    _class.prototype['@test it can render a basic component with a block'] = function testItCanRenderABasicComponentWithABlock() {
      var _this23 = this;

      this.registerComponent('foo-bar', { template: '{{yield}} - In component' });

      this.render('{{#foo-bar}}hello{{/foo-bar}}');

      this.assertComponentElement(this.firstChild, { content: 'hello - In component' });

      this.runTask(function () {
        return _this23.rerender();
      });

      this.assertComponentElement(this.firstChild, { content: 'hello - In component' });
    };

    _class.prototype['@test it can render a basic component with a block when the yield is in a partial'] = function testItCanRenderABasicComponentWithABlockWhenTheYieldIsInAPartial() {
      var _this24 = this;

      this.registerPartial('_partialWithYield', 'yielded: [{{yield}}]');

      this.registerComponent('foo-bar', { template: '{{partial "partialWithYield"}} - In component' });

      this.render('{{#foo-bar}}hello{{/foo-bar}}');

      this.assertComponentElement(this.firstChild, { content: 'yielded: [hello] - In component' });

      this.runTask(function () {
        return _this24.rerender();
      });

      this.assertComponentElement(this.firstChild, { content: 'yielded: [hello] - In component' });
    };

    _class.prototype['@test it can render a basic component with a block param when the yield is in a partial'] = function testItCanRenderABasicComponentWithABlockParamWhenTheYieldIsInAPartial() {
      var _this25 = this;

      this.registerPartial('_partialWithYield', 'yielded: [{{yield "hello"}}]');

      this.registerComponent('foo-bar', { template: '{{partial "partialWithYield"}} - In component' });

      this.render('{{#foo-bar as |value|}}{{value}}{{/foo-bar}}');

      this.assertComponentElement(this.firstChild, { content: 'yielded: [hello] - In component' });

      this.runTask(function () {
        return _this25.rerender();
      });

      this.assertComponentElement(this.firstChild, { content: 'yielded: [hello] - In component' });
    };

    _class.prototype['@test it renders the layout with the component instance as the context'] = function testItRendersTheLayoutWithTheComponentInstanceAsTheContext() {
      var _this26 = this;

      var instance = undefined;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super();
          instance = this;
          this.set('message', 'hello');
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: '{{message}}' });

      this.render('{{foo-bar}}');

      this.assertComponentElement(this.firstChild, { content: 'hello' });

      this.runTask(function () {
        return _this26.rerender();
      });

      this.assertComponentElement(this.firstChild, { content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(instance, 'message', 'goodbye');
      });

      this.assertComponentElement(this.firstChild, { content: 'goodbye' });

      this.runTask(function () {
        return _emberMetal.set(instance, 'message', 'hello');
      });

      this.assertComponentElement(this.firstChild, { content: 'hello' });
    };

    _class.prototype['@test it preserves the outer context when yielding'] = function testItPreservesTheOuterContextWhenYielding() {
      var _this27 = this;

      this.registerComponent('foo-bar', { template: '{{yield}}' });

      this.render('{{#foo-bar}}{{message}}{{/foo-bar}}', { message: 'hello' });

      this.assertComponentElement(this.firstChild, { content: 'hello' });

      this.runTask(function () {
        return _this27.rerender();
      });

      this.assertComponentElement(this.firstChild, { content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this27.context, 'message', 'goodbye');
      });

      this.assertComponentElement(this.firstChild, { content: 'goodbye' });

      this.runTask(function () {
        return _emberMetal.set(_this27.context, 'message', 'hello');
      });

      this.assertComponentElement(this.firstChild, { content: 'hello' });
    };

    _class.prototype['@test it can yield a block param named for reserved words [GH#14096]'] = function testItCanYieldABlockParamNamedForReservedWordsGH14096() {
      var instance = undefined;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          instance = this;
        },

        name: 'foo-bar'
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: '{{yield this}}' });

      this.render('{{#foo-bar as |component|}}{{component.name}}{{/foo-bar}}');

      this.assertComponentElement(this.firstChild, { content: 'foo-bar' });

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(instance, 'name', 'derp-qux');
      });

      this.assertComponentElement(this.firstChild, { content: 'derp-qux' });

      this.runTask(function () {
        return _emberMetal.set(instance, 'name', 'foo-bar');
      });

      this.assertComponentElement(this.firstChild, { content: 'foo-bar' });
    };

    _class.prototype['@test it can yield internal and external properties positionally'] = function testItCanYieldInternalAndExternalPropertiesPositionally() {
      var _this28 = this;

      var instance = undefined;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          instance = this;
        },
        greeting: 'hello'
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: '{{yield greeting greetee.firstName}}' });

      this.render('{{#foo-bar greetee=person as |greeting name|}}{{name}} {{person.lastName}}, {{greeting}}{{/foo-bar}}', {
        person: {
          firstName: 'Joel',
          lastName: 'Kang'
        }
      });

      this.assertComponentElement(this.firstChild, { content: 'Joel Kang, hello' });

      this.runTask(function () {
        return _this28.rerender();
      });

      this.assertComponentElement(this.firstChild, { content: 'Joel Kang, hello' });

      this.runTask(function () {
        return _emberMetal.set(_this28.context, 'person', { firstName: 'Dora', lastName: 'the Explorer' });
      });

      this.assertComponentElement(this.firstChild, { content: 'Dora the Explorer, hello' });

      this.runTask(function () {
        return _emberMetal.set(instance, 'greeting', 'hola');
      });

      this.assertComponentElement(this.firstChild, { content: 'Dora the Explorer, hola' });

      this.runTask(function () {
        _emberMetal.set(instance, 'greeting', 'hello');
        _emberMetal.set(_this28.context, 'person', {
          firstName: 'Joel',
          lastName: 'Kang'
        });
      });

      this.assertComponentElement(this.firstChild, { content: 'Joel Kang, hello' });
    };

    _class.prototype['@test #11519 - block param infinite loop'] = function test11519BlockParamInfiniteLoop() {
      var _this29 = this;

      var instance = undefined;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          instance = this;
        },
        danger: 0
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: '{{danger}}{{yield danger}}' });

      // On initial render, create streams. The bug will not have manifested yet, but at this point
      // we have created streams that create a circular invalidation.
      this.render('{{#foo-bar as |dangerBlockParam|}}{{/foo-bar}}');

      this.assertText('0');

      // Trigger a non-revalidating re-render. The yielded block will not be dirtied
      // nor will block param streams, and thus no infinite loop will occur.
      this.runTask(function () {
        return _this29.rerender();
      });

      this.assertText('0');

      // Trigger a revalidation, which will cause an infinite loop without the fix
      // in place.  Note that we do not see the infinite loop is in testing mode,
      // because a deprecation warning about re-renders is issued, which Ember
      // treats as an exception.
      this.runTask(function () {
        return _emberMetal.set(instance, 'danger', 1);
      });

      this.assertText('1');

      this.runTask(function () {
        return _emberMetal.set(instance, 'danger', 0);
      });

      this.assertText('0');
    };

    _class.prototype['@test the component and its child components are destroyed'] = function testTheComponentAndItsChildComponentsAreDestroyed(assert) {
      var _this30 = this;

      var destroyed = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 };

      this.registerComponent('foo-bar', {
        template: '{{id}} {{yield}}',
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          willDestroy: function () {
            this._super();
            destroyed[this.get('id')]++;
          }
        })
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2), {
        cond1: true,
        cond2: true,
        cond3: true,
        cond4: true,
        cond5: true
      });

      this.assertText('1 2 3 4 5 6 7 8 ');

      this.runTask(function () {
        return _this30.rerender();
      });

      assert.deepEqual(destroyed, { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });

      this.runTask(function () {
        return _emberMetal.set(_this30.context, 'cond5', false);
      });

      this.assertText('1 2 3 4 8 ');

      assert.deepEqual(destroyed, { 1: 0, 2: 0, 3: 0, 4: 0, 5: 1, 6: 1, 7: 1, 8: 0 });

      this.runTask(function () {
        _emberMetal.set(_this30.context, 'cond3', false);
        _emberMetal.set(_this30.context, 'cond5', true);
        _emberMetal.set(_this30.context, 'cond4', false);
      });

      assert.deepEqual(destroyed, { 1: 0, 2: 0, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1 });

      this.runTask(function () {
        _emberMetal.set(_this30.context, 'cond2', false);
        _emberMetal.set(_this30.context, 'cond1', false);
      });

      assert.deepEqual(destroyed, { 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1 });
    };

    _class.prototype['@test should escape HTML in normal mustaches'] = function testShouldEscapeHTMLInNormalMustaches() {
      var _this31 = this;

      var component = undefined;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        },
        output: 'you need to be more <b>bold</b>'
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: '{{output}}' });

      this.render('{{foo-bar}}');

      this.assertText('you need to be more <b>bold</b>');

      this.runTask(function () {
        return _this31.rerender();
      });

      this.assertText('you need to be more <b>bold</b>');

      this.runTask(function () {
        return _emberMetal.set(component, 'output', 'you are so <i>super</i>');
      });

      this.assertText('you are so <i>super</i>');

      this.runTask(function () {
        return _emberMetal.set(component, 'output', 'you need to be more <b>bold</b>');
      });
    };

    _class.prototype['@test should not escape HTML in triple mustaches'] = function testShouldNotEscapeHTMLInTripleMustaches(assert) {
      var _this32 = this;

      var expectedHtmlBold = 'you need to be more <b>bold</b>';
      var expectedHtmlItalic = 'you are so <i>super</i>';
      var component = undefined;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        },
        output: expectedHtmlBold
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: '{{{output}}}' });

      this.render('{{foo-bar}}');

      _emberGlimmerTestsUtilsTestHelpers.equalTokens(this.firstChild, expectedHtmlBold);

      this.runTask(function () {
        return _this32.rerender();
      });

      _emberGlimmerTestsUtilsTestHelpers.equalTokens(this.firstChild, expectedHtmlBold);

      this.runTask(function () {
        return _emberMetal.set(component, 'output', expectedHtmlItalic);
      });

      _emberGlimmerTestsUtilsTestHelpers.equalTokens(this.firstChild, expectedHtmlItalic);

      this.runTask(function () {
        return _emberMetal.set(component, 'output', expectedHtmlBold);
      });

      _emberGlimmerTestsUtilsTestHelpers.equalTokens(this.firstChild, expectedHtmlBold);
    };

    _class.prototype['@test should not escape HTML if string is a htmlSafe'] = function testShouldNotEscapeHTMLIfStringIsAHtmlSafe(assert) {
      var _this33 = this;

      var expectedHtmlBold = 'you need to be more <b>bold</b>';
      var expectedHtmlItalic = 'you are so <i>super</i>';
      var component = undefined;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        },
        output: _emberGlimmerTestsUtilsHelpers.htmlSafe(expectedHtmlBold)
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: '{{output}}' });

      this.render('{{foo-bar}}');

      _emberGlimmerTestsUtilsTestHelpers.equalTokens(this.firstChild, expectedHtmlBold);

      this.runTask(function () {
        return _this33.rerender();
      });

      _emberGlimmerTestsUtilsTestHelpers.equalTokens(this.firstChild, expectedHtmlBold);

      this.runTask(function () {
        return _emberMetal.set(component, 'output', _emberGlimmerTestsUtilsHelpers.htmlSafe(expectedHtmlItalic));
      });

      _emberGlimmerTestsUtilsTestHelpers.equalTokens(this.firstChild, expectedHtmlItalic);

      this.runTask(function () {
        return _emberMetal.set(component, 'output', _emberGlimmerTestsUtilsHelpers.htmlSafe(expectedHtmlBold));
      });

      _emberGlimmerTestsUtilsTestHelpers.equalTokens(this.firstChild, expectedHtmlBold);
    };

    _class.prototype['@test late bound layouts return the same definition'] = function testLateBoundLayoutsReturnTheSameDefinition(assert) {
      var templateIds = [];

      // This is testing the scenario where you import a template and
      // set it to the layout property:
      //
      // import layout from './template';
      //
      // export default Ember.Component.extend({
      //   layout
      // });
      var hello = _emberGlimmerTestsUtilsHelpers.compile('Hello');
      var bye = _emberGlimmerTestsUtilsHelpers.compile('Bye');

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          this.layout = this.cond ? hello : bye;
          templateIds.push(this.layout.id);
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent });

      this.render('{{foo-bar cond=true}}{{foo-bar cond=false}}{{foo-bar cond=true}}{{foo-bar cond=false}}');

      var t1 = templateIds[0];
      var t2 = templateIds[1];
      var t3 = templateIds[2];
      var t4 = templateIds[3];

      assert.equal(t1, t3);
      assert.equal(t2, t4);
    };

    _class.prototype['@test can use isStream property without conflict (#13271)'] = function testCanUseIsStreamPropertyWithoutConflict13271() {
      var _this34 = this;

      var component = undefined;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        isStream: true,

        init: function () {
          this._super.apply(this, arguments);
          component = this;
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,

        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject3)
      });

      this.render('{{foo-bar}}');

      this.assertComponentElement(this.firstChild, { content: 'true' });

      this.runTask(function () {
        return _this34.rerender();
      });

      this.assertComponentElement(this.firstChild, { content: 'true' });

      this.runTask(function () {
        return _emberMetal.set(component, 'isStream', false);
      });

      this.assertComponentElement(this.firstChild, { content: 'false' });

      this.runTask(function () {
        return _emberMetal.set(component, 'isStream', true);
      });

      this.assertComponentElement(this.firstChild, { content: 'true' });
    };

    _class.prototype['@test lookup of component takes priority over property'] = function testLookupOfComponentTakesPriorityOverProperty() {
      var _this35 = this;

      this.registerComponent('some-component', {
        template: 'some-component'
      });

      this.render('{{some-prop}} {{some-component}}', {
        'some-component': 'not-some-component',
        'some-prop': 'some-prop'
      });

      this.assertText('some-prop some-component');

      this.runTask(function () {
        return _this35.rerender();
      });

      this.assertText('some-prop some-component');
    };

    _class.prototype['@test component without dash is not looked up'] = function testComponentWithoutDashIsNotLookedUp() {
      var _this36 = this;

      this.registerComponent('somecomponent', {
        template: 'somecomponent'
      });

      this.render('{{somecomponent}}', {
        'somecomponent': 'notsomecomponent'
      });

      this.assertText('notsomecomponent');

      this.runTask(function () {
        return _this36.rerender();
      });

      this.assertText('notsomecomponent');

      this.runTask(function () {
        return _this36.context.set('somecomponent', 'not not notsomecomponent');
      });

      this.assertText('not not notsomecomponent');

      this.runTask(function () {
        return _this36.context.set('somecomponent', 'notsomecomponent');
      });

      this.assertText('notsomecomponent');
    };

    _class.prototype['@test non-block with properties on attrs'] = function testNonBlockWithPropertiesOnAttrs() {
      var _this37 = this;

      this.registerComponent('non-block', {
        template: 'In layout - someProp: {{attrs.someProp}}'
      });

      this.render('{{non-block someProp=prop}}', {
        prop: 'something here'
      });

      this.assertText('In layout - someProp: something here');

      this.runTask(function () {
        return _this37.rerender();
      });

      this.assertText('In layout - someProp: something here');

      this.runTask(function () {
        return _this37.context.set('prop', 'other thing there');
      });

      this.assertText('In layout - someProp: other thing there');

      this.runTask(function () {
        return _this37.context.set('prop', 'something here');
      });

      this.assertText('In layout - someProp: something here');
    };

    _class.prototype['@test non-block with properties overridden in init'] = function testNonBlockWithPropertiesOverriddenInInit() {
      var _this38 = this;

      var instance = undefined;
      this.registerComponent('non-block', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            instance = this;
            this.someProp = 'value set in instance';
          }
        }),
        template: 'In layout - someProp: {{someProp}}'
      });

      this.render('{{non-block someProp=prop}}', {
        prop: 'something passed when invoked'
      });

      this.assertText('In layout - someProp: value set in instance');

      this.runTask(function () {
        return _this38.rerender();
      });

      this.assertText('In layout - someProp: value set in instance');

      this.runTask(function () {
        return _this38.context.set('prop', 'updated something passed when invoked');
      });

      this.assertText('In layout - someProp: updated something passed when invoked');

      this.runTask(function () {
        return instance.set('someProp', 'update value set in instance');
      });

      this.assertText('In layout - someProp: update value set in instance');

      this.runTask(function () {
        return _this38.context.set('prop', 'something passed when invoked');
      });
      this.runTask(function () {
        return instance.set('someProp', 'value set in instance');
      });

      this.assertText('In layout - someProp: value set in instance');
    };

    _class.prototype['@test rerendering component with attrs from parent'] = function testRerenderingComponentWithAttrsFromParent(assert) {
      var _this39 = this;

      var willUpdateCount = 0;
      var didReceiveAttrsCount = 0;

      function expectHooks(_ref, callback) {
        var willUpdate = _ref.willUpdate;
        var didReceiveAttrs = _ref.didReceiveAttrs;

        willUpdateCount = 0;
        didReceiveAttrsCount = 0;

        callback();

        if (willUpdate) {
          assert.strictEqual(willUpdateCount, 1, 'The willUpdate hook was fired');
        } else {
          assert.strictEqual(willUpdateCount, 0, 'The willUpdate hook was not fired');
        }

        if (didReceiveAttrs) {
          assert.strictEqual(didReceiveAttrsCount, 1, 'The didReceiveAttrs hook was fired');
        } else {
          assert.strictEqual(didReceiveAttrsCount, 0, 'The didReceiveAttrs hook was not fired');
        }
      }

      this.registerComponent('non-block', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didReceiveAttrs: function () {
            didReceiveAttrsCount++;
          },

          willUpdate: function () {
            willUpdateCount++;
          }
        }),
        template: 'In layout - someProp: {{someProp}}'
      });

      expectHooks({ willUpdate: false, didReceiveAttrs: true }, function () {
        _this39.render('{{non-block someProp=someProp}}', {
          someProp: 'wycats'
        });
      });

      this.assertText('In layout - someProp: wycats');

      // Note: Hooks are not fired in Glimmer for idempotent re-renders
      expectHooks({ willUpdate: false, didReceiveAttrs: false }, function () {
        _this39.runTask(function () {
          return _this39.rerender();
        });
      });

      this.assertText('In layout - someProp: wycats');

      expectHooks({ willUpdate: true, didReceiveAttrs: true }, function () {
        _this39.runTask(function () {
          return _this39.context.set('someProp', 'tomdale');
        });
      });

      this.assertText('In layout - someProp: tomdale');

      // Note: Hooks are not fired in Glimmer for idempotent re-renders
      expectHooks({ willUpdate: false, didReceiveAttrs: false }, function () {
        _this39.runTask(function () {
          return _this39.rerender();
        });
      });

      this.assertText('In layout - someProp: tomdale');

      expectHooks({ willUpdate: true, didReceiveAttrs: true }, function () {
        _this39.runTask(function () {
          return _this39.context.set('someProp', 'wycats');
        });
      });

      this.assertText('In layout - someProp: wycats');
    };

    _class.prototype['@test this.attrs.foo === attrs.foo === foo'] = function testThisAttrsFooAttrsFooFoo() {
      var _this40 = this;

      this.registerComponent('foo-bar', {
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject4)
      });

      this.render('{{foo-bar value=model.value items=model.items}}', {
        model: {
          value: 'wat',
          items: [1, 2, 3]
        }
      });

      this.assertStableRerender();

      this.runTask(function () {
        _this40.context.set('model.value', 'lul');
        _this40.context.set('model.items', [1]);
      });

      this.assertText(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject5));

      this.runTask(function () {
        return _this40.context.set('model', { value: 'wat', items: [1, 2, 3] });
      });

      this.assertText('Args: wat | wat | wat123123123');
    };

    _class.prototype['@test non-block with properties on self'] = function testNonBlockWithPropertiesOnSelf() {
      var _this41 = this;

      this.registerComponent('non-block', {
        template: 'In layout - someProp: {{someProp}}'
      });

      this.render('{{non-block someProp=prop}}', {
        prop: 'something here'
      });

      this.assertText('In layout - someProp: something here');

      this.runTask(function () {
        return _this41.rerender();
      });

      this.assertText('In layout - someProp: something here');

      this.runTask(function () {
        return _this41.context.set('prop', 'something else');
      });

      this.assertText('In layout - someProp: something else');

      this.runTask(function () {
        return _this41.context.set('prop', 'something here');
      });

      this.assertText('In layout - someProp: something here');
    };

    _class.prototype['@test block with properties on self'] = function testBlockWithPropertiesOnSelf() {
      var _this42 = this;

      this.registerComponent('with-block', {
        template: 'In layout - someProp: {{someProp}} - {{yield}}'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject6), {
        prop: 'something here'
      });

      this.assertText('In layout - someProp: something here - In template');

      this.runTask(function () {
        return _this42.rerender();
      });

      this.assertText('In layout - someProp: something here - In template');

      this.runTask(function () {
        return _this42.context.set('prop', 'something else');
      });

      this.assertText('In layout - someProp: something else - In template');

      this.runTask(function () {
        return _this42.context.set('prop', 'something here');
      });

      this.assertText('In layout - someProp: something here - In template');
    };

    _class.prototype['@test block with properties on attrs'] = function testBlockWithPropertiesOnAttrs() {
      var _this43 = this;

      this.registerComponent('with-block', {
        template: 'In layout - someProp: {{attrs.someProp}} - {{yield}}'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject6), {
        prop: 'something here'
      });

      this.assertText('In layout - someProp: something here - In template');

      this.runTask(function () {
        return _this43.rerender();
      });

      this.assertText('In layout - someProp: something here - In template');

      this.runTask(function () {
        return _this43.context.set('prop', 'something else');
      });

      this.assertText('In layout - someProp: something else - In template');

      this.runTask(function () {
        return _this43.context.set('prop', 'something here');
      });

      this.assertText('In layout - someProp: something here - In template');
    };

    _class.prototype['@test static arbitrary number of positional parameters'] = function testStaticArbitraryNumberOfPositionalParameters(assert) {
      var _this44 = this;

      this.registerComponent('sample-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: 'names'
        }),
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject7)
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject8));

      assert.equal(this.$('#args-3').text(), 'Foo4Bar');
      assert.equal(this.$('#args-5').text(), 'Foo4Bar5Baz');

      this.runTask(function () {
        return _this44.rerender();
      });

      assert.equal(this.$('#args-3').text(), 'Foo4Bar');
      assert.equal(this.$('#args-5').text(), 'Foo4Bar5Baz');
    };

    _class.prototype['@test arbitrary positional parameter conflict with hash parameter is reported'] = function testArbitraryPositionalParameterConflictWithHashParameterIsReported() {
      var _this45 = this;

      this.registerComponent('sample-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: 'names'
        }),
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject7)
      });

      expectAssertion(function () {
        _this45.render('{{sample-component "Foo" 4 "Bar" names=numbers id="args-3"}}', {
          numbers: [1, 2, 3]
        });
      }, 'You cannot specify positional parameters and the hash argument `names`.');
    };

    _class.prototype['@test can use hash parameter instead of arbitrary positional param [GH #12444]'] = function testCanUseHashParameterInsteadOfArbitraryPositionalParamGH12444(assert) {
      var _this46 = this;

      this.registerComponent('sample-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: 'names'
        }),
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject7)
      });

      this.render('{{sample-component names=things}}', {
        things: _emberRuntime.A(['Foo', 4, 'Bar'])
      });

      this.assertText('Foo4Bar');

      this.runTask(function () {
        return _this46.rerender();
      });

      this.assertText('Foo4Bar');

      this.runTask(function () {
        return _this46.context.get('things').pushObject(5);
      });

      this.assertText('Foo4Bar5');

      this.runTask(function () {
        return _this46.context.get('things').shiftObject();
      });

      this.assertText('4Bar5');

      this.runTask(function () {
        return _this46.context.get('things').clear();
      });

      this.assertText('');

      this.runTask(function () {
        return _this46.context.set('things', _emberRuntime.A(['Foo', 4, 'Bar']));
      });

      this.assertText('Foo4Bar');
    };

    _class.prototype['@test can use hash parameter instead of positional param'] = function testCanUseHashParameterInsteadOfPositionalParam(assert) {
      var _this47 = this;

      this.registerComponent('sample-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: ['first', 'second']
        }),
        template: '{{first}} - {{second}}'
      });

      // TODO: Fix when id is implemented
      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject9));

      assert.equal(this.$('#two-positional').text(), 'one - two');
      assert.equal(this.$('#one-positional').text(), 'one - two');
      assert.equal(this.$('#no-positional').text(), 'one - two');

      this.runTask(function () {
        return _this47.rerender();
      });

      assert.equal(this.$('#two-positional').text(), 'one - two');
      assert.equal(this.$('#one-positional').text(), 'one - two');
      assert.equal(this.$('#no-positional').text(), 'one - two');
    };

    _class.prototype['@test dynamic arbitrary number of positional parameters'] = function testDynamicArbitraryNumberOfPositionalParameters(assert) {
      var _this48 = this;

      this.registerComponent('sample-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: 'n'
        }),
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject10)
      });

      this.render('{{sample-component user1 user2}}', {
        user1: 'Foo',
        user2: 4
      });

      this.assertText('Foo4');

      this.runTask(function () {
        return _this48.rerender();
      });

      this.assertText('Foo4');

      this.runTask(function () {
        return _this48.context.set('user1', 'Bar');
      });

      this.assertText('Bar4');

      this.runTask(function () {
        return _this48.context.set('user2', '5');
      });

      this.assertText('Bar5');

      this.runTask(function () {
        _this48.context.set('user1', 'Foo');
        _this48.context.set('user2', 4);
      });

      this.assertText('Foo4');
    };

    _class.prototype['@test with ariaRole specified'] = function testWithAriaRoleSpecified() {
      var _this49 = this;

      this.registerComponent('aria-test', {
        template: 'Here!'
      });

      this.render('{{aria-test ariaRole=role}}', {
        role: 'main'
      });

      this.assertComponentElement(this.firstChild, { attrs: { role: 'main' } });

      this.runTask(function () {
        return _this49.rerender();
      });

      this.assertComponentElement(this.firstChild, { attrs: { role: 'main' } });

      this.runTask(function () {
        return _this49.context.set('role', 'input');
      });

      this.assertComponentElement(this.firstChild, { attrs: { role: 'input' } });

      this.runTask(function () {
        return _this49.context.set('role', 'main');
      });

      this.assertComponentElement(this.firstChild, { attrs: { role: 'main' } });
    };

    _class.prototype['@test `template` specified in component is overriden by block'] = function testTemplateSpecifiedInComponentIsOverridenByBlock() {
      var _this50 = this;

      this.registerComponent('with-template', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          template: _emberGlimmerTestsUtilsHelpers.compile('Should not be used')
        }),
        template: '[In layout - {{name}}] {{yield}}'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject11), {
        name: 'Whoop, whoop!'
      });

      this.assertText('[In layout - with-block] [In block - Whoop, whoop!][In layout - without-block] ');

      this.runTask(function () {
        return _this50.rerender();
      });

      this.assertText('[In layout - with-block] [In block - Whoop, whoop!][In layout - without-block] ');

      this.runTask(function () {
        return _this50.context.set('name', 'Ole, ole');
      });

      this.assertText('[In layout - with-block] [In block - Ole, ole][In layout - without-block] ');

      this.runTask(function () {
        return _this50.context.set('name', 'Whoop, whoop!');
      });

      this.assertText('[In layout - with-block] [In block - Whoop, whoop!][In layout - without-block] ');
    };

    _class.prototype['@test hasBlock is true when block supplied'] = function testHasBlockIsTrueWhenBlockSupplied() {
      var _this51 = this;

      this.registerComponent('with-block', {
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject12)
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject13));

      this.assertText('In template');

      this.runTask(function () {
        return _this51.rerender();
      });

      this.assertText('In template');
    };

    _class.prototype['@test hasBlock is false when no block supplied'] = function testHasBlockIsFalseWhenNoBlockSupplied() {
      var _this52 = this;

      this.registerComponent('with-block', {
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject12)
      });

      this.render('{{with-block}}');

      this.assertText('No Block!');

      this.runTask(function () {
        return _this52.rerender();
      });

      this.assertText('No Block!');
    };

    _class.prototype['@test hasBlockParams is true when block param supplied'] = function testHasBlockParamsIsTrueWhenBlockParamSupplied() {
      var _this53 = this;

      this.registerComponent('with-block', {
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject14)
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject15));

      this.assertText('In template - In Component');

      this.runTask(function () {
        return _this53.rerender();
      });

      this.assertText('In template - In Component');
    };

    _class.prototype['@test hasBlockParams is false when no block param supplied'] = function testHasBlockParamsIsFalseWhenNoBlockParamSupplied() {
      var _this54 = this;

      this.registerComponent('with-block', {
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject16)
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject17));

      this.assertText('In block No Block Param!');

      this.runTask(function () {
        return _this54.rerender();
      });

      this.assertText('In block No Block Param!');
    };

    _class.prototype['@test static named positional parameters'] = function testStaticNamedPositionalParameters() {
      var _this55 = this;

      this.registerComponent('sample-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: ['name', 'age']
        }),
        template: '{{name}}{{age}}'
      });

      this.render('{{sample-component "Quint" 4}}');

      this.assertText('Quint4');

      this.runTask(function () {
        return _this55.rerender();
      });

      this.assertText('Quint4');
    };

    _class.prototype['@test dynamic named positional parameters'] = function testDynamicNamedPositionalParameters() {
      var _this56 = this;

      this.registerComponent('sample-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: ['name', 'age']
        }),
        template: '{{name}}{{age}}'
      });

      this.render('{{sample-component myName myAge}}', {
        myName: 'Quint',
        myAge: 4
      });

      this.assertText('Quint4');

      this.runTask(function () {
        return _this56.rerender();
      });

      this.assertText('Quint4');

      this.runTask(function () {
        return _this56.context.set('myName', 'Sergio');
      });

      this.assertText('Sergio4');

      this.runTask(function () {
        return _this56.context.set('myAge', 2);
      });

      this.assertText('Sergio2');

      this.runTask(function () {
        _this56.context.set('myName', 'Quint');
        _this56.context.set('myAge', 4);
      });

      this.assertText('Quint4');
    };

    _class.prototype['@test if a value is passed as a non-positional parameter, it raises an assertion'] = function testIfAValueIsPassedAsANonPositionalParameterItRaisesAnAssertion() {
      var _this57 = this;

      this.registerComponent('sample-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: ['name']
        }),
        template: '{{name}}'
      });

      expectAssertion(function () {
        _this57.render('{{sample-component notMyName name=myName}}', {
          myName: 'Quint',
          notMyName: 'Sergio'
        });
      }, 'You cannot specify both a positional param (at position 0) and the hash argument `name`.');
    };

    _class.prototype['@test yield to inverse'] = function testYieldToInverse() {
      var _this58 = this;

      this.registerComponent('my-if', {
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject18)
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject19), {
        activated: true
      });

      this.assertText('Yes:Hello42');

      this.runTask(function () {
        return _this58.rerender();
      });

      this.assertText('Yes:Hello42');

      this.runTask(function () {
        return _this58.context.set('activated', false);
      });

      this.assertText('No:Goodbye');

      this.runTask(function () {
        return _this58.context.set('activated', true);
      });

      this.assertText('Yes:Hello42');
    };

    _class.prototype['@test expression hasBlock inverse'] = function testExpressionHasBlockInverse(assert) {
      this.registerComponent('check-inverse', {
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject20)
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject21));

      this.assertComponentElement(this.firstChild, { content: 'No' });
      this.assertComponentElement(this.nthChild(1), { content: 'Yes' });

      this.assertStableRerender();
    };

    _class.prototype['@test expression hasBlock default'] = function testExpressionHasBlockDefault(assert) {
      this.registerComponent('check-block', {
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject22)
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject23));

      this.assertComponentElement(this.firstChild, { content: 'No' });
      this.assertComponentElement(this.nthChild(1), { content: 'Yes' });

      this.assertStableRerender();
    };

    _class.prototype['@test expression hasBlockParams inverse'] = function testExpressionHasBlockParamsInverse(assert) {
      this.registerComponent('check-inverse', {
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject24)
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject25));

      this.assertComponentElement(this.firstChild, { content: 'No' });
      this.assertComponentElement(this.nthChild(1), { content: 'No' });

      this.assertStableRerender();
    };

    _class.prototype['@test expression hasBlockParams default'] = function testExpressionHasBlockParamsDefault(assert) {
      this.registerComponent('check-block', {
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject26)
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject27));

      this.assertComponentElement(this.firstChild, { content: 'No' });
      this.assertComponentElement(this.nthChild(1), { content: 'Yes' });

      this.assertStableRerender();
    };

    _class.prototype['@test non-expression hasBlock'] = function testNonExpressionHasBlock(assert) {
      this.registerComponent('check-block', {
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject28)
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject23));

      this.assertComponentElement(this.firstChild, { content: 'No' });
      this.assertComponentElement(this.nthChild(1), { content: 'Yes' });

      this.assertStableRerender();
    };

    _class.prototype['@test expression hasBlockParams'] = function testExpressionHasBlockParams(assert) {
      this.registerComponent('check-params', {
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject26)
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject29));

      this.assertComponentElement(this.firstChild, { content: 'No' });
      this.assertComponentElement(this.nthChild(1), { content: 'Yes' });

      this.assertStableRerender();
    };

    _class.prototype['@test non-expression hasBlockParams'] = function testNonExpressionHasBlockParams(assert) {
      this.registerComponent('check-params', {
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject30)
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject29));

      this.assertComponentElement(this.firstChild, { content: 'No' });
      this.assertComponentElement(this.nthChild(1), { content: 'Yes' });

      this.assertStableRerender();
    };

    _class.prototype['@test hasBlock expression in an attribute'] = function testHasBlockExpressionInAnAttribute(assert) {
      this.registerComponent('check-attr', {
        template: '<button name={{hasBlock}}></button>'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject31));

      _emberGlimmerTestsUtilsTestHelpers.equalsElement(this.$('button')[0], 'button', { name: 'false' }, '');
      _emberGlimmerTestsUtilsTestHelpers.equalsElement(this.$('button')[1], 'button', { name: 'true' }, '');

      this.assertStableRerender();
    };

    _class.prototype['@test hasBlock inverse expression in an attribute'] = function testHasBlockInverseExpressionInAnAttribute(assert) {
      this.registerComponent('check-attr', {
        template: '<button name={{hasBlock "inverse"}}></button>'
      }, '');

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject32));

      _emberGlimmerTestsUtilsTestHelpers.equalsElement(this.$('button')[0], 'button', { name: 'false' }, '');
      _emberGlimmerTestsUtilsTestHelpers.equalsElement(this.$('button')[1], 'button', { name: 'true' }, '');

      this.assertStableRerender();
    };

    _class.prototype['@test hasBlockParams expression in an attribute'] = function testHasBlockParamsExpressionInAnAttribute(assert) {
      this.registerComponent('check-attr', {
        template: '<button name={{hasBlockParams}}></button>'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject33));

      _emberGlimmerTestsUtilsTestHelpers.equalsElement(this.$('button')[0], 'button', { name: 'false' }, '');
      _emberGlimmerTestsUtilsTestHelpers.equalsElement(this.$('button')[1], 'button', { name: 'true' }, '');

      this.assertStableRerender();
    };

    _class.prototype['@test hasBlockParams inverse expression in an attribute'] = function testHasBlockParamsInverseExpressionInAnAttribute(assert) {
      this.registerComponent('check-attr', {
        template: '<button name={{hasBlockParams "inverse"}}></button>'
      }, '');

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject33));

      _emberGlimmerTestsUtilsTestHelpers.equalsElement(this.$('button')[0], 'button', { name: 'false' }, '');
      _emberGlimmerTestsUtilsTestHelpers.equalsElement(this.$('button')[1], 'button', { name: 'false' }, '');

      this.assertStableRerender();
    };

    _class.prototype['@test hasBlock as a param to a helper'] = function testHasBlockAsAParamToAHelper(assert) {
      this.registerComponent('check-helper', {
        template: '{{if hasBlock "true" "false"}}'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject34));

      this.assertComponentElement(this.firstChild, { content: 'false' });
      this.assertComponentElement(this.nthChild(1), { content: 'true' });

      this.assertStableRerender();
    };

    _class.prototype['@test hasBlock as an expression param to a helper'] = function testHasBlockAsAnExpressionParamToAHelper(assert) {
      this.registerComponent('check-helper', {
        template: '{{if (hasBlock) "true" "false"}}'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject34));

      this.assertComponentElement(this.firstChild, { content: 'false' });
      this.assertComponentElement(this.nthChild(1), { content: 'true' });

      this.assertStableRerender();
    };

    _class.prototype['@test hasBlock inverse as a param to a helper'] = function testHasBlockInverseAsAParamToAHelper(assert) {
      this.registerComponent('check-helper', {
        template: '{{if (hasBlock "inverse") "true" "false"}}'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject35));

      this.assertComponentElement(this.firstChild, { content: 'false' });
      this.assertComponentElement(this.nthChild(1), { content: 'true' });

      this.assertStableRerender();
    };

    _class.prototype['@test hasBlockParams as a param to a helper'] = function testHasBlockParamsAsAParamToAHelper(assert) {
      this.registerComponent('check-helper', {
        template: '{{if hasBlockParams "true" "false"}}'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject36));

      this.assertComponentElement(this.firstChild, { content: 'false' });
      this.assertComponentElement(this.nthChild(1), { content: 'true' });

      this.assertStableRerender();
    };

    _class.prototype['@test hasBlockParams as an expression param to a helper'] = function testHasBlockParamsAsAnExpressionParamToAHelper(assert) {
      this.registerComponent('check-helper', {
        template: '{{if (hasBlockParams) "true" "false"}}'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject36));

      this.assertComponentElement(this.firstChild, { content: 'false' });
      this.assertComponentElement(this.nthChild(1), { content: 'true' });

      this.assertStableRerender();
    };

    _class.prototype['@test hasBlockParams inverse as a param to a helper'] = function testHasBlockParamsInverseAsAParamToAHelper(assert) {
      this.registerComponent('check-helper', {
        template: '{{if (hasBlockParams "inverse") "true" "false"}}'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject36));

      this.assertComponentElement(this.firstChild, { content: 'false' });
      this.assertComponentElement(this.nthChild(1), { content: 'false' });

      this.assertStableRerender();
    };

    _class.prototype['@test component in template of a yielding component should have the proper parentView'] = function testComponentInTemplateOfAYieldingComponentShouldHaveTheProperParentView(assert) {
      var _this59 = this;

      var outer = undefined,
          innerTemplate = undefined,
          innerLayout = undefined;

      this.registerComponent('x-outer', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            outer = this;
          }
        }),
        template: '{{x-inner-in-layout}}{{yield}}'
      });

      this.registerComponent('x-inner-in-template', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            innerTemplate = this;
          }
        })
      });

      this.registerComponent('x-inner-in-layout', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            innerLayout = this;
          }
        })
      });

      this.render('{{#x-outer}}{{x-inner-in-template}}{{/x-outer}}');

      assert.equal(innerTemplate.parentView, outer, 'receives the wrapping component as its parentView in template blocks');
      assert.equal(innerLayout.parentView, outer, 'receives the wrapping component as its parentView in layout');
      assert.equal(outer.parentView, this.context, 'x-outer receives the ambient scope as its parentView');

      this.runTask(function () {
        return _this59.rerender();
      });

      assert.equal(innerTemplate.parentView, outer, 'receives the wrapping component as its parentView in template blocks');
      assert.equal(innerLayout.parentView, outer, 'receives the wrapping component as its parentView in layout');
      assert.equal(outer.parentView, this.context, 'x-outer receives the ambient scope as its parentView');
    };

    _class.prototype['@test newly-added sub-components get correct parentView'] = function testNewlyAddedSubComponentsGetCorrectParentView(assert) {
      var _this60 = this;

      var outer = undefined,
          inner = undefined;

      this.registerComponent('x-outer', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            outer = this;
          }
        })
      });

      this.registerComponent('x-inner', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            inner = this;
          }
        })
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject37), {
        showInner: false
      });

      assert.equal(outer.parentView, this.context, 'x-outer receives the ambient scope as its parentView');

      this.runTask(function () {
        return _this60.rerender();
      });

      assert.equal(outer.parentView, this.context, 'x-outer receives the ambient scope as its parentView (after rerender)');

      this.runTask(function () {
        return _this60.context.set('showInner', true);
      });

      assert.equal(outer.parentView, this.context, 'x-outer receives the ambient scope as its parentView');
      assert.equal(inner.parentView, outer, 'receives the wrapping component as its parentView in template blocks');

      this.runTask(function () {
        return _this60.context.set('showInner', false);
      });

      assert.equal(outer.parentView, this.context, 'x-outer receives the ambient scope as its parentView');
    };

    _class.prototype['@test when a property is changed during children\'s rendering'] = function testWhenAPropertyIsChangedDuringChildrenSRendering(assert) {
      var _this61 = this;

      var outer = undefined,
          middle = undefined;

      this.registerComponent('x-outer', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            outer = this;
          },
          value: 1
        }),
        template: '{{#x-middle}}{{x-inner value=value}}{{/x-middle}}'
      });

      this.registerComponent('x-middle', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            middle = this;
          },
          value: null
        }),
        template: '<div id="middle-value">{{value}}</div>{{yield}}'
      });

      this.registerComponent('x-inner', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          value: null,
          pushDataUp: _emberMetal.observer('value', function () {
            middle.set('value', this.get('value'));
          })
        }),
        template: '<div id="inner-value">{{value}}</div>'
      });

      this.render('{{x-outer}}');

      assert.equal(this.$('#inner-value').text(), '1', 'initial render of inner');
      assert.equal(this.$('#middle-value').text(), '', 'initial render of middle (observers do not run during init)');

      this.runTask(function () {
        return _this61.rerender();
      });

      assert.equal(this.$('#inner-value').text(), '1', 'initial render of inner');
      assert.equal(this.$('#middle-value').text(), '', 'initial render of middle (observers do not run during init)');

      var expectedBacktrackingMessage = /modified "value" twice on <\(.+> in a single render\. It was rendered in "component:x-middle" and modified in "component:x-inner"/;

      if (true) {
        expectDeprecation(expectedBacktrackingMessage);
        this.runTask(function () {
          return outer.set('value', 2);
        });
      } else {
        expectAssertion(function () {
          _this61.runTask(function () {
            return outer.set('value', 2);
          });
        }, expectedBacktrackingMessage);

        return;
      }

      assert.equal(this.$('#inner-value').text(), '2', 'second render of inner');
      assert.equal(this.$('#middle-value').text(), '2', 'second render of middle');

      this.runTask(function () {
        return outer.set('value', 3);
      });

      assert.equal(this.$('#inner-value').text(), '3', 'third render of inner');
      assert.equal(this.$('#middle-value').text(), '3', 'third render of middle');

      this.runTask(function () {
        return outer.set('value', 1);
      });

      assert.equal(this.$('#inner-value').text(), '1', 'reset render of inner');
      assert.equal(this.$('#middle-value').text(), '1', 'reset render of middle');
    };

    _class.prototype['@test when a shared dependency is changed during children\'s rendering'] = function testWhenASharedDependencyIsChangedDuringChildrenSRendering(assert) {
      var _this62 = this;

      var outer = undefined;

      this.registerComponent('x-outer', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            outer = this;
          },
          value: 1,
          wrapper: _emberRuntime.Object.create({ content: null })
        }),
        template: '<div id="outer-value">{{wrapper.content}}</div> {{x-inner value=value wrapper=wrapper}}'
      });

      this.registerComponent('x-inner', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didReceiveAttrs: function () {
            this.get('wrapper').set('content', this.get('value'));
          },
          value: null
        }),
        template: '<div id="inner-value">{{wrapper.content}}</div>'
      });

      var expectedBacktrackingMessage = /modified "wrapper\.content" twice on <Ember\.Object.+> in a single render\. It was rendered in "component:x-outer" and modified in "component:x-inner"/;

      if (true) {
        expectDeprecation(expectedBacktrackingMessage);
        this.render('{{x-outer}}');
      } else {
        expectAssertion(function () {
          _this62.render('{{x-outer}}');
        }, expectedBacktrackingMessage);

        return;
      }

      assert.equal(this.$('#inner-value').text(), '1', 'initial render of inner');
      assert.equal(this.$('#outer-value').text(), '1', 'initial render of outer');

      this.runTask(function () {
        return _this62.rerender();
      });

      assert.equal(this.$('#inner-value').text(), '1', 're-render of inner');
      assert.equal(this.$('#outer-value').text(), '1', 're-render of outer');

      this.runTask(function () {
        return outer.set('value', 2);
      });

      assert.equal(this.$('#inner-value').text(), '2', 'second render of inner');
      assert.equal(this.$('#outer-value').text(), '2', 'second render of outer');

      this.runTask(function () {
        return outer.set('value', 3);
      });

      assert.equal(this.$('#inner-value').text(), '3', 'third render of inner');
      assert.equal(this.$('#outer-value').text(), '3', 'third render of outer');

      this.runTask(function () {
        return outer.set('value', 1);
      });

      assert.equal(this.$('#inner-value').text(), '1', 'reset render of inner');
      assert.equal(this.$('#outer-value').text(), '1', 'reset render of outer');
    };

    _class.prototype['@test non-block with each rendering child components'] = function testNonBlockWithEachRenderingChildComponents() {
      var _this63 = this;

      this.registerComponent('non-block', {
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject38)
      });

      this.registerComponent('child-non-block', {
        template: 'Child: {{item}}.'
      });

      var items = _emberRuntime.A(['Tom', 'Dick', 'Harry']);

      this.render('{{non-block items=items}}', { items: items });

      this.assertText('In layout. [Child: Tom.][Child: Dick.][Child: Harry.]');

      this.runTask(function () {
        return _this63.rerender();
      });

      this.assertText('In layout. [Child: Tom.][Child: Dick.][Child: Harry.]');

      this.runTask(function () {
        return _this63.context.get('items').pushObject('Sergio');
      });

      this.assertText('In layout. [Child: Tom.][Child: Dick.][Child: Harry.][Child: Sergio.]');

      this.runTask(function () {
        return _this63.context.get('items').shiftObject();
      });

      this.assertText('In layout. [Child: Dick.][Child: Harry.][Child: Sergio.]');

      this.runTask(function () {
        return _this63.context.set('items', _emberRuntime.A(['Tom', 'Dick', 'Harry']));
      });

      this.assertText('In layout. [Child: Tom.][Child: Dick.][Child: Harry.]');
    };

    _class.prototype['@test specifying classNames results in correct class'] = function testSpecifyingClassNamesResultsInCorrectClass(assert) {
      var _this64 = this;

      this.registerComponent('some-clicky-thing', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          tagName: 'button',
          classNames: ['foo', 'bar']
        })
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject39));

      // TODO: ember-view is no longer viewable in the classNames array. Bug or
      // feature?
      var expectedClassNames = ['ember-view', 'foo', 'bar', 'baz'];

      assert.ok(this.$('button').is('.foo.bar.baz.ember-view'), 'the element has the correct classes: ' + this.$('button').attr('class'));
      // `ember-view` is no longer in classNames.
      // assert.deepEqual(clickyThing.get('classNames'), expectedClassNames, 'classNames are properly combined');
      this.assertComponentElement(this.firstChild, { tagName: 'button', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes(expectedClassNames.join(' ')) } });

      this.runTask(function () {
        return _this64.rerender();
      });

      assert.ok(this.$('button').is('.foo.bar.baz.ember-view'), 'the element has the correct classes: ' + this.$('button').attr('class') + ' (rerender)');
      // `ember-view` is no longer in classNames.
      // assert.deepEqual(clickyThing.get('classNames'), expectedClassNames, 'classNames are properly combined (rerender)');
      this.assertComponentElement(this.firstChild, { tagName: 'button', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes(expectedClassNames.join(' ')) } });
    };

    _class.prototype['@test specifying custom concatenatedProperties avoids clobbering'] = function testSpecifyingCustomConcatenatedPropertiesAvoidsClobbering(assert) {
      var _this65 = this;

      this.registerComponent('some-clicky-thing', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          concatenatedProperties: ['blahzz'],
          blahzz: ['blark', 'pory']
        }),
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject40)
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject41));

      this.assertText('blarkporybaz- Click Me');

      this.runTask(function () {
        return _this65.rerender();
      });

      this.assertText('blarkporybaz- Click Me');
    };

    _class.prototype['@test a two way binding flows upstream when consumed in the template'] = function testATwoWayBindingFlowsUpstreamWhenConsumedInTheTemplate() {
      var _this66 = this;

      var component = undefined;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,

        template: '{{bar}}'
      });

      this.render('{{localBar}} - {{foo-bar bar=localBar}}', {
        localBar: 'initial value'
      });

      this.assertText('initial value - initial value');

      this.runTask(function () {
        return _this66.rerender();
      });

      this.assertText('initial value - initial value');

      if (false) {
        expectAssertion(function () {
          component.bar = 'foo-bar';
        }, /You must use Ember\.set\(\) to set the `bar` property \(of .+\) to `foo-bar`\./);

        this.assertText('initial value - initial value');
      }

      this.runTask(function () {
        component.set('bar', 'updated value');
      });

      this.assertText('updated value - updated value');

      this.runTask(function () {
        component.set('bar', undefined);
      });

      this.assertText(' - ');

      this.runTask(function () {
        _this66.component.set('localBar', 'initial value');
      });

      this.assertText('initial value - initial value');
    };

    _class.prototype['@test a two way binding flows upstream through a CP when consumed in the template'] = function testATwoWayBindingFlowsUpstreamThroughACPWhenConsumedInTheTemplate() {
      var _this67 = this;

      var component = undefined;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        },

        bar: _emberMetal.computed({
          get: function () {
            return this._bar;
          },

          set: function (key, value) {
            this._bar = value;
            return this._bar;
          }
        })
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,

        template: '{{bar}}'
      });

      this.render('{{localBar}} - {{foo-bar bar=localBar}}', {
        localBar: 'initial value'
      });

      this.assertText('initial value - initial value');

      this.runTask(function () {
        return _this67.rerender();
      });

      this.assertText('initial value - initial value');

      this.runTask(function () {
        component.set('bar', 'updated value');
      });

      this.assertText('updated value - updated value');

      this.runTask(function () {
        _this67.component.set('localBar', 'initial value');
      });

      this.assertText('initial value - initial value');
    };

    _class.prototype['@test a two way binding flows upstream through a CP without template consumption'] = function testATwoWayBindingFlowsUpstreamThroughACPWithoutTemplateConsumption() {
      var _this68 = this;

      var component = undefined;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        },

        bar: _emberMetal.computed({
          get: function () {
            return this._bar;
          },

          set: function (key, value) {
            this._bar = value;
            return this._bar;
          }
        })
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: ''
      });

      this.render('{{localBar}}{{foo-bar bar=localBar}}', {
        localBar: 'initial value'
      });

      this.assertText('initial value');

      this.runTask(function () {
        return _this68.rerender();
      });

      this.assertText('initial value');

      this.runTask(function () {
        component.set('bar', 'updated value');
      });

      this.assertText('updated value');

      this.runTask(function () {
        _this68.component.set('localBar', 'initial value');
      });

      this.assertText('initial value');
    };

    _class.prototype['@test services can be injected into components'] = function testServicesCanBeInjectedIntoComponents() {
      var _this69 = this;

      var service = undefined;
      this.registerService('name', _emberRuntime.Service.extend({
        init: function () {
          this._super.apply(this, arguments);
          service = this;
        },
        last: 'Jackson'
      }));

      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          name: _emberRuntime.inject.service()
        }),
        template: '{{name.last}}'
      });

      this.render('{{foo-bar}}');

      this.assertText('Jackson');

      this.runTask(function () {
        return _this69.rerender();
      });

      this.assertText('Jackson');

      this.runTask(function () {
        service.set('last', 'McGuffey');
      });

      this.assertText('McGuffey');

      this.runTask(function () {
        service.set('last', 'Jackson');
      });

      this.assertText('Jackson');
    };

    _class.prototype['@test injecting an unknown service raises an exception'] = function testInjectingAnUnknownServiceRaisesAnException(assert) {
      var _this70 = this;

      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          missingService: _emberRuntime.inject.service()
        })
      });

      expectAssertion(function () {
        _this70.render('{{foo-bar}}');
      }, 'Attempting to inject an unknown injection: \'service:missingService\'');
    };

    _class.prototype['@test can access `actions` hash via `_actions` [DEPRECATED]'] = function testCanAccessActionsHashVia_actionsDEPRECATED() {
      var _this71 = this;

      var component = undefined;

      function derp() {}

      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            component = this;
          },

          actions: {
            derp: derp
          }
        })
      });

      this.render('{{foo-bar}}');

      this.assert.strictEqual(component.actions.derp, derp);

      expectDeprecation(function () {
        _this71.assert.strictEqual(component._actions.derp, derp);
      }, 'Usage of `_actions` is deprecated, use `actions` instead.');
    };

    _class.prototype['@test throws if `this._super` is not called from `init`'] = function testThrowsIfThis_superIsNotCalledFromInit() {
      var _this72 = this;

      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {}
        })
      });

      expectAssertion(function () {
        _this72.render('{{foo-bar}}');
      }, /You must call `this._super\(...arguments\);` when overriding `init` on a framework object. Please update .* to call `this._super\(...arguments\);` from `init`./);
    };

    _class.prototype['@test should toggle visibility with isVisible'] = function testShouldToggleVisibilityWithIsVisible(assert) {
      var _this73 = this;

      var assertStyle = function (expected) {
        var matcher = _emberGlimmerTestsUtilsTestHelpers.styles(expected);
        var actual = _this73.firstChild.getAttribute('style');

        assert.pushResult({
          result: matcher.match(actual),
          message: matcher.message(),
          actual: actual,
          expected: expected
        });
      };

      this.registerComponent('foo-bar', {
        template: '<p>foo</p>'
      });

      this.render('{{foo-bar id="foo-bar" isVisible=visible}}', {
        visible: false
      });

      assertStyle('display: none;');

      this.assertStableRerender();

      this.runTask(function () {
        _emberMetal.set(_this73.context, 'visible', true);
      });
      assertStyle('');

      this.runTask(function () {
        _emberMetal.set(_this73.context, 'visible', false);
      });
      assertStyle('display: none;');
    };

    _class.prototype['@test isVisible does not overwrite component style'] = function testIsVisibleDoesNotOverwriteComponentStyle(assert) {
      var _this74 = this;

      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          attributeBindings: ['style'],
          style: _emberGlimmerTestsUtilsHelpers.htmlSafe('color: blue;')
        }),

        template: '<p>foo</p>'
      });

      this.render('{{foo-bar id="foo-bar" isVisible=visible}}', {
        visible: false
      });

      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: { id: 'foo-bar', style: _emberGlimmerTestsUtilsTestHelpers.styles('color: blue; display: none;') }
      });

      this.assertStableRerender();

      this.runTask(function () {
        _emberMetal.set(_this74.context, 'visible', true);
      });

      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: { id: 'foo-bar', style: _emberGlimmerTestsUtilsTestHelpers.styles('color: blue;') }
      });

      this.runTask(function () {
        _emberMetal.set(_this74.context, 'visible', false);
      });

      this.assertComponentElement(this.firstChild, {
        tagName: 'div',
        attrs: { id: 'foo-bar', style: _emberGlimmerTestsUtilsTestHelpers.styles('color: blue; display: none;') }
      });
    };

    _class.prototype['@test adds isVisible binding when style binding is missing and other bindings exist'] = function testAddsIsVisibleBindingWhenStyleBindingIsMissingAndOtherBindingsExist(assert) {
      var _this75 = this;

      var assertStyle = function (expected) {
        var matcher = _emberGlimmerTestsUtilsTestHelpers.styles(expected);
        var actual = _this75.firstChild.getAttribute('style');

        assert.pushResult({
          result: matcher.match(actual),
          message: matcher.message(),
          actual: actual,
          expected: expected
        });
      };

      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          attributeBindings: ['foo'],
          foo: 'bar'
        }),
        template: '<p>foo</p>'
      });

      this.render('{{foo-bar id="foo-bar" foo=foo isVisible=visible}}', {
        visible: false,
        foo: 'baz'
      });

      assertStyle('display: none;');

      this.assertStableRerender();

      this.runTask(function () {
        _emberMetal.set(_this75.context, 'visible', true);
      });

      assertStyle('');

      this.runTask(function () {
        _emberMetal.set(_this75.context, 'visible', false);
        _emberMetal.set(_this75.context, 'foo', 'woo');
      });

      assertStyle('display: none;');
      assert.equal(this.firstChild.getAttribute('foo'), 'woo');
    };

    _class.prototype['@test it can use readDOMAttr to read input value'] = function testItCanUseReadDOMAttrToReadInputValue() {
      var _this76 = this;

      var component = undefined;
      var assertElement = function (expectedValue) {
        // value is a property, not an attribute
        _this76.assertHTML('<input class="ember-view" id="' + component.elementId + '">');
        _this76.assert.equal(_this76.firstChild.value, expectedValue, 'value property is correct');
        _this76.assert.equal(_emberMetal.get(component, 'value'), expectedValue, 'component.get("value") is correct');
      };

      this.registerComponent('one-way-input', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          tagName: 'input',
          attributeBindings: ['value'],

          init: function () {
            this._super.apply(this, arguments);
            component = this;
          },

          change: function () {
            var value = this.readDOMAttr('value');
            this.set('value', value);
          }
        })
      });

      this.render('{{one-way-input value=value}}', {
        value: 'foo'
      });

      assertElement('foo');

      this.assertStableRerender();

      this.runTask(function () {
        _this76.firstChild.value = 'bar';
        _this76.$('input').trigger('change');
      });

      assertElement('bar');

      this.runTask(function () {
        _this76.firstChild.value = 'foo';
        _this76.$('input').trigger('change');
      });

      assertElement('foo');

      this.runTask(function () {
        _emberMetal.set(component, 'value', 'bar');
      });

      assertElement('bar');

      this.runTask(function () {
        _this76.firstChild.value = 'foo';
        _this76.$('input').trigger('change');
      });

      assertElement('foo');
    };

    _class.prototype['@test child triggers revalidate during parent destruction (GH#13846)'] = function testChildTriggersRevalidateDuringParentDestructionGH13846() {
      this.registerComponent('x-select', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          tagName: 'select',

          init: function () {
            this._super();
            this.options = _emberRuntime.A([]);
            this.value = null;
          },

          updateValue: function () {
            var newValue = this.get('options.lastObject.value');

            this.set('value', newValue);
          },

          registerOption: function (option) {
            this.get('options').addObject(option);
          },

          unregisterOption: function (option) {
            this.get('options').removeObject(option);

            this.updateValue();
          }
        }),

        template: '{{yield this}}'
      });

      this.registerComponent('x-option', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          tagName: 'option',
          attributeBindings: ['selected'],

          didInsertElement: function () {
            this._super.apply(this, arguments);

            this.get('select').registerOption(this);
          },

          selected: _emberMetal.computed('select.value', function () {
            return this.get('value') === this.get('select.value');
          }),

          willDestroyElement: function () {
            this._super.apply(this, arguments);
            this.get('select').unregisterOption(this);
          }
        })
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject42));

      this.teardown();

      this.assert.ok(true, 'no errors during teardown');
    };

    _class.prototype['@test setting a property in willDestroyElement does not assert (GH#14273)'] = function testSettingAPropertyInWillDestroyElementDoesNotAssertGH14273(assert) {
      assert.expect(2);

      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            this.showFoo = true;
          },

          willDestroyElement: function () {
            this.set('showFoo', false);
            assert.ok(true, 'willDestroyElement was fired');
            this._super.apply(this, arguments);
          }
        }),

        template: '{{#if showFoo}}things{{/if}}'
      });

      this.render('{{foo-bar}}');

      this.assertText('things');
    };

    _class.prototype['@test using didInitAttrs as an event is deprecated'] = function testUsingDidInitAttrsAsAnEventIsDeprecated(assert) {
      var _this77 = this;

      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          foo: _emberMetal.on('didInitAttrs', function () {
            assert.ok(true, 'should fire `didInitAttrs` event');
          })
        })
      });

      expectDeprecation(function () {
        _this77.render('{{foo-bar}}');
      }, /didInitAttrs called/);
    };

    // This test is a replication of the "component unit tests" scenario. When we deprecate
    // and remove them, this test could be removed as well. This is not fully/intentionally
    // supported, and it is unclear that this particular behavior is actually relied on.
    // Since there is no real "invocation" here, it has other issues and inconsistencies,
    // like there is no real "attrs" here, and there is no "update" pass.

    _class.prototype['@test did{Init,Receive}Attrs fires even if component is not rendered'] = function testDidInitReceiveAttrsFiresEvenIfComponentIsNotRendered(assert) {
      var _this78 = this;

      expectDeprecation(/didInitAttrs called/);

      var didInitAttrsCount = 0;
      var didReceiveAttrsCount = 0;

      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            this.didInit = true;
          },

          didInitAttrs: function () {
            assert.ok(this.didInit, 'expected init to have run before didInitAttrs');
            didInitAttrsCount++;
          },

          didReceiveAttrs: function () {
            assert.ok(this.didInit, 'expected init to have run before didReceiveAttrs');
            didReceiveAttrsCount++;
          },

          willRender: function () {
            throw new Error('Unexpected render!');
          }
        })
      });

      assert.strictEqual(didInitAttrsCount, 0, 'precond: didInitAttrs is not fired');
      assert.strictEqual(didReceiveAttrsCount, 0, 'precond: didReceiveAttrs is not fired');

      this.runTask(function () {
        return _this78.component = _this78.owner.lookup('component:foo-bar');
      });

      assert.strictEqual(didInitAttrsCount, 1, 'precond: didInitAttrs is fired');
      assert.strictEqual(didReceiveAttrsCount, 1, 'precond: didReceiveAttrs is fired');
    };

    _class.prototype['@test did{Init,Receive}Attrs fires after .init() but before observers become active'] = function testDidInitReceiveAttrsFiresAfterInitButBeforeObserversBecomeActive(assert) {
      var _this79 = this;

      expectDeprecation(/didInitAttrs called/);

      var fooCopyDidChangeCount = 0;
      var barCopyDidChangeCount = 0;

      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            this.didInit = true;
          },

          didInitAttrs: function (_ref2) {
            var attrs = _ref2.attrs;

            assert.ok(this.didInit, 'expected init to have run before didInitAttrs');
            this.set('fooCopy', attrs.foo.value + 1);
          },

          didReceiveAttrs: function (_ref3) {
            var newAttrs = _ref3.newAttrs;

            assert.ok(this.didInit, 'expected init to have run before didReceiveAttrs');
            this.set('barCopy', newAttrs.bar.value + 1);
          },

          fooCopyDidChange: _emberMetal.observer('fooCopy', function () {
            fooCopyDidChangeCount++;
          }),
          barCopyDidChange: _emberMetal.observer('barCopy', function () {
            barCopyDidChangeCount++;
          })
        }),

        template: '{{foo}}-{{fooCopy}}-{{bar}}-{{barCopy}}'
      });

      this.render('{{foo-bar foo=foo bar=bar}}', { foo: 1, bar: 3 });

      this.assertText('1-2-3-4');

      assert.strictEqual(fooCopyDidChangeCount, 0, 'expected NO observer firing for: fooCopy');
      assert.strictEqual(barCopyDidChangeCount, 0, 'expected NO observer firing for: barCopy');

      this.runTask(function () {
        return _emberMetal.set(_this79.context, 'foo', 5);
      });

      this.assertText('5-2-3-4');

      assert.strictEqual(fooCopyDidChangeCount, 0, 'expected observer firing for: fooCopy');
      assert.strictEqual(barCopyDidChangeCount, 0, 'expected NO observer firing for: barCopy');

      this.runTask(function () {
        return _emberMetal.set(_this79.context, 'bar', 7);
      });

      this.assertText('5-2-7-8');

      assert.strictEqual(fooCopyDidChangeCount, 0, 'expected observer firing for: fooCopy');
      assert.strictEqual(barCopyDidChangeCount, 1, 'expected observer firing for: barCopy');
    };

    _class.prototype['@test overriding didReceiveAttrs does not trigger deprecation'] = function testOverridingDidReceiveAttrsDoesNotTriggerDeprecation(assert) {
      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didReceiveAttrs: function () {
            assert.equal(1, this.get('foo'), 'expected attrs to have correct value');
          }
        }),

        template: '{{foo}}-{{fooCopy}}-{{bar}}-{{barCopy}}'
      });

      this.render('{{foo-bar foo=foo bar=bar}}', { foo: 1, bar: 3 });
    };

    _class.prototype['@test can access didReceiveAttrs arguments [DEPRECATED]'] = function testCanAccessDidReceiveAttrsArgumentsDEPRECATED(assert) {
      expectDeprecation(/didReceiveAttrs.*stop taking arguments/);

      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didReceiveAttrs: function (_ref4) {
            var attrs = _ref4.attrs;

            assert.equal(1, attrs.foo.value, 'expected attrs to have correct value');
          }
        }),

        template: '{{foo}}-{{fooCopy}}-{{bar}}-{{barCopy}}'
      });

      this.render('{{foo-bar foo=foo bar=bar}}', { foo: 1, bar: 3 });
    };

    _class.prototype['@test can access didUpdateAttrs arguments [DEPRECATED]'] = function testCanAccessDidUpdateAttrsArgumentsDEPRECATED(assert) {
      var _this80 = this;

      expectDeprecation(/didUpdateAttrs.*stop taking arguments/);

      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didUpdateAttrs: function (_ref5) {
            var newAttrs = _ref5.newAttrs;

            assert.equal(5, newAttrs.foo.value, "expected newAttrs to have new value");
          }
        }),

        template: '{{foo}}-{{fooCopy}}-{{bar}}-{{barCopy}}'
      });

      this.render('{{foo-bar foo=foo bar=bar}}', { foo: 1, bar: 3 });

      this.runTask(function () {
        return _emberMetal.set(_this80.context, 'foo', 5);
      });
    };

    _class.prototype['@test overriding didUpdateAttrs does not trigger deprecation'] = function testOverridingDidUpdateAttrsDoesNotTriggerDeprecation(assert) {
      var _this81 = this;

      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didUpdateAttrs: function () {
            assert.equal(5, this.get('foo'), "expected newAttrs to have new value");
          }
        }),

        template: '{{foo}}-{{fooCopy}}-{{bar}}-{{barCopy}}'
      });

      this.render('{{foo-bar foo=foo bar=bar}}', { foo: 1, bar: 3 });

      this.runTask(function () {
        return _emberMetal.set(_this81.context, 'foo', 5);
      });
    };

    _class.prototype['@test returning `true` from an action does not bubble if `target` is not specified (GH#14275)'] = function testReturningTrueFromAnActionDoesNotBubbleIfTargetIsNotSpecifiedGH14275(assert) {
      var _this82 = this;

      this.registerComponent('display-toggle', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          actions: {
            show: function () {
              assert.ok(true, 'display-toggle show action was called');
              return true;
            }
          }
        }),

        template: '<button {{action \'show\'}}>Show</button>'
      });

      this.render('{{display-toggle}}', {
        send: function () {
          assert.notOk(true, 'send should not be called when action is not "subscribed" to');
        }
      });

      this.assertText('Show');

      this.runTask(function () {
        return _this82.$('button').click();
      });
    };

    _class.prototype['@test returning `true` from an action bubbles to the `target` if specified'] = function testReturningTrueFromAnActionBubblesToTheTargetIfSpecified(assert) {
      var _this83 = this;

      assert.expect(4);

      this.registerComponent('display-toggle', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          actions: {
            show: function () {
              assert.ok(true, 'display-toggle show action was called');
              return true;
            }
          }
        }),

        template: '<button {{action \'show\'}}>Show</button>'
      });

      this.render('{{display-toggle target=this}}', {
        send: function (actionName) {
          assert.ok(true, 'send should be called when action is "subscribed" to');
          assert.equal(actionName, 'show');
        }
      });

      this.assertText('Show');

      this.runTask(function () {
        return _this83.$('button').click();
      });
    };

    _class.prototype['@test component yielding in an {{#each}} has correct block values after rerendering (GH#14284)'] = function testComponentYieldingInAnEachHasCorrectBlockValuesAfterRerenderingGH14284() {
      var _this84 = this;

      this.registerComponent('list-items', {
        template: '{{#each items as |item|}}{{yield item}}{{/each}}'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject43), {
        editMode: false,
        items: ['foo', 'bar', 'qux', 'baz']
      });

      this.assertText('|foo||bar||qux||baz|');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this84.context, 'editMode', true);
      });

      this.assertText('|foo|Remove foo|bar|Remove bar|qux|Remove qux|baz|Remove baz');

      this.runTask(function () {
        return _emberMetal.set(_this84.context, 'editMode', false);
      });

      this.assertText('|foo||bar||qux||baz|');
    };

    _class.prototype['@test unimplimented positionalParams do not cause an error GH#14416'] = function testUnimplimentedPositionalParamsDoNotCauseAnErrorGH14416(assert) {
      this.registerComponent('foo-bar', {
        template: 'hello'
      });

      this.render('{{foo-bar wat}}');
      this.assertText('hello');
    };

    _class.prototype['@test using attrs for positional params'] = function testUsingAttrsForPositionalParams(assert) {
      var MyComponent = _emberGlimmerTestsUtilsHelpers.Component.extend();

      this.registerComponent('foo-bar', {
        ComponentClass: MyComponent.reopenClass({
          positionalParams: ['myVar']
        }),
        template: 'MyVar1: {{attrs.myVar}} {{myVar}} MyVar2: {{myVar2}} {{attrs.myVar2}}'
      });

      this.render('{{foo-bar 1 myVar2=2}}');

      this.assertText('MyVar1: 1 1 MyVar2: 2 2');
    };

    _class.prototype['@test can use `{{this}}` to emit the component\'s toString value [GH#14581]'] = function testCanUseThisToEmitTheComponentSToStringValueGH14581(assert) {
      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          toString: function () {
            return 'special sauce goes here!';
          }
        }),
        template: '{{this}}'
      });

      this.render('{{foo-bar}}');

      this.assertText('special sauce goes here!');
    };

    _class.prototype['@test can use `{{this` to access paths on current context [GH#14581]'] = function testCanUseThisToAccessPathsOnCurrentContextGH14581(assert) {
      var instance = undefined;
      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);

            instance = this;
          },

          foo: {
            bar: {
              baz: 'huzzah!'
            }
          }
        }),
        template: '{{this.foo.bar.baz}}'
      });

      this.render('{{foo-bar}}');

      this.assertText('huzzah!');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(instance, 'foo.bar.baz', 'yippie!');
      });

      this.assertText('yippie!');

      this.runTask(function () {
        return _emberMetal.set(instance, 'foo.bar.baz', 'huzzah!');
      });

      this.assertText('huzzah!');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/components/curly-components-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/components/curly-components-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/components/curly-components-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/components/dynamic-components-test', ['exports', 'ember-metal', 'ember-glimmer/tests/utils/helpers', 'ember-glimmer/tests/utils/abstract-test-case', 'ember-glimmer/tests/utils/test-case'], function (exports, _emberMetal, _emberGlimmerTestsUtilsHelpers, _emberGlimmerTestsUtilsAbstractTestCase, _emberGlimmerTestsUtilsTestCase) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#if cond1}}\n        {{#component "foo-bar" id=1}}\n          {{#if cond2}}\n            {{#component "foo-bar" id=2}}{{/component}}\n            {{#if cond3}}\n              {{#component "foo-bar" id=3}}\n                {{#if cond4}}\n                  {{#component "foo-bar" id=4}}\n                    {{#if cond5}}\n                      {{#component "foo-bar" id=5}}{{/component}}\n                      {{#component "foo-bar" id=6}}{{/component}}\n                      {{#component "foo-bar" id=7}}{{/component}}\n                    {{/if}}\n                    {{#component "foo-bar" id=8}}{{/component}}\n                  {{/component}}\n                {{/if}}\n              {{/component}}\n            {{/if}}\n          {{/if}}\n        {{/component}}\n      {{/if}}'], ['\n      {{#if cond1}}\n        {{#component "foo-bar" id=1}}\n          {{#if cond2}}\n            {{#component "foo-bar" id=2}}{{/component}}\n            {{#if cond3}}\n              {{#component "foo-bar" id=3}}\n                {{#if cond4}}\n                  {{#component "foo-bar" id=4}}\n                    {{#if cond5}}\n                      {{#component "foo-bar" id=5}}{{/component}}\n                      {{#component "foo-bar" id=6}}{{/component}}\n                      {{#component "foo-bar" id=7}}{{/component}}\n                    {{/if}}\n                    {{#component "foo-bar" id=8}}{{/component}}\n                  {{/component}}\n                {{/if}}\n              {{/component}}\n            {{/if}}\n          {{/if}}\n        {{/component}}\n      {{/if}}']),
      _templateObject2 = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#each names as |name|}}\n          {{name}}\n        {{/each}}'], ['\n        {{#each names as |name|}}\n          {{name}}\n        {{/each}}']),
      _templateObject3 = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#each n as |name|}}\n          {{name}}\n        {{/each}}'], ['\n        {{#each n as |name|}}\n          {{name}}\n        {{/each}}']);

  _emberGlimmerTestsUtilsTestCase.moduleFor('Components test: dynamic components', (function (_RenderingTest) {
babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test it can render a basic component with a static component name argument'] = function testItCanRenderABasicComponentWithAStaticComponentNameArgument() {
      var _this = this;

      this.registerComponent('foo-bar', { template: 'hello {{name}}' });

      this.render('{{component "foo-bar" name=name}}', { name: 'Sarah' });

      this.assertComponentElement(this.firstChild, { content: 'hello Sarah' });

      this.runTask(function () {
        return _this.rerender();
      });

      this.assertComponentElement(this.firstChild, { content: 'hello Sarah' });

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'name', 'Gavin');
      });

      this.assertComponentElement(this.firstChild, { content: 'hello Gavin' });

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'name', 'Sarah');
      });

      this.assertComponentElement(this.firstChild, { content: 'hello Sarah' });
    };

    _class.prototype['@test it can render a basic component with a dynamic component name argument'] = function testItCanRenderABasicComponentWithADynamicComponentNameArgument() {
      var _this2 = this;

      this.registerComponent('foo-bar', { template: 'hello {{name}} from foo-bar' });
      this.registerComponent('foo-bar-baz', { template: 'hello {{name}} from foo-bar-baz' });

      this.render('{{component componentName name=name}}', { componentName: 'foo-bar', name: 'Alex' });

      this.assertComponentElement(this.firstChild, { content: 'hello Alex from foo-bar' });

      this.runTask(function () {
        return _this2.rerender();
      });

      this.assertComponentElement(this.firstChild, { content: 'hello Alex from foo-bar' });

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'name', 'Ben');
      });

      this.assertComponentElement(this.firstChild, { content: 'hello Ben from foo-bar' });

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'componentName', 'foo-bar-baz');
      });

      this.assertComponentElement(this.firstChild, { content: 'hello Ben from foo-bar-baz' });

      this.runTask(function () {
        _emberMetal.set(_this2.context, 'componentName', 'foo-bar');
        _emberMetal.set(_this2.context, 'name', 'Alex');
      });

      this.assertComponentElement(this.firstChild, { content: 'hello Alex from foo-bar' });
    };

    _class.prototype['@test it has an element'] = function testItHasAnElement() {
      var _this3 = this;

      var instance = undefined;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super();
          instance = this;
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{component "foo-bar"}}');

      var element1 = instance.element;

      this.assertComponentElement(element1, { content: 'hello' });

      this.runTask(function () {
        return _this3.rerender();
      });

      var element2 = instance.element;

      this.assertComponentElement(element2, { content: 'hello' });

      this.assertSameNode(element2, element1);
    };

    _class.prototype['@test it has a jQuery proxy to the element'] = function testItHasAJQueryProxyToTheElement(assert) {
      var _this4 = this;

      var instance = undefined;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super();
          instance = this;
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{component "foo-bar"}}');

      var element1 = instance.$()[0];

      this.assertComponentElement(element1, { content: 'hello' });

      this.runTask(function () {
        return _this4.rerender();
      });

      var element2 = instance.$()[0];

      this.assertComponentElement(element2, { content: 'hello' });

      this.assertSameNode(element2, element1);
    };

    _class.prototype['@test it scopes the jQuery proxy to the component element'] = function testItScopesTheJQueryProxyToTheComponentElement(assert) {
      var _this5 = this;

      var instance = undefined;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super();
          instance = this;
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: '<span class="inner">inner</span>' });

      this.render('<span class="outer">outer</span>{{component "foo-bar"}}');

      var $span = instance.$('span');

      assert.equal($span.length, 1);
      assert.equal($span.attr('class'), 'inner');

      this.runTask(function () {
        return _this5.rerender();
      });

      $span = instance.$('span');

      assert.equal($span.length, 1);
      assert.equal($span.attr('class'), 'inner');
    };

    _class.prototype['@test it has the right parentView and childViews'] = function testItHasTheRightParentViewAndChildViews(assert) {
      var _this6 = this;

      var fooBarInstance = undefined,
          fooBarBazInstance = undefined;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super();
          fooBarInstance = this;
        }
      });

      var FooBarBazComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super();
          fooBarBazInstance = this;
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'foo-bar {{foo-bar-baz}}' });
      this.registerComponent('foo-bar-baz', { ComponentClass: FooBarBazComponent, template: 'foo-bar-baz' });

      this.render('{{component "foo-bar"}}');
      this.assertText('foo-bar foo-bar-baz');

      assert.equal(fooBarInstance.parentView, this.component);
      assert.equal(fooBarBazInstance.parentView, fooBarInstance);

      assert.deepEqual(this.component.childViews, [fooBarInstance]);
      assert.deepEqual(fooBarInstance.childViews, [fooBarBazInstance]);

      this.runTask(function () {
        return _this6.rerender();
      });
      this.assertText('foo-bar foo-bar-baz');

      assert.equal(fooBarInstance.parentView, this.component);
      assert.equal(fooBarBazInstance.parentView, fooBarInstance);

      assert.deepEqual(this.component.childViews, [fooBarInstance]);
      assert.deepEqual(fooBarInstance.childViews, [fooBarBazInstance]);
    };

    _class.prototype['@test it can render a basic component with a block'] = function testItCanRenderABasicComponentWithABlock() {
      var _this7 = this;

      this.registerComponent('foo-bar', { template: '{{yield}}' });

      this.render('{{#component "foo-bar"}}hello{{/component}}');

      this.assertComponentElement(this.firstChild, { content: 'hello' });

      this.runTask(function () {
        return _this7.rerender();
      });

      this.assertComponentElement(this.firstChild, { content: 'hello' });
    };

    _class.prototype['@test it renders the layout with the component instance as the context'] = function testItRendersTheLayoutWithTheComponentInstanceAsTheContext() {
      var _this8 = this;

      var instance = undefined;

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super();
          instance = this;
          this.set('message', 'hello');
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: '{{message}}' });

      this.render('{{component "foo-bar"}}');

      this.assertComponentElement(this.firstChild, { content: 'hello' });

      this.runTask(function () {
        return _this8.rerender();
      });

      this.assertComponentElement(this.firstChild, { content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(instance, 'message', 'goodbye');
      });

      this.assertComponentElement(this.firstChild, { content: 'goodbye' });

      this.runTask(function () {
        return _emberMetal.set(instance, 'message', 'hello');
      });

      this.assertComponentElement(this.firstChild, { content: 'hello' });
    };

    _class.prototype['@test it preserves the outer context when yielding'] = function testItPreservesTheOuterContextWhenYielding() {
      var _this9 = this;

      this.registerComponent('foo-bar', { template: '{{yield}}' });

      this.render('{{#component "foo-bar"}}{{message}}{{/component}}', { message: 'hello' });

      this.assertComponentElement(this.firstChild, { content: 'hello' });

      this.runTask(function () {
        return _this9.rerender();
      });

      this.assertComponentElement(this.firstChild, { content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this9.context, 'message', 'goodbye');
      });

      this.assertComponentElement(this.firstChild, { content: 'goodbye' });

      this.runTask(function () {
        return _emberMetal.set(_this9.context, 'message', 'hello');
      });

      this.assertComponentElement(this.firstChild, { content: 'hello' });
    };

    _class.prototype['@test the component and its child components are destroyed'] = function testTheComponentAndItsChildComponentsAreDestroyed(assert) {
      var _this10 = this;

      var destroyed = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 };

      this.registerComponent('foo-bar', {
        template: '{{id}} {{yield}}',
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          willDestroy: function () {
            this._super();
            destroyed[this.get('id')]++;
          }
        })
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject), {
        cond1: true,
        cond2: true,
        cond3: true,
        cond4: true,
        cond5: true
      });

      this.assertText('1 2 3 4 5 6 7 8 ');

      this.runTask(function () {
        return _this10.rerender();
      });

      assert.deepEqual(destroyed, { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 });

      this.runTask(function () {
        return _emberMetal.set(_this10.context, 'cond5', false);
      });

      this.assertText('1 2 3 4 8 ');

      assert.deepEqual(destroyed, { 1: 0, 2: 0, 3: 0, 4: 0, 5: 1, 6: 1, 7: 1, 8: 0 });

      this.runTask(function () {
        _emberMetal.set(_this10.context, 'cond3', false);
        _emberMetal.set(_this10.context, 'cond5', true);
        _emberMetal.set(_this10.context, 'cond4', false);
      });

      assert.deepEqual(destroyed, { 1: 0, 2: 0, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1 });

      this.runTask(function () {
        _emberMetal.set(_this10.context, 'cond2', false);
        _emberMetal.set(_this10.context, 'cond1', false);
      });

      assert.deepEqual(destroyed, { 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1 });
    };

    _class.prototype['@test component helper destroys underlying component when it is swapped out'] = function testComponentHelperDestroysUnderlyingComponentWhenItIsSwappedOut(assert) {
      var _this11 = this;

      var destroyed = { 'foo-bar': 0, 'foo-bar-baz': 0 };
      var testContext = this;

      this.registerComponent('foo-bar', {
        template: 'hello from foo-bar',
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          willDestroyElement: function () {
            assert.equal(testContext.$('#' + this.elementId).length, 1, 'element is still attached to the document');
          },

          willDestroy: function () {
            this._super();
            destroyed['foo-bar']++;
          }
        })
      });

      this.registerComponent('foo-bar-baz', {
        template: 'hello from foo-bar-baz',
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          willDestroy: function () {
            this._super();
            destroyed['foo-bar-baz']++;
          }
        })
      });

      this.render('{{component componentName name=name}}', { componentName: 'foo-bar' });

      assert.deepEqual(destroyed, { 'foo-bar': 0, 'foo-bar-baz': 0 });

      this.runTask(function () {
        return _this11.rerender();
      });

      assert.deepEqual(destroyed, { 'foo-bar': 0, 'foo-bar-baz': 0 });

      this.runTask(function () {
        return _emberMetal.set(_this11.context, 'componentName', 'foo-bar-baz');
      });

      assert.deepEqual(destroyed, { 'foo-bar': 1, 'foo-bar-baz': 0 });

      this.runTask(function () {
        return _emberMetal.set(_this11.context, 'componentName', 'foo-bar');
      });

      assert.deepEqual(destroyed, { 'foo-bar': 1, 'foo-bar-baz': 1 });
    };

    _class.prototype['@test component helper with bound properties are updating correctly in init of component'] = function testComponentHelperWithBoundPropertiesAreUpdatingCorrectlyInInitOfComponent(assert) {
      var _this12 = this;

      this.registerComponent('foo-bar', {
        template: 'foo-bar {{location}} {{locationCopy}} {{yield}}',
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            this.set('locationCopy', this.get('location'));
          }
        })
      });

      this.registerComponent('foo-bar-baz', {
        template: 'foo-bar-baz {{location}} {{locationCopy}} {{yield}}',
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            this.set('locationCopy', this.get('location'));
          }
        })
      });

      this.registerComponent('outer-component', {
        template: '{{#component componentName location=location}}arepas!{{/component}}',
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          componentName: _emberMetal.computed('location', function () {
            if (this.get('location') === 'Caracas') {
              return 'foo-bar';
            } else {
              return 'foo-bar-baz';
            }
          })
        })
      });

      this.render('{{outer-component location=location}}', { location: 'Caracas' });

      this.assertText('foo-bar Caracas Caracas arepas!');

      this.runTask(function () {
        return _this12.rerender();
      });

      this.assertText('foo-bar Caracas Caracas arepas!');

      this.runTask(function () {
        return _emberMetal.set(_this12.context, 'location', 'Loisaida');
      });

      this.assertText('foo-bar-baz Loisaida Loisaida arepas!');

      this.runTask(function () {
        return _emberMetal.set(_this12.context, 'location', 'Caracas');
      });

      this.assertText('foo-bar Caracas Caracas arepas!');
    };

    _class.prototype['@test component helper with actions'] = function testComponentHelperWithActions(assert) {
      var _this14 = this;

      this.registerComponent('inner-component', {
        template: 'inner-component {{yield}}',
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          classNames: 'inner-component',
          didInsertElement: function () {
            var _this13 = this;

            // trigger action on click in absence of app's EventDispatcher
            this.$().on('click', function () {
              _this13.sendAction('somethingClicked');
            });
          },
          willDestroyElement: function () {
            this.$().off('click');
          }
        })
      });

      var actionTriggered = 0;
      this.registerComponent('outer-component', {
        template: '{{#component componentName somethingClicked="mappedAction"}}arepas!{{/component}}',
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          classNames: 'outer-component',
          componentName: 'inner-component',
          actions: {
            mappedAction: function () {
              actionTriggered++;
            }
          }
        })
      });

      this.render('{{outer-component}}');

      assert.equal(actionTriggered, 0, 'action was not triggered');

      this.runTask(function () {
        _this14.$('.inner-component').trigger('click');
      });

      assert.equal(actionTriggered, 1, 'action was triggered');
    };

    _class.prototype['@test nested component helpers'] = function testNestedComponentHelpers(assert) {
      var _this15 = this;

      this.registerComponent('foo-bar', { template: 'yippie! {{attrs.location}} {{yield}}' });
      this.registerComponent('baz-qux', { template: 'yummy {{attrs.location}} {{yield}}' });
      this.registerComponent('corge-grault', { template: 'delicious {{attrs.location}} {{yield}}' });

      this.render('{{#component componentName1 location=location}}{{#component componentName2 location=location}}arepas!{{/component}}{{/component}}', {
        componentName1: 'foo-bar',
        componentName2: 'baz-qux',
        location: 'Caracas'
      });

      this.assertText('yippie! Caracas yummy Caracas arepas!');

      this.runTask(function () {
        return _this15.rerender();
      });

      this.assertText('yippie! Caracas yummy Caracas arepas!');

      this.runTask(function () {
        return _emberMetal.set(_this15.context, 'location', 'Loisaida');
      });

      this.assertText('yippie! Loisaida yummy Loisaida arepas!');

      this.runTask(function () {
        return _emberMetal.set(_this15.context, 'componentName1', 'corge-grault');
      });

      this.assertText('delicious Loisaida yummy Loisaida arepas!');

      this.runTask(function () {
        _emberMetal.set(_this15.context, 'componentName1', 'foo-bar');
        _emberMetal.set(_this15.context, 'location', 'Caracas');
      });

      this.assertText('yippie! Caracas yummy Caracas arepas!');
    };

    _class.prototype['@test component with dynamic name argument resolving to non-existent component'] = function testComponentWithDynamicNameArgumentResolvingToNonExistentComponent(assert) {
      var _this16 = this;

      expectAssertion(function () {
        _this16.render('{{component componentName}}', { componentName: 'does-not-exist' });
      }, /Could not find component named "does-not-exist"/);
    };

    _class.prototype['@test component with static name argument for non-existent component'] = function testComponentWithStaticNameArgumentForNonExistentComponent(assert) {
      var _this17 = this;

      expectAssertion(function () {
        _this17.render('{{component "does-not-exist"}}');
      }, /Could not find component named "does-not-exist"/);
    };

    _class.prototype['@test component with dynamic component name resolving to a component, then non-existent component'] = function testComponentWithDynamicComponentNameResolvingToAComponentThenNonExistentComponent(assert) {
      var _this18 = this;

      this.registerComponent('foo-bar', { template: 'hello {{name}}' });

      this.render('{{component componentName name=name}}', { componentName: 'foo-bar', name: 'Alex' });

      this.assertText('hello Alex');

      this.runTask(function () {
        return _this18.rerender();
      });

      this.assertText('hello Alex');

      this.runTask(function () {
        return _emberMetal.set(_this18.context, 'componentName', undefined);
      });

      this.assertText('');

      this.runTask(function () {
        return _emberMetal.set(_this18.context, 'componentName', 'foo-bar');
      });

      this.assertText('hello Alex');
    };

    _class.prototype['@test component helper properly invalidates hash params inside an {{each}} invocation #11044'] = function testComponentHelperProperlyInvalidatesHashParamsInsideAnEachInvocation11044(assert) {
      var _this19 = this;

      this.registerComponent('foo-bar', {
        template: '[{{internalName}} - {{name}}]',
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          willRender: function () {
            // store internally available name to ensure that the name available in `this.attrs.name`
            // matches the template lookup name
            _emberMetal.set(this, 'internalName', this.get('name'));
          }
        })
      });

      this.render('{{#each items as |item|}}{{component "foo-bar" name=item.name}}{{/each}}', {
        items: [{ name: 'Robert' }, { name: 'Jacquie' }]
      });

      this.assertText('[Robert - Robert][Jacquie - Jacquie]');

      this.runTask(function () {
        return _this19.rerender();
      });

      this.assertText('[Robert - Robert][Jacquie - Jacquie]');

      this.runTask(function () {
        return _emberMetal.set(_this19.context, 'items', [{ name: 'Max' }, { name: 'James' }]);
      });

      this.assertText('[Max - Max][James - James]');

      this.runTask(function () {
        return _emberMetal.set(_this19.context, 'items', [{ name: 'Robert' }, { name: 'Jacquie' }]);
      });

      this.assertText('[Robert - Robert][Jacquie - Jacquie]');
    };

    _class.prototype['@test dashless components should not be found'] = function testDashlessComponentsShouldNotBeFound(assert) {
      var _this20 = this;

      this.registerComponent('dashless2', { template: 'Do not render me!' });

      expectAssertion(function () {
        _this20.render('{{component "dashless"}}');
      }, /You cannot use 'dashless' as a component name. Component names must contain a hyphen./);
    };

    _class.prototype['@test positional parameters does not clash when rendering different components'] = function testPositionalParametersDoesNotClashWhenRenderingDifferentComponents(assert) {
      var _this21 = this;

      this.registerComponent('foo-bar', {
        template: 'hello {{name}} ({{age}}) from foo-bar',
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: ['name', 'age']
        })
      });

      this.registerComponent('foo-bar-baz', {
        template: 'hello {{name}} ({{age}}) from foo-bar-baz',
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: ['name', 'age']
        })
      });

      this.render('{{component componentName name age}}', {
        componentName: 'foo-bar',
        name: 'Alex',
        age: 29
      });

      this.assertComponentElement(this.firstChild, { content: 'hello Alex (29) from foo-bar' });

      this.runTask(function () {
        return _this21.rerender();
      });

      this.assertComponentElement(this.firstChild, { content: 'hello Alex (29) from foo-bar' });

      this.runTask(function () {
        return _emberMetal.set(_this21.context, 'name', 'Ben');
      });

      this.assertComponentElement(this.firstChild, { content: 'hello Ben (29) from foo-bar' });

      this.runTask(function () {
        return _emberMetal.set(_this21.context, 'age', 22);
      });

      this.assertComponentElement(this.firstChild, { content: 'hello Ben (22) from foo-bar' });

      this.runTask(function () {
        return _emberMetal.set(_this21.context, 'componentName', 'foo-bar-baz');
      });

      this.assertComponentElement(this.firstChild, { content: 'hello Ben (22) from foo-bar-baz' });

      this.runTask(function () {
        _emberMetal.set(_this21.context, 'componentName', 'foo-bar');
        _emberMetal.set(_this21.context, 'name', 'Alex');
        _emberMetal.set(_this21.context, 'age', 29);
      });

      this.assertComponentElement(this.firstChild, { content: 'hello Alex (29) from foo-bar' });
    };

    _class.prototype['@test positional parameters does not pollute the attributes when changing components'] = function testPositionalParametersDoesNotPolluteTheAttributesWhenChangingComponents(assert) {
      var _this22 = this;

      this.registerComponent('normal-message', {
        template: 'Normal: {{something}}!',
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: ['something']
        })
      });

      this.registerComponent('alternative-message', {
        template: 'Alternative: {{something}} {{somethingElse}}!',
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          something: 'Another'
        }).reopenClass({
          positionalParams: ['somethingElse']
        })
      });

      this.render('{{component componentName message}}', { componentName: 'normal-message', message: 'Hello' });

      this.assertComponentElement(this.firstChild, { content: 'Normal: Hello!' });

      this.runTask(function () {
        return _this22.rerender();
      });

      this.assertComponentElement(this.firstChild, { content: 'Normal: Hello!' });

      this.runTask(function () {
        return _emberMetal.set(_this22.context, 'componentName', 'alternative-message');
      });

      this.assertComponentElement(this.firstChild, { content: 'Alternative: Another Hello!' });

      this.runTask(function () {
        return _emberMetal.set(_this22.context, 'message', 'Hi');
      });

      this.assertComponentElement(this.firstChild, { content: 'Alternative: Another Hi!' });

      this.runTask(function () {
        _emberMetal.set(_this22.context, 'componentName', 'normal-message');
        _emberMetal.set(_this22.context, 'message', 'Hello');
      });

      this.assertComponentElement(this.firstChild, { content: 'Normal: Hello!' });
    };

    _class.prototype['@test static arbitrary number of positional parameters'] = function testStaticArbitraryNumberOfPositionalParameters(assert) {
      var _this23 = this;

      this.registerComponent('sample-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: 'names'
        }),
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2)
      });

      this.render('{{component "sample-component" "Foo" 4 "Bar" 5 "Baz" elementId="helper"}}');

      this.assertText('Foo4Bar5Baz');

      this.runTask(function () {
        return _this23.rerender();
      });

      this.assertText('Foo4Bar5Baz');
    };

    _class.prototype['@test dynamic arbitrary number of positional parameters'] = function testDynamicArbitraryNumberOfPositionalParameters(assert) {
      var _this24 = this;

      this.registerComponent('sample-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend().reopenClass({
          positionalParams: 'n'
        }),
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject3)
      });

      this.render('{{component "sample-component" user1 user2}}', {
        user1: 'Foo',
        user2: 4
      });

      this.assertText('Foo4');

      this.runTask(function () {
        return _this24.rerender();
      });

      this.assertText('Foo4');

      this.runTask(function () {
        return _this24.context.set('user1', 'Bar');
      });

      this.assertText('Bar4');

      this.runTask(function () {
        return _this24.context.set('user2', '5');
      });

      this.assertText('Bar5');

      this.runTask(function () {
        _this24.context.set('user1', 'Foo');
        _this24.context.set('user2', 4);
      });

      this.assertText('Foo4');
    };

    _class.prototype['@test component helper emits useful backtracking re-render assertion message'] = function testComponentHelperEmitsUsefulBacktrackingReRenderAssertionMessage(assert) {
      var _this25 = this;

      this.registerComponent('outer-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            this.set('person', { name: 'Alex' });
          }
        }),
        template: 'Hi {{person.name}}! {{component "error-component" person=person}}'
      });

      this.registerComponent('error-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            this.set('person.name', { name: 'Ben' });
          }
        }),
        template: '{{person.name}}'
      });

      var expectedBacktrackingMessage = /modified "person\.name" twice on \[object Object\] in a single render\. It was rendered in "component:outer-component" and modified in "component:error-component"/;

      if (true) {
        expectDeprecation(expectedBacktrackingMessage);
        this.render('{{component componentName}}', { componentName: 'outer-component' });
      } else {
        expectAssertion(function () {
          _this25.render('{{component componentName}}', { componentName: 'outer-component' });
        }, expectedBacktrackingMessage);
      }
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/components/dynamic-components-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/components/dynamic-components-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/components/dynamic-components-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/components/fragment-components-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/abstract-test-case', 'ember-glimmer/tests/utils/helpers', 'ember-metal'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsAbstractTestCase, _emberGlimmerTestsUtilsHelpers, _emberMetal) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['<div>Hey</div>bar'], ['<div>Hey</div>bar']),
      _templateObject2 = babelHelpers.taggedTemplateLiteralLoose(['<!---->bar'], ['<!---->bar']),
      _templateObject3 = babelHelpers.taggedTemplateLiteralLoose(['<!---->bizz'], ['<!---->bizz']);

  _emberGlimmerTestsUtilsTestCase.moduleFor('Components test: fragment components', (function (_RenderingTest) {
babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype.getCustomDispatcherEvents = function getCustomDispatcherEvents() {
      return {
        hitDem: 'folks'
      };
    };

    _class.prototype['@test fragments do not render an outer tag'] = function testFragmentsDoNotRenderAnOuterTag() {
      var instance = undefined;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: '',
        init: function () {
          this._super();
          instance = this;
          this.foo = true;
          this.bar = 'bar';
        }
      });

      var template = '{{#if foo}}<div>Hey</div>{{/if}}{{yield bar}}';

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: template });

      this.render('{{#foo-bar as |bar|}}{{bar}}{{/foo-bar}}');

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject));

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(instance, 'foo', false);
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2));

      this.runTask(function () {
        return _emberMetal.set(instance, 'bar', 'bizz');
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject3));

      this.runTask(function () {
        _emberMetal.set(instance, 'bar', 'bar');
        _emberMetal.set(instance, 'foo', true);
      });
    };

    _class.prototype['@test throws an error if an event function is defined in a tagless component'] = function testThrowsAnErrorIfAnEventFunctionIsDefinedInATaglessComponent() {
      var _this = this;

      var template = 'hit dem folks';
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: '',
        click: function () {}
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: template });

      expectAssertion(function () {
        _this.render('{{#foo-bar}}{{/foo-bar}}');
      }, /You can not define a function that handles DOM events in the .* tagless component since it doesn't have any DOM element./);
    };

    _class.prototype['@test throws an error if a custom defined event function is defined in a tagless component'] = function testThrowsAnErrorIfACustomDefinedEventFunctionIsDefinedInATaglessComponent() {
      var _this2 = this;

      var template = 'hit dem folks';
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: '',
        folks: function () {}
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: template });

      expectAssertion(function () {
        _this2.render('{{#foo-bar}}{{/foo-bar}}');
      }, /You can not define a function that handles DOM events in the .* tagless component since it doesn't have any DOM element./);
    };

    _class.prototype['@test throws an error if `tagName` is an empty string and `classNameBindings` are specified'] = function testThrowsAnErrorIfTagNameIsAnEmptyStringAndClassNameBindingsAreSpecified() {
      var _this3 = this;

      var template = 'hit dem folks';
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: '',
        foo: true,
        classNameBindings: ['foo:is-foo:is-bar']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: template });

      expectAssertion(function () {
        _this3.render('{{#foo-bar}}{{/foo-bar}}');
      }, /You cannot use `classNameBindings` on a tag-less component/);
    };

    _class.prototype['@test throws an error if `tagName` is an empty string and `attributeBindings` are specified'] = function testThrowsAnErrorIfTagNameIsAnEmptyStringAndAttributeBindingsAreSpecified() {
      var _this4 = this;

      var template = 'hit dem folks';
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: '',
        attributeBindings: ['href']
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: template });
      expectAssertion(function () {
        _this4.render('{{#foo-bar}}{{/foo-bar}}');
      }, /You cannot use `attributeBindings` on a tag-less component/);
    };

    _class.prototype['@test throws an error if `tagName` is an empty string and `elementId` is specified via JS'] = function testThrowsAnErrorIfTagNameIsAnEmptyStringAndElementIdIsSpecifiedViaJS() {
      var _this5 = this;

      var template = 'hit dem folks';
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: '',
        elementId: 'turntUp'
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: template });
      expectAssertion(function () {
        _this5.render('{{#foo-bar}}{{/foo-bar}}');
      }, /You cannot use `elementId` on a tag-less component/);
    };

    _class.prototype['@test throws an error if `tagName` is an empty string and `elementId` is specified via template'] = function testThrowsAnErrorIfTagNameIsAnEmptyStringAndElementIdIsSpecifiedViaTemplate() {
      var _this6 = this;

      var template = 'hit dem folks';
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: ''
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: template });
      expectAssertion(function () {
        _this6.render('{{#foo-bar elementId=\'turntUp\'}}{{/foo-bar}}');
      }, /You cannot use `elementId` on a tag-less component/);
    };

    _class.prototype['@test does not throw an error if `tagName` is an empty string and `id` is specified via JS'] = function testDoesNotThrowAnErrorIfTagNameIsAnEmptyStringAndIdIsSpecifiedViaJS() {
      var template = '{{id}}';
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: '',
        id: 'baz'
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: template });
      this.render('{{#foo-bar}}{{/foo-bar}}');
      this.assertText('baz');
    };

    _class.prototype['@test does not throw an error if `tagName` is an empty string and `id` is specified via template'] = function testDoesNotThrowAnErrorIfTagNameIsAnEmptyStringAndIdIsSpecifiedViaTemplate() {
      var template = '{{id}}';
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: ''
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: template });
      this.render('{{#foo-bar id=\'baz\'}}{{/foo-bar}}');
      this.assertText('baz');
    };

    _class.prototype['@test does not throw an error if `tagName` is an empty string and `id` is bound property specified via template'] = function testDoesNotThrowAnErrorIfTagNameIsAnEmptyStringAndIdIsBoundPropertySpecifiedViaTemplate() {
      var _this7 = this;

      var template = '{{id}}';
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: ''
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: template });

      this.render('{{#foo-bar id=fooBarId}}{{/foo-bar}}', { fooBarId: 'baz' });

      this.assertText('baz');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'fooBarId', 'qux');
      });

      this.assertText('qux');

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'fooBarId', 'baz');
      });

      this.assertText('baz');
    };

    _class.prototype['@test does not throw an error if `tagName` is an empty string and `id` is specified via template and passed to child component'] = function testDoesNotThrowAnErrorIfTagNameIsAnEmptyStringAndIdIsSpecifiedViaTemplateAndPassedToChildComponent() {
      var fooBarTemplate = '{{#baz-child id=id}}{{/baz-child}}';
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: ''
      });
      var BazChildComponent = _emberGlimmerTestsUtilsHelpers.Component.extend();
      var bazChildTemplate = '{{id}}';

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: fooBarTemplate });
      this.registerComponent('baz-child', { ComponentClass: BazChildComponent, template: bazChildTemplate });
      this.render('{{#foo-bar id=\'baz\'}}{{/foo-bar}}');
      this.assertText('baz');
    };

    _class.prototype['@test throws an error if when $() is accessed on component where `tagName` is an empty string'] = function testThrowsAnErrorIfWhen$IsAccessedOnComponentWhereTagNameIsAnEmptyString() {
      var _this8 = this;

      var template = 'hit dem folks';
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: '',
        init: function () {
          this._super();
          this.$();
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: template });

      expectAssertion(function () {
        _this8.render('{{#foo-bar}}{{/foo-bar}}');
      }, /You cannot access this.\$\(\) on a component with `tagName: \'\'` specified/);
    };

    _class.prototype['@test renders a contained view with omitted start tag and tagless parent view context'] = function testRendersAContainedViewWithOmittedStartTagAndTaglessParentViewContext() {
      var _this9 = this;

      this.registerComponent('root-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          tagName: 'section'
        }),
        template: '{{frag-ment}}'
      });

      this.registerComponent('frag-ment', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          tagName: ''
        }),
        template: '{{my-span}}'
      });

      this.registerComponent('my-span', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          tagName: 'span'
        }),
        template: 'dab'
      });

      this.render('{{root-component}}');

      this.assertElement(this.firstChild, { tagName: 'section' });
      this.assertElement(this.firstChild.firstElementChild, { tagName: 'span' });

      this.runTask(function () {
        return _this9.rerender();
      });

      this.assertElement(this.firstChild, { tagName: 'section' });
      this.assertElement(this.firstChild.firstElementChild, { tagName: 'span' });
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/components/fragment-components-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/components/fragment-components-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/components/fragment-components-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/components/instrumentation-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/helpers', 'ember-metal'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsHelpers, _emberMetal) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Components instrumentation', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      var _this = this;

      _RenderingTest.call(this);

      this.resetEvents();

      _emberMetal.instrumentationSubscribe('render.component', {
        before: function (name, timestamp, payload) {
          if (payload.view !== _this.component) {
            _this.actual.before.push(payload);
          }
        },
        after: function (name, timestamp, payload) {
          if (payload.view !== _this.component) {
            _this.actual.after.push(payload);
          }
        }
      });
    }

    _class.prototype.resetEvents = function resetEvents() {
      this.expected = {
        before: [],
        after: []
      };

      this.actual = {
        before: [],
        after: []
      };
    };

    _class.prototype.teardown = function teardown() {
      this.assert.deepEqual(this.actual.before, [], 'No unexpected events (before)');
      this.assert.deepEqual(this.actual.after, [], 'No unexpected events (after)');
      _RenderingTest.prototype.teardown.call(this);
      _emberMetal.instrumentationReset();
    };

    _class.prototype['@test zomg'] = function testZomg(assert) {
      assert.ok(true);
    };

    _class.prototype['@test it should receive an instrumentation event for both initial render and updates'] = function testItShouldReceiveAnInstrumentationEventForBothInitialRenderAndUpdates(assert) {
      var _this2 = this;

      var testCase = this;

      var BaseClass = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: '',

        willRender: function () {
          testCase.expected.before.push(this);
          testCase.expected.after.unshift(this);
        }
      });

      this.registerComponent('x-bar', {
        template: '[x-bar: {{bar}}] {{yield}}',
        ComponentClass: BaseClass.extend()
      });

      this.registerComponent('x-baz', {
        template: '[x-baz: {{baz}}]',
        ComponentClass: BaseClass.extend()
      });

      this.registerComponent('x-bat', {
        template: '[x-bat: {{bat}}]',
        ComponentClass: BaseClass.extend()
      });

      this.render('[-top-level: {{foo}}] {{#x-bar bar=bar}}{{x-baz baz=baz}}{{/x-bar}} {{x-bat bat=bat}}', {
        foo: 'foo', bar: 'bar', baz: 'baz', bat: 'bat'
      });

      this.assertText('[-top-level: foo] [x-bar: bar] [x-baz: baz] [x-bat: bat]');

      this.assertEvents('after initial render', true);

      this.runTask(function () {
        return _this2.rerender();
      });

      this.assertEvents('after no-op rerender');

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'foo', 'FOO');
      });

      this.assertEvents('after updating top-level');

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'baz', 'BAZ');
      });

      this.assertEvents('after updating inner-most');

      this.runTask(function () {
        _emberMetal.set(_this2.context, 'bar', 'BAR');
        _emberMetal.set(_this2.context, 'bat', 'BAT');
      });

      this.assertEvents('after updating the rest');

      this.runTask(function () {
        _emberMetal.set(_this2.context, 'foo', 'FOO');
        _emberMetal.set(_this2.context, 'bar', 'BAR');
        _emberMetal.set(_this2.context, 'baz', 'BAZ');
        _emberMetal.set(_this2.context, 'bat', 'BAT');
      });

      this.assertEvents('after reset');
    };

    _class.prototype.assertEvents = function assertEvents(label) {
      var initialRender = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
      var actual = this.actual;
      var expected = this.expected;

      this.assert.strictEqual(actual.before.length, actual.after.length, label + ': before and after callbacks should be balanced');

      this._assertEvents(label + ' (before):', actual.before, expected.before, initialRender);
      this._assertEvents(label + ' (after):', actual.before, expected.before, initialRender);

      this.resetEvents();
    };

    _class.prototype._assertEvents = function _assertEvents(label, actual, expected, initialRender) {
      var _this3 = this;

      this.assert.equal(actual.length, expected.length, label + ': expected ' + expected.length + ' and got ' + actual.length);

      actual.forEach(function (payload, i) {
        return _this3.assertPayload(payload, expected[i], initialRender);
      });
    };

    _class.prototype.assertPayload = function assertPayload(payload, component, initialRender) {
      this.assert.equal(payload.object, component.toString(), 'payload.object');
      this.assert.ok(payload.containerKey, 'the container key should be present');
      this.assert.equal(payload.containerKey, component._debugContainerKey, 'payload.containerKey');
      this.assert.equal(payload.view, component, 'payload.view');
      this.assert.strictEqual(payload.initialRender, initialRender, 'payload.initialRender');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/components/instrumentation-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/components/instrumentation-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/components/instrumentation-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/components/life-cycle-test', ['exports', 'ember-metal', 'ember-runtime', 'ember-glimmer/tests/utils/helpers', 'ember-glimmer/tests/utils/abstract-test-case', 'ember-glimmer/tests/utils/test-case', 'ember-views', 'ember-glimmer/tests/utils/test-helpers', 'ember-utils', 'internal-test-helpers'], function (exports, _emberMetal, _emberRuntime, _emberGlimmerTestsUtilsHelpers, _emberGlimmerTestsUtilsAbstractTestCase, _emberGlimmerTestsUtilsTestCase, _emberViews, _emberGlimmerTestsUtilsTestHelpers, _emberUtils, _internalTestHelpers) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n      <div>\n        Twitter: {{', '}}|\n        ', '\n      </div>'], ['\n      <div>\n        Twitter: {{', '}}|\n        ', '\n      </div>']),
      _templateObject2 = babelHelpers.taggedTemplateLiteralLoose(['\n      <div>\n        Name: {{', '}}|\n        ', '\n      </div>'], ['\n      <div>\n        Name: {{', '}}|\n        ', '\n      </div>']),
      _templateObject3 = babelHelpers.taggedTemplateLiteralLoose(['\n      <div>\n        Website: {{', '}}\n      </div>'], ['\n      <div>\n        Website: {{', '}}\n      </div>']),
      _templateObject4 = babelHelpers.taggedTemplateLiteralLoose(['\n      <div>\n        ', '|\n        ', '|\n        ', '\n      </div>'], ['\n      <div>\n        ', '|\n        ', '|\n        ', '\n      </div>']),
      _templateObject5 = babelHelpers.taggedTemplateLiteralLoose(['\n      <div>\n        Top: ', '\n      </div>'], ['\n      <div>\n        Top: ', '\n      </div>']),
      _templateObject6 = babelHelpers.taggedTemplateLiteralLoose(['\n      <div>\n        Middle: ', '\n      </div>'], ['\n      <div>\n        Middle: ', '\n      </div>']),
      _templateObject7 = babelHelpers.taggedTemplateLiteralLoose(['\n      <div>\n        Bottom: {{', '}}\n      </div>'], ['\n      <div>\n        Bottom: {{', '}}\n      </div>']),
      _templateObject8 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#nested-item}}Item: {{count}}{{/nested-item}}\n    '], ['\n      {{#nested-item}}Item: {{count}}{{/nested-item}}\n    ']),
      _templateObject9 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#nested-item}}Nothing to see here{{/nested-item}}\n    '], ['\n      {{#nested-item}}Nothing to see here{{/nested-item}}\n    ']),
      _templateObject10 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#each items as |item|}}\n        ', '\n      {{else}}\n        ', '\n      {{/each}}\n    '], ['\n      {{#each items as |item|}}\n        ', '\n      {{else}}\n        ', '\n      {{/each}}\n    ']),
      _templateObject11 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{yield}}\n      <ul>\n        {{#nested-component nestedId=(concat itemId \'-A\')}}A{{/nested-component}}\n        {{#nested-component nestedId=(concat itemId \'-B\')}}B{{/nested-component}}\n      </ul>\n    '], ['\n      {{yield}}\n      <ul>\n        {{#nested-component nestedId=(concat itemId \'-A\')}}A{{/nested-component}}\n        {{#nested-component nestedId=(concat itemId \'-B\')}}B{{/nested-component}}\n      </ul>\n    ']),
      _templateObject12 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#each items as |item|}}\n        {{#parent-component itemId=item.id}}{{item.id}}{{/parent-component}}\n      {{/each}}\n      {{#if model.shouldShow}}\n        {{#parent-component itemId=6}}6{{/parent-component}}\n      {{/if}}\n      {{#if model.shouldShow}}\n        {{#parent-component itemId=7}}7{{/parent-component}}\n      {{/if}}\n    '], ['\n      {{#each items as |item|}}\n        {{#parent-component itemId=item.id}}{{item.id}}{{/parent-component}}\n      {{/each}}\n      {{#if model.shouldShow}}\n        {{#parent-component itemId=6}}6{{/parent-component}}\n      {{/if}}\n      {{#if model.shouldShow}}\n        {{#parent-component itemId=7}}7{{/parent-component}}\n      {{/if}}\n    ']);

  var LifeCycleHooksTest = (function (_RenderingTest) {
babelHelpers.inherits(LifeCycleHooksTest, _RenderingTest);

    function LifeCycleHooksTest() {
      _RenderingTest.call(this);
      this.hooks = [];
      this.components = {};
      this.componentRegistry = [];
      this.teardownAssertions = [];
    }

    LifeCycleHooksTest.prototype.teardown = function teardown() {
      _RenderingTest.prototype.teardown.call(this);

      for (var i = 0; i < this.teardownAssertions.length; i++) {
        this.teardownAssertions[i]();
      }
    };

    LifeCycleHooksTest.prototype.getBootOptions = function getBootOptions() {
      return {
        isInteractive: this.isInteractive
      };
    };

    /* abstract */

    /* abstract */

    LifeCycleHooksTest.prototype.invocationFor = function invocationFor(name) {
      var namedArgs = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      throw new Error('Not implemented: `invocationFor`');
    };

    /* abstract */

    LifeCycleHooksTest.prototype.attrFor = function attrFor(name) {
      throw new Error('Not implemented: `attrFor`');
    };

    LifeCycleHooksTest.prototype.assertRegisteredViews = function assertRegisteredViews(label) {
      var viewRegistry = this.owner.lookup('-view-registry:main');
      var topLevelId = _emberViews.getViewId(this.component);
      var actual = Object.keys(viewRegistry).sort().filter(function (id) {
        return id !== topLevelId;
      });

      if (this.isInteractive) {
        var expected = this.componentRegistry.sort();

        this.assert.deepEqual(actual, expected, 'registered views - ' + label);
      } else {
        this.assert.deepEqual(actual, [], 'no views should be registered for non-interactive mode');
      }
    };

    LifeCycleHooksTest.prototype.registerComponent = function registerComponent(name, _ref) {
      var _this = this;

      var _ref$template = _ref.template;
      var template = _ref$template === undefined ? null : _ref$template;

      var pushComponent = function (instance) {
        _this.components[name] = instance;
        _this.componentRegistry.push(_emberViews.getViewId(instance));
      };

      var removeComponent = function (instance) {
        var index = _this.componentRegistry.indexOf(instance);
        _this.componentRegistry.splice(index, 1);

        delete _this.components[name];
      };

      var pushHook = function (hookName, args) {
        _this.hooks.push(hook(name, hookName, args));
      };

      var assertParentView = function (hookName, instance) {
        _this.assert.ok(instance.parentView, 'parentView should be present in ' + hookName);

        if (hookName === 'willDestroyElement') {
          _this.assert.ok(instance.parentView.childViews.indexOf(instance) !== -1, 'view is still connected to parentView in ' + hookName);
        }
      };

      var assertElement = function (hookName, instance) {
        var inDOM = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

        if (instance.tagName === '') {
          return;
        }

        _this.assert.ok(_emberViews.getViewElement(instance), 'element should be present on ' + instance + ' during ' + hookName);

        if (_this.isInteractive) {
          _this.assert.ok(instance.element, 'this.element should be present on ' + instance + ' during ' + hookName);
          _this.assert.equal(document.body.contains(instance.element), inDOM, 'element for ' + instance + ' ' + (inDOM ? 'should' : 'should not') + ' be in the DOM during ' + hookName);
        } else {
          _this.assert.throws(function () {
            return instance.element;
          }, /Accessing `this.element` is not allowed in non-interactive environments/);
        }
      };

      var assertNoElement = function (hookName, instance) {
        _this.assert.strictEqual(_emberViews.getViewElement(instance), null, 'element should not be present in ' + hookName);

        if (_this.isInteractive) {
          _this.assert.strictEqual(instance.element, null, 'this.element should not be present in ' + hookName);
        } else {
          _this.assert.throws(function () {
            return instance.element;
          }, /Accessing `this.element` is not allowed in non-interactive environments/);
        }
      };

      var assertState = function (hookName, expectedState, instance) {
        _this.assert.equal(instance._state, expectedState, 'within ' + hookName + ' the expected _state is ' + expectedState);
      };

      var isInteractive = this.isInteractive;

      var ComponentClass = this.ComponentClass.extend({
        init: function () {
          var _this2 = this,
              _arguments = arguments;

          expectDeprecation(function () {
            _this2._super.apply(_this2, _arguments);
          }, /didInitAttrs called/);

          this.isInitialRender = true;
          this.componentName = name;
          pushHook('init');
          pushComponent(this);
          assertParentView('init', this);
          assertNoElement('init', this);
          assertState('init', 'preRender', this);

          this.on('init', function () {
            return pushHook('on(init)');
          });

          _emberMetal.run.scheduleOnce('afterRender', function () {
            _this2.isInitialRender = false;
          });
        },

        didInitAttrs: function (options) {
          pushHook('didInitAttrs', options);
          assertParentView('didInitAttrs', this);
          assertNoElement('didInitAttrs', this);
          assertState('didInitAttrs', 'preRender', this);
        },

        didReceiveAttrs: function (options) {
          pushHook('didReceiveAttrs', options);
          assertParentView('didReceiveAttrs', this);

          if (this.isInitialRender) {
            assertNoElement('didReceiveAttrs', this);
            assertState('didReceiveAttrs', 'preRender', this);
          } else {
            assertElement('didReceiveAttrs', this);

            if (isInteractive) {
              assertState('didReceiveAttrs', 'inDOM', this);
            } else {
              assertState('didReceiveAttrs', 'hasElement', this);
            }
          }
        },

        willInsertElement: function () {
          pushHook('willInsertElement');
          assertParentView('willInsertElement', this);
          assertElement('willInsertElement', this, false);
          assertState('willInsertElement', 'hasElement', this);
        },

        willRender: function () {
          pushHook('willRender');
          assertParentView('willRender', this);

          if (this.isInitialRender) {
            assertNoElement('willRender', this, false);
            assertState('willRender', 'preRender', this);
          } else {
            assertElement('willRender', this);
            assertState('willRender', 'inDOM', this);
          }
        },

        didInsertElement: function () {
          pushHook('didInsertElement');
          assertParentView('didInsertElement', this);
          assertElement('didInsertElement', this);
          assertState('didInsertElement', 'inDOM', this);
        },

        didRender: function () {
          pushHook('didRender');
          assertParentView('didRender', this);
          assertElement('didRender', this);
          assertState('didRender', 'inDOM', this);
        },

        didUpdateAttrs: function (options) {
          pushHook('didUpdateAttrs', options);
          assertParentView('didUpdateAttrs', this);

          if (isInteractive) {
            assertState('didUpdateAttrs', 'inDOM', this);
          } else {
            assertState('didUpdateAttrs', 'hasElement', this);
          }
        },

        willUpdate: function (options) {
          pushHook('willUpdate', options);
          assertParentView('willUpdate', this);
          assertElement('willUpdate', this);
          assertState('willUpdate', 'inDOM', this);
        },

        didUpdate: function (options) {
          pushHook('didUpdate', options);
          assertParentView('didUpdate', this);
          assertElement('didUpdate', this);
          assertState('didUpdate', 'inDOM', this);
        },

        willDestroyElement: function () {
          pushHook('willDestroyElement');
          assertParentView('willDestroyElement', this);
          assertElement('willDestroyElement', this);
          assertState('willDestroyElement', 'inDOM', this);
        },

        willClearRender: function () {
          pushHook('willClearRender');
          assertParentView('willClearRender', this);
          assertElement('willClearRender', this);
          assertState('willClearRender', 'inDOM', this);
        },

        didDestroyElement: function () {
          pushHook('didDestroyElement');
          assertNoElement('didDestroyElement', this);
          assertState('didDestroyElement', 'destroying', this);
        },

        willDestroy: function () {
          pushHook('willDestroy');
          removeComponent(this);

          this._super.apply(this, arguments);
        }
      });

      _RenderingTest.prototype.registerComponent.call(this, name, { ComponentClass: ComponentClass, template: template });
    };

    LifeCycleHooksTest.prototype.assertHooks = function assertHooks(_ref2) {
      var label = _ref2.label;
      var interactive = _ref2.interactive;
      var nonInteractive = _ref2.nonInteractive;

      var rawHooks = this.isInteractive ? interactive : nonInteractive;
      var hooks = rawHooks.map(function (raw) {
        return hook.apply(undefined, raw);
      });
      this.assert.deepEqual(json(this.hooks), json(hooks), label);
      this.hooks = [];
    };

    LifeCycleHooksTest.prototype['@test lifecycle hooks are invoked in a predictable order'] = function testLifecycleHooksAreInvokedInAPredictableOrder() {
      var _this3 = this;

      var _boundHelpers = this.boundHelpers;
      var attr = _boundHelpers.attr;
      var invoke = _boundHelpers.invoke;

      this.registerComponent('the-top', { template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject, attr('twitter'), invoke('the-middle', { name: string('Tom Dale') }))
      });

      this.registerComponent('the-middle', { template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2, attr('name'), invoke('the-bottom', { website: string('tomdale.net') }))
      });

      this.registerComponent('the-bottom', { template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject3, attr('website'))
      });

      this.render(invoke('the-top', { twitter: expr('twitter') }), { twitter: '@tomdale' });

      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');
      this.assertRegisteredViews('intial render');

      var topAttrs = { twitter: '@tomdale' };
      var middleAttrs = { name: 'Tom Dale' };
      var bottomAttrs = { website: 'tomdale.net' };

      this.assertHooks({
        label: 'after initial render',

        interactive: [
        // Sync hooks

        ['the-top', 'init'], ['the-top', 'didInitAttrs', { attrs: topAttrs, newAttrs: topAttrs }], ['the-top', 'didReceiveAttrs', { attrs: topAttrs, newAttrs: topAttrs }], ['the-top', 'on(init)'], ['the-top', 'willRender'], ['the-top', 'willInsertElement'], ['the-middle', 'init'], ['the-middle', 'didInitAttrs', { attrs: middleAttrs, newAttrs: middleAttrs }], ['the-middle', 'didReceiveAttrs', { attrs: middleAttrs, newAttrs: middleAttrs }], ['the-middle', 'on(init)'], ['the-middle', 'willRender'], ['the-middle', 'willInsertElement'], ['the-bottom', 'init'], ['the-bottom', 'didInitAttrs', { attrs: bottomAttrs, newAttrs: bottomAttrs }], ['the-bottom', 'didReceiveAttrs', { attrs: bottomAttrs, newAttrs: bottomAttrs }], ['the-bottom', 'on(init)'], ['the-bottom', 'willRender'], ['the-bottom', 'willInsertElement'],

        // Async hooks

        ['the-bottom', 'didInsertElement'], ['the-bottom', 'didRender'], ['the-middle', 'didInsertElement'], ['the-middle', 'didRender'], ['the-top', 'didInsertElement'], ['the-top', 'didRender']],

        nonInteractive: [
        // Sync hooks
        ['the-top', 'init'], ['the-top', 'didInitAttrs', { attrs: topAttrs, newAttrs: topAttrs }], ['the-top', 'didReceiveAttrs', { attrs: topAttrs, newAttrs: topAttrs }], ['the-top', 'on(init)'], ['the-middle', 'init'], ['the-middle', 'didInitAttrs', { attrs: middleAttrs, newAttrs: middleAttrs }], ['the-middle', 'didReceiveAttrs', { attrs: middleAttrs, newAttrs: middleAttrs }], ['the-middle', 'on(init)'], ['the-bottom', 'init'], ['the-bottom', 'didInitAttrs', { attrs: bottomAttrs, newAttrs: bottomAttrs }], ['the-bottom', 'didReceiveAttrs', { attrs: bottomAttrs, newAttrs: bottomAttrs }], ['the-bottom', 'on(init)']]
      });

      this.runTask(function () {
        return _this3.components['the-bottom'].rerender();
      });

      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');

      this.assertHooks({
        label: 'after no-op rerender (bottom)',

        interactive: [
        // Sync hooks
        ['the-top', 'willUpdate'], ['the-top', 'willRender'], ['the-middle', 'willUpdate'], ['the-middle', 'willRender'], ['the-bottom', 'willUpdate'], ['the-bottom', 'willRender'],

        // Async hooks

        ['the-bottom', 'didUpdate'], ['the-bottom', 'didRender'], ['the-middle', 'didUpdate'], ['the-middle', 'didRender'], ['the-top', 'didUpdate'], ['the-top', 'didRender']],

        nonInteractive: []
      });

      this.runTask(function () {
        return _this3.components['the-middle'].rerender();
      });

      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');

      this.assertHooks({
        label: 'after no-op rerender (middle)',

        interactive: [
        // Sync hooks

        ['the-top', 'willUpdate'], ['the-top', 'willRender'], ['the-middle', 'willUpdate'], ['the-middle', 'willRender'],

        // Async hooks

        ['the-middle', 'didUpdate'], ['the-middle', 'didRender'], ['the-top', 'didUpdate'], ['the-top', 'didRender']],

        nonInteractive: []
      });

      this.runTask(function () {
        return _this3.components['the-top'].rerender();
      });

      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');

      this.assertHooks({
        label: 'after no-op rerender (top)',

        interactive: [
        // Sync hooks

        ['the-top', 'willUpdate'], ['the-top', 'willRender'],

        // Async hooks

        ['the-top', 'didUpdate'], ['the-top', 'didRender']],

        nonInteractive: []
      });

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'twitter', '@horsetomdale');
      });

      this.assertText('Twitter: @horsetomdale|Name: Tom Dale|Website: tomdale.net');

      // Because the `twitter` attr is only used by the topmost component,
      // and not passed down, we do not expect to see lifecycle hooks
      // called for child components. If the `didReceiveAttrs` hook used
      // the new attribute to rerender itself imperatively, that would result
      // in lifecycle hooks being invoked for the child.

      topAttrs = { attrs: { twitter: '@horsetomdale' }, oldAttrs: { twitter: '@tomdale' }, newAttrs: { twitter: '@horsetomdale' } };

      this.assertHooks({
        label: 'after update',

        interactive: [
        // Sync hooks

        ['the-top', 'didUpdateAttrs', topAttrs], ['the-top', 'didReceiveAttrs', topAttrs], ['the-top', 'willUpdate'], ['the-top', 'willRender'],

        // Async hooks

        ['the-top', 'didUpdate'], ['the-top', 'didRender']],

        nonInteractive: [
        // Sync hooks
        ['the-top', 'didUpdateAttrs', topAttrs], ['the-top', 'didReceiveAttrs', topAttrs]]
      });

      this.teardownAssertions.push(function () {
        _this3.assertHooks({
          label: 'destroy',

          interactive: [['the-top', 'willDestroyElement'], ['the-top', 'willClearRender'], ['the-middle', 'willDestroyElement'], ['the-middle', 'willClearRender'], ['the-bottom', 'willDestroyElement'], ['the-bottom', 'willClearRender'], ['the-top', 'didDestroyElement'], ['the-middle', 'didDestroyElement'], ['the-bottom', 'didDestroyElement'], ['the-top', 'willDestroy'], ['the-middle', 'willDestroy'], ['the-bottom', 'willDestroy']],

          nonInteractive: [['the-top', 'willDestroy'], ['the-middle', 'willDestroy'], ['the-bottom', 'willDestroy']]
        });

        _this3.assertRegisteredViews('after destroy');
      });
    };

    LifeCycleHooksTest.prototype['@test lifecycle hooks are invoked in a correct sibling order'] = function testLifecycleHooksAreInvokedInACorrectSiblingOrder() {
      var _this4 = this;

      var _boundHelpers2 = this.boundHelpers;
      var attr = _boundHelpers2.attr;
      var invoke = _boundHelpers2.invoke;

      this.registerComponent('the-parent', { template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject4, invoke('the-first-child', { twitter: expr(attr('twitter')) }), invoke('the-second-child', { name: expr(attr('name')) }), invoke('the-last-child', { website: expr(attr('website')) }))
      });

      this.registerComponent('the-first-child', { template: 'Twitter: {{' + attr('twitter') + '}}' });

      this.registerComponent('the-second-child', { template: 'Name: {{' + attr('name') + '}}' });

      this.registerComponent('the-last-child', { template: 'Website: {{' + attr('website') + '}}' });

      this.render(invoke('the-parent', {
        twitter: expr('twitter'),
        name: expr('name'),
        website: expr('website')
      }), {
        twitter: '@tomdale',
        name: 'Tom Dale',
        website: 'tomdale.net'
      });

      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');
      this.assertRegisteredViews('intial render');

      var parentAttrs = { twitter: '@tomdale', name: 'Tom Dale', website: 'tomdale.net' };
      var firstAttrs = { twitter: '@tomdale' };
      var secondAttrs = { name: 'Tom Dale' };
      var lastAttrs = { website: 'tomdale.net' };

      this.assertHooks({
        label: 'after initial render',

        interactive: [
        // Sync hooks

        ['the-parent', 'init'], ['the-parent', 'didInitAttrs', { attrs: parentAttrs, newAttrs: parentAttrs }], ['the-parent', 'didReceiveAttrs', { attrs: parentAttrs, newAttrs: parentAttrs }], ['the-parent', 'on(init)'], ['the-parent', 'willRender'], ['the-parent', 'willInsertElement'], ['the-first-child', 'init'], ['the-first-child', 'didInitAttrs', { attrs: firstAttrs, newAttrs: firstAttrs }], ['the-first-child', 'didReceiveAttrs', { attrs: firstAttrs, newAttrs: firstAttrs }], ['the-first-child', 'on(init)'], ['the-first-child', 'willRender'], ['the-first-child', 'willInsertElement'], ['the-second-child', 'init'], ['the-second-child', 'didInitAttrs', { attrs: secondAttrs, newAttrs: secondAttrs }], ['the-second-child', 'didReceiveAttrs', { attrs: secondAttrs, newAttrs: secondAttrs }], ['the-second-child', 'on(init)'], ['the-second-child', 'willRender'], ['the-second-child', 'willInsertElement'], ['the-last-child', 'init'], ['the-last-child', 'didInitAttrs', { attrs: lastAttrs, newAttrs: lastAttrs }], ['the-last-child', 'didReceiveAttrs', { attrs: lastAttrs, newAttrs: lastAttrs }], ['the-last-child', 'on(init)'], ['the-last-child', 'willRender'], ['the-last-child', 'willInsertElement'],

        // Async hooks

        ['the-first-child', 'didInsertElement'], ['the-first-child', 'didRender'], ['the-second-child', 'didInsertElement'], ['the-second-child', 'didRender'], ['the-last-child', 'didInsertElement'], ['the-last-child', 'didRender'], ['the-parent', 'didInsertElement'], ['the-parent', 'didRender']],

        nonInteractive: [
        // Sync hooks

        ['the-parent', 'init'], ['the-parent', 'didInitAttrs', { attrs: parentAttrs, newAttrs: parentAttrs }], ['the-parent', 'didReceiveAttrs', { attrs: parentAttrs, newAttrs: parentAttrs }], ['the-parent', 'on(init)'], ['the-first-child', 'init'], ['the-first-child', 'didInitAttrs', { attrs: firstAttrs, newAttrs: firstAttrs }], ['the-first-child', 'didReceiveAttrs', { attrs: firstAttrs, newAttrs: firstAttrs }], ['the-first-child', 'on(init)'], ['the-second-child', 'init'], ['the-second-child', 'didInitAttrs', { attrs: secondAttrs, newAttrs: secondAttrs }], ['the-second-child', 'didReceiveAttrs', { attrs: secondAttrs, newAttrs: secondAttrs }], ['the-second-child', 'on(init)'], ['the-last-child', 'init'], ['the-last-child', 'didInitAttrs', { attrs: lastAttrs, newAttrs: lastAttrs }], ['the-last-child', 'didReceiveAttrs', { attrs: lastAttrs, newAttrs: lastAttrs }], ['the-last-child', 'on(init)']]
      });

      this.runTask(function () {
        return _this4.components['the-first-child'].rerender();
      });

      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');

      this.assertHooks({
        label: 'after no-op rerender (first child)',

        interactive: [
        // Sync hooks

        ['the-parent', 'willUpdate'], ['the-parent', 'willRender'], ['the-first-child', 'willUpdate'], ['the-first-child', 'willRender'],

        // Async hooks

        ['the-first-child', 'didUpdate'], ['the-first-child', 'didRender'], ['the-parent', 'didUpdate'], ['the-parent', 'didRender']],

        nonInteractive: []
      });

      this.runTask(function () {
        return _this4.components['the-second-child'].rerender();
      });

      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');

      this.assertHooks({
        label: 'after no-op rerender (second child)',

        interactive: [
        // Sync hooks

        ['the-parent', 'willUpdate'], ['the-parent', 'willRender'], ['the-second-child', 'willUpdate'], ['the-second-child', 'willRender'],

        // Async hooks

        ['the-second-child', 'didUpdate'], ['the-second-child', 'didRender'], ['the-parent', 'didUpdate'], ['the-parent', 'didRender']],

        nonInteractive: []
      });

      this.runTask(function () {
        return _this4.components['the-last-child'].rerender();
      });

      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');

      this.assertHooks({
        label: 'after no-op rerender (last child)',

        interactive: [
        // Sync hooks

        ['the-parent', 'willUpdate'], ['the-parent', 'willRender'], ['the-last-child', 'willUpdate'], ['the-last-child', 'willRender'],

        // Async hooks

        ['the-last-child', 'didUpdate'], ['the-last-child', 'didRender'], ['the-parent', 'didUpdate'], ['the-parent', 'didRender']],

        nonInteractive: []
      });

      this.runTask(function () {
        return _this4.components['the-parent'].rerender();
      });

      this.assertText('Twitter: @tomdale|Name: Tom Dale|Website: tomdale.net');

      this.assertHooks({
        label: 'after no-op rerender (parent)',

        interactive: [
        // Sync hooks

        ['the-parent', 'willUpdate'], ['the-parent', 'willRender'],

        // Async hooks

        ['the-parent', 'didUpdate'], ['the-parent', 'didRender']],

        nonInteractive: []
      });

      this.runTask(function () {
        return _emberMetal.setProperties(_this4.context, {
          twitter: '@horsetomdale',
          name: 'Horse Tom Dale',
          website: 'horsetomdale.net'
        });
      });

      this.assertText('Twitter: @horsetomdale|Name: Horse Tom Dale|Website: horsetomdale.net');

      parentAttrs = {
        attrs: { twitter: '@horsetomdale', name: 'Horse Tom Dale', website: 'horsetomdale.net' },
        oldAttrs: { twitter: '@tomdale', name: 'Tom Dale', website: 'tomdale.net' },
        newAttrs: { twitter: '@horsetomdale', name: 'Horse Tom Dale', website: 'horsetomdale.net' }
      };
      firstAttrs = { attrs: { twitter: '@horsetomdale' }, oldAttrs: { twitter: '@tomdale' }, newAttrs: { twitter: '@horsetomdale' } };
      secondAttrs = { attrs: { name: 'Horse Tom Dale' }, oldAttrs: { name: 'Tom Dale' }, newAttrs: { name: 'Horse Tom Dale' } };
      lastAttrs = { attrs: { website: 'horsetomdale.net' }, oldAttrs: { website: 'tomdale.net' }, newAttrs: { website: 'horsetomdale.net' } };

      this.assertHooks({
        label: 'after update',

        interactive: [
        // Sync hooks

        ['the-parent', 'didUpdateAttrs', parentAttrs], ['the-parent', 'didReceiveAttrs', parentAttrs], ['the-parent', 'willUpdate'], ['the-parent', 'willRender'], ['the-first-child', 'didUpdateAttrs', firstAttrs], ['the-first-child', 'didReceiveAttrs', firstAttrs], ['the-first-child', 'willUpdate'], ['the-first-child', 'willRender'], ['the-second-child', 'didUpdateAttrs', secondAttrs], ['the-second-child', 'didReceiveAttrs', secondAttrs], ['the-second-child', 'willUpdate'], ['the-second-child', 'willRender'], ['the-last-child', 'didUpdateAttrs', lastAttrs], ['the-last-child', 'didReceiveAttrs', lastAttrs], ['the-last-child', 'willUpdate'], ['the-last-child', 'willRender'],

        // Async hooks

        ['the-first-child', 'didUpdate'], ['the-first-child', 'didRender'], ['the-second-child', 'didUpdate'], ['the-second-child', 'didRender'], ['the-last-child', 'didUpdate'], ['the-last-child', 'didRender'], ['the-parent', 'didUpdate'], ['the-parent', 'didRender']],

        nonInteractive: [
        // Sync hooks

        ['the-parent', 'didUpdateAttrs', parentAttrs], ['the-parent', 'didReceiveAttrs', parentAttrs], ['the-first-child', 'didUpdateAttrs', firstAttrs], ['the-first-child', 'didReceiveAttrs', firstAttrs], ['the-second-child', 'didUpdateAttrs', secondAttrs], ['the-second-child', 'didReceiveAttrs', secondAttrs], ['the-last-child', 'didUpdateAttrs', lastAttrs], ['the-last-child', 'didReceiveAttrs', lastAttrs]]
      });

      this.teardownAssertions.push(function () {
        _this4.assertHooks({
          label: 'destroy',

          interactive: [['the-parent', 'willDestroyElement'], ['the-parent', 'willClearRender'], ['the-first-child', 'willDestroyElement'], ['the-first-child', 'willClearRender'], ['the-second-child', 'willDestroyElement'], ['the-second-child', 'willClearRender'], ['the-last-child', 'willDestroyElement'], ['the-last-child', 'willClearRender'], ['the-parent', 'didDestroyElement'], ['the-first-child', 'didDestroyElement'], ['the-second-child', 'didDestroyElement'], ['the-last-child', 'didDestroyElement'], ['the-parent', 'willDestroy'], ['the-first-child', 'willDestroy'], ['the-second-child', 'willDestroy'], ['the-last-child', 'willDestroy']],

          nonInteractive: [['the-parent', 'willDestroy'], ['the-first-child', 'willDestroy'], ['the-second-child', 'willDestroy'], ['the-last-child', 'willDestroy']]
        });

        _this4.assertRegisteredViews('after destroy');
      });
    };

    LifeCycleHooksTest.prototype['@test passing values through attrs causes lifecycle hooks to fire if the attribute values have changed'] = function testPassingValuesThroughAttrsCausesLifecycleHooksToFireIfTheAttributeValuesHaveChanged() {
      var _this5 = this;

      var _boundHelpers3 = this.boundHelpers;
      var attr = _boundHelpers3.attr;
      var invoke = _boundHelpers3.invoke;

      this.registerComponent('the-top', { template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject5, invoke('the-middle', { twitterTop: expr(attr('twitter')) }))
      });

      this.registerComponent('the-middle', { template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject6, invoke('the-bottom', { twitterMiddle: expr(attr('twitterTop')) }))
      });

      this.registerComponent('the-bottom', { template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject7, attr('twitterMiddle'))
      });

      this.render(invoke('the-top', { twitter: expr('twitter') }), { twitter: '@tomdale' });

      this.assertText('Top: Middle: Bottom: @tomdale');
      this.assertRegisteredViews('intial render');

      var topAttrs = { twitter: '@tomdale' };
      var middleAttrs = { twitterTop: '@tomdale' };
      var bottomAttrs = { twitterMiddle: '@tomdale' };

      this.assertHooks({
        label: 'after initial render',

        interactive: [
        // Sync hooks

        ['the-top', 'init'], ['the-top', 'didInitAttrs', { attrs: topAttrs, newAttrs: topAttrs }], ['the-top', 'didReceiveAttrs', { attrs: topAttrs, newAttrs: topAttrs }], ['the-top', 'on(init)'], ['the-top', 'willRender'], ['the-top', 'willInsertElement'], ['the-middle', 'init'], ['the-middle', 'didInitAttrs', { attrs: middleAttrs, newAttrs: middleAttrs }], ['the-middle', 'didReceiveAttrs', { attrs: middleAttrs, newAttrs: middleAttrs }], ['the-middle', 'on(init)'], ['the-middle', 'willRender'], ['the-middle', 'willInsertElement'], ['the-bottom', 'init'], ['the-bottom', 'didInitAttrs', { attrs: bottomAttrs, newAttrs: bottomAttrs }], ['the-bottom', 'didReceiveAttrs', { attrs: bottomAttrs, newAttrs: bottomAttrs }], ['the-bottom', 'on(init)'], ['the-bottom', 'willRender'], ['the-bottom', 'willInsertElement'],

        // Async hooks

        ['the-bottom', 'didInsertElement'], ['the-bottom', 'didRender'], ['the-middle', 'didInsertElement'], ['the-middle', 'didRender'], ['the-top', 'didInsertElement'], ['the-top', 'didRender']],

        nonInteractive: [
        // Sync hooks

        ['the-top', 'init'], ['the-top', 'didInitAttrs', { attrs: topAttrs, newAttrs: topAttrs }], ['the-top', 'didReceiveAttrs', { attrs: topAttrs, newAttrs: topAttrs }], ['the-top', 'on(init)'], ['the-middle', 'init'], ['the-middle', 'didInitAttrs', { attrs: middleAttrs, newAttrs: middleAttrs }], ['the-middle', 'didReceiveAttrs', { attrs: middleAttrs, newAttrs: middleAttrs }], ['the-middle', 'on(init)'], ['the-bottom', 'init'], ['the-bottom', 'didInitAttrs', { attrs: bottomAttrs, newAttrs: bottomAttrs }], ['the-bottom', 'didReceiveAttrs', { attrs: bottomAttrs, newAttrs: bottomAttrs }], ['the-bottom', 'on(init)']]
      });

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'twitter', '@horsetomdale');
      });

      this.assertText('Top: Middle: Bottom: @horsetomdale');

      // Because the `twitter` attr is used by the all of the components,
      // the lifecycle hooks are invoked for all components.

      topAttrs = { attrs: { twitter: '@horsetomdale' }, oldAttrs: { twitter: '@tomdale' }, newAttrs: { twitter: '@horsetomdale' } };
      middleAttrs = { attrs: { twitterTop: '@horsetomdale' }, oldAttrs: { twitterTop: '@tomdale' }, newAttrs: { twitterTop: '@horsetomdale' } };
      bottomAttrs = { attrs: { twitterMiddle: '@horsetomdale' }, oldAttrs: { twitterMiddle: '@tomdale' }, newAttrs: { twitterMiddle: '@horsetomdale' } };

      this.assertHooks({
        label: 'after updating (root)',

        interactive: [
        // Sync hooks

        ['the-top', 'didUpdateAttrs', topAttrs], ['the-top', 'didReceiveAttrs', topAttrs], ['the-top', 'willUpdate'], ['the-top', 'willRender'], ['the-middle', 'didUpdateAttrs', middleAttrs], ['the-middle', 'didReceiveAttrs', middleAttrs], ['the-middle', 'willUpdate'], ['the-middle', 'willRender'], ['the-bottom', 'didUpdateAttrs', bottomAttrs], ['the-bottom', 'didReceiveAttrs', bottomAttrs], ['the-bottom', 'willUpdate'], ['the-bottom', 'willRender'],

        // Async hooks

        ['the-bottom', 'didUpdate'], ['the-bottom', 'didRender'], ['the-middle', 'didUpdate'], ['the-middle', 'didRender'], ['the-top', 'didUpdate'], ['the-top', 'didRender']],

        nonInteractive: [
        // Sync hooks

        ['the-top', 'didUpdateAttrs', topAttrs], ['the-top', 'didReceiveAttrs', topAttrs], ['the-middle', 'didUpdateAttrs', middleAttrs], ['the-middle', 'didReceiveAttrs', middleAttrs], ['the-bottom', 'didUpdateAttrs', bottomAttrs], ['the-bottom', 'didReceiveAttrs', bottomAttrs]]
      });

      this.runTask(function () {
        return _this5.rerender();
      });

      this.assertText('Top: Middle: Bottom: @horsetomdale');

      // In this case, because the attrs are passed down, all child components are invoked.

      topAttrs = { attrs: { twitter: '@horsetomdale' }, oldAttrs: { twitter: '@horsetomdale' }, newAttrs: { twitter: '@horsetomdale' } };
      middleAttrs = { attrs: { twitterTop: '@horsetomdale' }, oldAttrs: { twitterTop: '@horsetomdale' }, newAttrs: { twitterTop: '@horsetomdale' } };
      bottomAttrs = { attrs: { twitterMiddle: '@horsetomdale' }, oldAttrs: { twitterMiddle: '@horsetomdale' }, newAttrs: { twitterMiddle: '@horsetomdale' } };

      this.assertHooks({
        label: 'after no-op rernder (root)',
        interactive: [],
        nonInteractive: []
      });

      this.teardownAssertions.push(function () {
        _this5.assertHooks({
          label: 'destroy',

          interactive: [['the-top', 'willDestroyElement'], ['the-top', 'willClearRender'], ['the-middle', 'willDestroyElement'], ['the-middle', 'willClearRender'], ['the-bottom', 'willDestroyElement'], ['the-bottom', 'willClearRender'], ['the-top', 'didDestroyElement'], ['the-middle', 'didDestroyElement'], ['the-bottom', 'didDestroyElement'], ['the-top', 'willDestroy'], ['the-middle', 'willDestroy'], ['the-bottom', 'willDestroy']],

          nonInteractive: [['the-top', 'willDestroy'], ['the-middle', 'willDestroy'], ['the-bottom', 'willDestroy']]
        });

        _this5.assertRegisteredViews('after destroy');
      });
    };

    LifeCycleHooksTest.prototype['@test components rendered from `{{each}}` have correct life-cycle hooks to be called'] = function testComponentsRenderedFromEachHaveCorrectLifeCycleHooksToBeCalled() {
      var _this6 = this;

      var invoke = this.boundHelpers.invoke;

      this.registerComponent('nested-item', { template: '{{yield}}' });

      this.registerComponent('an-item', { template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject8) });

      this.registerComponent('no-items', { template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject9) });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject10, invoke('an-item', { count: expr('item') }), invoke('no-items')), {
        items: [1, 2, 3, 4, 5]
      });

      this.assertText('Item: 1Item: 2Item: 3Item: 4Item: 5');
      this.assertRegisteredViews('intial render');

      var initialHooks = function (count) {
        var ret = [['an-item', 'init'], ['an-item', 'didInitAttrs', { attrs: { count: count }, newAttrs: { count: count } }], ['an-item', 'didReceiveAttrs', { attrs: { count: count }, newAttrs: { count: count } }], ['an-item', 'on(init)']];
        if (_this6.isInteractive) {
          ret.push(['an-item', 'willRender'], ['an-item', 'willInsertElement']);
        }
        ret.push(['nested-item', 'init'], ['nested-item', 'didInitAttrs', { attrs: {}, newAttrs: {} }], ['nested-item', 'didReceiveAttrs', { attrs: {}, newAttrs: {} }], ['nested-item', 'on(init)']);
        if (_this6.isInteractive) {
          ret.push(['nested-item', 'willRender'], ['nested-item', 'willInsertElement']);
        }
        return ret;
      };

      var initialAfterRenderHooks = function (count) {
        if (_this6.isInteractive) {
          return [['nested-item', 'didInsertElement'], ['nested-item', 'didRender'], ['an-item', 'didInsertElement'], ['an-item', 'didRender']];
        } else {
          return [];
        }
      };

      this.assertHooks({
        label: 'after initial render',

        interactive: [].concat(initialHooks(1), initialHooks(2), initialHooks(3), initialHooks(4), initialHooks(5), initialAfterRenderHooks(5), initialAfterRenderHooks(4), initialAfterRenderHooks(3), initialAfterRenderHooks(2), initialAfterRenderHooks(1)),

        nonInteractive: [].concat(initialHooks(1), initialHooks(2), initialHooks(3), initialHooks(4), initialHooks(5), initialAfterRenderHooks(5), initialAfterRenderHooks(4), initialAfterRenderHooks(3), initialAfterRenderHooks(2), initialAfterRenderHooks(1))
      });

      // TODO: Is this correct? Should childViews be populated in non-interactive mode?
      if (this.isInteractive) {
        this.assert.equal(this.component.childViews.length, 5, 'childViews precond');
      }

      this.runTask(function () {
        return _emberMetal.set(_this6.context, 'items', []);
      });

      // TODO: Is this correct? Should childViews be populated in non-interactive mode?
      if (this.isInteractive) {
        this.assert.equal(this.component.childViews.length, 1, 'childViews updated');
      }

      this.assertText('Nothing to see here');

      this.assertHooks({
        label: 'reset to empty array',

        interactive: [['an-item', 'willDestroyElement'], ['an-item', 'willClearRender'], ['nested-item', 'willDestroyElement'], ['nested-item', 'willClearRender'], ['an-item', 'willDestroyElement'], ['an-item', 'willClearRender'], ['nested-item', 'willDestroyElement'], ['nested-item', 'willClearRender'], ['an-item', 'willDestroyElement'], ['an-item', 'willClearRender'], ['nested-item', 'willDestroyElement'], ['nested-item', 'willClearRender'], ['an-item', 'willDestroyElement'], ['an-item', 'willClearRender'], ['nested-item', 'willDestroyElement'], ['nested-item', 'willClearRender'], ['an-item', 'willDestroyElement'], ['an-item', 'willClearRender'], ['nested-item', 'willDestroyElement'], ['nested-item', 'willClearRender'], ['no-items', 'init'], ['no-items', 'didInitAttrs', { attrs: {}, newAttrs: {} }], ['no-items', 'didReceiveAttrs', { attrs: {}, newAttrs: {} }], ['no-items', 'on(init)'], ['no-items', 'willRender'], ['no-items', 'willInsertElement'], ['nested-item', 'init'], ['nested-item', 'didInitAttrs', { attrs: {}, newAttrs: {} }], ['nested-item', 'didReceiveAttrs', { attrs: {}, newAttrs: {} }], ['nested-item', 'on(init)'], ['nested-item', 'willRender'], ['nested-item', 'willInsertElement'], ['an-item', 'didDestroyElement'], ['nested-item', 'didDestroyElement'], ['an-item', 'didDestroyElement'], ['nested-item', 'didDestroyElement'], ['an-item', 'didDestroyElement'], ['nested-item', 'didDestroyElement'], ['an-item', 'didDestroyElement'], ['nested-item', 'didDestroyElement'], ['an-item', 'didDestroyElement'], ['nested-item', 'didDestroyElement'], ['nested-item', 'didInsertElement'], ['nested-item', 'didRender'], ['no-items', 'didInsertElement'], ['no-items', 'didRender'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy']],

        nonInteractive: [['no-items', 'init'], ['no-items', 'didInitAttrs', { attrs: {}, newAttrs: {} }], ['no-items', 'didReceiveAttrs', { attrs: {}, newAttrs: {} }], ['no-items', 'on(init)'], ['nested-item', 'init'], ['nested-item', 'didInitAttrs', { attrs: {}, newAttrs: {} }], ['nested-item', 'didReceiveAttrs', { attrs: {}, newAttrs: {} }], ['nested-item', 'on(init)'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy'], ['an-item', 'willDestroy'], ['nested-item', 'willDestroy']]
      });

      this.teardownAssertions.push(function () {
        _this6.assertHooks({
          label: 'destroy',

          interactive: [['no-items', 'willDestroyElement'], ['no-items', 'willClearRender'], ['nested-item', 'willDestroyElement'], ['nested-item', 'willClearRender'], ['no-items', 'didDestroyElement'], ['nested-item', 'didDestroyElement'], ['no-items', 'willDestroy'], ['nested-item', 'willDestroy']],

          nonInteractive: [['no-items', 'willDestroy'], ['nested-item', 'willDestroy']]
        });

        _this6.assertRegisteredViews('after destroy');
      });
    };

babelHelpers.createClass(LifeCycleHooksTest, [{
      key: 'isInteractive',
      get: function () {
        return true;
      }
    }, {
      key: 'ComponentClass',
      get: function () {
        throw new Error('Not implemented: `ComponentClass`');
      }
    }, {
      key: 'boundHelpers',
      get: function () {
        return {
          invoke: bind(this.invocationFor, this),
          attr: bind(this.attrFor, this)
        };
      }
    }]);
    return LifeCycleHooksTest;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest);

  var CurlyComponentsTest = (function (_LifeCycleHooksTest) {
babelHelpers.inherits(CurlyComponentsTest, _LifeCycleHooksTest);

    function CurlyComponentsTest() {
      _LifeCycleHooksTest.apply(this, arguments);
    }

    CurlyComponentsTest.prototype.invocationFor = function invocationFor(name) {
      var _this7 = this;

      var namedArgs = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var attrs = Object.keys(namedArgs).map(function (k) {
        return k + '=' + _this7.val(namedArgs[k]);
      }).join(' ');
      return '{{' + name + ' ' + attrs + '}}';
    };

    CurlyComponentsTest.prototype.attrFor = function attrFor(name) {
      return '' + name;
    };

    /* private */

    CurlyComponentsTest.prototype.val = function val(value) {
      if (value.isString) {
        return JSON.stringify(value.value);
      } else if (value.isExpr) {
        return '(readonly ' + value.value + ')';
      } else {
        throw new Error('Unknown value: ' + value);
      }
    };

babelHelpers.createClass(CurlyComponentsTest, [{
      key: 'ComponentClass',
      get: function () {
        return _emberGlimmerTestsUtilsHelpers.Component;
      }
    }]);
    return CurlyComponentsTest;
  })(LifeCycleHooksTest);

  _emberGlimmerTestsUtilsTestCase.moduleFor('Components test: interactive lifecycle hooks (curly components)', (function (_CurlyComponentsTest) {
babelHelpers.inherits(_class, _CurlyComponentsTest);

    function _class() {
      _CurlyComponentsTest.apply(this, arguments);
    }

babelHelpers.createClass(_class, [{
      key: 'isInteractive',
      get: function () {
        return true;
      }
    }]);
    return _class;
  })(CurlyComponentsTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Components test: non-interactive lifecycle hooks (curly components)', (function (_CurlyComponentsTest2) {
babelHelpers.inherits(_class2, _CurlyComponentsTest2);

    function _class2() {
      _CurlyComponentsTest2.apply(this, arguments);
    }

babelHelpers.createClass(_class2, [{
      key: 'isInteractive',
      get: function () {
        return false;
      }
    }]);
    return _class2;
  })(CurlyComponentsTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Components test: interactive lifecycle hooks (tagless curly components)', (function (_CurlyComponentsTest3) {
babelHelpers.inherits(_class3, _CurlyComponentsTest3);

    function _class3() {
      _CurlyComponentsTest3.apply(this, arguments);
    }

babelHelpers.createClass(_class3, [{
      key: 'ComponentClass',
      get: function () {
        return _emberGlimmerTestsUtilsHelpers.Component.extend({ tagName: '' });
      }
    }, {
      key: 'isInteractive',
      get: function () {
        return true;
      }
    }]);
    return _class3;
  })(CurlyComponentsTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Components test: non-interactive lifecycle hooks (tagless curly components)', (function (_CurlyComponentsTest4) {
babelHelpers.inherits(_class4, _CurlyComponentsTest4);

    function _class4() {
      _CurlyComponentsTest4.apply(this, arguments);
    }

babelHelpers.createClass(_class4, [{
      key: 'ComponentClass',
      get: function () {
        return _emberGlimmerTestsUtilsHelpers.Component.extend({ tagName: '' });
      }
    }, {
      key: 'isInteractive',
      get: function () {
        return false;
      }
    }]);
    return _class4;
  })(CurlyComponentsTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Run loop and lifecycle hooks', (function (_RenderingTest2) {
babelHelpers.inherits(_class5, _RenderingTest2);

    function _class5() {
      _RenderingTest2.apply(this, arguments);
    }

    _class5.prototype['@test afterRender set'] = function testAfterRenderSet() {
      var _this9 = this;

      var ComponentClass = _emberGlimmerTestsUtilsHelpers.Component.extend({
        width: '5',
        didInsertElement: function () {
          var _this8 = this;

          _emberMetal.run.scheduleOnce('afterRender', function () {
            _this8.set('width', '10');
          });
        }
      });

      var template = '{{width}}';
      this.registerComponent('foo-bar', { ComponentClass: ComponentClass, template: template });

      this.render('{{foo-bar}}');

      this.assertText('10');

      this.runTask(function () {
        return _this9.rerender();
      });

      this.assertText('10');
    };

    _class5.prototype['@test afterRender set on parent'] = function testAfterRenderSetOnParent() {
      var _this11 = this;

      var ComponentClass = _emberGlimmerTestsUtilsHelpers.Component.extend({
        didInsertElement: function () {
          var _this10 = this;

          _emberMetal.run.scheduleOnce('afterRender', function () {
            var parent = _this10.get('parent');
            parent.set('foo', 'wat');
          });
        }
      });

      var template = '{{foo}}';

      this.registerComponent('foo-bar', { ComponentClass: ComponentClass, template: template });

      this.render('{{foo-bar parent=this foo=foo}}');

      this.assertText('wat');

      this.runTask(function () {
        return _this11.rerender();
      });

      this.assertText('wat');
    };

    _class5.prototype['@test `willRender` can set before render (GH#14458)'] = function testWillRenderCanSetBeforeRenderGH14458(assert) {
      var ComponentClass = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: 'a',
        customHref: 'http://google.com',
        attributeBindings: ['customHref:href'],
        willRender: function () {
          this.set('customHref', 'http://willRender.com');
        }
      });

      var template = 'Hello World';

      this.registerComponent('foo-bar', { ComponentClass: ComponentClass, template: template });

      this.render('{{foo-bar id="foo"}}');

      this.assertElement(this.firstChild, {
        tagName: 'a',
        attrs: {
          id: 'foo',
          href: 'http://willRender.com',
          class: _emberGlimmerTestsUtilsTestHelpers.classes('ember-view')
        }
      });
    };

    _class5.prototype['@test that thing about destroying'] = function testThatThingAboutDestroying(assert) {
      var _this12 = this;

      var ParentDestroyedElements = [];
      var ChildDestroyedElements = [];

      var ParentComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        willDestroyElement: function () {
          ParentDestroyedElements.push({
            id: this.itemId,
            name: 'parent-component',
            hasParent: !!this.element.parentNode,
            nextSibling: !!this.element.nextSibling,
            previousSibling: !!this.element.previousSibling
          });
        }
      });

      var PartentTemplate = _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject11);

      var NestedComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        willDestroyElement: function () {
          ChildDestroyedElements.push({
            id: this.nestedId,
            name: 'nested-component',
            hasParent: !!this.element.parentNode,
            nextSibling: !!this.element.nextSibling,
            previousSibling: !!this.element.previousSibling
          });
        }
      });

      var NestedTemplate = '{{yield}}';

      this.registerComponent('parent-component', {
        ComponentClass: ParentComponent,
        template: PartentTemplate
      });

      this.registerComponent('nested-component', {
        ComponentClass: NestedComponent,
        template: NestedTemplate
      });

      var array = _emberRuntime.A([{ id: 1 }, { id: 2 }, { id: 3 }, { id: 4 }, { id: 5 }]);

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject12), {
        items: array,
        model: { shouldShow: true }
      });

      this.assertText('1AB2AB3AB4AB5AB6AB7AB');

      this.runTask(function () {
        array.removeAt(2);
        array.removeAt(2);
        _emberMetal.set(_this12.context, 'model.shouldShow', false);
      });

      this.assertText('1AB2AB5AB');

      assertDestroyHooks(assert, [].concat(ParentDestroyedElements), [{
        id: 3,
        hasParent: true,
        nextSibling: true,
        previousSibling: true
      }, {
        id: 4,
        hasParent: true,
        nextSibling: true,
        previousSibling: true
      }, {
        id: 6,
        hasParent: true,
        nextSibling: true,
        previousSibling: true
      }, {
        id: 7,
        hasParent: true,
        nextSibling: false,
        previousSibling: true
      }]);

      assertDestroyHooks(assert, [].concat(ChildDestroyedElements), [{
        id: '3-A',
        hasParent: true,
        nextSibling: true,
        previousSibling: false
      }, {
        id: '3-B',
        hasParent: true,
        nextSibling: false,
        previousSibling: true
      }, {
        id: '4-A',
        hasParent: true,
        nextSibling: true,
        previousSibling: false
      }, {
        id: '4-B',
        hasParent: true,
        nextSibling: false,
        previousSibling: true
      }, {
        id: '6-A',
        hasParent: true,
        nextSibling: true,
        previousSibling: false
      }, {
        id: '6-B',
        hasParent: true,
        nextSibling: false,
        previousSibling: true
      }, {
        id: '7-A',
        hasParent: true,
        nextSibling: true,
        previousSibling: false
      }, {
        id: '7-B',
        hasParent: true,
        nextSibling: false,
        previousSibling: true
      }]);
    };

    _class5.prototype['@test lifecycle hooks have proper access to this.$()'] = function testLifecycleHooksHaveProperAccessToThis$(assert) {
      assert.expect(6);
      var component = undefined;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: 'div',
        init: function () {
          assert.notOk(this.$(), 'no access to element via this.$() on init() enter');
          this._super.apply(this, arguments);
          assert.notOk(this.$(), 'no access to element via this.$() after init() finished');
        },
        willInsertElement: function () {
          component = this;
          assert.ok(this.$(), 'willInsertElement has access to element via this.$()');
        },
        didInsertElement: function () {
          assert.ok(this.$(), 'didInsertElement has access to element via this.$()');
        },
        willDestroyElement: function () {
          assert.ok(this.$(), 'willDestroyElement has access to element via this.$()');
        },
        didDestroyElement: function () {
          assert.notOk(this.$(), 'didDestroyElement does not have access to element via this.$()');
        }
      });
      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });
      var owner = this.owner;

      var comp = owner.lookup('component:foo-bar');
      _internalTestHelpers.runAppend(comp);
      this.runTask(function () {
        return _emberUtils.tryInvoke(component, 'destroy');
      });
    };

    return _class5;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));

  function assertDestroyHooks(assert, _actual, _expected) {
    _expected.forEach(function (expected, i) {
      var name = expected.name;
      assert.equal(expected.id, _actual[i].id, name + ' id is the same');
      assert.equal(expected.hasParent, _actual[i].hasParent, name + ' has parent node');
      assert.equal(expected.nextSibling, _actual[i].nextSibling, name + ' has next sibling node');
      assert.equal(expected.previousSibling, _actual[i].previousSibling, name + ' has previous sibling node');
    });
  }

  function bind(func, thisArg) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return func.apply(thisArg, args);
    };
  }

  function string(value) {
    return { isString: true, value: value };
  }

  function expr(value) {
    return { isExpr: true, value: value };
  }

  function hook(name, hook) {
    var _ref3 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    var attrs = _ref3.attrs;
    var oldAttrs = _ref3.oldAttrs;
    var newAttrs = _ref3.newAttrs;

    return { name: name, hook: hook, args: { attrs: attrs, oldAttrs: oldAttrs, newAttrs: newAttrs } };
  }

  function json(serializable) {
    return JSON.parse(JSON.stringify(serializable));
  }
});

// Sync hooks

// Async hooks

// Sync hooks

// Async hooks
enifed('ember-glimmer/tests/integration/components/life-cycle-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/components/life-cycle-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/components/life-cycle-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/components/link-to-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-runtime', 'ember-metal', 'ember-glimmer/tests/utils/helpers', 'ember-glimmer/tests/utils/test-helpers'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberRuntime, _emberMetal, _emberGlimmerTestsUtilsHelpers, _emberGlimmerTestsUtilsTestHelpers) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Link-to component', (function (_ApplicationTest) {
    babelHelpers.inherits(_class, _ApplicationTest);

    function _class() {
      _ApplicationTest.apply(this, arguments);
    }

    _class.prototype.visitWithDeprecation = function visitWithDeprecation(path, deprecation) {
      var _this = this;

      var p = undefined;

      expectDeprecation(function () {
        p = _this.visit(path);
      }, deprecation);

      return p;
    };

    _class.prototype['@test accessing `currentWhen` triggers a deprecation'] = function testAccessingCurrentWhenTriggersADeprecation(assert) {
      var component = undefined;
      this.registerComponent('link-to', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.LinkComponent.extend({
          init: function () {
            this._super.apply(this, arguments);
            component = this;
          }
        })
      });

      this.registerTemplate('application', '{{link-to \'Index\' \'index\'}}');

      return this.visit('/').then(function () {
        expectDeprecation(function () {
          component.get('currentWhen');
        }, /Usage of `currentWhen` is deprecated, use `current-when` instead/);
      });
    };

    _class.prototype['@test should be able to be inserted in DOM when the router is not present'] = function testShouldBeAbleToBeInsertedInDOMWhenTheRouterIsNotPresent() {
      var _this2 = this;

      this.registerTemplate('application', '{{#link-to \'index\'}}Go to Index{{/link-to}}');

      return this.visit('/').then(function () {
        _this2.assertText('Go to Index');
      });
    };

    _class.prototype['@test re-renders when title changes'] = function testReRendersWhenTitleChanges() {
      var _this3 = this;

      var controller = undefined;

      this.registerTemplate('application', '{{link-to title routeName}}');
      this.registerController('application', _emberRuntime.Controller.extend({
        init: function () {
          this._super.apply(this, arguments);
          controller = this;
        },
        title: 'foo',
        routeName: 'index'
      }));

      return this.visit('/').then(function () {
        _this3.assertText('foo');
        _this3.runTask(function () {
          return _emberMetal.set(controller, 'title', 'bar');
        });
        _this3.assertText('bar');
      });
    };

    _class.prototype['@test escaped inline form (double curlies) escapes link title'] = function testEscapedInlineFormDoubleCurliesEscapesLinkTitle() {
      var _this4 = this;

      this.registerTemplate('application', '{{link-to title \'index\'}}');
      this.registerController('application', _emberRuntime.Controller.extend({
        title: '<b>blah</b>'
      }));

      return this.visit('/').then(function () {
        _this4.assertText('<b>blah</b>');
      });
    };

    _class.prototype['@test escaped inline form with (-html-safe) does not escape link title'] = function testEscapedInlineFormWithHtmlSafeDoesNotEscapeLinkTitle(assert) {
      var _this5 = this;

      this.registerTemplate('application', '{{link-to (-html-safe title) \'index\'}}');
      this.registerController('application', _emberRuntime.Controller.extend({
        title: '<b>blah</b>'
      }));

      return this.visit('/').then(function () {
        _this5.assertText('blah');
        assert.equal(_this5.$('b').length, 1);
      });
    };

    _class.prototype['@test unescaped inline form (triple curlies) does not escape link title'] = function testUnescapedInlineFormTripleCurliesDoesNotEscapeLinkTitle(assert) {
      var _this6 = this;

      this.registerTemplate('application', '{{{link-to title \'index\'}}}');
      this.registerController('application', _emberRuntime.Controller.extend({
        title: '<b>blah</b>'
      }));

      return this.visit('/').then(function () {
        _this6.assertText('blah');
        assert.equal(_this6.$('b').length, 1);
      });
    };

    _class.prototype['@test unwraps controllers'] = function testUnwrapsControllers() {
      var _this7 = this;

      this.router.map(function () {
        this.route('profile', { path: '/profile/:id' });
      });
      this.registerTemplate('application', '{{#link-to \'profile\' otherController}}Text{{/link-to}}');
      this.registerController('application', _emberRuntime.Controller.extend({
        otherController: _emberRuntime.Controller.create({
          model: 'foo'
        })
      }));

      var deprecation = /Providing `{{link-to}}` with a param that is wrapped in a controller is deprecated./;

      return this.visitWithDeprecation('/', deprecation).then(function () {
        _this7.assertText('Text');
      });
    };

    _class.prototype['@test able to safely extend the built-in component and use the normal path'] = function testAbleToSafelyExtendTheBuiltInComponentAndUseTheNormalPath() {
      var _this8 = this;

      this.registerComponent('custom-link-to', { ComponentClass: _emberGlimmerTestsUtilsHelpers.LinkComponent.extend() });
      this.registerTemplate('application', '{{#custom-link-to \'index\'}}{{title}}{{/custom-link-to}}');
      this.registerController('application', _emberRuntime.Controller.extend({
        title: 'Hello'
      }));

      return this.visit('/').then(function () {
        _this8.assertText('Hello');
      });
    };

    _class.prototype['@test [GH#13432] able to safely extend the built-in component and invoke it inline'] = function testGH13432AbleToSafelyExtendTheBuiltInComponentAndInvokeItInline() {
      var _this9 = this;

      this.registerComponent('custom-link-to', { ComponentClass: _emberGlimmerTestsUtilsHelpers.LinkComponent.extend() });
      this.registerTemplate('application', '{{custom-link-to title \'index\'}}');
      this.registerController('application', _emberRuntime.Controller.extend({
        title: 'Hello'
      }));

      return this.visit('/').then(function () {
        _this9.assertText('Hello');
      });
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.ApplicationTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Link-to component with query-params', (function (_ApplicationTest2) {
    babelHelpers.inherits(_class2, _ApplicationTest2);

    function _class2() {
      _ApplicationTest2.apply(this, arguments);

      this.registerController('index', _emberRuntime.Controller.extend({
        queryParams: ['foo'],
        foo: '123',
        bar: 'yes'
      }));
    }

    _class2.prototype['@test populates href with fully supplied query param values'] = function testPopulatesHrefWithFullySuppliedQueryParamValues(assert) {
      var _this10 = this;

      this.registerTemplate('index', '{{#link-to \'index\' (query-params foo=\'456\' bar=\'NAW\')}}Index{{/link-to}}');

      return this.visit('/').then(function () {
        _this10.assertComponentElement(_this10.firstChild.firstElementChild, {
          tagName: 'a',
          attrs: { href: '/?bar=NAW&foo=456' },
          content: 'Index'
        });
      });
    };

    _class2.prototype['@test populates href with partially supplied query param values, but omits if value is default value'] = function testPopulatesHrefWithPartiallySuppliedQueryParamValuesButOmitsIfValueIsDefaultValue() {
      var _this11 = this;

      this.registerTemplate('index', '{{#link-to \'index\' (query-params foo=\'123\')}}Index{{/link-to}}');

      return this.visit('/').then(function () {
        _this11.assertComponentElement(_this11.firstChild.firstElementChild, {
          tagName: 'a',
          attrs: { href: '/', class: _emberGlimmerTestsUtilsTestHelpers.classes('ember-view active') },
          content: 'Index'
        });
      });
    };

    return _class2;
  })(_emberGlimmerTestsUtilsTestCase.ApplicationTest));
});
enifed('ember-glimmer/tests/integration/components/link-to-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/components/link-to-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/components/link-to-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/components/local-lookup-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/helpers'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsHelpers) {
  'use strict';

  function buildResolver() {
    var resolver = {
      resolve: function () {},
      expandLocalLookup: function (fullName, sourceFullName) {
        var _sourceFullName$split = sourceFullName.split(':');

        var sourceType = _sourceFullName$split[0];
        var sourceName = _sourceFullName$split[1];

        var _fullName$split = fullName.split(':');

        var type = _fullName$split[0];
        var name = _fullName$split[1];

        if (type !== 'template' && sourceType === 'template' && sourceName.slice(0, 11) === 'components/') {
          sourceName = sourceName.slice(11);
        }

        if (type === 'template' && sourceType === 'template' && name.slice(0, 11) === 'components/') {
          name = name.slice(11);
        }

        var result = type + ':' + sourceName + '/' + name;

        return result;
      }
    };

    return resolver;
  }

  _emberGlimmerTestsUtilsTestCase.moduleFor('Components test: local lookup', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype.getResolver = function getResolver() {
      return buildResolver();
    };

    _class.prototype['@test it can lookup a local template'] = function testItCanLookupALocalTemplate() {
      var _this = this;

      this.registerComponent('x-outer/x-inner', { template: 'Nested template says: {{yield}}' });
      this.registerComponent('x-outer', { template: '{{#x-inner}}Hi!{{/x-inner}}' });

      this.render('{{x-outer}}');

      this.assertText('Nested template says: Hi!', 'Initial render works');

      this.runTask(function () {
        return _this.rerender();
      });

      this.assertText('Nested template says: Hi!', 'Re-render works');
    };

    _class.prototype['@test tagless blockless component can lookup local template'] = function testTaglessBlocklessComponentCanLookupLocalTemplate() {
      var _this2 = this;

      this.registerComponent('x-outer/x-inner', { template: 'Nested template says: {{yield}}' });
      this.registerTemplate('components/x-outer', '{{#x-inner}}Hi!{{/x-inner}}');
      this.registerComponent('x-outer', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({ tagName: '' })
      });

      this.render('{{x-outer}}');

      this.assertText('Nested template says: Hi!', 'Re-render works');

      this.runTask(function () {
        return _this2.rerender();
      });

      this.assertText('Nested template says: Hi!', 'Re-render works');
    };

    _class.prototype['@test it can lookup a local component template'] = function testItCanLookupALocalComponentTemplate() {
      var _this3 = this;

      this.registerTemplate('components/x-outer/x-inner', 'Nested template says: {{yield}}');
      this.registerTemplate('components/x-outer', '{{#x-inner}}Hi!{{/x-inner}}');

      this.render('{{x-outer}}');

      this.assertText('Nested template says: Hi!', 'Initial render works');

      this.runTask(function () {
        return _this3.rerender();
      });

      this.assertText('Nested template says: Hi!', 'Re-render works');
    };

    _class.prototype['@test it can local lookup a dynamic component'] = function testItCanLocalLookupADynamicComponent() {
      var _this4 = this;

      this.registerComponent('foo-bar', { template: 'yall finished {{component child}}' });
      this.registerComponent('foo-bar/biz-baz', { template: 'or yall done?' });

      this.render('{{foo-bar child=child}}', { child: 'biz-baz' });

      this.assertText('yall finished or yall done?');

      this.runTask(function () {
        return _this4.rerender();
      });

      this.assertText('yall finished or yall done?');
    };

    _class.prototype['@test it can local lookup a dynamic component from a dynamic component'] = function testItCanLocalLookupADynamicComponentFromADynamicComponent() {
      var _this5 = this;

      this.registerComponent('foo-bar', { template: 'yall finished {{component child}}' });
      this.registerComponent('foo-bar/biz-baz', { template: 'or yall done?' });

      this.render('{{component componentName child=child}}', { componentName: 'foo-bar', child: 'biz-baz' });

      this.assertText('yall finished or yall done?');

      this.runTask(function () {
        return _this5.rerender();
      });

      this.assertText('yall finished or yall done?');
    };

    _class.prototype['@test it can local lookup a dynamic component from a passed named argument'] = function testItCanLocalLookupADynamicComponentFromAPassedNamedArgument() {
      var _this6 = this;

      this.registerComponent('parent-foo', { template: 'yall finished {{global-biz baz=(component \'local-bar\')}}' });
      this.registerComponent('global-biz', { template: 'or {{component baz}}' });
      this.registerComponent('parent-foo/local-bar', { template: 'yall done?' });

      this.render('{{parent-foo}}');

      this.assertText('yall finished or yall done?');

      this.runTask(function () {
        return _this6.rerender();
      });

      this.assertText('yall finished or yall done?');
    };

    _class.prototype['@test it can local lookup a re-wrapped dynamic component from a passed named argument'] = function testItCanLocalLookupAReWrappedDynamicComponentFromAPassedNamedArgument() {
      var _this7 = this;

      this.registerComponent('parent-foo', { template: 'yall finished {{global-x comp=(component \'local-bar\')}}' });
      this.registerComponent('global-x', { template: 'or {{global-y comp=(component comp phrase=\'done\')}}' });
      this.registerComponent('global-y', { template: '{{component comp}}?' });
      this.registerComponent('parent-foo/local-bar', { template: 'yall {{phrase}}' });

      this.render('{{parent-foo}}');

      this.assertText('yall finished or yall done?');

      this.runTask(function () {
        return _this7.rerender();
      });

      this.assertText('yall finished or yall done?');
    };

    _class.prototype['@test it can nest local lookups of dynamic components from a passed named argument'] = function testItCanNestLocalLookupsOfDynamicComponentsFromAPassedNamedArgument() {
      var _this8 = this;

      this.registerComponent('parent-foo', { template: 'yall finished {{global-x comp=(component \'local-bar\')}}' });
      this.registerComponent('global-x', { template: 'or {{global-y comp=(component comp phrase=\'done\')}}' });
      this.registerComponent('global-y', { template: '{{component comp}}{{component \'local-bar\'}}' });
      this.registerComponent('parent-foo/local-bar', { template: 'yall {{phrase}}' });
      this.registerComponent('global-y/local-bar', { template: '?' });

      this.render('{{parent-foo}}');

      this.assertText('yall finished or yall done?');

      this.runTask(function () {
        return _this8.rerender();
      });

      this.assertText('yall finished or yall done?');
    };

    _class.prototype['@test it can switch from local to global lookups of dynamic components from a passed named argument'] = function testItCanSwitchFromLocalToGlobalLookupsOfDynamicComponentsFromAPassedNamedArgument() {
      var _this9 = this;

      this.registerComponent('parent-foo', { template: 'yall finished {{global-x comp=(component bar)}}' });
      this.registerComponent('global-x', { template: 'or yall {{component comp}}' });
      this.registerComponent('parent-foo/local-bar', { template: 'done?' });
      this.registerComponent('global-bar', { template: 'ready?' });

      this.render('{{parent-foo bar=bar}}', { bar: 'local-bar' });

      this.assertText('yall finished or yall done?');

      this.runTask(function () {
        return _this9.context.set('bar', 'global-bar');
      });

      this.runTask(function () {
        return _this9.rerender();
      });

      this.assertText('yall finished or yall ready?');
    };

    _class.prototype['@test it can lookup a local helper'] = function testItCanLookupALocalHelper() {
      var _this10 = this;

      this.registerHelper('x-outer/x-helper', function () {
        return 'Who dis?';
      });
      this.registerComponent('x-outer', { template: 'Who dat? {{x-helper}}' });

      this.render('{{x-outer}}');

      this.assertText('Who dat? Who dis?', 'Initial render works');

      this.runTask(function () {
        return _this10.rerender();
      });

      this.assertText('Who dat? Who dis?', 'Re-render works');
    };

    _class.prototype['@test it overrides global helper lookup'] = function testItOverridesGlobalHelperLookup() {
      var _this11 = this;

      this.registerHelper('x-outer/x-helper', function () {
        return 'Who dis?';
      });

      this.registerHelper('x-helper', function () {
        return 'I dunno';
      });

      this.registerComponent('x-outer', { template: 'Who dat? {{x-helper}}' });

      this.render('{{x-outer}} {{x-helper}}');

      this.assertText('Who dat? Who dis? I dunno', 'Initial render works');

      this.runTask(function () {
        return _this11.rerender();
      });

      this.assertText('Who dat? Who dis? I dunno', 'Re-render works');
    };

    _class.prototype['@test lookup without match issues standard assertion (with local helper name)'] = function testLookupWithoutMatchIssuesStandardAssertionWithLocalHelperName() {
      var _this12 = this;

      this.registerComponent('x-outer', { template: '{{#x-inner}}Hi!{{/x-inner}}' });

      expectAssertion(function () {
        _this12.render('{{x-outer}}');
      }, /A component or helper named "x-inner" could not be found/);
    };

    _class.prototype['@test overrides global lookup'] = function testOverridesGlobalLookup() {
      var _this13 = this;

      this.registerComponent('x-outer', { template: '{{#x-inner}}Hi!{{/x-inner}}' });
      this.registerComponent('x-outer/x-inner', { template: 'Nested template says (from local): {{yield}}' });
      this.registerComponent('x-inner', { template: 'Nested template says (from global): {{yield}}' });

      this.render('{{#x-inner}}Hi!{{/x-inner}} {{x-outer}} {{#x-outer/x-inner}}Hi!{{/x-outer/x-inner}}');

      this.assertText('Nested template says (from global): Hi! Nested template says (from local): Hi! Nested template says (from local): Hi!');

      this.runTask(function () {
        return _this13.rerender();
      });

      this.assertText('Nested template says (from global): Hi! Nested template says (from local): Hi! Nested template says (from local): Hi!');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/components/local-lookup-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/components/local-lookup-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/components/local-lookup-test.js should pass ESLint\n\n');
  });
});
enifed("ember-glimmer/tests/integration/components/render-to-element-test", ["exports"], function (exports) {
  "use strict";
});
enifed('ember-glimmer/tests/integration/components/render-to-element-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/components/render-to-element-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/components/render-to-element-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/components/target-action-test', ['exports', 'ember-utils', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/abstract-test-case', 'ember-metal', 'ember-glimmer/tests/utils/helpers', 'ember-runtime', 'ember-routing'], function (exports, _emberUtils, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsAbstractTestCase, _emberMetal, _emberGlimmerTestsUtilsHelpers, _emberRuntime, _emberRouting) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#component-a}}\n          {{component-b bar="derp"}}\n        {{/component-a}}\n      '], ['\n        {{#component-a}}\n          {{component-b bar="derp"}}\n        {{/component-a}}\n      ']);

  _emberGlimmerTestsUtilsTestCase.moduleFor('Components test: sendAction', (function (_RenderingTest) {
babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.call(this);
      this.actionCounts = {};
      this.sendCount = 0;
      this.actionArguments = null;

      var self = this;

      this.registerComponent('action-delegate', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super();
            self.delegate = this;
            this.name = 'action-delegate';
          }
        })
      });
    }

    _class.prototype.renderDelegate = function renderDelegate() {
      var template = arguments.length <= 0 || arguments[0] === undefined ? '{{action-delegate}}' : arguments[0];
      var context = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var root = this;
      context = _emberUtils.assign(context, {
        send: function (actionName) {
          root.sendCount++;
          root.actionCounts[actionName] = root.actionCounts[actionName] || 0;
          root.actionCounts[actionName]++;

          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          root.actionArguments = args;
        }
      });
      this.render(template, context);
    };

    _class.prototype.assertSendCount = function assertSendCount(count) {
      this.assert.equal(this.sendCount, count, 'Send was called ' + count + ' time(s)');
    };

    _class.prototype.assertNamedSendCount = function assertNamedSendCount(actionName, count) {
      this.assert.equal(this.actionCounts[actionName], count, 'An action named \'' + actionName + '\' was sent ' + count + ' times');
    };

    _class.prototype.assertSentWithArgs = function assertSentWithArgs(expected) {
      var message = arguments.length <= 1 || arguments[1] === undefined ? 'arguments were sent with the action' : arguments[1];

      this.assert.deepEqual(this.actionArguments, expected, message);
    };

    _class.prototype['@test Calling sendAction on a component without an action defined does nothing'] = function testCallingSendActionOnAComponentWithoutAnActionDefinedDoesNothing() {
      var _this = this;

      this.renderDelegate();

      this.runTask(function () {
        return _this.delegate.sendAction();
      });

      this.assertSendCount(0);
    };

    _class.prototype['@test Calling sendAction on a component with an action defined calls send on the controller'] = function testCallingSendActionOnAComponentWithAnActionDefinedCallsSendOnTheController() {
      var _this2 = this;

      this.renderDelegate();

      this.runTask(function () {
        _emberMetal.set(_this2.delegate, 'action', 'addItem');
        _this2.delegate.sendAction();
      });

      this.assertSendCount(1);
      this.assertNamedSendCount('addItem', 1);
    };

    _class.prototype['@test Calling sendAction on a component with a function calls the function'] = function testCallingSendActionOnAComponentWithAFunctionCallsTheFunction() {
      var _this3 = this;

      this.assert.expect(1);

      this.renderDelegate();

      this.runTask(function () {
        _emberMetal.set(_this3.delegate, 'action', function () {
          return _this3.assert.ok(true, 'function is called');
        });
        _this3.delegate.sendAction();
      });
    };

    _class.prototype['@test Calling sendAction on a component with a function calls the function with arguments'] = function testCallingSendActionOnAComponentWithAFunctionCallsTheFunctionWithArguments() {
      var _this4 = this;

      this.assert.expect(1);
      var argument = {};

      this.renderDelegate();

      this.runTask(function () {
        _emberMetal.set(_this4.delegate, 'action', function (actualArgument) {
          _this4.assert.deepEqual(argument, actualArgument, 'argument is passed');
        });
        _this4.delegate.sendAction('action', argument);
      });
    };

    // TODO consolidate these next 2 tests

    _class.prototype['@test Calling sendAction on a component with a reference attr calls the function with arguments'] = function testCallingSendActionOnAComponentWithAReferenceAttrCallsTheFunctionWithArguments() {
      var _this5 = this;

      this.renderDelegate('{{action-delegate playing=playing}}', {
        playing: null
      });

      this.runTask(function () {
        return _this5.delegate.sendAction();
      });

      this.assertSendCount(0);

      this.runTask(function () {
        _emberMetal.set(_this5.context, 'playing', 'didStartPlaying');
      });

      this.runTask(function () {
        _this5.delegate.sendAction('playing');
      });

      this.assertSendCount(1);
      this.assertNamedSendCount('didStartPlaying', 1);
    };

    _class.prototype['@test Calling sendAction on a component with a {{mut}} attr calls the function with arguments'] = function testCallingSendActionOnAComponentWithAMutAttrCallsTheFunctionWithArguments() {
      var _this6 = this;

      this.renderDelegate('{{action-delegate playing=(mut playing)}}', {
        playing: null
      });

      this.runTask(function () {
        return _this6.delegate.sendAction('playing');
      });

      this.assertSendCount(0);

      this.runTask(function () {
        return _this6.delegate.attrs.playing.update('didStartPlaying');
      });
      this.runTask(function () {
        return _this6.delegate.sendAction('playing');
      });

      this.assertSendCount(1);
      this.assertNamedSendCount('didStartPlaying', 1);
    };

    _class.prototype['@test Calling sendAction with a named action uses the component\'s property as the action name'] = function testCallingSendActionWithANamedActionUsesTheComponentSPropertyAsTheActionName() {
      var _this7 = this;

      this.renderDelegate();

      var component = this.delegate;

      this.runTask(function () {
        _emberMetal.set(_this7.delegate, 'playing', 'didStartPlaying');
        component.sendAction('playing');
      });

      this.assertSendCount(1);
      this.assertNamedSendCount('didStartPlaying', 1);

      this.runTask(function () {
        return component.sendAction('playing');
      });

      this.assertSendCount(2);
      this.assertNamedSendCount('didStartPlaying', 2);

      this.runTask(function () {
        _emberMetal.set(component, 'action', 'didDoSomeBusiness');
        component.sendAction();
      });

      this.assertSendCount(3);
      this.assertNamedSendCount('didDoSomeBusiness', 1);
    };

    _class.prototype['@test Calling sendAction when the action name is not a string raises an exception'] = function testCallingSendActionWhenTheActionNameIsNotAStringRaisesAnException() {
      var _this8 = this;

      this.renderDelegate();

      this.runTask(function () {
        _emberMetal.set(_this8.delegate, 'action', {});
        _emberMetal.set(_this8.delegate, 'playing', {});
      });

      expectAssertion(function () {
        return _this8.delegate.sendAction();
      });
      expectAssertion(function () {
        return _this8.delegate.sendAction('playing');
      });
    };

    _class.prototype['@test Calling sendAction on a component with contexts'] = function testCallingSendActionOnAComponentWithContexts() {
      var _this9 = this;

      this.renderDelegate();

      var testContext = { song: 'She Broke My Ember' };
      var firstContext = { song: 'She Broke My Ember' };
      var secondContext = { song: 'My Achey Breaky Ember' };

      this.runTask(function () {
        _emberMetal.set(_this9.delegate, 'playing', 'didStartPlaying');
        _this9.delegate.sendAction('playing', testContext);
      });

      this.assertSendCount(1);
      this.assertNamedSendCount('didStartPlaying', 1);
      this.assertSentWithArgs([testContext], 'context was sent with the action');

      this.runTask(function () {
        _this9.delegate.sendAction('playing', firstContext, secondContext);
      });

      this.assertSendCount(2);
      this.assertNamedSendCount('didStartPlaying', 2);
      this.assertSentWithArgs([firstContext, secondContext], 'multiple contexts were sent to the action');
    };

    _class.prototype['@test calling sendAction on a component within a block sends to the outer scope GH#14216'] = function testCallingSendActionOnAComponentWithinABlockSendsToTheOuterScopeGH14216(assert) {
      var testContext = this;
      // overrides default action-delegate so actions can be added
      this.registerComponent('action-delegate', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super();
            testContext.delegate = this;
            this.name = 'action-delegate';
          },

          actions: {
            derp: function (arg1) {
              assert.ok(true, 'action called on action-delgate');
              assert.equal(arg1, 'something special', 'argument passed through properly');
            }
          }
        }),

        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject)
      });

      this.registerComponent('component-a', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            this.name = 'component-a';
          },
          actions: {
            derp: function () {
              assert.ok(false, 'no! bad scoping!');
            }
          }
        })
      });

      var innerChild = undefined;
      this.registerComponent('component-b', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            innerChild = this;
            this.name = 'component-b';
          }
        })
      });

      this.renderDelegate();

      this.runTask(function () {
        return innerChild.sendAction('bar', 'something special');
      });
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Components test: sendAction to a controller', (function (_ApplicationTest) {
babelHelpers.inherits(_class2, _ApplicationTest);

    function _class2() {
      _ApplicationTest.apply(this, arguments);
    }

    _class2.prototype['@test sendAction should trigger an action on the parent component\'s controller if it exists'] = function testSendActionShouldTriggerAnActionOnTheParentComponentSControllerIfItExists(assert) {
      var _this10 = this;

      assert.expect(15);

      var component = undefined;

      this.router.map(function () {
        this.route('a');
        this.route('b');
        this.route('c', function () {
          this.route('d');
          this.route('e');
        });
      });

      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            component = this;
          }
        }),
        template: '{{val}}'
      });

      this.registerController('a', _emberRuntime.Controller.extend({
        send: function (actionName, actionContext) {
          assert.equal(actionName, 'poke', 'send() method was invoked from a top level controller');
          assert.equal(actionContext, 'top', 'action arguments were passed into the top level controller');
        }
      }));
      this.registerTemplate('a', '{{foo-bar val="a" poke="poke"}}');

      this.registerRoute('b', _emberRouting.Route.extend({
        actions: {
          poke: function (actionContext) {
            assert.ok(true, 'Unhandled action sent to route');
            assert.equal(actionContext, 'top no controller');
          }
        }
      }));
      this.registerTemplate('b', '{{foo-bar val="b" poke="poke"}}');

      this.registerRoute('c', _emberRouting.Route.extend({
        actions: {
          poke: function (actionContext) {
            assert.ok(true, 'Unhandled action sent to route');
            assert.equal(actionContext, 'top with nested no controller');
          }
        }
      }));
      this.registerTemplate('c', '{{foo-bar val="c" poke="poke"}}{{outlet}}');

      this.registerRoute('c.d', _emberRouting.Route.extend({}));

      this.registerController('c.d', _emberRuntime.Controller.extend({
        send: function (actionName, actionContext) {
          assert.equal(actionName, 'poke', 'send() method was invoked from a nested controller');
          assert.equal(actionContext, 'nested', 'action arguments were passed into the nested controller');
        }
      }));
      this.registerTemplate('c.d', '{{foo-bar val=".d" poke="poke"}}');

      this.registerRoute('c.e', _emberRouting.Route.extend({
        actions: {
          poke: function (actionContext) {
            assert.ok(true, 'Unhandled action sent to route');
            assert.equal(actionContext, 'nested no controller');
          }
        }
      }));
      this.registerTemplate('c.e', '{{foo-bar val=".e" poke="poke"}}');

      return this.visit('/a').then(function () {
        return component.sendAction('poke', 'top');
      }).then(function () {
        _this10.assertText('a');
        return _this10.visit('/b');
      }).then(function () {
        return component.sendAction('poke', 'top no controller');
      }).then(function () {
        _this10.assertText('b');
        return _this10.visit('/c');
      }).then(function () {
        return component.sendAction('poke', 'top with nested no controller');
      }).then(function () {
        _this10.assertText('c');
        return _this10.visit('/c/d');
      }).then(function () {
        return component.sendAction('poke', 'nested');
      }).then(function () {
        _this10.assertText('c.d');
        return _this10.visit('/c/e');
      }).then(function () {
        return component.sendAction('poke', 'nested no controller');
      }).then(function () {
        return _this10.assertText('c.e');
      });
    };

    _class2.prototype['@test sendAction should not trigger an action in an outlet\'s controller if a parent component handles it'] = function testSendActionShouldNotTriggerAnActionInAnOutletSControllerIfAParentComponentHandlesIt(assert) {
      assert.expect(1);

      var component = undefined;

      this.registerComponent('x-parent', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          actions: {
            poke: function () {
              assert.ok(true, 'parent component handled the aciton');
            }
          }
        }),
        template: '{{x-child poke="poke"}}'
      });

      this.registerComponent('x-child', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            component = this;
          }
        })
      });

      this.registerTemplate('application', '{{x-parent}}');
      this.registerController('application', _emberRuntime.Controller.extend({
        send: function (actionName) {
          throw new Error('controller action should not be called');
        }
      }));

      return this.visit('/').then(function () {
        return component.sendAction('poke');
      });
    };

    return _class2;
  })(_emberGlimmerTestsUtilsTestCase.ApplicationTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Components test: sendAction of a closure action', (function (_RenderingTest2) {
babelHelpers.inherits(_class3, _RenderingTest2);

    function _class3() {
      _RenderingTest2.apply(this, arguments);
    }

    _class3.prototype['@test action should be called'] = function testActionShouldBeCalled(assert) {
      assert.expect(1);
      var component = undefined;

      this.registerComponent('inner-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            component = this;
          }
        }),
        template: 'inner'
      });

      this.registerComponent('outer-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          outerSubmit: function () {
            assert.ok(true, 'outerSubmit called');
          }
        }),
        template: '{{inner-component submitAction=(action outerSubmit)}}'
      });

      this.render('{{outer-component}}');

      this.runTask(function () {
        return component.sendAction('submitAction');
      });
    };

    _class3.prototype['@test contexts passed to sendAction are appended to the bound arguments on a closure action'] = function testContextsPassedToSendActionAreAppendedToTheBoundArgumentsOnAClosureAction() {
      var first = 'mitch';
      var second = 'martin';
      var third = 'matt';
      var fourth = 'wacky wycats';

      var innerComponent = undefined;
      var actualArgs = undefined;

      this.registerComponent('inner-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            innerComponent = this;
          }
        }),
        template: 'inner'
      });

      this.registerComponent('outer-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          third: third,
          actions: {
            outerSubmit: function () {
              actualArgs = [].concat(babelHelpers.slice.call(arguments));
            }
          }
        }),
        template: '{{inner-component innerSubmit=(action (action "outerSubmit" "' + first + '") "' + second + '" third)}}'
      });

      this.render('{{outer-component}}');

      this.runTask(function () {
        return innerComponent.sendAction('innerSubmit', fourth);
      });

      this.assert.deepEqual(actualArgs, [first, second, third, fourth], 'action has the correct args');
    };

    return _class3;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Components test: send', (function (_RenderingTest3) {
babelHelpers.inherits(_class4, _RenderingTest3);

    function _class4() {
      _RenderingTest3.apply(this, arguments);
    }

    _class4.prototype['@test sending to undefined actions triggers an error'] = function testSendingToUndefinedActionsTriggersAnError(assert) {
      assert.expect(2);

      var component = undefined;

      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super();
            component = this;
          },
          actions: {
            foo: function (message) {
              assert.equal('bar', message);
            }
          }
        })
      });

      this.render('{{foo-bar}}');

      this.runTask(function () {
        return component.send('foo', 'bar');
      });

      expectAssertion(function () {
        return component.send('baz', 'bar');
      }, /had no action handler for: baz/);
    };

    _class4.prototype['@test `send` will call send from a target if it is defined'] = function testSendWillCallSendFromATargetIfItIsDefined() {
      var _this11 = this;

      var component = undefined;
      var target = {
        send: function (message, payload) {
          _this11.assert.equal('foo', message);
          _this11.assert.equal('baz', payload);
        }
      };

      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super();
            component = this;
          },
          target: target
        })
      });

      this.render('{{foo-bar}}');

      this.runTask(function () {
        return component.send('foo', 'baz');
      });
    };

    _class4.prototype['@test a handled action can be bubbled to the target for continued processing'] = function testAHandledActionCanBeBubbledToTheTargetForContinuedProcessing() {
      var _this12 = this;

      this.assert.expect(2);

      var component = undefined;

      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            component = this;
          },
          actions: {
            poke: function () {
              _this12.assert.ok(true, 'component action called');
              return true;
            }
          },
          target: _emberRuntime.Controller.extend({
            actions: {
              poke: function () {
                _this12.assert.ok(true, 'action bubbled to controller');
              }
            }
          }).create()
        })
      });

      this.render('{{foo-bar poke="poke"}}');

      this.runTask(function () {
        return component.send('poke');
      });
    };

    _class4.prototype['@test action can be handled by a superclass\' actions object'] = function testActionCanBeHandledByASuperclassActionsObject(assert) {
      this.assert.expect(4);

      var component = undefined;

      var SuperComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          foo: function () {
            assert.ok(true, 'foo');
          },
          bar: function (msg) {
            assert.equal(msg, 'HELLO');
          }
        }
      });

      var BarViewMixin = _emberMetal.Mixin.create({
        actions: {
          bar: function (msg) {
            assert.equal(msg, 'HELLO');
            this._super(msg);
          }
        }
      });

      this.registerComponent('x-index', {
        ComponentClass: SuperComponent.extend(BarViewMixin, {
          init: function () {
            this._super.apply(this, arguments);
            component = this;
          },
          actions: {
            baz: function () {
              assert.ok(true, 'baz');
            }
          }
        })
      });

      this.render('{{x-index}}');

      this.runTask(function () {
        component.send('foo');
        component.send('bar', 'HELLO');
        component.send('baz');
      });
    };

    _class4.prototype['@test actions cannot be provided at create time'] = function testActionsCannotBeProvidedAtCreateTime(assert) {
      expectAssertion(function () {
        return _emberGlimmerTestsUtilsHelpers.Component.create({
          actions: {
            foo: function () {
              assert.ok(true, 'foo');
            }
          }
        });
      });
      // but should be OK on an object that doesn't mix in Ember.ActionHandler
      _emberRuntime.Object.create({
        actions: ['foo']
      });
    };

    return _class4;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/components/target-action-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/components/target-action-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/components/target-action-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/components/utils-test', ['exports', 'ember-runtime', 'ember-views', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/helpers'], function (exports, _emberRuntime, _emberViews, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsHelpers) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('View tree tests', (function (_ApplicationTest) {
    babelHelpers.inherits(_class, _ApplicationTest);

    function _class() {
      _ApplicationTest.call(this);

      this.registerComponent('x-tagless', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          tagName: ''
        }),

        template: '<div id="{{id}}">[{{id}}] {{#if isShowing}}{{yield}}{{/if}}</div>'
      });

      this.registerComponent('x-toggle', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          isExpanded: true,

          click: function () {
            this.toggleProperty('isExpanded');
            return false;
          }
        }),

        template: '[{{id}}] {{#if isExpanded}}{{yield}}{{/if}}'
      });

      var ToggleController = _emberRuntime.Controller.extend({
        isExpanded: true,

        actions: {
          toggle: function () {
            this.toggleProperty('isExpanded');
          }
        }
      });

      this.registerController('application', ToggleController);

      this.registerTemplate('application', '\n      {{x-tagless id="root-1"}}\n\n      {{#x-toggle id="root-2"}}\n        {{x-toggle id="inner-1"}}\n\n        {{#x-toggle id="inner-2"}}\n          {{x-toggle id="inner-3"}}\n        {{/x-toggle}}\n      {{/x-toggle}}\n\n      <button id="toggle-application" {{action "toggle"}}>Toggle</button>\n\n      {{#if isExpanded}}\n        {{x-toggle id="root-3"}}\n      {{/if}}\n\n      {{outlet}}\n    ');

      this.registerController('index', ToggleController.extend({
        isExpanded: false
      }));

      this.registerTemplate('index', '\n      {{x-tagless id="root-4"}}\n\n      {{#x-toggle id="root-5" isExpanded=false}}\n        {{x-toggle id="inner-4"}}\n\n        {{#x-toggle id="inner-5"}}\n          {{x-toggle id="inner-6"}}\n        {{/x-toggle}}\n      {{/x-toggle}}\n\n      <button id="toggle-index" {{action "toggle"}}>Toggle</button>\n\n      {{#if isExpanded}}\n        {{x-toggle id="root-6"}}\n      {{/if}}\n    ');

      this.registerTemplate('zomg', '\n      {{x-tagless id="root-7"}}\n\n      {{#x-toggle id="root-8"}}\n        {{x-toggle id="inner-7"}}\n\n        {{#x-toggle id="inner-8"}}\n          {{x-toggle id="inner-9"}}\n        {{/x-toggle}}\n      {{/x-toggle}}\n\n      {{#x-toggle id="root-9"}}\n        {{outlet}}\n      {{/x-toggle}}\n    ');

      this.registerTemplate('zomg.lol', '\n      {{x-toggle id="inner-10"}}\n    ');

      this.router.map(function () {
        this.route('zomg', function () {
          this.route('lol');
        });
      });
    }

    _class.prototype['@test getRootViews'] = function testGetRootViews(assert) {
      var _this = this;

      return this.visit('/').then(function () {
        _this.assertRootViews(['root-1', 'root-2', 'root-3', 'root-4', 'root-5']);

        _this.runTask(function () {
          return _emberViews.jQuery('#toggle-application').click();
        });

        _this.assertRootViews(['root-1', 'root-2', 'root-4', 'root-5']);

        _this.runTask(function () {
          _emberViews.jQuery('#toggle-application').click();
          _emberViews.jQuery('#toggle-index').click();
        });

        _this.assertRootViews(['root-1', 'root-2', 'root-3', 'root-4', 'root-5', 'root-6']);

        return _this.visit('/zomg/lol');
      }).then(function () {
        _this.assertRootViews(['root-1', 'root-2', 'root-3', 'root-7', 'root-8', 'root-9']);

        return _this.visit('/');
      }).then(function () {
        _this.assertRootViews(['root-1', 'root-2', 'root-3', 'root-4', 'root-5', 'root-6']);
      });
    };

    _class.prototype.assertRootViews = function assertRootViews(ids) {
      var owner = this.applicationInstance;

      var actual = _emberViews.getRootViews(owner).map(function (view) {
        return view.id;
      }).sort();
      var expected = ids.sort();

      this.assert.deepEqual(actual, expected, 'root views');
    };

    _class.prototype['@test getChildViews'] = function testGetChildViews(assert) {
      var _this2 = this;

      return this.visit('/').then(function () {
        _this2.assertChildViews('root-2', ['inner-1', 'inner-2']);
        _this2.assertChildViews('root-5', []);
        _this2.assertChildViews('inner-2', ['inner-3']);

        _this2.runTask(function () {
          return _emberViews.jQuery('#root-2').click();
        });

        _this2.assertChildViews('root-2', []);

        _this2.runTask(function () {
          return _emberViews.jQuery('#root-5').click();
        });

        _this2.assertChildViews('root-5', ['inner-4', 'inner-5']);
        _this2.assertChildViews('inner-5', ['inner-6']);

        return _this2.visit('/zomg');
      }).then(function () {
        _this2.assertChildViews('root-2', []);
        _this2.assertChildViews('root-8', ['inner-7', 'inner-8']);
        _this2.assertChildViews('inner-8', ['inner-9']);
        _this2.assertChildViews('root-9', []);

        _this2.runTask(function () {
          return _emberViews.jQuery('#root-8').click();
        });

        _this2.assertChildViews('root-8', []);

        return _this2.visit('/zomg/lol');
      }).then(function () {
        _this2.assertChildViews('root-2', []);
        _this2.assertChildViews('root-8', []);
        _this2.assertChildViews('root-9', ['inner-10']);

        return _this2.visit('/');
      }).then(function () {
        _this2.assertChildViews('root-2', []);
        _this2.assertChildViews('root-5', []);

        _this2.runTask(function () {
          return _emberViews.jQuery('#root-2').click();
        });
        _this2.runTask(function () {
          return _emberViews.jQuery('#inner-2').click();
        });

        _this2.assertChildViews('root-2', ['inner-1', 'inner-2']);
        _this2.assertChildViews('inner-2', []);
      });
    };

    _class.prototype['@test getChildViews does not return duplicates'] = function testGetChildViewsDoesNotReturnDuplicates(assert) {
      var _this3 = this;

      return this.visit('/').then(function () {
        _this3.assertChildViews('root-2', ['inner-1', 'inner-2']);

        _this3.runTask(function () {
          return _emberViews.jQuery('#root-2').click();
        });
        _this3.runTask(function () {
          return _emberViews.jQuery('#root-2').click();
        });
        _this3.runTask(function () {
          return _emberViews.jQuery('#root-2').click();
        });
        _this3.runTask(function () {
          return _emberViews.jQuery('#root-2').click();
        });
        _this3.runTask(function () {
          return _emberViews.jQuery('#root-2').click();
        });
        _this3.runTask(function () {
          return _emberViews.jQuery('#root-2').click();
        });
        _this3.runTask(function () {
          return _emberViews.jQuery('#root-2').click();
        });
        _this3.runTask(function () {
          return _emberViews.jQuery('#root-2').click();
        });
        _this3.runTask(function () {
          return _emberViews.jQuery('#root-2').click();
        });
        _this3.runTask(function () {
          return _emberViews.jQuery('#root-2').click();
        });

        _this3.assertChildViews('root-2', ['inner-1', 'inner-2']);
      });
    };

    _class.prototype.assertChildViews = function assertChildViews(parentId, childIds) {
      var parentView = this.viewFor(parentId);
      var childViews = _emberViews.getChildViews(parentView);

      var actual = childViews.map(function (view) {
        return view.id;
      }).sort();
      var expected = childIds.sort();

      this.assert.deepEqual(actual, expected, 'child views for #' + parentId);
    };

    _class.prototype.viewFor = function viewFor(id) {
      var owner = this.applicationInstance;
      var registry = owner.lookup('-view-registry:main');
      return registry[id];
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.ApplicationTest));

  var hasGetClientRects = undefined,
      hasGetBoundingClientRect = undefined;
  var ClientRectListCtor = undefined,
      ClientRectCtor = undefined;

  (function () {
    if (document.createRange) {
      var range = document.createRange();

      if (range.getClientRects) {
        var clientRectsList = range.getClientRects();
        hasGetClientRects = true;
        ClientRectListCtor = clientRectsList && clientRectsList.constructor;
      }

      if (range.getBoundingClientRect) {
        var clientRect = range.getBoundingClientRect();
        hasGetBoundingClientRect = true;
        ClientRectCtor = clientRect && clientRect.constructor;
      }
    }
  })();

  _emberGlimmerTestsUtilsTestCase.moduleFor('Bounds tests', (function (_RenderingTest) {
    babelHelpers.inherits(_class2, _RenderingTest);

    function _class2() {
      _RenderingTest.apply(this, arguments);
    }

    _class2.prototype['@test getViewBounds on a regular component'] = function testGetViewBoundsOnARegularComponent(assert) {
      var component = undefined;
      this.registerComponent('hi-mom', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            component = this;
          }
        }),
        template: '<p>Hi, mom!</p>'
      });

      this.render('{{hi-mom}}');

      var _getViewBounds = _emberViews.getViewBounds(component);

      var parentElement = _getViewBounds.parentElement;
      var firstNode = _getViewBounds.firstNode;
      var lastNode = _getViewBounds.lastNode;

      assert.equal(parentElement, this.element, 'a regular component should have the right parentElement');
      assert.equal(firstNode, component.element, 'a regular component should have a single node that is its element');
      assert.equal(lastNode, component.element, 'a regular component should have a single node that is its element');
    };

    _class2.prototype['@test getViewBounds on a tagless component'] = function testGetViewBoundsOnATaglessComponent(assert) {
      var component = undefined;
      this.registerComponent('hi-mom', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          tagName: '',
          init: function () {
            this._super.apply(this, arguments);
            component = this;
          }
        }),
        template: '<span id="start-node">Hi,</span> <em id="before-end-node">mom</em>!'
      });

      this.render('{{hi-mom}}');

      var _getViewBounds2 = _emberViews.getViewBounds(component);

      var parentElement = _getViewBounds2.parentElement;
      var firstNode = _getViewBounds2.firstNode;
      var lastNode = _getViewBounds2.lastNode;

      assert.equal(parentElement, this.element, 'a tagless component should have the right parentElement');
      assert.equal(firstNode, this.$('#start-node')[0], 'a tagless component should have a range enclosing all of its nodes');
      assert.equal(lastNode, this.$('#before-end-node')[0].nextSibling, 'a tagless component should have a range enclosing all of its nodes');
    };

    _class2.prototype['@test getViewClientRects'] = function testGetViewClientRects(assert) {
      if (!hasGetClientRects || !ClientRectListCtor) {
        assert.ok(true, 'The test environment does not support the DOM API required to run this test.');
        return;
      }

      var component = undefined;
      this.registerComponent('hi-mom', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            component = this;
          }
        }),
        template: '<p>Hi, mom!</p>'
      });

      this.render('{{hi-mom}}');

      assert.ok(_emberViews.getViewClientRects(component) instanceof ClientRectListCtor);
    };

    _class2.prototype['@test getViewBoundingClientRect'] = function testGetViewBoundingClientRect(assert) {
      if (!hasGetBoundingClientRect || !ClientRectCtor) {
        assert.ok(true, 'The test environment does not support the DOM API required to run this test.');
        return;
      }

      var component = undefined;
      this.registerComponent('hi-mom', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            component = this;
          }
        }),
        template: '<p>Hi, mom!</p>'
      });

      this.render('{{hi-mom}}');

      assert.ok(_emberViews.getViewBoundingClientRect(component) instanceof ClientRectCtor);
    };

    return _class2;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/components/utils-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/components/utils-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/components/utils-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/components/web-component-fallback-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-metal'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberMetal) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Components test: web component fallback', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test custom elements are rendered'] = function testCustomElementsAreRendered() {
      var template = '<foo-bar some-attr="123">hello</foo-bar>';

      this.render(template);

      this.assertHTML(template);

      this.assertStableRerender();
    };

    _class.prototype['@test custom elements can have bound attributes'] = function testCustomElementsCanHaveBoundAttributes() {
      var _this = this;

      var template = '<foo-bar some-attr="{{name}}">hello</foo-bar>';

      this.render(template, { name: 'Robert' });

      this.assertHTML('<foo-bar some-attr="Robert">hello</foo-bar>');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'name', 'Kris');
      });

      this.assertHTML('<foo-bar some-attr="Kris">hello</foo-bar>');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'name', 'Robert');
      });

      this.assertHTML('<foo-bar some-attr="Robert">hello</foo-bar>');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/components/web-component-fallback-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/components/web-component-fallback-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/components/web-component-fallback-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/components/will-destroy-element-hook-test', ['exports', 'ember-metal', 'ember-glimmer/tests/utils/helpers', 'ember-glimmer/tests/utils/test-case'], function (exports, _emberMetal, _emberGlimmerTestsUtilsHelpers, _emberGlimmerTestsUtilsTestCase) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Component willDestroyElement hook', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test it calls willDestroyElement when removed by if'] = function testItCallsWillDestroyElementWhenRemovedByIf(assert) {
      var _this = this;

      var didInsertElementCount = 0;
      var willDestroyElementCount = 0;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        didInsertElement: function () {
          didInsertElementCount++;
          assert.notEqual(this.element.parentNode, null, 'precond component is in DOM');
        },
        willDestroyElement: function () {
          willDestroyElementCount++;
          assert.notEqual(this.element.parentNode, null, 'has not been removed from DOM yet');
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

      this.render('{{#if switch}}{{foo-bar}}{{/if}}', { switch: true });

      assert.equal(didInsertElementCount, 1, 'didInsertElement was called once');

      this.assertComponentElement(this.firstChild, { content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'switch', false);
      });

      assert.equal(willDestroyElementCount, 1, 'willDestroyElement was called once');

      this.assertText('');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/components/will-destroy-element-hook-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/components/will-destroy-element-hook-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/components/will-destroy-element-hook-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/content-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/abstract-test-case', 'ember-metal', 'ember-runtime', 'ember-glimmer/tests/utils/test-helpers', 'ember-views', 'ember-glimmer/tests/utils/helpers'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsAbstractTestCase, _emberMetal, _emberRuntime, _emberGlimmerTestsUtilsTestHelpers, _emberViews, _emberGlimmerTestsUtilsHelpers) {
  /* globals EmberDev */
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Static content tests', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test it can render a static text node'] = function testItCanRenderAStaticTextNode() {
      var _this = this;

      this.render('hello');
      var text1 = this.assertTextNode(this.firstChild, 'hello');

      this.runTask(function () {
        return _this.rerender();
      });

      var text2 = this.assertTextNode(this.firstChild, 'hello');

      this.assertSameNode(text1, text2);
    };

    _class.prototype['@test it can render a static element'] = function testItCanRenderAStaticElement() {
      var _this2 = this;

      this.render('<p>hello</p>');
      var p1 = this.assertElement(this.firstChild, { tagName: 'p' });
      var text1 = this.assertTextNode(this.firstChild.firstChild, 'hello');

      this.runTask(function () {
        return _this2.rerender();
      });

      var p2 = this.assertElement(this.firstChild, { tagName: 'p' });
      var text2 = this.assertTextNode(this.firstChild.firstChild, 'hello');

      this.assertSameNode(p1, p2);
      this.assertSameNode(text1, text2);
    };

    _class.prototype['@test it can render a static template'] = function testItCanRenderAStaticTemplate() {
      var _this3 = this;

      var template = '\n      <div class="header">\n        <h1>Welcome to Ember.js</h1>\n      </div>\n      <div class="body">\n        <h2>Why you should use Ember.js?</h2>\n        <ol>\n          <li>It\'s great</li>\n          <li>It\'s awesome</li>\n          <li>It\'s Ember.js</li>\n        </ol>\n      </div>\n      <div class="footer">\n        Ember.js is free, open source and always will be.\n      </div>\n    ';

      this.render(template);
      this.assertHTML(template);

      this.runTask(function () {
        return _this3.rerender();
      });

      this.assertHTML(template);
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));

  var DynamicContentTest = (function (_RenderingTest2) {
    babelHelpers.inherits(DynamicContentTest, _RenderingTest2);

    function DynamicContentTest() {
      _RenderingTest2.apply(this, arguments);
    }

    /* abstract */

    DynamicContentTest.prototype.renderPath = function renderPath(path) {
      var context = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      throw new Error('Not implemented: `renderValues`');
    };

    DynamicContentTest.prototype.assertIsEmpty = function assertIsEmpty() {
      this.assert.strictEqual(this.firstChild, null);
    };

    /* abstract */

    DynamicContentTest.prototype.assertContent = function assertContent(content) {
      throw new Error('Not implemented: `assertContent`');
    };

    DynamicContentTest.prototype['@test it can render a dynamic path'] = function testItCanRenderADynamicPath() {
      var _this4 = this;

      this.renderPath('message', { message: 'hello' });

      this.assertContent('hello');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'message', 'goodbye');
      });

      this.assertContent('goodbye');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'message', 'hello');
      });

      this.assertContent('hello');
      this.assertInvariants();
    };

    DynamicContentTest.prototype['@test resolves the string length properly'] = function testResolvesTheStringLengthProperly() {
      var _this5 = this;

      this.render('<p>{{foo.length}}</p>', { foo: undefined });

      this.assertHTML('<p></p>');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'foo', 'foo');
      });

      this.assertHTML('<p>3</p>');

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'foo', '');
      });

      this.assertHTML('<p>0</p>');

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'foo', undefined);
      });

      this.assertHTML('<p></p>');
    };

    DynamicContentTest.prototype['@test resolves the array length properly'] = function testResolvesTheArrayLengthProperly() {
      var _this6 = this;

      this.render('<p>{{foo.length}}</p>', { foo: undefined });

      this.assertHTML('<p></p>');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this6.context, 'foo', [1, 2, 3]);
      });

      this.assertHTML('<p>3</p>');

      this.runTask(function () {
        return _emberMetal.set(_this6.context, 'foo', []);
      });

      this.assertHTML('<p>0</p>');

      this.runTask(function () {
        return _emberMetal.set(_this6.context, 'foo', undefined);
      });

      this.assertHTML('<p></p>');
    };

    DynamicContentTest.prototype['@test it can render a capitalized path with no deprecation'] = function testItCanRenderACapitalizedPathWithNoDeprecation() {
      var _this7 = this;

      expectNoDeprecation();

      this.renderPath('CaptializedPath', { CaptializedPath: 'no deprecation' });

      this.assertContent('no deprecation');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'CaptializedPath', 'still no deprecation');
      });

      this.assertContent('still no deprecation');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'CaptializedPath', 'no deprecation');
      });

      this.assertContent('no deprecation');
      this.assertInvariants();
    };

    DynamicContentTest.prototype['@test it can render undefined dynamic paths'] = function testItCanRenderUndefinedDynamicPaths() {
      var _this8 = this;

      this.renderPath('name', {});

      this.assertIsEmpty();

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this8.context, 'name', 'foo-bar');
      });

      this.assertContent('foo-bar');

      this.runTask(function () {
        return _emberMetal.set(_this8.context, 'name', undefined);
      });

      this.assertIsEmpty();
    };

    DynamicContentTest.prototype['@test it can render a deeply nested dynamic path'] = function testItCanRenderADeeplyNestedDynamicPath() {
      var _this9 = this;

      this.renderPath('a.b.c.d.e.f', {
        a: { b: { c: { d: { e: { f: 'hello' } } } } }
      });

      this.assertContent('hello');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this9.context, 'a.b.c.d.e.f', 'goodbye');
      });

      this.assertContent('goodbye');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this9.context, 'a.b.c.d', { e: { f: 'aloha' } });
      });

      this.assertContent('aloha');
      this.assertInvariants();

      this.runTask(function () {
        _emberMetal.set(_this9.context, 'a', { b: { c: { d: { e: { f: 'hello' } } } } });
      });

      this.assertContent('hello');
      this.assertInvariants();
    };

    DynamicContentTest.prototype['@test it can render a computed property'] = function testItCanRenderAComputedProperty() {
      var _this10 = this;

      var Formatter = _emberRuntime.Object.extend({
        formattedMessage: _emberMetal.computed('message', function () {
          return this.get('message').toUpperCase();
        })
      });

      var m = Formatter.create({ message: 'hello' });

      this.renderPath('m.formattedMessage', { m: m });

      this.assertContent('HELLO');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(m, 'message', 'goodbye');
      });

      this.assertContent('GOODBYE');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this10.context, 'm', Formatter.create({ message: 'hello' }));
      });

      this.assertContent('HELLO');
      this.assertInvariants();
    };

    DynamicContentTest.prototype['@test it can render a computed property with nested dependency'] = function testItCanRenderAComputedPropertyWithNestedDependency() {
      var _this11 = this;

      var Formatter = _emberRuntime.Object.extend({
        formattedMessage: _emberMetal.computed('messenger.message', function () {
          return this.get('messenger.message').toUpperCase();
        })
      });

      var m = Formatter.create({ messenger: { message: 'hello' } });

      this.renderPath('m.formattedMessage', { m: m });

      this.assertContent('HELLO');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(m, 'messenger.message', 'goodbye');
      });

      this.assertContent('GOODBYE');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this11.context, 'm', Formatter.create({ messenger: { message: 'hello' } }));
      });

      this.assertContent('HELLO');
      this.assertInvariants();
    };

    DynamicContentTest.prototype['@test it can read from a proxy object'] = function testItCanReadFromAProxyObject() {
      var _this12 = this;

      this.renderPath('proxy.name', { proxy: _emberRuntime.ObjectProxy.create({ content: { name: 'Tom Dale' } }) });

      this.assertContent('Tom Dale');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this12.context, 'proxy.content.name', 'Yehuda Katz');
      });

      this.assertContent('Yehuda Katz');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this12.context, 'proxy.content', { name: 'Godfrey Chan' });
      });

      this.assertContent('Godfrey Chan');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this12.context, 'proxy.name', 'Stefan Penner');
      });

      this.assertContent('Stefan Penner');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this12.context, 'proxy.content', null);
      });

      this.assertIsEmpty();

      this.runTask(function () {
        return _emberMetal.set(_this12.context, 'proxy', _emberRuntime.ObjectProxy.create({ content: { name: 'Tom Dale' } }));
      });

      this.assertContent('Tom Dale');
      this.assertInvariants();
    };

    DynamicContentTest.prototype['@test it can read from a nested path in a proxy object'] = function testItCanReadFromANestedPathInAProxyObject() {
      var _this13 = this;

      this.renderPath('proxy.name.last', { proxy: _emberRuntime.ObjectProxy.create({ content: { name: { first: 'Tom', last: 'Dale' } } }) });

      this.assertContent('Dale');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this13.context, 'proxy.content.name.last', 'Cruise');
      });

      this.assertContent('Cruise');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this13.context, 'proxy.content.name.first', 'Suri');
      });

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this13.context, 'proxy.content.name', { first: 'Yehuda', last: 'Katz' });
      });

      this.assertContent('Katz');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this13.context, 'proxy.content', { name: { first: 'Godfrey', last: 'Chan' } });
      });

      this.assertContent('Chan');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this13.context, 'proxy.name', { first: 'Stefan', last: 'Penner' });
      });

      this.assertContent('Penner');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this13.context, 'proxy', null);
      });

      this.assertIsEmpty();

      this.runTask(function () {
        return _emberMetal.set(_this13.context, 'proxy', _emberRuntime.ObjectProxy.create({ content: { name: { first: 'Tom', last: 'Dale' } } }));
      });

      this.assertContent('Dale');
      this.assertInvariants();
    };

    DynamicContentTest.prototype['@test it can read from a path flipping between a proxy and a real object'] = function testItCanReadFromAPathFlippingBetweenAProxyAndARealObject() {
      var _this14 = this;

      this.renderPath('proxyOrObject.name.last', { proxyOrObject: _emberRuntime.ObjectProxy.create({ content: { name: { first: 'Tom', last: 'Dale' } } }) });

      this.assertContent('Dale');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this14.context, 'proxyOrObject', { name: { first: 'Tom', last: 'Dale' } });
      });

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this14.context, 'proxyOrObject.name.last', 'Cruise');
      });

      this.assertContent('Cruise');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this14.context, 'proxyOrObject.name.first', 'Suri');
      });

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this14.context, 'proxyOrObject', { name: { first: 'Yehuda', last: 'Katz' } });
      });

      this.assertContent('Katz');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this14.context, 'proxyOrObject', _emberRuntime.ObjectProxy.create({ content: { name: { first: 'Godfrey', last: 'Chan' } } }));
      });

      this.assertContent('Chan');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this14.context, 'proxyOrObject.content.name', { first: 'Stefan', last: 'Penner' });
      });

      this.assertContent('Penner');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this14.context, 'proxyOrObject', null);
      });

      this.assertIsEmpty();

      this.runTask(function () {
        return _emberMetal.set(_this14.context, 'proxyOrObject', _emberRuntime.ObjectProxy.create({ content: { name: { first: 'Tom', last: 'Dale' } } }));
      });

      this.assertContent('Dale');
      this.assertInvariants();
    };

    DynamicContentTest.prototype['@test it can read from a path flipping between a real object and a proxy'] = function testItCanReadFromAPathFlippingBetweenARealObjectAndAProxy() {
      var _this15 = this;

      this.renderPath('objectOrProxy.name.last', { objectOrProxy: { name: { first: 'Tom', last: 'Dale' } } });

      this.assertContent('Dale');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this15.context, 'objectOrProxy', _emberRuntime.ObjectProxy.create({ content: { name: { first: 'Tom', last: 'Dale' } } }));
      });

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this15.context, 'objectOrProxy.content.name.last', 'Cruise');
      });

      this.assertContent('Cruise');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this15.context, 'objectOrProxy.content.name.first', 'Suri');
      });

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this15.context, 'objectOrProxy.content', { name: { first: 'Yehuda', last: 'Katz' } });
      });

      this.assertContent('Katz');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this15.context, 'objectOrProxy', { name: { first: 'Godfrey', last: 'Chan' } });
      });

      this.assertContent('Chan');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this15.context, 'objectOrProxy.name', { first: 'Stefan', last: 'Penner' });
      });

      this.assertContent('Penner');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this15.context, 'objectOrProxy', null);
      });

      this.assertIsEmpty();

      this.runTask(function () {
        return _emberMetal.set(_this15.context, 'objectOrProxy', { name: { first: 'Tom', last: 'Dale' } });
      });

      this.assertContent('Dale');
      this.assertInvariants();
    };

    DynamicContentTest.prototype['@test it can read from a null object'] = function testItCanReadFromANullObject() {
      var _this16 = this;

      var nullObject = Object.create(null);
      nullObject['message'] = 'hello';

      this.renderPath('nullObject.message', { nullObject: nullObject });

      this.assertContent('hello');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(nullObject, 'message', 'goodbye');
      });

      this.assertContent('goodbye');
      this.assertInvariants();

      nullObject = Object.create(null);
      nullObject['message'] = 'hello';

      this.runTask(function () {
        return _emberMetal.set(_this16.context, 'nullObject', nullObject);
      });

      this.assertContent('hello');
      this.assertInvariants();
    };

    DynamicContentTest.prototype['@test it can render a readOnly property of a path'] = function testItCanRenderAReadOnlyPropertyOfAPath() {
      var _this17 = this;

      var Messenger = _emberRuntime.Object.extend({
        message: _emberMetal.computed.readOnly('a.b.c')
      });

      var messenger = Messenger.create({
        a: {
          b: {
            c: 'hello'
          }
        }
      });

      this.renderPath('messenger.message', { messenger: messenger });

      this.assertContent('hello');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(messenger, 'a.b.c', 'hi');
      });

      this.assertContent('hi');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this17.context, 'messenger.a.b', {
          c: 'goodbye'
        });
      });

      this.assertContent('goodbye');
      this.assertInvariants();

      this.runTask(function () {
        return _emberMetal.set(_this17.context, 'messenger', {
          message: 'hello'
        });
      });

      this.assertContent('hello');
      this.assertInvariants();
    };

    return DynamicContentTest;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest);

  var EMPTY = {};

  var ContentTestGenerator = (function () {
    function ContentTestGenerator(cases) {
      var tag = arguments.length <= 1 || arguments[1] === undefined ? '@test' : arguments[1];

      this.cases = cases;
      this.tag = tag;
    }

    ContentTestGenerator.prototype.generate = function generate(_ref3) {
      var value = _ref3[0];
      var expected = _ref3[1];
      var label = _ref3[2];

      var tag = this.tag;
      label = label || value;

      if (expected === EMPTY) {
        var _ref;

        return _ref = {}, _ref[tag + ' rendering ' + label] = function () {
          var _this18 = this;

          this.renderPath('value', { value: value });

          this.assertIsEmpty();

          this.runTask(function () {
            return _emberMetal.set(_this18.context, 'value', 'hello');
          });

          this.assertContent('hello');

          this.runTask(function () {
            return _emberMetal.set(_this18.context, 'value', value);
          });

          this.assertIsEmpty();
        }, _ref;
      } else {
        var _ref2;

        return _ref2 = {}, _ref2[tag + ' rendering ' + label] = function () {
          var _this19 = this;

          this.renderPath('value', { value: value });

          this.assertContent(expected);

          this.assertStableRerender();

          this.runTask(function () {
            return _emberMetal.set(_this19.context, 'value', 'hello');
          });

          this.assertContent('hello');
          this.assertInvariants();

          this.runTask(function () {
            return _emberMetal.set(_this19.context, 'value', value);
          });

          this.assertContent(expected);
          this.assertInvariants();
        }, _ref2;
      }
    };

    return ContentTestGenerator;
  })();

  var SharedContentTestCases = new ContentTestGenerator([['foo', 'foo'], [0, '0'], [-0, '0', '-0'], [1, '1'], [-1, '-1'], [0.0, '0', '0.0'], [0.5, '0.5'], [undefined, EMPTY], [null, EMPTY], [true, 'true'], [false, 'false'], [NaN, 'NaN'], [new Date(2000, 0, 1), String(new Date(2000, 0, 1)), 'a Date object'], [Infinity, 'Infinity'], [1 / -0, '-Infinity'], [{ foo: 'bar' }, '[object Object]', '{ foo: \'bar\' }'], [{ toString: function () {
      return 'foo';
    } }, 'foo', 'an object with a custom toString function'], [{ valueOf: function () {
      return 1;
    } }, '[object Object]', 'an object with a custom valueOf function'],

  // Escaping tests
  ['<b>Max</b><b>James</b>', '<b>Max</b><b>James</b>']]);

  var GlimmerContentTestCases = new ContentTestGenerator([[Object.create(null), EMPTY, 'an object with no toString']]);

  if (typeof Symbol !== 'undefined') {
    GlimmerContentTestCases.cases.push([Symbol('debug'), 'Symbol(debug)', 'a symbol']);
  }

  _emberGlimmerTestsUtilsAbstractTestCase.applyMixins(DynamicContentTest, SharedContentTestCases, GlimmerContentTestCases);

  _emberGlimmerTestsUtilsTestCase.moduleFor('Dynamic content tests (content position)', (function (_DynamicContentTest) {
    babelHelpers.inherits(_class2, _DynamicContentTest);

    function _class2() {
      _DynamicContentTest.apply(this, arguments);
    }

    _class2.prototype.renderPath = function renderPath(path) {
      var context = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      this.render('{{' + path + '}}', context);
    };

    _class2.prototype.assertContent = function assertContent(content) {
      this.assert.strictEqual(this.nodesCount, 1, 'It should render exactly one text node');
      this.assertTextNode(this.firstChild, content);
    };

    return _class2;
  })(DynamicContentTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Dynamic content tests (content concat)', (function (_DynamicContentTest2) {
    babelHelpers.inherits(_class3, _DynamicContentTest2);

    function _class3() {
      _DynamicContentTest2.apply(this, arguments);
    }

    _class3.prototype.renderPath = function renderPath(path) {
      var context = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      this.render('{{concat "" ' + path + ' ""}}', context);
    };

    _class3.prototype.assertContent = function assertContent(content) {
      this.assert.strictEqual(this.nodesCount, 1, 'It should render exactly one text node');
      this.assertTextNode(this.firstChild, content);
    };

    return _class3;
  })(DynamicContentTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Dynamic content tests (inside an element)', (function (_DynamicContentTest3) {
    babelHelpers.inherits(_class4, _DynamicContentTest3);

    function _class4() {
      _DynamicContentTest3.apply(this, arguments);
    }

    _class4.prototype.renderPath = function renderPath(path) {
      var context = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      this.render('<p>{{' + path + '}}</p>', context);
    };

    _class4.prototype.assertIsEmpty = function assertIsEmpty() {
      this.assert.strictEqual(this.nodesCount, 1, 'It should render exactly one <p> tag');
      this.assertElement(this.firstChild, { tagName: 'p' });
      this.assertText('');
    };

    _class4.prototype.assertContent = function assertContent(content) {
      this.assert.strictEqual(this.nodesCount, 1, 'It should render exactly one <p> tag');
      this.assertElement(this.firstChild, { tagName: 'p' });
      this.assertText(content);
    };

    return _class4;
  })(DynamicContentTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Dynamic content tests (attribute position)', (function (_DynamicContentTest4) {
    babelHelpers.inherits(_class5, _DynamicContentTest4);

    function _class5() {
      _DynamicContentTest4.apply(this, arguments);
    }

    _class5.prototype.renderPath = function renderPath(path) {
      var context = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      this.render('<div data-foo="{{' + path + '}}"></div>', context);
    };

    _class5.prototype.assertIsEmpty = function assertIsEmpty() {
      this.assert.strictEqual(this.nodesCount, 1, 'It should render exactly one <div> tag');
      this.assertElement(this.firstChild, { tagName: 'div', content: '' });
    };

    _class5.prototype.assertContent = function assertContent(content) {
      this.assert.strictEqual(this.nodesCount, 1, 'It should render exactly one <div> tag');
      this.assertElement(this.firstChild, { tagName: 'div', attrs: { 'data-foo': content }, content: '' });
    };

    return _class5;
  })(DynamicContentTest));

  var TrustedContentTest = (function (_DynamicContentTest5) {
    babelHelpers.inherits(TrustedContentTest, _DynamicContentTest5);

    function TrustedContentTest() {
      _DynamicContentTest5.apply(this, arguments);
    }

    TrustedContentTest.prototype.assertIsEmpty = function assertIsEmpty() {
      this.assert.strictEqual(this.firstChild, null);
    };

    TrustedContentTest.prototype.assertContent = function assertContent(content) {
      this.assertHTML(content);
    };

    TrustedContentTest.prototype.assertStableRerender = function assertStableRerender() {
      var _this20 = this;

      this.takeSnapshot();
      this.runTask(function () {
        return _this20.rerender();
      });
      _DynamicContentTest5.prototype.assertInvariants.call(this);
    };

    TrustedContentTest.prototype.assertInvariants = function assertInvariants() {
      // If it's not stable, we will wipe out all the content and replace them,
      // so there are no invariants
    };

    return TrustedContentTest;
  })(DynamicContentTest);

  _emberGlimmerTestsUtilsTestCase.moduleFor('Dynamic content tests (trusted)', (function (_TrustedContentTest) {
    babelHelpers.inherits(_class6, _TrustedContentTest);

    function _class6() {
      _TrustedContentTest.apply(this, arguments);
    }

    _class6.prototype.renderPath = function renderPath(path) {
      var context = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      this.render('{{{' + path + '}}}', context);
    };

    _class6.prototype['@test updating trusted curlies'] = function testUpdatingTrustedCurlies() {
      var _this21 = this;

      this.render('{{{htmlContent}}}{{{nested.htmlContent}}}', {
        htmlContent: '<b>Max</b>',
        nested: { htmlContent: '<b>James</b>' }
      });

      this.assertContent('<b>Max</b><b>James</b>');

      this.runTask(function () {
        return _this21.rerender();
      });

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this21.context, 'htmlContent', '<i>M</i><u>a</u><s>x</s>');
      });

      this.assertContent('<i>M</i><u>a</u><s>x</s><b>James</b>');

      this.runTask(function () {
        return _emberMetal.set(_this21.context, 'nested.htmlContent', 'Jammie');
      });

      this.assertContent('<i>M</i><u>a</u><s>x</s>Jammie');

      this.runTask(function () {
        _emberMetal.set(_this21.context, 'htmlContent', '<b>Max</b>');
        _emberMetal.set(_this21.context, 'nested', { htmlContent: '<i>James</i>' });
      });

      this.assertContent('<b>Max</b><i>James</i>');
    };

    return _class6;
  })(TrustedContentTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Dynamic content tests (integration)', (function (_RenderingTest3) {
    babelHelpers.inherits(_class7, _RenderingTest3);

    function _class7() {
      _RenderingTest3.apply(this, arguments);
    }

    _class7.prototype['@test it can render a dynamic template'] = function testItCanRenderADynamicTemplate() {
      var _this22 = this;

      var template = '\n      <div class="header">\n        <h1>Welcome to {{framework}}</h1>\n      </div>\n      <div class="body">\n        <h2>Why you should use {{framework}}?</h2>\n        <ol>\n          <li>It\'s great</li>\n          <li>It\'s awesome</li>\n          <li>It\'s {{framework}}</li>\n        </ol>\n      </div>\n      <div class="footer">\n        {{framework}} is free, open source and always will be.\n      </div>\n    ';

      var ember = '\n      <div class="header">\n        <h1>Welcome to Ember.js</h1>\n      </div>\n      <div class="body">\n        <h2>Why you should use Ember.js?</h2>\n        <ol>\n          <li>It\'s great</li>\n          <li>It\'s awesome</li>\n          <li>It\'s Ember.js</li>\n        </ol>\n      </div>\n      <div class="footer">\n        Ember.js is free, open source and always will be.\n      </div>\n    ';

      var react = '\n      <div class="header">\n        <h1>Welcome to React</h1>\n      </div>\n      <div class="body">\n        <h2>Why you should use React?</h2>\n        <ol>\n          <li>It\'s great</li>\n          <li>It\'s awesome</li>\n          <li>It\'s React</li>\n        </ol>\n      </div>\n      <div class="footer">\n        React is free, open source and always will be.\n      </div>\n    ';

      this.render(template, {
        framework: 'Ember.js'
      });
      this.assertHTML(ember);

      this.runTask(function () {
        return _this22.rerender();
      });

      this.assertHTML(ember);

      this.runTask(function () {
        return _emberMetal.set(_this22.context, 'framework', 'React');
      });

      this.assertHTML(react);

      this.runTask(function () {
        return _emberMetal.set(_this22.context, 'framework', 'Ember.js');
      });

      this.assertHTML(ember);
    };

    _class7.prototype['@test it should evaluate to nothing if part of the path is `undefined`'] = function testItShouldEvaluateToNothingIfPartOfThePathIsUndefined() {
      var _this23 = this;

      this.render('{{foo.bar.baz.bizz}}', {
        foo: {}
      });

      this.assertText('');

      this.runTask(function () {
        return _this23.rerender();
      });

      this.assertText('');

      this.runTask(function () {
        return _emberMetal.set(_this23.context, 'foo', {
          bar: { baz: { bizz: 'Hey!' } }
        });
      });

      this.assertText('Hey!');

      this.runTask(function () {
        return _emberMetal.set(_this23.context, 'foo', {});
      });

      this.assertText('');

      this.runTask(function () {
        return _emberMetal.set(_this23.context, 'foo', {
          bar: { baz: { bizz: 'Hello!' } }
        });
      });

      this.assertText('Hello!');

      this.runTask(function () {
        return _emberMetal.set(_this23.context, 'foo', {});
      });

      this.assertText('');
    };

    _class7.prototype['@test it should evaluate to nothing if part of the path is a primative'] = function testItShouldEvaluateToNothingIfPartOfThePathIsAPrimative() {
      var _this24 = this;

      this.render('{{foo.bar.baz.bizz}}', {
        foo: { bar: true }
      });

      this.assertText('');

      this.runTask(function () {
        return _this24.rerender();
      });

      this.assertText('');

      this.runTask(function () {
        return _emberMetal.set(_this24.context, 'foo', {
          bar: false
        });
      });

      this.assertText('');

      this.runTask(function () {
        return _emberMetal.set(_this24.context, 'foo', {
          bar: 'Haha'
        });
      });

      this.assertText('');

      this.runTask(function () {
        return _emberMetal.set(_this24.context, 'foo', {
          bar: null
        });
      });

      this.assertText('');

      this.runTask(function () {
        return _emberMetal.set(_this24.context, 'foo', {
          bar: undefined
        });
      });

      this.assertText('');

      this.runTask(function () {
        return _emberMetal.set(_this24.context, 'foo', {
          bar: 1
        });
      });

      this.assertText('');

      this.runTask(function () {
        return _emberMetal.set(_this24.context, 'foo', {
          bar: { baz: { bizz: 'Hello!' } }
        });
      });

      this.assertText('Hello!');

      this.runTask(function () {
        return _emberMetal.set(_this24.context, 'foo', {
          bar: true
        });
      });

      this.assertText('');
    };

    _class7.prototype['@test can set dynamic href'] = function testCanSetDynamicHref() {
      var _this25 = this;

      this.render('<a href={{model.url}}>Example</a>', {
        model: {
          url: 'http://example.com'
        }
      });

      this.assertElement(this.firstChild, { tagName: 'a', content: 'Example', attrs: { 'href': 'http://example.com' } });

      this.runTask(function () {
        return _this25.rerender();
      });

      this.assertElement(this.firstChild, { tagName: 'a', content: 'Example', attrs: { 'href': 'http://example.com' } });

      this.runTask(function () {
        return _emberMetal.set(_this25.context, 'model.url', 'http://linkedin.com');
      });

      this.assertElement(this.firstChild, { tagName: 'a', content: 'Example', attrs: { 'href': 'http://linkedin.com' } });

      this.runTask(function () {
        return _emberMetal.set(_this25.context, 'model', { url: 'http://example.com' });
      });

      this.assertElement(this.firstChild, { tagName: 'a', content: 'Example', attrs: { 'href': 'http://example.com' } });
    };

    _class7.prototype['@test quoteless class attributes update correctly'] = function testQuotelessClassAttributesUpdateCorrectly() {
      var _this26 = this;

      this.render('<div class={{if fooBar "foo-bar"}}>hello</div>', {
        fooBar: true
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo-bar') } });

      this.runTask(function () {
        return _this26.rerender();
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo-bar') } });

      this.runTask(function () {
        return _emberMetal.set(_this26.context, 'fooBar', false);
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello' });

      this.runTask(function () {
        return _emberMetal.set(_this26.context, 'fooBar', true);
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo-bar') } });
    };

    _class7.prototype['@test quoted class attributes update correctly'] = function testQuotedClassAttributesUpdateCorrectly(assert) {
      var _this27 = this;

      this.render('<div class="{{if fooBar "foo-bar"}}">hello</div>', {
        fooBar: true
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo-bar') } });

      this.runTask(function () {
        return _this27.rerender();
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo-bar') } });

      this.runTask(function () {
        return _emberMetal.set(_this27.context, 'fooBar', false);
      });

      assert.equal(this.firstChild.className, '');

      this.runTask(function () {
        return _emberMetal.set(_this27.context, 'fooBar', true);
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo-bar') } });
    };

    _class7.prototype['@test unquoted class attribute can contain multiple classes'] = function testUnquotedClassAttributeCanContainMultipleClasses() {
      var _this28 = this;

      this.render('<div class={{model.classes}}>hello</div>', {
        model: {
          classes: 'foo bar baz'
        }
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo bar baz') } });

      this.runTask(function () {
        return _this28.rerender();
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo bar baz') } });

      this.runTask(function () {
        return _emberMetal.set(_this28.context, 'model.classes', 'fizz bizz');
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('fizz bizz') } });

      this.runTask(function () {
        return _emberMetal.set(_this28.context, 'model', { classes: 'foo bar baz' });
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo bar baz') } });
    };

    _class7.prototype['@test unquoted class attribute'] = function testUnquotedClassAttribute() {
      var _this29 = this;

      this.render('<div class={{model.foo}}>hello</div>', {
        model: {
          foo: 'foo'
        }
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo') } });

      this.runTask(function () {
        return _this29.rerender();
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo') } });

      this.runTask(function () {
        return _emberMetal.set(_this29.context, 'model.foo', 'fizz');
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('fizz') } });

      this.runTask(function () {
        return _emberMetal.set(_this29.context, 'model', { foo: 'foo' });
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo') } });
    };

    _class7.prototype['@test quoted class attribute'] = function testQuotedClassAttribute() {
      var _this30 = this;

      this.render('<div class="{{model.foo}}">hello</div>', {
        model: {
          foo: 'foo'
        }
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo') } });

      this.runTask(function () {
        return _this30.rerender();
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo') } });

      this.runTask(function () {
        return _emberMetal.set(_this30.context, 'model.foo', 'fizz');
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('fizz') } });

      this.runTask(function () {
        return _emberMetal.set(_this30.context, 'model', { foo: 'foo' });
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo') } });
    };

    _class7.prototype['@test quoted class attribute can contain multiple classes'] = function testQuotedClassAttributeCanContainMultipleClasses() {
      var _this31 = this;

      this.render('<div class="{{model.classes}}">hello</div>', {
        model: {
          classes: 'foo bar baz'
        }
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo bar baz') } });

      this.runTask(function () {
        return _this31.rerender();
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo bar baz') } });

      this.runTask(function () {
        return _emberMetal.set(_this31.context, 'model.classes', 'fizz bizz');
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('fizz bizz') } });

      this.runTask(function () {
        return _emberMetal.set(_this31.context, 'model', { classes: 'foo bar baz' });
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo bar baz') } });
    };

    _class7.prototype['@test class attribute concats bound values'] = function testClassAttributeConcatsBoundValues() {
      var _this32 = this;

      this.render('<div class="{{model.foo}} {{model.bar}} {{model.bizz}}">hello</div>', {
        model: {
          foo: 'foo',
          bar: 'bar',
          bizz: 'bizz'
        }
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo bar bizz') } });

      this.runTask(function () {
        return _this32.rerender();
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo bar bizz') } });

      this.runTask(function () {
        return _emberMetal.set(_this32.context, 'model.foo', 'fizz');
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('fizz bar bizz') } });

      this.runTask(function () {
        return _emberMetal.set(_this32.context, 'model.bar', null);
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('fizz bizz') } });

      this.runTask(function () {
        return _emberMetal.set(_this32.context, 'model', {
          foo: 'foo',
          bar: 'bar',
          bizz: 'bizz'
        });
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo bar bizz') } });
    };

    _class7.prototype['@test class attribute accepts nested helpers, and updates'] = function testClassAttributeAcceptsNestedHelpersAndUpdates() {
      var _this33 = this;

      this.render('<div class="{{if model.hasSize model.size}} {{if model.hasShape model.shape}}">hello</div>', {
        model: {
          size: 'large',
          hasSize: true,
          hasShape: false,
          shape: 'round'
        }
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('large') } });

      this.runTask(function () {
        return _this33.rerender();
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('large') } });

      this.runTask(function () {
        return _emberMetal.set(_this33.context, 'model.hasShape', true);
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('large round') } });

      this.runTask(function () {
        return _emberMetal.set(_this33.context, 'model.hasSize', false);
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('round') } });

      this.runTask(function () {
        return _emberMetal.set(_this33.context, 'model', {
          size: 'large',
          hasSize: true,
          hasShape: false,
          shape: 'round'
        });
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('large') } });
    };

    _class7.prototype['@test Multiple dynamic classes'] = function testMultipleDynamicClasses() {
      var _this34 = this;

      this.render('<div class="{{model.foo}} {{model.bar}} {{model.fizz}} {{model.baz}}">hello</div>', {
        model: {
          foo: 'foo',
          bar: 'bar',
          fizz: 'fizz',
          baz: 'baz'
        }
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo bar fizz baz') } });

      this.runTask(function () {
        return _this34.rerender();
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo bar fizz baz') } });

      this.runTask(function () {
        _emberMetal.set(_this34.context, 'model.foo', null);
        _emberMetal.set(_this34.context, 'model.fizz', null);
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('bar baz') } });

      this.runTask(function () {
        _emberMetal.set(_this34.context, 'model', {
          foo: 'foo',
          bar: 'bar',
          fizz: 'fizz',
          baz: 'baz'
        });
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': _emberGlimmerTestsUtilsTestHelpers.classes('foo bar fizz baz') } });
    };

    _class7.prototype['@test classes are ordered: See issue #9912'] = function testClassesAreOrderedSeeIssue9912() {
      var _this35 = this;

      this.render('<div class="{{model.foo}}  static   {{model.bar}}">hello</div>', {
        model: {
          foo: 'foo',
          bar: 'bar'
        }
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': 'foo  static   bar' } });

      this.runTask(function () {
        return _this35.rerender();
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': 'foo  static   bar' } });

      this.runTask(function () {
        _emberMetal.set(_this35.context, 'model.bar', null);
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': 'foo  static   ' } });

      this.runTask(function () {
        _emberMetal.set(_this35.context, 'model', {
          foo: 'foo',
          bar: 'bar'
        });
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: 'hello', attrs: { 'class': 'foo  static   bar' } });
    };

    return _class7;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));

  var warnings = undefined,
      originalWarn = undefined;

  var StyleTest = (function (_RenderingTest4) {
    babelHelpers.inherits(StyleTest, _RenderingTest4);

    function StyleTest() {
      _RenderingTest4.apply(this, arguments);
      warnings = [];
      originalWarn = _emberMetal.getDebugFunction('warn');
      _emberMetal.setDebugFunction('warn', function (message, test) {
        if (!test) {
          warnings.push(message);
        }
      });
    }

    StyleTest.prototype.teardown = function teardown() {
      var _RenderingTest4$prototype$teardown;

      (_RenderingTest4$prototype$teardown = _RenderingTest4.prototype.teardown).call.apply(_RenderingTest4$prototype$teardown, [this].concat(babelHelpers.slice.call(arguments)));
      _emberMetal.setDebugFunction('warn', originalWarn);
    };

    StyleTest.prototype.assertStyleWarning = function assertStyleWarning() {
      this.assert.deepEqual(warnings, [_emberViews.STYLE_WARNING]);
    };

    StyleTest.prototype.assertNoWarning = function assertNoWarning() {
      this.assert.deepEqual(warnings, []);
    };

    return StyleTest;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest);

  _emberGlimmerTestsUtilsTestCase.moduleFor('Inline style tests', (function (_StyleTest) {
    babelHelpers.inherits(_class8, _StyleTest);

    function _class8() {
      _StyleTest.apply(this, arguments);
    }

    _class8.prototype['@test can set dynamic style'] = function testCanSetDynamicStyle() {
      var _this36 = this;

      this.render('<div style={{model.style}}></div>', {
        model: {
          style: 'width: 60px;'
        }
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: '', attrs: { 'style': 'width: 60px;' } });

      this.runTask(function () {
        return _this36.rerender();
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: '', attrs: { 'style': 'width: 60px;' } });

      this.runTask(function () {
        return _emberMetal.set(_this36.context, 'model.style', 'height: 60px;');
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: '', attrs: { 'style': 'height: 60px;' } });

      this.runTask(function () {
        return _emberMetal.set(_this36.context, 'model.style', null);
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: '', attrs: {} });

      this.runTask(function () {
        return _emberMetal.set(_this36.context, 'model', { style: 'width: 60px;' });
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: '', attrs: { 'style': 'width: 60px;' } });
    };

    _class8.prototype['@test can set dynamic style with -html-safe'] = function testCanSetDynamicStyleWithHtmlSafe() {
      var _this37 = this;

      this.render('<div style={{-html-safe model.style}}></div>', {
        model: {
          style: 'width: 60px;'
        }
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: '', attrs: { 'style': 'width: 60px;' } });

      this.runTask(function () {
        return _this37.rerender();
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: '', attrs: { 'style': 'width: 60px;' } });

      this.runTask(function () {
        return _emberMetal.set(_this37.context, 'model.style', 'height: 60px;');
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: '', attrs: { 'style': 'height: 60px;' } });

      this.runTask(function () {
        return _emberMetal.set(_this37.context, 'model', { style: 'width: 60px;' });
      });

      this.assertElement(this.firstChild, { tagName: 'div', content: '', attrs: { 'style': 'width: 60px;' } });
    };

    return _class8;
  })(StyleTest));

  if (!EmberDev.runningProdBuild) {
    _emberGlimmerTestsUtilsTestCase.moduleFor('Inline style tests - warnings', (function (_StyleTest2) {
      babelHelpers.inherits(_class9, _StyleTest2);

      function _class9() {
        _StyleTest2.apply(this, arguments);
      }

      _class9.prototype['@test specifying <div style={{userValue}}></div> generates a warning'] = function testSpecifyingDivStyleUserValueDivGeneratesAWarning(assert) {
        this.render('<div style={{userValue}}></div>', {
          userValue: 'width: 42px'
        });

        this.assertStyleWarning();
      };

      _class9.prototype['@test specifying `attributeBindings: ["style"]` generates a warning'] = function testSpecifyingAttributeBindingsStyleGeneratesAWarning(assert) {
        var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
          attributeBindings: ['style']
        });

        this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: 'hello' });

        this.render('{{foo-bar style=userValue}}', {
          userValue: 'width: 42px'
        });

        this.assertStyleWarning();
      };

      _class9.prototype['@test specifying `<div style={{{userValue}}}></div>` works properly without a warning'] = function testSpecifyingDivStyleUserValueDivWorksProperlyWithoutAWarning(assert) {
        this.render('<div style={{{userValue}}}></div>', {
          userValue: 'width: 42px'
        });

        this.assertNoWarning();
      };

      _class9.prototype['@test specifying `<div style={{userValue}}></div>` works properly with a SafeString'] = function testSpecifyingDivStyleUserValueDivWorksProperlyWithASafeString(assert) {
        this.render('<div style={{userValue}}></div>', {
          userValue: new _emberGlimmerTestsUtilsHelpers.SafeString('width: 42px')
        });

        this.assertNoWarning();
      };

      _class9.prototype['@test null value do not generate htmlsafe warning'] = function testNullValueDoNotGenerateHtmlsafeWarning(assert) {
        this.render('<div style={{userValue}}></div>', {
          userValue: null
        });

        this.assertNoWarning();
      };

      _class9.prototype['@test undefined value do not generate htmlsafe warning'] = function testUndefinedValueDoNotGenerateHtmlsafeWarning(assert) {
        this.render('<div style={{userValue}}></div>');

        this.assertNoWarning();
      };

      _class9.prototype['@test no warnings are triggered when using `-html-safe`'] = function testNoWarningsAreTriggeredWhenUsingHtmlSafe(assert) {
        this.render('<div style={{-html-safe userValue}}></div>', {
          userValue: 'width: 42px'
        });

        this.assertNoWarning();
      };

      _class9.prototype['@test no warnings are triggered when a safe string is quoted'] = function testNoWarningsAreTriggeredWhenASafeStringIsQuoted(assert) {
        this.render('<div style="{{userValue}}"></div>', {
          userValue: new _emberGlimmerTestsUtilsHelpers.SafeString('width: 42px')
        });

        this.assertNoWarning();
      };

      _class9.prototype['@test binding warning is triggered when an unsafe string is quoted'] = function testBindingWarningIsTriggeredWhenAnUnsafeStringIsQuoted(assert) {
        this.render('<div style="{{userValue}}"></div>', {
          userValue: 'width: 42px'
        });

        this.assertStyleWarning();
      };

      _class9.prototype['@test binding warning is triggered when a safe string for a complete property is concatenated in place'] = function testBindingWarningIsTriggeredWhenASafeStringForACompletePropertyIsConcatenatedInPlace(assert) {
        this.render('<div style="color: green; {{userValue}}"></div>', {
          userValue: new _emberGlimmerTestsUtilsHelpers.SafeString('width: 42px')
        });

        this.assertStyleWarning();
      };

      _class9.prototype['@test binding warning is triggered when a safe string for a value is concatenated in place'] = function testBindingWarningIsTriggeredWhenASafeStringForAValueIsConcatenatedInPlace(assert) {
        this.render('<div style="color: green; width: {{userValue}}"></div>', {
          userValue: new _emberGlimmerTestsUtilsHelpers.SafeString('42px')
        });

        this.assertStyleWarning();
      };

      _class9.prototype['@test binding warning is triggered when a safe string for a property name is concatenated in place'] = function testBindingWarningIsTriggeredWhenASafeStringForAPropertyNameIsConcatenatedInPlace(assert) {
        this.render('<div style="color: green; {{userProperty}}: 42px"></div>', {
          userProperty: new _emberGlimmerTestsUtilsHelpers.SafeString('width')
        });

        this.assertStyleWarning();
      };

      return _class9;
    })(StyleTest));
  }
});
enifed('ember-glimmer/tests/integration/content-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/content-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/content-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/event-dispatcher-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/helpers', 'ember-metal'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsHelpers, _emberMetal) {
  'use strict';

  var canDataTransfer = !!document.createEvent('HTMLEvents').dataTransfer;

  function fireNativeWithDataTransfer(node, type, dataTransfer) {
    var event = document.createEvent('HTMLEvents');
    event.initEvent(type, true, true);
    event.dataTransfer = dataTransfer;
    node.dispatchEvent(event);
  }

  _emberGlimmerTestsUtilsTestCase.moduleFor('EventDispatcher', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test events bubble view hierarchy for form elements'] = function testEventsBubbleViewHierarchyForFormElements(assert) {
      var _this = this;

      var receivedEvent = undefined;

      this.registerComponent('x-foo', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          change: function (event) {
            receivedEvent = event;
          }
        }),
        template: '<input id="is-done" type="checkbox">'
      });

      this.render('{{x-foo}}');

      this.runTask(function () {
        return _this.$('#is-done').trigger('change');
      });
      assert.ok(receivedEvent, 'change event was triggered');
      assert.strictEqual(receivedEvent.target, this.$('#is-done')[0]);
    };

    _class.prototype['@test dispatches to the nearest event manager'] = function testDispatchesToTheNearestEventManager(assert) {
      var _this2 = this;

      var receivedEvent = undefined;

      this.registerComponent('x-foo', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          click: function (event) {
            assert.notOk(true, 'should not trigger `click` on component');
          },

          eventManager: {
            click: function (event) {
              receivedEvent = event;
            }
          }
        }),

        template: '<input id="is-done" type="checkbox">'
      });

      this.render('{{x-foo}}');

      this.runTask(function () {
        return _this2.$('#is-done').trigger('click');
      });
      assert.strictEqual(receivedEvent.target, this.$('#is-done')[0]);
    };

    _class.prototype['@test event manager can re-dispatch to the component'] = function testEventManagerCanReDispatchToTheComponent(assert) {
      var _this3 = this;

      var handlers = [];

      this.registerComponent('x-foo', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          click: function () {
            handlers.push('component');
          },

          eventManager: {
            click: function (event, component) {
              handlers.push('eventManager');
              // Re-dispatch event when you get it.
              //
              // The second parameter tells the dispatcher
              // that this event has been handled. This
              // API will clearly need to be reworked since
              // multiple eventManagers in a single view
              // hierarchy would break, but it shows that
              // re-dispatching works
              component.$().trigger('click', this);
            }
          }
        }),

        template: '<input id="is-done" type="checkbox">'
      });

      this.render('{{x-foo}}');

      this.runTask(function () {
        return _this3.$('#is-done').trigger('click');
      });
      assert.deepEqual(handlers, ['eventManager', 'component']);
    };

    _class.prototype['@test event handlers are wrapped in a run loop'] = function testEventHandlersAreWrappedInARunLoop(assert) {
      this.registerComponent('x-foo', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          change: function () {
            assert.ok(_emberMetal.run.currentRunLoop, 'a run loop should have started');
          }
        }),
        template: '<input id="is-done" type="checkbox">'
      });

      this.render('{{x-foo}}');

      this.$('#is-done').trigger('click');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('EventDispatcher#setup', (function (_RenderingTest2) {
    babelHelpers.inherits(_class2, _RenderingTest2);

    function _class2() {
      _RenderingTest2.call(this);

      var dispatcher = this.owner.lookup('event_dispatcher:main');
      _emberMetal.run(dispatcher, 'destroy');
      this.owner.__container__.reset('event_dispatcher:main');
      this.dispatcher = this.owner.lookup('event_dispatcher:main');
    }

    _class2.prototype['@test additonal events can be specified'] = function testAdditonalEventsCanBeSpecified(assert) {
      this.dispatcher.setup({ myevent: 'myEvent' });

      this.registerComponent('x-foo', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          myEvent: function () {
            assert.ok(true, 'custom event was triggered');
          }
        }),
        template: '<p>Hello!</p>'
      });

      this.render('{{x-foo}}');

      this.$('div').trigger('myevent');
    };

    _class2.prototype['@test a rootElement can be specified'] = function testARootElementCanBeSpecified(assert) {
      this.$().append('<div id="app"></div>');
      this.dispatcher.setup({ myevent: 'myEvent' }, '#app');

      assert.ok(this.$('#app').hasClass('ember-application'), 'custom rootElement was used');
      assert.equal(this.dispatcher.rootElement, '#app', 'the dispatchers rootElement was updated');
    };

    _class2.prototype['@test default events can be disabled via `customEvents`'] = function testDefaultEventsCanBeDisabledViaCustomEvents(assert) {
      this.dispatcher.setup({ click: null });

      this.registerComponent('x-foo', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          click: function () {
            assert.ok(false, 'click method was called');
          },

          null: function () {
            assert.ok(false, 'null method was called');
          },

          doubleClick: function () {
            assert.ok(true, 'a non-disabled event is still handled properly');
          }
        }),

        template: '<p>Hello!</p>'
      });

      this.render('{{x-foo}}');

      this.$('div').trigger('click');
      this.$('div').trigger('dblclick');
    };

    _class2.prototype['@test throws if specified rootElement does not exist'] = function testThrowsIfSpecifiedRootElementDoesNotExist(assert) {
      var _this4 = this;

      assert.throws(function () {
        _this4.dispatcher.setup({ myevent: 'myEvent' }, '#app');
      });
    };

    return _class2;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));

  if (_emberMetal.isFeatureEnabled('ember-improved-instrumentation')) {
    _emberGlimmerTestsUtilsTestCase.moduleFor('EventDispatcher - Instrumentation', (function (_RenderingTest3) {
      babelHelpers.inherits(_class3, _RenderingTest3);

      function _class3() {
        _RenderingTest3.apply(this, arguments);
      }

      _class3.prototype.teardown = function teardown() {
        _RenderingTest3.prototype.teardown.call(this);
        _emberMetal.instrumentationReset();
      };

      _class3.prototype['@test instruments triggered events'] = function testInstrumentsTriggeredEvents(assert) {
        var clicked = 0;

        this.registerComponent('x-foo', {
          ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
            click: function (evt) {
              clicked++;
            }
          }),
          template: '<p>hello</p>'
        });

        this.render('{{x-foo}}');

        this.$('div').trigger('click');

        assert.equal(clicked, 1, 'precond - the click handler was invoked');

        var clickInstrumented = 0;
        _emberMetal.instrumentationSubscribe('interaction.click', {
          before: function () {
            clickInstrumented++;
            assert.equal(clicked, 1, 'invoked before event is handled');
          },
          after: function () {
            clickInstrumented++;
            assert.equal(clicked, 2, 'invoked after event is handled');
          }
        });

        var keypressInstrumented = 0;
        _emberMetal.instrumentationSubscribe('interaction.keypress', {
          before: function () {
            keypressInstrumented++;
          },
          after: function () {
            keypressInstrumented++;
          }
        });

        this.$('div').trigger('click');
        this.$('div').trigger('change');
        assert.equal(clicked, 2, 'precond - The click handler was invoked');
        assert.equal(clickInstrumented, 2, 'The click was instrumented');
        assert.strictEqual(keypressInstrumented, 0, 'The keypress was not instrumented');
      };

      return _class3;
    })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
  }

  if (canDataTransfer) {
    _emberGlimmerTestsUtilsTestCase.moduleFor('EventDispatcher - Event Properties', (function (_RenderingTest4) {
      babelHelpers.inherits(_class4, _RenderingTest4);

      function _class4() {
        _RenderingTest4.apply(this, arguments);
      }

      _class4.prototype['@test dataTransfer property is added to drop event'] = function testDataTransferPropertyIsAddedToDropEvent(assert) {
        var receivedEvent = undefined;
        this.registerComponent('x-foo', {
          ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
            drop: function (event) {
              receivedEvent = event;
            }
          })
        });

        this.render('{{x-foo}}');

        fireNativeWithDataTransfer(this.$('div')[0], 'drop', 'success');
        assert.equal(receivedEvent.dataTransfer, 'success');
      };

      return _class4;
    })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
  }
});
enifed('ember-glimmer/tests/integration/event-dispatcher-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/event-dispatcher-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/event-dispatcher-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/helpers/-class-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/test-helpers', 'ember-metal'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsTestHelpers, _emberMetal) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: {{-class}}', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test casts binding to dasherized class'] = function testCastsBindingToDasherizedClass() {
      var _this = this;

      this.registerComponent('foo-bar', { template: '' });
      this.render('{{foo-bar class=(-class someTruth "someTruth")}}', {
        someTruth: true
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { class: _emberGlimmerTestsUtilsTestHelpers.classes('some-truth ember-view') } });

      this.runTask(function () {
        return _this.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { class: _emberGlimmerTestsUtilsTestHelpers.classes('some-truth ember-view') } });

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'someTruth', false);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { class: _emberGlimmerTestsUtilsTestHelpers.classes('ember-view') } });

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'someTruth', true);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { class: _emberGlimmerTestsUtilsTestHelpers.classes('some-truth ember-view') } });
    };

    _class.prototype['@tests casts leaf path of binding to dasherized class'] = function testsCastsLeafPathOfBindingToDasherizedClass() {
      var _this2 = this;

      this.registerComponent('foo-bar', { template: '' });
      this.render('{{foo-bar class=(-class model.someTruth "someTruth")}}', {
        model: {
          someTruth: true
        }
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { class: _emberGlimmerTestsUtilsTestHelpers.classes('some-truth ember-view') } });

      this.runTask(function () {
        return _this2.rerender();
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { class: _emberGlimmerTestsUtilsTestHelpers.classes('some-truth ember-view') } });

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'model.someTruth', false);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { class: _emberGlimmerTestsUtilsTestHelpers.classes('ember-view') } });

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'model', { someTruth: true });
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { class: _emberGlimmerTestsUtilsTestHelpers.classes('some-truth ember-view') } });
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/helpers/-class-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/helpers/-class-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/helpers/-class-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/helpers/closure-action-test', ['exports', 'ember-metal', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/abstract-test-case', 'ember-glimmer/tests/utils/helpers'], function (exports, _emberMetal, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsAbstractTestCase, _emberGlimmerTestsUtilsHelpers) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n        <div id="counter">clicked: {{clicked}}; foo: {{foo}}</div>\n\n        {{click-me id="string-action" onClick=(action "on-click")}}\n        {{click-me id="function-action" onClick=(action onClick)}}\n        {{click-me id="mut-action" onClick=(action (mut clicked))}}\n      '], ['\n        <div id="counter">clicked: {{clicked}}; foo: {{foo}}</div>\n\n        {{click-me id="string-action" onClick=(action "on-click")}}\n        {{click-me id="function-action" onClick=(action onClick)}}\n        {{click-me id="mut-action" onClick=(action (mut clicked))}}\n      ']);

  if (_emberMetal.isFeatureEnabled('ember-improved-instrumentation')) {
    _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: closure {{action}} improved instrumentation', (function (_RenderingTest) {
babelHelpers.inherits(_class, _RenderingTest);

      function _class() {
        _RenderingTest.apply(this, arguments);
      }

      _class.prototype.subscribe = function subscribe(eventName, options) {
        this.subscriber = _emberMetal.instrumentationSubscribe(eventName, options);
      };

      _class.prototype.teardown = function teardown() {
        if (this.subscriber) {
          _emberMetal.instrumentationUnsubscribe(this.subscriber);
        }

        _RenderingTest.prototype.teardown.call(this);
      };

      _class.prototype['@test interaction event subscriber should be passed parameters'] = function testInteractionEventSubscriberShouldBePassedParameters() {
        var _this = this;

        var actionParam = 'So krispy';
        var beforeParameters = [];
        var afterParameters = [];

        var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
          actions: {
            fireAction: function () {
              this.attrs.submit(actionParam);
            }
          }
        });

        var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
          outerSubmit: function () {}
        });

        this.registerComponent('inner-component', {
          ComponentClass: InnerComponent,
          template: '<button id="instrument-button" {{action "fireAction"}}>What it do</button>'
        });

        this.registerComponent('outer-component', {
          ComponentClass: OuterComponent,
          template: '{{inner-component submit=(action outerSubmit)}}'
        });

        this.subscribe('interaction.ember-action', {
          before: function (name, timestamp, payload) {
            beforeParameters.push(payload.args);
          },
          after: function (name, timestamp, payload) {
            afterParameters.push(payload.args);
          }
        });

        this.render('{{outer-component}}');

        this.runTask(function () {
          _this.$('#instrument-button').trigger('click');
        });

        this.assert.deepEqual(beforeParameters, [[], [actionParam]], 'instrumentation subscriber before function was passed closure action parameters');
        this.assert.deepEqual(afterParameters, [[actionParam], []], 'instrumentation subscriber after function was passed closure action parameters');
      };

      _class.prototype['@test interaction event subscriber should be passed target'] = function testInteractionEventSubscriberShouldBePassedTarget() {
        var _this2 = this;

        var beforeParameters = [];
        var afterParameters = [];

        var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
          myProperty: 'inner-thing',
          actions: {
            fireAction: function () {
              this.attrs.submit();
            }
          }
        });

        var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
          myProperty: 'outer-thing',
          outerSubmit: function () {}
        });

        this.registerComponent('inner-component', {
          ComponentClass: InnerComponent,
          template: '<button id="instrument-button" {{action "fireAction"}}>What it do</button>'
        });

        this.registerComponent('outer-component', {
          ComponentClass: OuterComponent,
          template: '{{inner-component submit=(action outerSubmit)}}'
        });

        this.subscribe('interaction.ember-action', {
          before: function (name, timestamp, payload) {
            beforeParameters.push(payload.target.get('myProperty'));
          },
          after: function (name, timestamp, payload) {
            afterParameters.push(payload.target.get('myProperty'));
          }
        });

        this.render('{{outer-component}}');

        this.runTask(function () {
          _this2.$('#instrument-button').trigger('click');
        });

        this.assert.deepEqual(beforeParameters, ['inner-thing', 'outer-thing'], 'instrumentation subscriber before function was passed target');
        this.assert.deepEqual(afterParameters, ['outer-thing', 'inner-thing'], 'instrumentation subscriber after function was passed target');
      };

      _class.prototype['@test instrumented action should return value'] = function testInstrumentedActionShouldReturnValue() {
        var _this3 = this;

        var returnedValue = 'Chris P is so krispy';
        var actualReturnedValue = undefined;

        var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
          actions: {
            fireAction: function () {
              actualReturnedValue = this.attrs.submit();
            }
          }
        });

        var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
          outerSubmit: function () {
            return returnedValue;
          }
        });

        this.registerComponent('inner-component', {
          ComponentClass: InnerComponent,
          template: '<button id="instrument-button" {{action "fireAction"}}>What it do</button>'
        });

        this.registerComponent('outer-component', {
          ComponentClass: OuterComponent,
          template: '{{inner-component submit=(action outerSubmit)}}'
        });

        this.subscribe('interaction.ember-action', {
          before: function (name, timestamp, payload) {},
          after: function (name, timestamp, payload) {}
        });

        this.render('{{outer-component}}');

        this.runTask(function () {
          _this3.$('#instrument-button').trigger('click');
        });

        this.assert.equal(actualReturnedValue, returnedValue, 'action can return to caller');
      };

      return _class;
    })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
  }

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: closure {{action}}', (function (_RenderingTest2) {
babelHelpers.inherits(_class2, _RenderingTest2);

    function _class2() {
      _RenderingTest2.apply(this, arguments);
    }

    _class2.prototype['@test action should be called'] = function testActionShouldBeCalled() {
      var outerActionCalled = false;
      var component = undefined;

      var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        },
        fireAction: function () {
          this.attrs.submit();
        }
      });

      var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        outerSubmit: function () {
          outerActionCalled = true;
        }
      });

      this.registerComponent('inner-component', { ComponentClass: InnerComponent, template: 'inner' });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action outerSubmit)}}'
      });

      this.render('{{outer-component}}');

      this.runTask(function () {
        component.fireAction();
      });

      this.assert.ok(outerActionCalled, 'the action was called');
    };

    _class2.prototype['@test an error is triggered when bound action function is undefined'] = function testAnErrorIsTriggeredWhenBoundActionFunctionIsUndefined() {
      var _this4 = this;

      this.registerComponent('inner-component', {
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        template: '{{inner-component submit=(action somethingThatIsUndefined)}}'
      });

      expectAssertion(function () {
        _this4.render('{{outer-component}}');
      }, /Action passed is null or undefined in \(action[^)]*\) from .*\./);
    };

    _class2.prototype['@test an error is triggered when bound action being passed in is a non-function'] = function testAnErrorIsTriggeredWhenBoundActionBeingPassedInIsANonFunction() {
      var _this5 = this;

      this.registerComponent('inner-component', {
        template: 'inner'
      });
      this.registerComponent('outer-component', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          nonFunctionThing: {}
        }),
        template: '{{inner-component submit=(action nonFunctionThing)}}'
      });

      expectAssertion(function () {
        _this5.render('{{outer-component}}');
      }, /An action could not be made for `.*` in .*\. Please confirm that you are using either a quoted action name \(i\.e\. `\(action '.*'\)`\) or a function available in .*\./);
    };

    _class2.prototype['@test [#12718] a nice error is shown when a bound action function is undefined and it is passed as attrs.foo'] = function test12718ANiceErrorIsShownWhenABoundActionFunctionIsUndefinedAndItIsPassedAsAttrsFoo() {
      var _this6 = this;

      this.registerComponent('inner-component', {
        template: '<button id="inner-button" {{action (action attrs.external-action)}}>Click me</button>'
      });

      this.registerComponent('outer-component', {
        template: '{{inner-component}}'
      });

      expectAssertion(function () {
        _this6.render('{{outer-component}}');
      }, /Action passed is null or undefined in \(action[^)]*\) from .*\./);
    };

    _class2.prototype['@test action value is returned'] = function testActionValueIsReturned() {
      var expectedValue = 'terrible tom';
      var returnedValue = undefined;
      var innerComponent = undefined;

      var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          innerComponent = this;
        },
        fireAction: function () {
          returnedValue = this.attrs.submit();
        }
      });

      var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        outerSubmit: function () {
          return expectedValue;
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });

      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action outerSubmit)}}'
      });

      this.render('{{outer-component}}');

      this.runTask(function () {
        innerComponent.fireAction();
      });

      this.assert.equal(returnedValue, expectedValue, 'action can return to caller');
    };

    _class2.prototype['@test action should be called on the correct scope'] = function testActionShouldBeCalledOnTheCorrectScope() {
      var innerComponent = undefined;
      var outerComponent = undefined;
      var actualComponent = undefined;

      var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit();
        }
      });

      var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          outerComponent = this;
        },
        isOuterComponent: true,
        outerSubmit: function () {
          actualComponent = this;
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });

      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action outerSubmit)}}'
      });

      this.render('{{outer-component}}');

      this.runTask(function () {
        innerComponent.fireAction();
      });

      this.assert.equal(actualComponent, outerComponent, 'action has the correct context');
      this.assert.ok(actualComponent.isOuterComponent, 'action has the correct context');
    };

    _class2.prototype['@test arguments to action are passed, curry'] = function testArgumentsToActionArePassedCurry() {
      var first = 'mitch';
      var second = 'martin';
      var third = 'matt';
      var fourth = 'wacky wycats';

      var innerComponent = undefined;
      var actualArgs = undefined;

      var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit(fourth);
        }
      });

      var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        third: third,
        outerSubmit: function (actualFirst, actualSecond, actualThird, actualFourth) {
          actualArgs = [].concat(babelHelpers.slice.call(arguments));
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });

      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action (action outerSubmit "' + first + '") "' + second + '" third)}}'
      });

      this.render('{{outer-component}}');

      this.runTask(function () {
        innerComponent.fireAction();
      });

      this.assert.deepEqual(actualArgs, [first, second, third, fourth], 'action has the correct args');
    };

    _class2.prototype['@test `this` can be passed as an argument'] = function testThisCanBePassedAsAnArgument() {
      var value = {};
      var component = undefined;
      var innerComponent = undefined;

      var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit();
        }
      });

      var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        },
        actions: {
          outerAction: function (incomingValue) {
            value = incomingValue;
          }
        }
      });

      this.registerComponent('inner-component', { ComponentClass: InnerComponent, template: 'inner' });
      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action "outerAction" this)}}'
      });

      this.render('{{outer-component}}');

      this.runTask(function () {
        innerComponent.fireAction();
      });

      this.assert.strictEqual(value, component, 'the component is passed at `this`');
    };

    _class2.prototype['@test arguments to action are bound'] = function testArgumentsToActionAreBound() {
      var value = 'lazy leah';

      var innerComponent = undefined;
      var outerComponent = undefined;
      var actualArg = undefined;

      var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit();
        }
      });

      var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          outerComponent = this;
        },
        value: '',
        outerSubmit: function (incomingValue) {
          actualArg = incomingValue;
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });

      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action outerSubmit value)}}'
      });

      this.render('{{outer-component}}');

      this.runTask(function () {
        innerComponent.fireAction();
      });

      this.assert.strictEqual(actualArg, '', 'action has the correct first arg');

      this.runTask(function () {
        outerComponent.set('value', value);
      });

      this.runTask(function () {
        innerComponent.fireAction();
      });

      this.assert.strictEqual(actualArg, value, 'action has the correct first arg');
    };

    _class2.prototype['@test array arguments are passed correctly to action'] = function testArrayArgumentsArePassedCorrectlyToAction() {
      var first = 'foo';
      var second = [3, 5];
      var third = [4, 9];

      var actualFirst = undefined;
      var actualSecond = undefined;
      var actualThird = undefined;

      var innerComponent = undefined;
      var outerComponent = undefined;

      var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit(second, third);
        }
      });

      var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          outerComponent = this;
        },
        outerSubmit: function (incomingFirst, incomingSecond, incomingThird) {
          actualFirst = incomingFirst;
          actualSecond = incomingSecond;
          actualThird = incomingThird;
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });

      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action outerSubmit first)}}'
      });

      this.render('{{outer-component}}');

      this.runTask(function () {
        outerComponent.set('first', first);
        outerComponent.set('second', second);
      });

      this.runTask(function () {
        innerComponent.fireAction();
      });

      this.assert.equal(actualFirst, first, 'action has the correct first arg');
      this.assert.equal(actualSecond, second, 'action has the correct second arg');
      this.assert.equal(actualThird, third, 'action has the correct third arg');
    };

    _class2.prototype['@test mut values can be wrapped in actions, are settable'] = function testMutValuesCanBeWrappedInActionsAreSettable() {
      var newValue = 'trollin trek';

      var innerComponent = undefined;
      var outerComponent = undefined;

      var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit(newValue);
        }
      });

      var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          outerComponent = this;
        },
        outerMut: 'patient peter'
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });

      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action (mut outerMut))}}'
      });

      this.render('{{outer-component}}');

      this.runTask(function () {
        innerComponent.fireAction();
      });

      this.assert.equal(outerComponent.get('outerMut'), newValue, 'mut value is set');
    };

    _class2.prototype['@test mut values can be wrapped in actions, are settable with a curry'] = function testMutValuesCanBeWrappedInActionsAreSettableWithACurry() {
      var newValue = 'trollin trek';

      var innerComponent = undefined;
      var outerComponent = undefined;

      var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit();
        }
      });

      var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          outerComponent = this;
        },
        outerMut: 'patient peter'
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });

      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action (mut outerMut) \'' + newValue + '\')}}'
      });

      this.render('{{outer-component}}');

      this.runTask(function () {
        innerComponent.fireAction();
      });

      this.assert.equal(outerComponent.get('outerMut'), newValue, 'mut value is set');
    };

    _class2.prototype['@test action can create closures over actions'] = function testActionCanCreateClosuresOverActions() {
      var first = 'raging robert';
      var second = 'mild machty';
      var returnValue = 'butch brian';

      var actualFirst = undefined;
      var actualSecond = undefined;
      var actualReturnedValue = undefined;

      var innerComponent = undefined;

      var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          innerComponent = this;
        },
        fireAction: function () {
          actualReturnedValue = this.attrs.submit(second);
        }
      });

      var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          outerAction: function (incomingFirst, incomingSecond) {
            actualFirst = incomingFirst;
            actualSecond = incomingSecond;
            return returnValue;
          }
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });

      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action \'outerAction\' \'' + first + '\')}}'
      });

      this.render('{{outer-component}}');

      this.runTask(function () {
        innerComponent.fireAction();
      });

      this.assert.equal(actualReturnedValue, returnValue, 'return value is present');
      this.assert.equal(actualFirst, first, 'first argument is correct');
      this.assert.equal(actualSecond, second, 'second argument is correct');
    };

    _class2.prototype['@test provides a helpful error if an action is not present'] = function testProvidesAHelpfulErrorIfAnActionIsNotPresent() {
      var _this7 = this;

      var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({});

      var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          something: function () {
            // this is present to ensure `actions` hash is present
            // a different error is triggered if `actions` is missing
            // completely
          }
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });

      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action \'doesNotExist\')}}'
      });

      expectAssertion(function () {
        _this7.render('{{outer-component}}');
      }, /An action named 'doesNotExist' was not found in /);
    };

    _class2.prototype['@test provides a helpful error if actions hash is not present'] = function testProvidesAHelpfulErrorIfActionsHashIsNotPresent() {
      var _this8 = this;

      var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({});

      var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({});

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });

      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action \'doesNotExist\')}}'
      });

      expectAssertion(function () {
        _this8.render('{{outer-component}}');
      }, /An action named 'doesNotExist' was not found in /);
    };

    _class2.prototype['@test action can create closures over actions with target'] = function testActionCanCreateClosuresOverActionsWithTarget() {
      var innerComponent = undefined;
      var actionCalled = false;

      var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit();
        }
      });

      var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        otherComponent: _emberMetal.computed(function () {
          return {
            actions: {
              outerAction: function () {
                actionCalled = true;
              }
            }
          };
        })
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });

      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action \'outerAction\' target=otherComponent)}}'
      });

      this.render('{{outer-component}}');

      this.runTask(function () {
        innerComponent.fireAction();
      });

      this.assert.ok(actionCalled, 'action called on otherComponent');
    };

    _class2.prototype['@test value can be used with action over actions'] = function testValueCanBeUsedWithActionOverActions() {
      var newValue = 'yelping yehuda';

      var innerComponent = undefined;
      var actualValue = undefined;

      var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit({
            readProp: newValue
          });
        }
      });

      var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        outerContent: {
          readProp: newValue
        },
        actions: {
          outerAction: function (incomingValue) {
            actualValue = incomingValue;
          }
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });

      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action \'outerAction\' value="readProp")}}'
      });

      this.render('{{outer-component}}');

      this.runTask(function () {
        innerComponent.fireAction();
      });

      this.assert.equal(actualValue, newValue, 'value is read');
    };

    _class2.prototype['@test action will read the value of a first property'] = function testActionWillReadTheValueOfAFirstProperty() {
      var newValue = 'irate igor';

      var innerComponent = undefined;
      var actualValue = undefined;

      var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit({
            readProp: newValue
          });
        }
      });

      var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        outerAction: function (incomingValue) {
          actualValue = incomingValue;
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });

      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action outerAction value="readProp")}}'
      });

      this.render('{{outer-component}}');

      this.runTask(function () {
        innerComponent.fireAction();
      });

      this.assert.equal(actualValue, newValue, 'property is read');
    };

    _class2.prototype['@test action will read the value of a curried first argument property'] = function testActionWillReadTheValueOfACurriedFirstArgumentProperty() {
      var newValue = 'kissing kris';

      var innerComponent = undefined;
      var actualValue = undefined;

      var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit();
        }
      });

      var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        objectArgument: {
          readProp: newValue
        },
        outerAction: function (incomingValue) {
          actualValue = incomingValue;
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });

      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action outerAction objectArgument value="readProp")}}'
      });

      this.render('{{outer-component}}');

      this.runTask(function () {
        innerComponent.fireAction();
      });

      this.assert.equal(actualValue, newValue, 'property is read');
    };

    _class2.prototype['@test action closure does not get auto-mut wrapped'] = function testActionClosureDoesNotGetAutoMutWrapped(assert) {
      var first = 'raging robert';
      var second = 'mild machty';
      var returnValue = 'butch brian';

      var innerComponent = undefined;
      var actualFirst = undefined;
      var actualSecond = undefined;
      var actualReturnedValue = undefined;

      var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          innerComponent = this;
        },
        fireAction: function () {
          this.get('submit')(second);
          this.get('attrs-submit')(second);
          var attrsSubmitReturnValue = this.attrs['attrs-submit'](second);
          var submitReturnValue = this.attrs.submit(second);

          assert.equal(attrsSubmitReturnValue, submitReturnValue, 'both attrs.foo and foo should behave the same');

          return submitReturnValue;
        }
      });

      var MiddleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({});

      var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          outerAction: function (incomingFirst, incomingSecond) {
            actualFirst = incomingFirst;
            actualSecond = incomingSecond;
            return returnValue;
          }
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });

      this.registerComponent('middle-component', {
        ComponentClass: MiddleComponent,
        template: '{{inner-component attrs-submit=attrs.submit submit=submit}}'
      });

      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{middle-component submit=(action \'outerAction\' \'' + first + '\')}}'
      });

      this.render('{{outer-component}}');

      this.runTask(function () {
        actualReturnedValue = innerComponent.fireAction();
      });

      this.assert.equal(actualFirst, first, 'first argument is correct');
      this.assert.equal(actualSecond, second, 'second argument is correct');
      this.assert.equal(actualReturnedValue, returnValue, 'return value is present');
    };

    _class2.prototype['@test action should be called within a run loop'] = function testActionShouldBeCalledWithinARunLoop() {
      var innerComponent = undefined;
      var capturedRunLoop = undefined;

      var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          innerComponent = this;
        },
        fireAction: function () {
          this.attrs.submit();
        }
      });

      var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          submit: function () {
            capturedRunLoop = _emberMetal.run.currentRunLoop;
          }
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });

      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action \'submit\')}}'
      });

      this.render('{{outer-component}}');

      this.runTask(function () {
        innerComponent.fireAction();
      });

      this.assert.ok(capturedRunLoop, 'action is called within a run loop');
    };

    _class2.prototype['@test objects that define INVOKE can be casted to actions'] = function testObjectsThatDefineINVOKECanBeCastedToActions() {
      var innerComponent = undefined;
      var actionArgs = undefined;
      var invokableArgs = undefined;

      var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          innerComponent = this;
        },
        fireAction: function () {
          actionArgs = this.attrs.submit(4, 5, 6);
        }
      });

      var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        foo: 123,
        submitTask: _emberMetal.computed(function () {
          var _ref,
              _this9 = this;

          return _ref = {}, _ref[_emberGlimmerTestsUtilsHelpers.INVOKE] = function () {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            invokableArgs = args;
            return _this9.foo;
          }, _ref;
        })
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: 'inner'
      });

      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: '{{inner-component submit=(action submitTask 1 2 3)}}'
      });

      this.render('{{outer-component}}');

      this.runTask(function () {
        innerComponent.fireAction();
      });

      this.assert.equal(actionArgs, 123);
      this.assert.deepEqual(invokableArgs, [1, 2, 3, 4, 5, 6]);
    };

    _class2.prototype['@test closure action with `(mut undefinedThing)` works properly [GH#13959]'] = function testClosureActionWithMutUndefinedThingWorksProperlyGH13959() {
      var _this10 = this;

      var component = undefined;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        label: undefined,
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button onclick={{action (mut label) "Clicked!"}}>{{if label label "Click me"}}</button>'
      });

      this.render('{{example-component}}');

      this.assertText('Click me');

      this.assertStableRerender();

      this.runTask(function () {
        _this10.$('button').click();
      });

      this.assertText('Clicked!');

      this.runTask(function () {
        component.set('label', 'Dun clicked');
      });

      this.assertText('Dun clicked');

      this.runTask(function () {
        _this10.$('button').click();
      });

      this.assertText('Clicked!');

      this.runTask(function () {
        component.set('label', undefined);
      });

      this.assertText('Click me');
    };

    _class2.prototype['@test closure actions does not cause component hooks to fire unnecessarily [GH#14305] [GH#14654]'] = function testClosureActionsDoesNotCauseComponentHooksToFireUnnecessarilyGH14305GH14654(assert) {
      var _this12 = this;

      var clicked = 0;
      var didReceiveAttrsFired = 0;

      var ClickMeComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        tagName: 'button',

        click: function () {
          this.get('onClick').call(undefined, ++clicked);
        },

        didReceiveAttrs: function () {
          didReceiveAttrsFired++;
        }
      });

      this.registerComponent('click-me', {
        ComponentClass: ClickMeComponent
      });

      var outer = undefined;

      var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        clicked: 0,

        actions: {
          'on-click': function () {
            this.incrementProperty('clicked');
          }
        },

        init: function () {
          var _this11 = this;

          this._super();
          outer = this;
          this.set('onClick', function () {
            return _this11.incrementProperty('clicked');
          });
        }
      });

      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject)
      });

      this.render('{{outer-component foo=foo}}', { foo: 1 });

      this.assertText('clicked: 0; foo: 1');

      assert.equal(didReceiveAttrsFired, 3);

      this.runTask(function () {
        return _this12.rerender();
      });

      this.assertText('clicked: 0; foo: 1');

      assert.equal(didReceiveAttrsFired, 3);

      this.runTask(function () {
        return _emberMetal.set(_this12.context, 'foo', 2);
      });

      this.assertText('clicked: 0; foo: 2');

      assert.equal(didReceiveAttrsFired, 3);

      this.runTask(function () {
        return _this12.$('#string-action').click();
      });

      this.assertText('clicked: 1; foo: 2');

      assert.equal(didReceiveAttrsFired, 3);

      this.runTask(function () {
        return _this12.$('#function-action').click();
      });

      this.assertText('clicked: 2; foo: 2');

      assert.equal(didReceiveAttrsFired, 3);

      this.runTask(function () {
        return _emberMetal.set(outer, 'onClick', function () {
          outer.incrementProperty('clicked');
        });
      });

      this.assertText('clicked: 2; foo: 2');

      assert.equal(didReceiveAttrsFired, 3);

      this.runTask(function () {
        return _this12.$('#function-action').click();
      });

      this.assertText('clicked: 3; foo: 2');

      assert.equal(didReceiveAttrsFired, 3);

      this.runTask(function () {
        return _this12.$('#mut-action').click();
      });

      this.assertText('clicked: 4; foo: 2');

      assert.equal(didReceiveAttrsFired, 3);
    };

    return _class2;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/helpers/closure-action-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/helpers/closure-action-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/helpers/closure-action-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/helpers/concat-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-metal'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberMetal) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: {{concat}}', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test it concats static arguments'] = function testItConcatsStaticArguments() {
      this.render('{{concat "foo" " " "bar" " " "baz"}}');
      this.assertText('foo bar baz');
    };

    _class.prototype['@test it updates for bound arguments'] = function testItUpdatesForBoundArguments() {
      var _this = this;

      this.render('{{concat model.first model.second}}', {
        model: { first: 'one', second: 'two' }
      });

      this.assertText('onetwo');

      this.runTask(function () {
        return _this.rerender();
      });

      this.assertText('onetwo');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'model.first', 'three');
      });

      this.assertText('threetwo');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'model.second', 'four');
      });

      this.assertText('threefour');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'model', { first: 'one', second: 'two' });
      });

      this.assertText('onetwo');
    };

    _class.prototype['@test it can be used as a sub-expression'] = function testItCanBeUsedAsASubExpression() {
      var _this2 = this;

      this.render('{{concat (concat model.first model.second) (concat model.third model.fourth)}}', {
        model: {
          first: 'one',
          second: 'two',
          third: 'three',
          fourth: 'four'
        }
      });

      this.assertText('onetwothreefour');

      this.runTask(function () {
        return _this2.rerender();
      });

      this.assertText('onetwothreefour');

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'model.first', 'five');
      });

      this.assertText('fivetwothreefour');

      this.runTask(function () {
        _emberMetal.set(_this2.context, 'model.second', 'six');
        _emberMetal.set(_this2.context, 'model.third', 'seven');
      });

      this.assertText('fivesixsevenfour');

      this.runTask(function () {
        _emberMetal.set(_this2.context, 'model', {
          first: 'one',
          second: 'two',
          third: 'three',
          fourth: 'four'
        });
      });

      this.assertText('onetwothreefour');
    };

    _class.prototype['@test it can be used as input for other helpers'] = function testItCanBeUsedAsInputForOtherHelpers() {
      var _this3 = this;

      this.registerHelper('x-eq', function (_ref) {
        var actual = _ref[0];
        var expected = _ref[1];
        return actual === expected;
      });

      this.render('{{#if (x-eq (concat model.first model.second) "onetwo")}}Truthy!{{else}}False{{/if}}', {
        model: {
          first: 'one',
          second: 'two'
        }
      });

      this.assertText('Truthy!');

      this.runTask(function () {
        return _this3.rerender();
      });

      this.assertText('Truthy!');

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'model.first', 'three');
      });

      this.assertText('False');

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'model', { first: 'one', second: 'two' });
      });

      this.assertText('Truthy!');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/helpers/concat-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/helpers/concat-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/helpers/concat-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/helpers/custom-helper-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/helpers', 'internal-test-helpers', 'ember-metal', 'ember-utils'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsHelpers, _internalTestHelpers, _emberMetal, _emberUtils) {
  /* globals EmberDev */
  'use strict';

  var assert = QUnit.assert;

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: custom helpers', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test it cannot override built-in syntax'] = function testItCannotOverrideBuiltInSyntax() {
      var _this = this;

      this.registerHelper('if', function () {
        return 'Nope';
      });
      expectAssertion(function () {
        _this.render('{{if foo \'LOL\'}}', { foo: true });
      }, /You attempted to overwrite the built-in helper \"if\" which is not allowed. Please rename the helper./);
    };

    _class.prototype['@test it can resolve custom simple helpers with or without dashes'] = function testItCanResolveCustomSimpleHelpersWithOrWithoutDashes() {
      var _this2 = this;

      this.registerHelper('hello', function () {
        return 'hello';
      });
      this.registerHelper('hello-world', function () {
        return 'hello world';
      });

      this.render('{{hello}} | {{hello-world}}');

      this.assertText('hello | hello world');

      this.runTask(function () {
        return _this2.rerender();
      });

      this.assertText('hello | hello world');
    };

    _class.prototype['@test it does not resolve helpers with a `.` (period)'] = function testItDoesNotResolveHelpersWithAPeriod() {
      var _this3 = this;

      this.registerHelper('hello.world', function () {
        return 'hello world';
      });

      this.render('{{hello.world}}', {
        hello: {
          world: ''
        }
      });

      this.assertText('');

      this.assertStableRerender();

      this.assertText('');

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'hello', { world: 'hello world!' });
      });

      this.assertText('hello world!');

      this.runTask(function () {
        _emberMetal.set(_this3.context, 'hello', {
          world: ''
        });
      });

      this.assertText('');
    };

    _class.prototype['@test it can resolve custom makeBoundHelper with or without dashes [DEPRECATED]'] = function testItCanResolveCustomMakeBoundHelperWithOrWithoutDashesDEPRECATED() {
      var _this4 = this;

      expectDeprecation(function () {
        _this4.owner.register('helper:hello', _emberGlimmerTestsUtilsHelpers.makeBoundHelper(function () {
          return 'hello';
        }));
      }, 'Using `Ember.HTMLBars.makeBoundHelper` is deprecated. Please refactor to use `Ember.Helper` or `Ember.Helper.helper`.');

      expectDeprecation(function () {
        _this4.owner.register('helper:hello-world', _emberGlimmerTestsUtilsHelpers.makeBoundHelper(function () {
          return 'hello world';
        }));
      }, 'Using `Ember.HTMLBars.makeBoundHelper` is deprecated. Please refactor to use `Ember.Helper` or `Ember.Helper.helper`.');

      this.render('{{hello}} | {{hello-world}}');

      this.assertText('hello | hello world');

      this.runTask(function () {
        return _this4.rerender();
      });

      this.assertText('hello | hello world');
    };

    _class.prototype['@test it can resolve custom class-based helpers with or without dashes'] = function testItCanResolveCustomClassBasedHelpersWithOrWithoutDashes() {
      var _this5 = this;

      this.registerHelper('hello', {
        compute: function () {
          return 'hello';
        }
      });

      this.registerHelper('hello-world', {
        compute: function () {
          return 'hello world';
        }
      });

      this.render('{{hello}} | {{hello-world}}');

      this.assertText('hello | hello world');

      this.runTask(function () {
        return _this5.rerender();
      });

      this.assertText('hello | hello world');
    };

    _class.prototype['@test throws if `this._super` is not called from `init`'] = function testThrowsIfThis_superIsNotCalledFromInit() {
      var _this6 = this;

      this.registerHelper('hello-world', {
        init: function () {}
      });

      expectAssertion(function () {
        _this6.render('{{hello-world}}');
      }, /You must call `this._super\(...arguments\);` when overriding `init` on a framework object. Please update .* to call `this._super\(...arguments\);` from `init`./);
    };

    _class.prototype['@test class-based helper can recompute a new value'] = function testClassBasedHelperCanRecomputeANewValue() {
      var _this7 = this;

      var destroyCount = 0;
      var computeCount = 0;
      var helper = undefined;

      this.registerHelper('hello-world', {
        init: function () {
          this._super.apply(this, arguments);
          helper = this;
        },
        compute: function () {
          return ++computeCount;
        },
        destroy: function () {
          destroyCount++;
          this._super();
        }
      });

      this.render('{{hello-world}}');

      this.assertText('1');

      this.runTask(function () {
        return _this7.rerender();
      });

      this.assertText('1');

      this.runTask(function () {
        return helper.recompute();
      });

      this.assertText('2');

      assert.strictEqual(destroyCount, 0, 'destroy is not called on recomputation');
    };

    _class.prototype['@test class-based helper with static arguments can recompute a new value'] = function testClassBasedHelperWithStaticArgumentsCanRecomputeANewValue() {
      var _this8 = this;

      var destroyCount = 0;
      var computeCount = 0;
      var helper = undefined;

      this.registerHelper('hello-world', {
        init: function () {
          this._super.apply(this, arguments);
          helper = this;
        },
        compute: function () {
          return ++computeCount;
        },
        destroy: function () {
          destroyCount++;
          this._super();
        }
      });

      this.render('{{hello-world "whut"}}');

      this.assertText('1');

      this.runTask(function () {
        return _this8.rerender();
      });

      this.assertText('1');

      this.runTask(function () {
        return helper.recompute();
      });

      this.assertText('2');

      assert.strictEqual(destroyCount, 0, 'destroy is not called on recomputation');
    };

    _class.prototype['@test helper params can be returned'] = function testHelperParamsCanBeReturned() {
      this.registerHelper('hello-world', function (values) {
        return values;
      });

      this.render('{{#each (hello-world model) as |item|}}({{item}}){{/each}}', {
        model: ['bob']
      });

      this.assertText('(bob)');
    };

    _class.prototype['@test helper hash can be returned'] = function testHelperHashCanBeReturned() {
      this.registerHelper('hello-world', function (_, hash) {
        return hash.model;
      });

      this.render('{{get (hello-world model=model) \'name\'}}', {
        model: { name: 'bob' }
      });

      this.assertText('bob');
    };

    _class.prototype['@test simple helper is called for param changes'] = function testSimpleHelperIsCalledForParamChanges() {
      var _this9 = this;

      var computeCount = 0;

      this.registerHelper('hello-world', function (_ref) {
        var value = _ref[0];

        computeCount++;
        return value + '-value';
      });

      this.render('{{hello-world model.name}}', {
        model: { name: 'bob' }
      });

      this.assertText('bob-value');

      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');

      this.runTask(function () {
        return _this9.rerender();
      });

      this.assertText('bob-value');

      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');

      this.runTask(function () {
        return _emberMetal.set(_this9.context, 'model.name', 'sal');
      });

      this.assertText('sal-value');

      assert.strictEqual(computeCount, 2, 'compute is called exactly 2 times');

      this.runTask(function () {
        return _emberMetal.set(_this9.context, 'model', { name: 'bob' });
      });

      this.assertText('bob-value');

      assert.strictEqual(computeCount, 3, 'compute is called exactly 3 times');
    };

    _class.prototype['@test class-based helper compute is called for param changes'] = function testClassBasedHelperComputeIsCalledForParamChanges() {
      var _this10 = this;

      var createCount = 0;
      var computeCount = 0;

      this.registerHelper('hello-world', {
        init: function () {
          this._super.apply(this, arguments);
          createCount++;
        },
        compute: function (_ref2) {
          var value = _ref2[0];

          computeCount++;
          return value + '-value';
        }
      });

      this.render('{{hello-world model.name}}', {
        model: { name: 'bob' }
      });

      this.assertText('bob-value');

      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');

      this.runTask(function () {
        return _this10.rerender();
      });

      this.assertText('bob-value');

      assert.strictEqual(computeCount, 1, 'compute is called exactly 1 time');

      this.runTask(function () {
        return _emberMetal.set(_this10.context, 'model.name', 'sal');
      });

      this.assertText('sal-value');

      assert.strictEqual(computeCount, 2, 'compute is called exactly 2 times');

      this.runTask(function () {
        return _emberMetal.set(_this10.context, 'model', { name: 'bob' });
      });

      this.assertText('bob-value');

      assert.strictEqual(computeCount, 3, 'compute is called exactly 3 times');
      assert.strictEqual(createCount, 1, 'helper is only created once');
    };

    _class.prototype['@test simple helper receives params, hash'] = function testSimpleHelperReceivesParamsHash() {
      var _this11 = this;

      this.registerHelper('hello-world', function (_params, _hash) {
        return 'params: ' + JSON.stringify(_params) + ', hash: ' + JSON.stringify(_hash);
      });

      this.render('{{hello-world model.name "rich" first=model.age last="sam"}}', {
        model: {
          name: 'bob',
          age: 42
        }
      });

      this.assertText('params: ["bob","rich"], hash: {"first":42,"last":"sam"}');

      this.runTask(function () {
        return _this11.rerender();
      });

      this.assertText('params: ["bob","rich"], hash: {"first":42,"last":"sam"}');

      this.runTask(function () {
        return _emberMetal.set(_this11.context, 'model.name', 'sal');
      });

      this.assertText('params: ["sal","rich"], hash: {"first":42,"last":"sam"}');

      this.runTask(function () {
        return _emberMetal.set(_this11.context, 'model.age', 28);
      });

      this.assertText('params: ["sal","rich"], hash: {"first":28,"last":"sam"}');

      this.runTask(function () {
        return _emberMetal.set(_this11.context, 'model', { name: 'bob', age: 42 });
      });

      this.assertText('params: ["bob","rich"], hash: {"first":42,"last":"sam"}');
    };

    _class.prototype['@test class-based helper receives params, hash'] = function testClassBasedHelperReceivesParamsHash() {
      var _this12 = this;

      this.registerHelper('hello-world', {
        compute: function (_params, _hash) {
          return 'params: ' + JSON.stringify(_params) + ', hash: ' + JSON.stringify(_hash);
        }
      });

      this.render('{{hello-world model.name "rich" first=model.age last="sam"}}', {
        model: {
          name: 'bob',
          age: 42
        }
      });

      this.assertText('params: ["bob","rich"], hash: {"first":42,"last":"sam"}');

      this.runTask(function () {
        return _this12.rerender();
      });

      this.assertText('params: ["bob","rich"], hash: {"first":42,"last":"sam"}');

      this.runTask(function () {
        return _emberMetal.set(_this12.context, 'model.name', 'sal');
      });

      this.assertText('params: ["sal","rich"], hash: {"first":42,"last":"sam"}');

      this.runTask(function () {
        return _emberMetal.set(_this12.context, 'model.age', 28);
      });

      this.assertText('params: ["sal","rich"], hash: {"first":28,"last":"sam"}');

      this.runTask(function () {
        return _emberMetal.set(_this12.context, 'model', { name: 'bob', age: 42 });
      });

      this.assertText('params: ["bob","rich"], hash: {"first":42,"last":"sam"}');
    };

    _class.prototype['@test class-based helper usable in subexpressions'] = function testClassBasedHelperUsableInSubexpressions() {
      var _this13 = this;

      this.registerHelper('join-words', {
        compute: function (params) {
          return params.join(' ');
        }
      });

      this.render('{{join-words "Who"\n                   (join-words "overcomes" "by")\n                   model.reason\n                   (join-words (join-words "hath overcome but" "half"))\n                   (join-words "his" (join-words "foe"))}}', { model: { reason: 'force' } });

      this.assertText('Who overcomes by force hath overcome but half his foe');

      this.runTask(function () {
        return _this13.rerender();
      });

      this.assertText('Who overcomes by force hath overcome but half his foe');

      this.runTask(function () {
        return _emberMetal.set(_this13.context, 'model.reason', 'Nickleback');
      });

      this.assertText('Who overcomes by Nickleback hath overcome but half his foe');

      this.runTask(function () {
        return _emberMetal.set(_this13.context, 'model', { reason: 'force' });
      });

      this.assertText('Who overcomes by force hath overcome but half his foe');
    };

    _class.prototype['@test parameterless helper is usable in subexpressions'] = function testParameterlessHelperIsUsableInSubexpressions() {
      var _this14 = this;

      this.registerHelper('should-show', function () {
        return true;
      });

      this.render('{{#if (should-show)}}true{{/if}}');

      this.assertText('true');

      this.runTask(function () {
        return _this14.rerender();
      });

      this.assertText('true');
    };

    _class.prototype['@test parameterless helper is usable in attributes'] = function testParameterlessHelperIsUsableInAttributes() {
      var _this15 = this;

      this.registerHelper('foo-bar', function () {
        return 'baz';
      });

      this.render('<div data-foo-bar="{{foo-bar}}"></div>');

      this.assertHTML('<div data-foo-bar="baz"></div>');

      this.runTask(function () {
        return _this15.rerender();
      });

      this.assertHTML('<div data-foo-bar="baz"></div>');
    };

    _class.prototype['@test simple helper not usable with a block'] = function testSimpleHelperNotUsableWithABlock() {
      var _this16 = this;

      this.registerHelper('some-helper', function () {});

      expectAssertion(function () {
        _this16.render('{{#some-helper}}{{/some-helper}}');
      }, /Helpers may not be used in the block form/);
    };

    _class.prototype['@test class-based helper not usable with a block'] = function testClassBasedHelperNotUsableWithABlock() {
      var _this17 = this;

      this.registerHelper('some-helper', {
        compute: function () {}
      });

      expectAssertion(function () {
        _this17.render('{{#some-helper}}{{/some-helper}}');
      }, /Helpers may not be used in the block form/);
    };

    _class.prototype['@test simple helper not usable within element'] = function testSimpleHelperNotUsableWithinElement() {
      var _this18 = this;

      this.registerHelper('some-helper', function () {});

      this.assert.throws(function () {
        _this18.render('<div {{some-helper}}></div>');
      }, /Compile Error some-helper is not a modifier: Helpers may not be used in the element form/);
    };

    _class.prototype['@test class-based helper not usable within element'] = function testClassBasedHelperNotUsableWithinElement() {
      var _this19 = this;

      this.registerHelper('some-helper', {
        compute: function () {}
      });

      this.assert.throws(function () {
        _this19.render('<div {{some-helper}}></div>');
      }, /Compile Error some-helper is not a modifier: Helpers may not be used in the element form/);
    };

    _class.prototype['@test class-based helper is torn down'] = function testClassBasedHelperIsTornDown() {
      var destroyCalled = 0;

      this.registerHelper('some-helper', {
        destroy: function () {
          destroyCalled++;
          this._super.apply(this, arguments);
        },
        compute: function () {
          return 'must define a compute';
        }
      });

      this.render('{{some-helper}}');

      _internalTestHelpers.runDestroy(this.component);

      assert.strictEqual(destroyCalled, 1, 'destroy called once');
    };

    _class.prototype['@test class-based helper used in subexpression can recompute'] = function testClassBasedHelperUsedInSubexpressionCanRecompute() {
      var _this20 = this;

      var helper = undefined;
      var phrase = 'overcomes by';

      this.registerHelper('dynamic-segment', {
        init: function () {
          this._super.apply(this, arguments);
          helper = this;
        },
        compute: function () {
          return phrase;
        }
      });

      this.registerHelper('join-words', {
        compute: function (params) {
          return params.join(' ');
        }
      });

      this.render('{{join-words "Who"\n                   (dynamic-segment)\n                   "force"\n                   (join-words (join-words "hath overcome but" "half"))\n                   (join-words "his" (join-words "foe"))}}');

      this.assertText('Who overcomes by force hath overcome but half his foe');

      this.runTask(function () {
        return _this20.rerender();
      });

      this.assertText('Who overcomes by force hath overcome but half his foe');

      phrase = 'believes his';

      this.runTask(function () {
        return helper.recompute();
      });

      this.assertText('Who believes his force hath overcome but half his foe');

      phrase = 'overcomes by';

      this.runTask(function () {
        return helper.recompute();
      });

      this.assertText('Who overcomes by force hath overcome but half his foe');
    };

    _class.prototype['@test class-based helper used in subexpression can recompute component'] = function testClassBasedHelperUsedInSubexpressionCanRecomputeComponent() {
      var _this21 = this;

      var helper = undefined;
      var phrase = 'overcomes by';

      this.registerHelper('dynamic-segment', {
        init: function () {
          this._super.apply(this, arguments);
          helper = this;
        },
        compute: function () {
          return phrase;
        }
      });

      this.registerHelper('join-words', {
        compute: function (params) {
          return params.join(' ');
        }
      });

      this.registerComponent('some-component', {
        template: '{{first}} {{second}} {{third}} {{fourth}} {{fifth}}'
      });

      this.render('{{some-component first="Who"\n                   second=(dynamic-segment)\n                   third="force"\n                   fourth=(join-words (join-words "hath overcome but" "half"))\n                   fifth=(join-words "his" (join-words "foe"))}}');

      this.assertText('Who overcomes by force hath overcome but half his foe');

      this.runTask(function () {
        return _this21.rerender();
      });

      this.assertText('Who overcomes by force hath overcome but half his foe');

      phrase = 'believes his';

      this.runTask(function () {
        return helper.recompute();
      });

      this.assertText('Who believes his force hath overcome but half his foe');

      phrase = 'overcomes by';

      this.runTask(function () {
        return helper.recompute();
      });

      this.assertText('Who overcomes by force hath overcome but half his foe');
    };

    _class.prototype['@test class-based helper used in subexpression is destroyed'] = function testClassBasedHelperUsedInSubexpressionIsDestroyed() {
      var destroyCount = 0;

      this.registerHelper('dynamic-segment', {
        phrase: 'overcomes by',
        init: function () {
          this._super.apply(this, arguments);
        },
        compute: function () {
          return this.phrase;
        },
        destroy: function () {
          destroyCount++;
          this._super.apply(this, arguments);
        }
      });

      this.registerHelper('join-words', {
        compute: function (params) {
          return params.join(' ');
        }
      });

      this.render('{{join-words "Who"\n                   (dynamic-segment)\n                   "force"\n                   (join-words (join-words "hath overcome but" "half"))\n                   (join-words "his" (join-words "foe"))}}');

      _internalTestHelpers.runDestroy(this.component);

      equal(destroyCount, 1, 'destroy is called after a view is destroyed');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));

  // these feature detects prevent errors in these tests
  // on platforms (*cough* IE9 *cough*) that do not
  // property support `Object.freeze`
  var pushingIntoFrozenArrayThrows = (function () {
    var array = [];
    Object.freeze(array);

    try {
      array.push('foo');

      return false;
    } catch (e) {
      return true;
    }
  })();

  var assigningExistingFrozenPropertyThrows = (function () {
    var obj = { foo: 'asdf' };
    Object.freeze(obj);

    try {
      obj.foo = 'derp';

      return false;
    } catch (e) {
      return true;
    }
  })();

  var addingPropertyToFrozenObjectThrows = (function () {
    var obj = { foo: 'asdf' };
    Object.freeze(obj);

    try {
      obj.bar = 'derp';

      return false;
    } catch (e) {
      return true;
    }
  })();

  if (!EmberDev.runningProdBuild && _emberUtils.HAS_NATIVE_WEAKMAP && (pushingIntoFrozenArrayThrows || assigningExistingFrozenPropertyThrows || addingPropertyToFrozenObjectThrows)) {
    (function () {
      var HelperMutatingArgsTests = (function (_RenderingTest2) {
        babelHelpers.inherits(HelperMutatingArgsTests, _RenderingTest2);

        function HelperMutatingArgsTests() {
          _RenderingTest2.apply(this, arguments);
        }

        HelperMutatingArgsTests.prototype.buildCompute = function buildCompute() {
          var _this22 = this;

          return function (params, hash) {
            if (pushingIntoFrozenArrayThrows) {
              _this22.assert.throws(function () {
                params.push('foo');

                // cannot assert error message as it varies by platform
              });
            }

            if (assigningExistingFrozenPropertyThrows) {
              _this22.assert.throws(function () {
                hash.foo = 'bar';

                // cannot assert error message as it varies by platform
              });
            }

            if (addingPropertyToFrozenObjectThrows) {
              _this22.assert.throws(function () {
                hash.someUnusedHashProperty = 'bar';

                // cannot assert error message as it varies by platform
              });
            }
          };
        };

        HelperMutatingArgsTests.prototype['@test cannot mutate params - no positional specified / named specified'] = function testCannotMutateParamsNoPositionalSpecifiedNamedSpecified() {
          this.render('{{test-helper foo=bar}}', { bar: 'derp' });
        };

        HelperMutatingArgsTests.prototype['@test cannot mutate params - positional specified / no named specified'] = function testCannotMutateParamsPositionalSpecifiedNoNamedSpecified() {
          this.render('{{test-helper bar}}', { bar: 'derp' });
        };

        HelperMutatingArgsTests.prototype['@test cannot mutate params - positional specified / named specified'] = function testCannotMutateParamsPositionalSpecifiedNamedSpecified() {
          this.render('{{test-helper bar foo=qux}}', { bar: 'derp', qux: 'baz' });
        };

        HelperMutatingArgsTests.prototype['@test cannot mutate params - no positional specified / no named specified'] = function testCannotMutateParamsNoPositionalSpecifiedNoNamedSpecified() {
          this.render('{{test-helper}}', { bar: 'derp', qux: 'baz' });
        };

        return HelperMutatingArgsTests;
      })(_emberGlimmerTestsUtilsTestCase.RenderingTest);

      _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: mutation triggers errors - class based helper', (function (_HelperMutatingArgsTests) {
        babelHelpers.inherits(_class2, _HelperMutatingArgsTests);

        function _class2() {
          _HelperMutatingArgsTests.call(this);

          var compute = this.buildCompute();

          this.registerHelper('test-helper', {
            compute: compute
          });
        }

        return _class2;
      })(HelperMutatingArgsTests));

      _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: mutation triggers errors - simple helper', (function (_HelperMutatingArgsTests2) {
        babelHelpers.inherits(_class3, _HelperMutatingArgsTests2);

        function _class3() {
          _HelperMutatingArgsTests2.call(this);

          var compute = this.buildCompute();

          this.registerHelper('test-helper', compute);
        }

        return _class3;
      })(HelperMutatingArgsTests));
    })();
  }
});
enifed('ember-glimmer/tests/integration/helpers/custom-helper-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/helpers/custom-helper-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/helpers/custom-helper-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/helpers/element-action-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/abstract-test-case', 'ember-glimmer/tests/utils/helpers', 'ember-metal', 'ember-runtime', 'ember-views'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsAbstractTestCase, _emberGlimmerTestsUtilsHelpers, _emberMetal, _emberRuntime, _emberViews) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#inner-component}}\n          <button {{action "wat"}}>Wat me!</button>\n        {{/inner-component}}\n      '], ['\n        {{#inner-component}}\n          <button {{action "wat"}}>Wat me!</button>\n        {{/inner-component}}\n      ']),
      _templateObject2 = babelHelpers.taggedTemplateLiteralLoose(['\n          {{#target-component as |parent|}}\n            {{other-component anotherTarget=parent}}\n          {{/target-component}}\n        '], ['\n          {{#target-component as |parent|}}\n            {{other-component anotherTarget=parent}}\n          {{/target-component}}\n        ']),
      _templateObject3 = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#target-component as |aTarget|}}\n          <a id="edit" href="#" {{action "edit" this target=aTarget}}>click me</a>\n        {{/target-component}}\n        '], ['\n        {{#target-component as |aTarget|}}\n          <a id="edit" href="#" {{action "edit" this target=aTarget}}>click me</a>\n        {{/target-component}}\n        ']),
      _templateObject4 = babelHelpers.taggedTemplateLiteralLoose(['\n        <a href="#"\n          {{action "clicked" on="click"}}\n          {{action "doubleClicked" on="doubleClick"}}\n        >click me</a>'], ['\n        <a href="#"\n          {{action "clicked" on="click"}}\n          {{action "doubleClicked" on="doubleClick"}}\n        >click me</a>']),
      _templateObject5 = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#middle-component}}\n          {{inner-component action="hey"}}\n        {{/middle-component}}\n      '], ['\n        {{#middle-component}}\n          {{inner-component action="hey"}}\n        {{/middle-component}}\n      ']),
      _templateObject6 = babelHelpers.taggedTemplateLiteralLoose(['\n        <button>Click Me</button>\n        {{yield}}\n      '], ['\n        <button>Click Me</button>\n        {{yield}}\n      ']);

  function getActionAttributes(element) {
    var attributes = element.attributes;
    var actionAttrs = [];

    for (var i = 0; i < attributes.length; i++) {
      var attr = attributes.item(i);

      if (attr.name.indexOf('data-ember-action-') === 0) {
        actionAttrs.push(attr.name);
      }
    }

    return actionAttrs;
  }

  function getActionIds(element) {
    return getActionAttributes(element).map(function (attribute) {
      return attribute.slice('data-ember-action-'.length);
    });
  }

  if (_emberMetal.isFeatureEnabled('ember-improved-instrumentation')) {
    _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: element action instrumentation', (function (_RenderingTest) {
babelHelpers.inherits(_class, _RenderingTest);

      function _class() {
        _RenderingTest.apply(this, arguments);
      }

      _class.prototype.teardown = function teardown() {
        _RenderingTest.prototype.teardown.call(this);
        _emberMetal.instrumentationReset();
      };

      _class.prototype['@test action should fire interaction event with proper params'] = function testActionShouldFireInteractionEventWithProperParams() {
        var _this = this;

        var subscriberCallCount = 0;
        var subscriberPayload = null;

        var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
          actions: {
            foo: function () {}
          }
        });

        this.registerComponent('example-component', {
          ComponentClass: ExampleComponent,
          template: '<button {{action "foo" "bar"}}>Click me</button>'
        });

        _emberMetal.instrumentationSubscribe('interaction.ember-action', {
          before: function () {
            subscriberCallCount++;
          },
          after: function (name, time, payload) {
            subscriberPayload = payload;
          }
        });

        this.render('{{example-component}}');

        this.assert.equal(subscriberCallCount, 0, 'subscriber has not been called');

        this.runTask(function () {
          return _this.rerender();
        });

        this.assert.equal(subscriberCallCount, 0, 'subscriber has not been called');

        this.runTask(function () {
          _this.$('button').click();
        });

        this.assert.equal(subscriberCallCount, 1, 'subscriber has been called 1 time');
        this.assert.equal(subscriberPayload.name, 'foo', 'subscriber called with correct name');
        this.assert.equal(subscriberPayload.args[0], 'bar', 'subscriber called with correct args');
      };

      return _class;
    })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
  }

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: element action', (function (_RenderingTest2) {
babelHelpers.inherits(_class2, _RenderingTest2);

    function _class2() {
      _RenderingTest2.apply(this, arguments);
    }

    _class2.prototype['@test it can call an action on its enclosing component'] = function testItCanCallAnActionOnItsEnclosingComponent() {
      var _this2 = this;

      var fooCallCount = 0;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          foo: function () {
            fooCallCount++;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button {{action "foo"}}>Click me</button>'
      });

      this.render('{{example-component}}');

      this.assert.equal(fooCallCount, 0, 'foo has not been called');

      this.runTask(function () {
        return _this2.rerender();
      });

      this.assert.equal(fooCallCount, 0, 'foo has not been called');

      this.runTask(function () {
        _this2.$('button').click();
      });

      this.assert.equal(fooCallCount, 1, 'foo has been called 1 time');

      this.runTask(function () {
        _this2.$('button').click();
      });

      this.assert.equal(fooCallCount, 2, 'foo has been called 2 times');
    };

    _class2.prototype['@test it can call an action with parameters'] = function testItCanCallAnActionWithParameters() {
      var _this3 = this;

      var fooArgs = [];
      var component = undefined;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        member: 'a',
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        },
        actions: {
          foo: function (thing) {
            fooArgs.push(thing);
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button {{action "foo" member}}>Click me</button>'
      });

      this.render('{{example-component}}');

      this.assert.deepEqual(fooArgs, [], 'foo has not been called');

      this.runTask(function () {
        return _this3.rerender();
      });

      this.assert.deepEqual(fooArgs, [], 'foo has not been called');

      this.runTask(function () {
        _this3.$('button').click();
      });

      this.assert.deepEqual(fooArgs, ['a'], 'foo has not been called');

      this.runTask(function () {
        component.set('member', 'b');
      });

      this.runTask(function () {
        _this3.$('button').click();
      });

      this.assert.deepEqual(fooArgs, ['a', 'b'], 'foo has been called with an updated value');
    };

    _class2.prototype['@test it should output a marker attribute with a guid'] = function testItShouldOutputAMarkerAttributeWithAGuid() {
      this.render('<button {{action "show"}}>me the money</button>');

      var button = this.$('button');

      var attributes = getActionAttributes(button.get(0));

      this.assert.ok(button.attr('data-ember-action').match(''), 'An empty data-ember-action attribute was added');
      this.assert.ok(attributes[0].match(/data-ember-action-\d+/), 'A data-ember-action-xyz attribute with a guid was added');
    };

    _class2.prototype['@test it should allow alternative events to be handled'] = function testItShouldAllowAlternativeEventsToBeHandled() {
      var _this4 = this;

      var showCalled = false;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          show: function () {
            showCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<div id="show" {{action "show" on="mouseUp"}}></div>'
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        var event = _emberViews.jQuery.Event('mouseup');
        _this4.$('#show').trigger(event);
      });

      this.assert.ok(showCalled, 'show action was called on mouseUp');
    };

    _class2.prototype['@test inside a yield, the target points at the original target'] = function testInsideAYieldTheTargetPointsAtTheOriginalTarget() {
      var _this5 = this;

      var targetWatted = false;
      var innerWatted = false;

      var TargetComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          wat: function () {
            targetWatted = true;
          }
        }
      });

      var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          wat: function () {
            innerWatted = true;
          }
        }
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: '{{yield}}'
      });

      this.registerComponent('target-component', {
        ComponentClass: TargetComponent,
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject)
      });

      this.render('{{target-component}}');

      this.runTask(function () {
        _this5.$('button').click();
      });

      this.assert.ok(targetWatted, 'the correct target was watted');
      this.assert.notOk(innerWatted, 'the inner target was not watted');
    };

    _class2.prototype['@test it should allow a target to be specified'] = function testItShouldAllowATargetToBeSpecified() {
      var _this6 = this;

      var targetWatted = false;

      var TargetComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          wat: function () {
            targetWatted = true;
          }
        }
      });

      var OtherComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({});

      this.registerComponent('target-component', {
        ComponentClass: TargetComponent,
        template: '{{yield this}}'
      });

      this.registerComponent('other-component', {
        ComponentClass: OtherComponent,
        template: '<a {{action "wat" target=anotherTarget}}>Wat?</a>'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2));

      this.runTask(function () {
        _this6.$('a').click();
      });

      this.assert.equal(targetWatted, true, 'the specified target was watted');
    };

    _class2.prototype['@test it should lazily evaluate the target'] = function testItShouldLazilyEvaluateTheTarget() {
      var _this7 = this;

      var firstEdit = 0;
      var secondEdit = 0;
      var component = undefined;

      var first = {
        edit: function () {
          firstEdit++;
        }
      };

      var second = {
        edit: function () {
          secondEdit++;
        }
      };

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        },
        theTarget: first
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a {{action "edit" target=theTarget}}>Edit</a>'
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        _this7.$('a').click();
      });

      this.assert.equal(firstEdit, 1);

      this.runTask(function () {
        _emberMetal.set(component, 'theTarget', second);
      });

      this.runTask(function () {
        _this7.$('a').click();
      });

      this.assert.equal(firstEdit, 1);
      this.assert.equal(secondEdit, 1);
    };

    _class2.prototype['@test it should register an event handler'] = function testItShouldRegisterAnEventHandler() {
      var _this8 = this;

      var editHandlerWasCalled = false;
      var shortcutHandlerWasCalled = false;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          },
          shortcut: function () {
            shortcutHandlerWasCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a href="#" {{action "edit" allowedKeys="alt"}}>click me</a> <div {{action "shortcut" allowedKeys="any"}}>click me too</div>'
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        var event = _emberViews.jQuery.Event('click');
        event.altKey = true;
        _this8.$('a[data-ember-action]').trigger(event);
      });

      this.assert.equal(editHandlerWasCalled, true, 'the event handler was called');

      this.runTask(function () {
        var event = _emberViews.jQuery.Event('click');
        event.ctrlKey = true;
        _this8.$('div[data-ember-action]').trigger(event);
      });

      this.assert.equal(shortcutHandlerWasCalled, true, 'the "any" shortcut\'s event handler was called');
    };

    _class2.prototype['@test it handles whitelisted bound modifier keys'] = function testItHandlesWhitelistedBoundModifierKeys() {
      var _this9 = this;

      var editHandlerWasCalled = false;
      var shortcutHandlerWasCalled = false;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        altKey: 'alt',
        anyKey: 'any',
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          },
          shortcut: function () {
            shortcutHandlerWasCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a href="#" {{action "edit" allowedKeys=altKey}}>click me</a> <div {{action "shortcut" allowedKeys=anyKey}}>click me too</div>'
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        var event = _emberViews.jQuery.Event('click');
        event.altKey = true;
        _this9.$('a[data-ember-action]').trigger(event);
      });

      this.assert.equal(editHandlerWasCalled, true, 'the event handler was called');

      this.runTask(function () {
        var event = _emberViews.jQuery.Event('click');
        event.ctrlKey = true;
        _this9.$('div[data-ember-action]').trigger(event);
      });

      this.assert.equal(shortcutHandlerWasCalled, true, 'the "any" shortcut\'s event handler was called');
    };

    _class2.prototype['@test it handles whitelisted bound modifier keys with current value'] = function testItHandlesWhitelistedBoundModifierKeysWithCurrentValue() {
      var _this10 = this;

      var editHandlerWasCalled = false;
      var component = undefined;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        },
        acceptedKeys: 'alt',
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a href="#" {{action "edit" allowedKeys=acceptedKeys}}>click me</a>'
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        var event = _emberViews.jQuery.Event('click');
        event.altKey = true;
        _this10.$('a[data-ember-action]').trigger(event);
      });

      this.assert.equal(editHandlerWasCalled, true, 'the event handler was called');

      editHandlerWasCalled = false;

      this.runTask(function () {
        component.set('acceptedKeys', '');
      });

      this.runTask(function () {
        var event = _emberViews.jQuery.Event('click');
        _this10.$('div[data-ember-action]').trigger(event);
      });

      this.assert.equal(editHandlerWasCalled, false, 'the event handler was not called');
    };

    _class2.prototype['@test should be able to use action more than once for the same event within a view'] = function testShouldBeAbleToUseActionMoreThanOnceForTheSameEventWithinAView() {
      var _this11 = this;

      var editHandlerWasCalled = false;
      var deleteHandlerWasCalled = false;
      var originalHandlerWasCalled = false;
      var component = undefined;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        },
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          },
          'delete': function () {
            deleteHandlerWasCalled = true;
          }
        },
        click: function () {
          originalHandlerWasCalled = true;
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a id="edit" href="#" {{action "edit"}}>edit</a><a id="delete" href="#" {{action "delete"}}>delete</a>'
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        _this11.$('#edit').click();
      });

      this.assert.equal(editHandlerWasCalled, true, 'the edit action was called');
      this.assert.equal(deleteHandlerWasCalled, false, 'the delete action was not called');
      this.assert.equal(originalHandlerWasCalled, true, 'the click handler was called (due to bubbling)');

      editHandlerWasCalled = deleteHandlerWasCalled = originalHandlerWasCalled = false;

      this.runTask(function () {
        _this11.$('#delete').click();
      });

      this.assert.equal(editHandlerWasCalled, false, 'the edit action was not called');
      this.assert.equal(deleteHandlerWasCalled, true, 'the delete action was called');
      this.assert.equal(originalHandlerWasCalled, true, 'the click handler was called (due to bubbling)');

      editHandlerWasCalled = deleteHandlerWasCalled = originalHandlerWasCalled = false;

      this.runTask(function () {
        component.$().click();
      });

      this.assert.equal(editHandlerWasCalled, false, 'the edit action was not called');
      this.assert.equal(deleteHandlerWasCalled, false, 'the delete action was not called');
      this.assert.equal(originalHandlerWasCalled, true, 'the click handler was called');
    };

    _class2.prototype['@test the event should not bubble if `bubbles=false` is passed'] = function testTheEventShouldNotBubbleIfBubblesFalseIsPassed() {
      var _this12 = this;

      var editHandlerWasCalled = false;
      var deleteHandlerWasCalled = false;
      var originalHandlerWasCalled = false;
      var component = undefined;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        },
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          },
          'delete': function () {
            deleteHandlerWasCalled = true;
          }
        },
        click: function () {
          originalHandlerWasCalled = true;
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a id="edit" href="#" {{action "edit" bubbles=false}}>edit</a><a id="delete" href="#" {{action "delete" bubbles=false}}>delete</a>'
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        _this12.$('#edit').click();
      });

      this.assert.equal(editHandlerWasCalled, true, 'the edit action was called');
      this.assert.equal(deleteHandlerWasCalled, false, 'the delete action was not called');
      this.assert.equal(originalHandlerWasCalled, false, 'the click handler was not called');

      editHandlerWasCalled = deleteHandlerWasCalled = originalHandlerWasCalled = false;

      this.runTask(function () {
        _this12.$('#delete').click();
      });

      this.assert.equal(editHandlerWasCalled, false, 'the edit action was not called');
      this.assert.equal(deleteHandlerWasCalled, true, 'the delete action was called');
      this.assert.equal(originalHandlerWasCalled, false, 'the click handler was not called');

      editHandlerWasCalled = deleteHandlerWasCalled = originalHandlerWasCalled = false;

      this.runTask(function () {
        component.$().click();
      });

      this.assert.equal(editHandlerWasCalled, false, 'the edit action was not called');
      this.assert.equal(deleteHandlerWasCalled, false, 'the delete action was not called');
      this.assert.equal(originalHandlerWasCalled, true, 'the click handler was called');
    };

    _class2.prototype['@test the event should not bubble if `bubbles=false` is passed bound'] = function testTheEventShouldNotBubbleIfBubblesFalseIsPassedBound() {
      var _this13 = this;

      var editHandlerWasCalled = false;
      var deleteHandlerWasCalled = false;
      var originalHandlerWasCalled = false;
      var component = undefined;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        },
        isFalse: false,
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          },
          'delete': function () {
            deleteHandlerWasCalled = true;
          }
        },
        click: function () {
          originalHandlerWasCalled = true;
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a id="edit" href="#" {{action "edit" bubbles=isFalse}}>edit</a><a id="delete" href="#" {{action "delete" bubbles=isFalse}}>delete</a>'
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        _this13.$('#edit').click();
      });

      this.assert.equal(editHandlerWasCalled, true, 'the edit action was called');
      this.assert.equal(deleteHandlerWasCalled, false, 'the delete action was not called');
      this.assert.equal(originalHandlerWasCalled, false, 'the click handler was not called');

      editHandlerWasCalled = deleteHandlerWasCalled = originalHandlerWasCalled = false;

      this.runTask(function () {
        _this13.$('#delete').click();
      });

      this.assert.equal(editHandlerWasCalled, false, 'the edit action was not called');
      this.assert.equal(deleteHandlerWasCalled, true, 'the delete action was called');
      this.assert.equal(originalHandlerWasCalled, false, 'the click handler was not called');

      editHandlerWasCalled = deleteHandlerWasCalled = originalHandlerWasCalled = false;

      this.runTask(function () {
        component.$().click();
      });

      this.assert.equal(editHandlerWasCalled, false, 'the edit action was not called');
      this.assert.equal(deleteHandlerWasCalled, false, 'the delete action was not called');
      this.assert.equal(originalHandlerWasCalled, true, 'the click handler was called');
    };

    _class2.prototype['@test the bubbling depends on the bound parameter'] = function testTheBubblingDependsOnTheBoundParameter() {
      var _this14 = this;

      var editHandlerWasCalled = false;
      var originalHandlerWasCalled = false;
      var component = undefined;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        },
        shouldBubble: false,
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          }
        },
        click: function () {
          originalHandlerWasCalled = true;
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a id="edit" href="#" {{action "edit" bubbles=shouldBubble}}>edit</a>'
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        _this14.$('#edit').click();
      });

      this.assert.equal(editHandlerWasCalled, true, 'the edit action was called');
      this.assert.equal(originalHandlerWasCalled, false, 'the click handler was not called');

      editHandlerWasCalled = originalHandlerWasCalled = false;

      this.runTask(function () {
        component.set('shouldBubble', true);
      });

      this.runTask(function () {
        _this14.$('#edit').click();
      });

      this.assert.equal(editHandlerWasCalled, true, 'the edit action was called');
      this.assert.equal(originalHandlerWasCalled, true, 'the click handler was called');
    };

    _class2.prototype['@test it should work properly in an #each block'] = function testItShouldWorkProperlyInAnEachBlock() {
      var _this15 = this;

      var editHandlerWasCalled = false;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        items: _emberRuntime.A([1, 2, 3, 4]),
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '{{#each items as |item|}}<a href="#" {{action "edit"}}>click me</a>{{/each}}'
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        _this15.$('a').click();
      });

      this.assert.equal(editHandlerWasCalled, true, 'the event handler was called');
    };

    _class2.prototype['@test it should work properly in a {{#with foo as |bar|}} block'] = function testItShouldWorkProperlyInAWithFooAsBarBlock() {
      var _this16 = this;

      var editHandlerWasCalled = false;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        something: { ohai: 'there' },
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '{{#with something as |somethingElse|}}<a href="#" {{action "edit"}}>click me</a>{{/with}}'
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        _this16.$('a').click();
      });

      this.assert.equal(editHandlerWasCalled, true, 'the event handler was called');
    };

    _class2.prototype['@test it should unregister event handlers when an element action is removed'] = function testItShouldUnregisterEventHandlersWhenAnElementActionIsRemoved() {
      var _this17 = this;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          edit: function () {}
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '{{#if isActive}}<a href="#" {{action "edit"}}>click me</a>{{/if}}'
      });

      this.render('{{example-component isActive=isActive}}', { isActive: true });

      equal(this.$('a[data-ember-action]').length, 1, 'The element is rendered');

      var actionId = undefined;

      actionId = getActionIds(this.$('a[data-ember-action]').get(0))[0];

      ok(_emberViews.ActionManager.registeredActions[actionId], 'An action is registered');

      this.runTask(function () {
        return _this17.rerender();
      });

      equal(this.$('a[data-ember-action]').length, 1, 'The element is still present');

      ok(_emberViews.ActionManager.registeredActions[actionId], 'The action is still registered');

      this.runTask(function () {
        return _emberMetal.set(_this17.context, 'isActive', false);
      });

      strictEqual(this.$('a[data-ember-action]').length, 0, 'The element is removed');

      ok(!_emberViews.ActionManager.registeredActions[actionId], 'The action is unregistered');

      this.runTask(function () {
        return _emberMetal.set(_this17.context, 'isActive', true);
      });

      equal(this.$('a[data-ember-action]').length, 1, 'The element is rendered');

      actionId = getActionIds(this.$('a[data-ember-action]').get(0))[0];

      ok(_emberViews.ActionManager.registeredActions[actionId], 'A new action is registered');
    };

    _class2.prototype['@test it should capture events from child elements and allow them to trigger the action'] = function testItShouldCaptureEventsFromChildElementsAndAllowThemToTriggerTheAction() {
      var _this18 = this;

      var editHandlerWasCalled = false;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<div {{action "edit"}}><button>click me</button></div>'
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        _this18.$('button').click();
      });

      this.assert.ok(editHandlerWasCalled, 'event on a child target triggered the action of its parent');
    };

    _class2.prototype['@test it should allow bubbling of events from action helper to original parent event'] = function testItShouldAllowBubblingOfEventsFromActionHelperToOriginalParentEvent() {
      var _this19 = this;

      var editHandlerWasCalled = false;
      var originalHandlerWasCalled = false;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          }
        },
        click: function () {
          originalHandlerWasCalled = true;
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a href="#" {{action "edit"}}>click me</a>'
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        _this19.$('a').click();
      });

      this.assert.ok(editHandlerWasCalled && originalHandlerWasCalled, 'both event handlers were called');
    };

    _class2.prototype['@test it should not bubble an event from action helper to original parent event if `bubbles=false` is passed'] = function testItShouldNotBubbleAnEventFromActionHelperToOriginalParentEventIfBubblesFalseIsPassed() {
      var _this20 = this;

      var editHandlerWasCalled = false;
      var originalHandlerWasCalled = false;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          }
        },
        click: function () {
          originalHandlerWasCalled = true;
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a href="#" {{action "edit" bubbles=false}}>click me</a>'
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        _this20.$('a').click();
      });

      this.assert.ok(editHandlerWasCalled, 'the child event handler was called');
      this.assert.notOk(originalHandlerWasCalled, 'the parent handler was not called');
    };

    _class2.prototype['@test it should allow "send" as the action name (#594)'] = function testItShouldAllowSendAsTheActionName594() {
      var _this21 = this;

      var sendHandlerWasCalled = false;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          send: function () {
            sendHandlerWasCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a href="#" {{action "send"}}>click me</a>'
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        _this21.$('a').click();
      });

      this.assert.ok(sendHandlerWasCalled, 'the event handler was called');
    };

    _class2.prototype['@test it should send the view, event, and current context to the action'] = function testItShouldSendTheViewEventAndCurrentContextToTheAction() {
      var _this22 = this;

      var passedTarget = undefined;
      var passedContext = undefined;
      var targetThis = undefined;

      var TargetComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          targetThis = this;
        },
        actions: {
          edit: function (context) {
            passedTarget = this === targetThis;
            passedContext = context;
          }
        }
      });

      var aContext = undefined;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          aContext = this;
        }
      });

      this.registerComponent('target-component', {
        ComponentClass: TargetComponent,
        template: '{{yield this}}'
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject3)
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        _this22.$('#edit').click();
      });

      this.assert.ok(passedTarget, 'the action is called with the target as this');
      this.assert.strictEqual(passedContext, aContext, 'the parameter is passed along');
    };

    _class2.prototype['@test it should only trigger actions for the event they were registered on'] = function testItShouldOnlyTriggerActionsForTheEventTheyWereRegisteredOn() {
      var _this23 = this;

      var editHandlerWasCalled = false;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          edit: function () {
            editHandlerWasCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a href="#" {{action "edit"}}>click me</a>'
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        _this23.$('a').click();
      });

      this.assert.ok(editHandlerWasCalled, 'the event handler was called on click');

      editHandlerWasCalled = false;

      this.runTask(function () {
        _this23.$('a').trigger('mouseover');
      });

      this.assert.notOk(editHandlerWasCalled, 'the event handler was not called on mouseover');
    };

    _class2.prototype['@test it should allow multiple contexts to be specified'] = function testItShouldAllowMultipleContextsToBeSpecified() {
      var _this24 = this;

      var passedContexts = undefined;
      var models = [_emberRuntime.Object.create(), _emberRuntime.Object.create()];

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        modelA: models[0],
        modelB: models[1],
        actions: {
          edit: function () {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            passedContexts = args;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button {{action "edit" modelA modelB}}>click me</button>'
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        _this24.$('button').click();
      });

      this.assert.deepEqual(passedContexts, models, 'the action was called with the passed contexts');
    };

    _class2.prototype['@test it should allow multiple contexts to be specified mixed with string args'] = function testItShouldAllowMultipleContextsToBeSpecifiedMixedWithStringArgs() {
      var _this25 = this;

      var passedContexts = undefined;
      var model = _emberRuntime.Object.create();

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        model: model,
        actions: {
          edit: function () {
            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            passedContexts = args;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button {{action "edit" "herp" model}}>click me</button>'
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        _this25.$('button').click();
      });

      this.assert.deepEqual(passedContexts, ['herp', model], 'the action was called with the passed contexts');
    };

    _class2.prototype['@test it should not trigger action with special clicks'] = function testItShouldNotTriggerActionWithSpecialClicks() {
      var showCalled = false;
      var component = undefined;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        },
        actions: {
          show: function () {
            showCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button {{action "show" href=true}}>Howdy</button>'
      });

      this.render('{{example-component}}');

      var assert = this.assert;

      function checkClick(prop, value, expected) {
        var event = _emberViews.jQuery.Event('click');
        event[prop] = value;

        component.$('button').trigger(event);

        if (expected) {
          assert.ok(showCalled, 'should call action with ' + prop + ':' + value);
          assert.ok(event.isDefaultPrevented(), 'should prevent default');
        } else {
          assert.notOk(showCalled, 'should not call action with ' + prop + ':' + value);
          assert.notOk(event.isDefaultPrevented(), 'should not prevent default');
        }
      }

      checkClick('ctrlKey', true, false);
      checkClick('altKey', true, false);
      checkClick('metaKey', true, false);
      checkClick('shiftKey', true, false);
      checkClick('which', 2, false);

      checkClick('which', 1, true);
      checkClick('which', undefined, true); // IE <9
    };

    _class2.prototype['@test it can trigger actions for keyboard events'] = function testItCanTriggerActionsForKeyboardEvents() {
      var _this26 = this;

      var showCalled = false;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          show: function () {
            showCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<input type="text" {{action "show" on="keyUp"}}>'
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        var event = _emberViews.jQuery.Event('keyup');
        event.char = 'a';
        event.which = 65;
        _this26.$('input').trigger(event);
      });

      this.assert.ok(showCalled, 'the action was called with keyup');
    };

    _class2.prototype['@test a quoteless parameter should allow dynamic lookup of the actionName'] = function testAQuotelessParameterShouldAllowDynamicLookupOfTheActionName() {
      var lastAction = undefined;
      var actionOrder = [];
      var component = undefined;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        },
        hookMeUp: 'rock',
        actions: {
          rock: function () {
            lastAction = 'rock';
            actionOrder.push('rock');
          },
          paper: function () {
            lastAction = 'paper';
            actionOrder.push('paper');
          },
          scissors: function () {
            lastAction = 'scissors';
            actionOrder.push('scissors');
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a id="bound-param" {{action hookMeUp}}>Whistle tips go woop woooop</a>'
      });

      this.render('{{example-component}}');

      var test = this;

      function testBoundAction(propertyValue) {
        test.runTask(function () {
          component.set('hookMeUp', propertyValue);
        });

        test.runTask(function () {
          component.$('#bound-param').click();
        });

        test.assert.ok(lastAction, propertyValue, 'lastAction set to ' + propertyValue);
      }

      testBoundAction('rock');
      testBoundAction('paper');
      testBoundAction('scissors');

      this.assert.deepEqual(actionOrder, ['rock', 'paper', 'scissors'], 'action name was looked up properly');
    };

    _class2.prototype['@test a quoteless string parameter should resolve actionName, including path'] = function testAQuotelessStringParameterShouldResolveActionNameIncludingPath() {
      var lastAction = undefined;
      var actionOrder = [];
      var component = undefined;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        },
        allactions: _emberRuntime.A([{ title: 'Rock', name: 'rock' }, { title: 'Paper', name: 'paper' }, { title: 'Scissors', name: 'scissors' }]),
        actions: {
          rock: function () {
            lastAction = 'rock';
            actionOrder.push('rock');
          },
          paper: function () {
            lastAction = 'paper';
            actionOrder.push('paper');
          },
          scissors: function () {
            lastAction = 'scissors';
            actionOrder.push('scissors');
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '{{#each allactions as |allaction|}}<a id="{{allaction.name}}" {{action allaction.name}}>{{allaction.title}}</a>{{/each}}'
      });

      this.render('{{example-component}}');

      var test = this;

      function testBoundAction(propertyValue) {
        test.runTask(function () {
          component.$('#' + propertyValue).click();
        });

        test.assert.ok(lastAction, propertyValue, 'lastAction set to ' + propertyValue);
      }

      testBoundAction('rock');
      testBoundAction('paper');
      testBoundAction('scissors');

      this.assert.deepEqual(actionOrder, ['rock', 'paper', 'scissors'], 'action name was looked up properly');
    };

    _class2.prototype['@test a quoteless function parameter should be called, including arguments'] = function testAQuotelessFunctionParameterShouldBeCalledIncludingArguments() {
      var _this27 = this;

      var submitCalled = false;
      var incomingArg = undefined;

      var arg = 'rough ray';

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        submit: function (actualArg) {
          incomingArg = actualArg;
          submitCalled = true;
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a {{action submit \'' + arg + '\'}}>Hi</a>'
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        _this27.$('a').click();
      });

      this.assert.ok(submitCalled, 'submit function called');
      this.assert.equal(incomingArg, arg, 'argument passed');
    };

    _class2.prototype['@test a quoteless parameter that does not resolve to a value asserts'] = function testAQuotelessParameterThatDoesNotResolveToAValueAsserts() {
      var _this28 = this;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          ohNoeNotValid: function () {}
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a id="oops-bound-param" {{action ohNoeNotValid}}>Hi</a>'
      });

      expectAssertion(function () {
        _this28.render('{{example-component}}');
      }, 'You specified a quoteless path, `ohNoeNotValid`, to the {{action}} helper ' + 'which did not resolve to an action name (a string). ' + 'Perhaps you meant to use a quoted actionName? (e.g. {{action "ohNoeNotValid"}}).');
    };

    _class2.prototype['@test allows multiple actions on a single element'] = function testAllowsMultipleActionsOnASingleElement() {
      var _this29 = this;

      var clickActionWasCalled = false;
      var doubleClickActionWasCalled = false;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          clicked: function () {
            clickActionWasCalled = true;
          },
          doubleClicked: function () {
            doubleClickActionWasCalled = true;
          }
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject4)
      });

      this.render('{{example-component}}');

      this.runTask(function () {
        _this29.$('a').trigger('click');
      });

      this.assert.ok(clickActionWasCalled, 'the clicked action was called');

      this.runTask(function () {
        _this29.$('a').trigger('dblclick');
      });

      this.assert.ok(doubleClickActionWasCalled, 'the doubleClicked action was called');
    };

    _class2.prototype['@test it should respect preventDefault option if provided'] = function testItShouldRespectPreventDefaultOptionIfProvided() {
      var _this30 = this;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          show: function () {}
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a {{action "show" preventDefault=false}}>Hi</a>'
      });

      this.render('{{example-component}}');

      var event = _emberViews.jQuery.Event('click');

      this.runTask(function () {
        _this30.$('a').trigger(event);
      });

      this.assert.equal(event.isDefaultPrevented(), false, 'should not preventDefault');
    };

    _class2.prototype['@test it should respect preventDefault option if provided bound'] = function testItShouldRespectPreventDefaultOptionIfProvidedBound() {
      var _this31 = this;

      var component = undefined;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        shouldPreventDefault: false,
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        },
        actions: {
          show: function () {}
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<a {{action "show" preventDefault=shouldPreventDefault}}>Hi</a>'
      });

      this.render('{{example-component}}');

      var event = _emberViews.jQuery.Event('click');

      this.runTask(function () {
        _this31.$('a').trigger(event);
      });

      this.assert.equal(event.isDefaultPrevented(), false, 'should not preventDefault');

      event = _emberViews.jQuery.Event('click');

      this.runTask(function () {
        component.set('shouldPreventDefault', true);
        _this31.$('a').trigger(event);
      });

      this.assert.equal(event.isDefaultPrevented(), true, 'should preventDefault');
    };

    _class2.prototype['@test it should target the proper component when `action` is in yielded block [GH #12409]'] = function testItShouldTargetTheProperComponentWhenActionIsInYieldedBlockGH12409() {
      var _this32 = this;

      var outerActionCalled = false;
      var innerClickCalled = false;

      var OuterComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        actions: {
          hey: function () {
            outerActionCalled = true;
          }
        }
      });

      var MiddleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({});

      var InnerComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        click: function () {
          innerClickCalled = true;
          this.sendAction();
        }
      });

      this.registerComponent('outer-component', {
        ComponentClass: OuterComponent,
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject5)
      });

      this.registerComponent('middle-component', {
        ComponentClass: MiddleComponent,
        template: '{{yield}}'
      });

      this.registerComponent('inner-component', {
        ComponentClass: InnerComponent,
        template: _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject6)
      });

      this.render('{{outer-component}}');

      this.runTask(function () {
        _this32.$('button').click();
      });

      this.assert.ok(outerActionCalled, 'the action fired on the proper target');
      this.assert.ok(innerClickCalled, 'the click was triggered');
    };

    _class2.prototype['@test element action with (mut undefinedThing) works properly'] = function testElementActionWithMutUndefinedThingWorksProperly() {
      var _this33 = this;

      var component = undefined;

      var ExampleComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        label: undefined,
        init: function () {
          this._super.apply(this, arguments);
          component = this;
        }
      });

      this.registerComponent('example-component', {
        ComponentClass: ExampleComponent,
        template: '<button {{action (mut label) "Clicked!"}}>{{if label label "Click me"}}</button>'
      });

      this.render('{{example-component}}');

      this.assertText('Click me');

      this.assertStableRerender();

      this.runTask(function () {
        _this33.$('button').click();
      });

      this.assertText('Clicked!');

      this.runTask(function () {
        component.set('label', 'Dun clicked');
      });

      this.assertText('Dun clicked');

      this.runTask(function () {
        _this33.$('button').click();
      });

      this.assertText('Clicked!');

      this.runTask(function () {
        component.set('label', undefined);
      });

      this.assertText('Click me');
    };

    return _class2;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/helpers/element-action-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/helpers/element-action-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/helpers/element-action-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/helpers/get-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/helpers', 'ember-metal'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsHelpers, _emberMetal) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: {{get}}', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test should be able to get an object value with a static key'] = function testShouldBeAbleToGetAnObjectValueWithAStaticKey() {
      var _this = this;

      this.render('[{{get colors \'apple\'}}] [{{if true (get colors \'apple\')}}]', {
        colors: { apple: 'red' }
      });

      this.assertText('[red] [red]');

      this.runTask(function () {
        return _this.rerender();
      });

      this.assertText('[red] [red]');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'colors.apple', 'green');
      });

      this.assertText('[green] [green]');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'colors', {
          apple: 'red'
        });
      });

      this.assertText('[red] [red]');
    };

    _class.prototype['@test should be able to get an object value with nested static key'] = function testShouldBeAbleToGetAnObjectValueWithNestedStaticKey() {
      var _this2 = this;

      this.render('[{{get colors "apple.gala"}}] [{{if true (get colors "apple.gala")}}]', {
        colors: {
          apple: {
            gala: 'red and yellow'
          }
        }
      });

      this.assertText('[red and yellow] [red and yellow]');

      this.runTask(function () {
        return _this2.rerender();
      });

      this.assertText('[red and yellow] [red and yellow]');

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'colors.apple.gala', 'yellow and red striped');
      });

      this.assertText('[yellow and red striped] [yellow and red striped]');

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'colors', { apple: { gala: 'red and yellow' } });
      });

      this.assertText('[red and yellow] [red and yellow]');
    };

    _class.prototype['@test should be able to get an object value with a bound/dynamic key'] = function testShouldBeAbleToGetAnObjectValueWithABoundDynamicKey() {
      var _this3 = this;

      this.render('[{{get colors key}}] [{{if true (get colors key)}}]', {
        colors: { apple: 'red', banana: 'yellow' },
        key: 'apple'
      });

      this.assertText('[red] [red]');

      this.runTask(function () {
        return _this3.rerender();
      });

      this.assertText('[red] [red]');

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'key', 'banana');
      });

      this.assertText('[yellow] [yellow]');

      this.runTask(function () {
        _emberMetal.set(_this3.context, 'colors.apple', 'green');
        _emberMetal.set(_this3.context, 'colors.banana', 'purple');
      });

      this.assertText('[purple] [purple]');

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'key', 'apple');
      });

      this.assertText('[green] [green]');

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'colors', { apple: 'red' });
      });

      this.assertText('[red] [red]');
    };

    _class.prototype['@test should be able to get an object value with nested dynamic key'] = function testShouldBeAbleToGetAnObjectValueWithNestedDynamicKey() {
      var _this4 = this;

      this.render('[{{get colors key}}] [{{if true (get colors key)}}]', {
        colors: {
          apple: {
            gala: 'red and yellow',
            mcintosh: 'red'
          },
          banana: 'yellow'
        },
        key: 'apple.gala'
      });

      this.assertText('[red and yellow] [red and yellow]');

      this.runTask(function () {
        return _this4.rerender();
      });

      this.assertText('[red and yellow] [red and yellow]');

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'key', 'apple.mcintosh');
      });

      this.assertText('[red] [red]');

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'key', 'banana');
      });

      this.assertText('[yellow] [yellow]');

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'key', 'apple.gala');
      });

      this.assertText('[red and yellow] [red and yellow]');
    };

    _class.prototype['@test should be able to get an object value with subexpression returning nested key'] = function testShouldBeAbleToGetAnObjectValueWithSubexpressionReturningNestedKey() {
      var _this5 = this;

      this.render('[{{get colors (concat \'apple\' \'.\' \'gala\')}}] [{{if true (get colors (concat \'apple\' \'.\' \'gala\'))}}]', {
        colors: {
          apple: {
            gala: 'red and yellow',
            mcintosh: 'red'
          }
        },
        key: 'apple.gala'
      });

      this.assertText('[red and yellow] [red and yellow]');

      this.runTask(function () {
        return _this5.rerender();
      });

      this.assertText('[red and yellow] [red and yellow]');

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'colors.apple.gala', 'yellow and red striped');
      });

      this.assertText('[yellow and red striped] [yellow and red striped]');

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'colors.apple.gala', 'yellow-redish');
      });

      this.assertText('[yellow-redish] [yellow-redish]');

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'colors', {
          apple: {
            gala: 'red and yellow',
            mcintosh: 'red'
          }
        });
      });

      this.assertText('[red and yellow] [red and yellow]');
    };

    _class.prototype['@test should be able to get an object value with a get helper as the key'] = function testShouldBeAbleToGetAnObjectValueWithAGetHelperAsTheKey() {
      var _this6 = this;

      this.render('[{{get colors (get possibleKeys key)}}] [{{if true (get colors (get possibleKeys key))}}]', {
        colors: { apple: 'red', banana: 'yellow' },
        key: 'key1',
        possibleKeys: { key1: 'apple', key2: 'banana' }
      });

      this.assertText('[red] [red]');

      this.runTask(function () {
        return _this6.rerender();
      });

      this.assertText('[red] [red]');

      this.runTask(function () {
        return _emberMetal.set(_this6.context, 'key', 'key2');
      });

      this.assertText('[yellow] [yellow]');

      this.runTask(function () {
        _emberMetal.set(_this6.context, 'colors.apple', 'green');
        _emberMetal.set(_this6.context, 'colors.banana', 'purple');
      });

      this.assertText('[purple] [purple]');

      this.runTask(function () {
        return _emberMetal.set(_this6.context, 'key', 'key1');
      });

      this.assertText('[green] [green]');

      this.runTask(function () {
        return _emberMetal.set(_this6.context, 'colors', { apple: 'red', banana: 'yellow' });
      });

      this.assertText('[red] [red]');
    };

    _class.prototype['@test should be able to get an object value with a get helper value as a bound/dynamic key'] = function testShouldBeAbleToGetAnObjectValueWithAGetHelperValueAsABoundDynamicKey() {
      var _this7 = this;

      this.render('[{{get (get possibleValues objectKey) key}}] [{{if true (get (get possibleValues objectKey) key)}}]', {
        possibleValues: {
          colors1: { apple: 'red', banana: 'yellow' },
          colors2: { apple: 'green', banana: 'purple' }
        },
        objectKey: 'colors1',
        key: 'apple'
      });

      this.assertText('[red] [red]');

      this.runTask(function () {
        return _this7.rerender();
      });

      this.assertText('[red] [red]');

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'objectKey', 'colors2');
      });

      this.assertText('[green] [green]');

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'objectKey', 'colors1');
      });

      this.assertText('[red] [red]');

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'key', 'banana');
      });

      this.assertText('[yellow] [yellow]');

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'objectKey', 'colors2');
      });

      this.assertText('[purple] [purple]');

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'objectKey', 'colors1');
      });

      this.assertText('[yellow] [yellow]');

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'key', 'apple');
      });
    };

    _class.prototype['@test should be able to get an object value with a get helper as the value and a get helper as the key'] = function testShouldBeAbleToGetAnObjectValueWithAGetHelperAsTheValueAndAGetHelperAsTheKey() {
      var _this8 = this;

      this.render('[{{get (get possibleValues objectKey) (get possibleKeys key)}}] [{{if true (get (get possibleValues objectKey) (get possibleKeys key))}}]', {
        possibleValues: {
          colors1: { apple: 'red', banana: 'yellow' },
          colors2: { apple: 'green', banana: 'purple' }
        },
        objectKey: 'colors1',
        possibleKeys: {
          key1: 'apple',
          key2: 'banana'
        },
        key: 'key1'
      });

      this.assertText('[red] [red]');

      this.runTask(function () {
        return _this8.rerender();
      });

      this.assertText('[red] [red]');

      this.runTask(function () {
        return _emberMetal.set(_this8.context, 'objectKey', 'colors2');
      });

      this.assertText('[green] [green]');

      this.runTask(function () {
        return _emberMetal.set(_this8.context, 'objectKey', 'colors1');
      });

      this.assertText('[red] [red]');

      this.runTask(function () {
        return _emberMetal.set(_this8.context, 'key', 'key2');
      });

      this.assertText('[yellow] [yellow]');

      this.runTask(function () {
        return _emberMetal.set(_this8.context, 'objectKey', 'colors2');
      });

      this.assertText('[purple] [purple]');

      this.runTask(function () {
        _emberMetal.set(_this8.context, 'objectKey', 'colors1');
        _emberMetal.set(_this8.context, 'key', 'key1');
      });

      this.assertText('[red] [red]');
    };

    _class.prototype['@test the result of a get helper can be yielded'] = function testTheResultOfAGetHelperCanBeYielded() {
      var _this9 = this;

      var fooBarInstance = undefined;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super();
          fooBarInstance = this;
          this.mcintosh = 'red';
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{yield (get colors mcintosh)}}'
      });

      this.render('{{#foo-bar colors=colors as |value|}}{{value}}{{/foo-bar}}', {
        colors: {
          red: 'banana'
        }
      });

      this.assertText('banana');

      this.runTask(function () {
        return _this9.rerender();
      });

      this.assertText('banana');

      this.runTask(function () {
        _emberMetal.set(fooBarInstance, 'mcintosh', 'yellow');
        _emberMetal.set(_this9.context, 'colors', { yellow: 'bus' });
      });

      this.assertText('bus');

      this.runTask(function () {
        _emberMetal.set(fooBarInstance, 'mcintosh', 'red');
        _emberMetal.set(_this9.context, 'colors', { red: 'banana' });
      });

      this.assertText('banana');
    };

    _class.prototype['@test should handle object values as nulls'] = function testShouldHandleObjectValuesAsNulls() {
      var _this10 = this;

      this.render('[{{get colors \'apple\'}}] [{{if true (get colors \'apple\')}}]', {
        colors: null
      });

      this.assertText('[] []');

      this.runTask(function () {
        return _this10.rerender();
      });

      this.assertText('[] []');

      this.runTask(function () {
        return _emberMetal.set(_this10.context, 'colors', { apple: 'green', banana: 'purple' });
      });

      this.assertText('[green] [green]');

      this.runTask(function () {
        return _emberMetal.set(_this10.context, 'colors', null);
      });

      this.assertText('[] []');
    };

    _class.prototype['@test should handle object keys as nulls'] = function testShouldHandleObjectKeysAsNulls() {
      var _this11 = this;

      this.render('[{{get colors key}}] [{{if true (get colors key)}}]', {
        colors: {
          apple: 'red',
          banana: 'yellow'
        },
        key: null
      });

      this.assertText('[] []');

      this.runTask(function () {
        return _this11.rerender();
      });

      this.assertText('[] []');

      this.runTask(function () {
        return _emberMetal.set(_this11.context, 'key', 'banana');
      });

      this.assertText('[yellow] [yellow]');

      this.runTask(function () {
        return _emberMetal.set(_this11.context, 'key', null);
      });

      this.assertText('[] []');
    };

    _class.prototype['@test should handle object values and keys as nulls'] = function testShouldHandleObjectValuesAndKeysAsNulls() {
      this.render('[{{get colors \'apple\'}}] [{{if true (get colors key)}}]', {
        colors: null,
        key: null
      });

      this.assertText('[] []');
    };

    _class.prototype['@test get helper value should be updatable using {{input}} and (mut) - static key'] = function testGetHelperValueShouldBeUpdatableUsingInputAndMutStaticKey(assert) {
      var _this12 = this;

      this.render('{{input type=\'text\' value=(mut (get source \'banana\')) id=\'get-input\'}}', {
        source: {
          banana: 'banana'
        }
      });

      assert.strictEqual(this.$('#get-input').val(), 'banana');

      this.runTask(function () {
        return _this12.rerender();
      });

      assert.strictEqual(this.$('#get-input').val(), 'banana');

      this.runTask(function () {
        return _emberMetal.set(_this12.context, 'source.banana', 'yellow');
      });

      assert.strictEqual(this.$('#get-input').val(), 'yellow');

      this.runTask(function () {
        return _this12.$('#get-input').val('some value').trigger('change');
      });

      assert.strictEqual(this.$('#get-input').val(), 'some value');
      assert.strictEqual(_emberMetal.get(this.context, 'source.banana'), 'some value');

      this.runTask(function () {
        return _emberMetal.set(_this12.context, 'source', { banana: 'banana' });
      });

      assert.strictEqual(this.$('#get-input').val(), 'banana');
    };

    _class.prototype['@test get helper value should be updatable using {{input}} and (mut) - dynamic key'] = function testGetHelperValueShouldBeUpdatableUsingInputAndMutDynamicKey(assert) {
      var _this13 = this;

      this.render('{{input type=\'text\' value=(mut (get source key)) id=\'get-input\'}}', {
        source: {
          apple: 'apple',
          banana: 'banana'
        },
        key: 'banana'
      });

      assert.strictEqual(this.$('#get-input').val(), 'banana');

      this.runTask(function () {
        return _this13.rerender();
      });

      assert.strictEqual(this.$('#get-input').val(), 'banana');

      this.runTask(function () {
        return _emberMetal.set(_this13.context, 'source.banana', 'yellow');
      });

      assert.strictEqual(this.$('#get-input').val(), 'yellow');

      this.runTask(function () {
        return _this13.$('#get-input').val('some value').trigger('change');
      });

      assert.strictEqual(this.$('#get-input').val(), 'some value');
      assert.strictEqual(_emberMetal.get(this.context, 'source.banana'), 'some value');

      this.runTask(function () {
        return _emberMetal.set(_this13.context, 'key', 'apple');
      });

      assert.strictEqual(this.$('#get-input').val(), 'apple');

      this.runTask(function () {
        return _this13.$('#get-input').val('some other value').trigger('change');
      });

      assert.strictEqual(this.$('#get-input').val(), 'some other value');
      assert.strictEqual(_emberMetal.get(this.context, 'source.apple'), 'some other value');

      this.runTask(function () {
        _emberMetal.set(_this13.context, 'key', 'banana');
        _emberMetal.set(_this13.context, 'source', { banana: 'banana' });
      });

      assert.strictEqual(this.$('#get-input').val(), 'banana');
    };

    _class.prototype['@test get helper value should be updatable using {{input}} and (mut) - dynamic nested key'] = function testGetHelperValueShouldBeUpdatableUsingInputAndMutDynamicNestedKey(assert) {
      var _this14 = this;

      this.render('{{input type=\'text\' value=(mut (get source key)) id=\'get-input\'}}', {
        source: {
          apple: {
            gala: 'gala',
            mcintosh: 'mcintosh'
          },
          banana: 'banana'
        },
        key: 'apple.mcintosh'
      });

      assert.strictEqual(this.$('#get-input').val(), 'mcintosh');

      this.runTask(function () {
        return _this14.rerender();
      });

      assert.strictEqual(this.$('#get-input').val(), 'mcintosh');

      this.runTask(function () {
        return _emberMetal.set(_this14.context, 'source.apple.mcintosh', 'red');
      });

      assert.strictEqual(this.$('#get-input').val(), 'red');

      this.runTask(function () {
        return _this14.$('#get-input').val('some value').trigger('change');
      });

      assert.strictEqual(this.$('#get-input').val(), 'some value');
      assert.strictEqual(_emberMetal.get(this.context, 'source.apple.mcintosh'), 'some value');

      this.runTask(function () {
        return _emberMetal.set(_this14.context, 'key', 'apple.gala');
      });

      assert.strictEqual(this.$('#get-input').val(), 'gala');

      this.runTask(function () {
        return _this14.$('#get-input').val('some other value').trigger('change');
      });

      assert.strictEqual(this.$('#get-input').val(), 'some other value');
      assert.strictEqual(_emberMetal.get(this.context, 'source.apple.gala'), 'some other value');

      this.runTask(function () {
        return _emberMetal.set(_this14.context, 'key', 'banana');
      });

      assert.strictEqual(this.$('#get-input').val(), 'banana');

      this.runTask(function () {
        return _this14.$('#get-input').val('yet another value').trigger('change');
      });

      assert.strictEqual(this.$('#get-input').val(), 'yet another value');
      assert.strictEqual(_emberMetal.get(this.context, 'source.banana'), 'yet another value');

      this.runTask(function () {
        _emberMetal.set(_this14.context, 'key', 'apple.mcintosh');
        _emberMetal.set(_this14.context, 'source', {
          apple: {
            gala: 'gala',
            mcintosh: 'mcintosh'
          },
          banana: 'banana'
        });
      });

      assert.strictEqual(this.$('#get-input').val(), 'mcintosh');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/helpers/get-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/helpers/get-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/helpers/get-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/helpers/hash-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/helpers', 'ember-metal'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsHelpers, _emberMetal) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: {{hash}}', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test returns a hash with the right key-value'] = function testReturnsAHashWithTheRightKeyValue() {
      var _this = this;

      this.render('{{#with (hash name="Sergio") as |person|}}{{person.name}}{{/with}}');

      this.assertText('Sergio');

      this.runTask(function () {
        return _this.rerender();
      });

      this.assertText('Sergio');
    };

    _class.prototype['@test can have more than one key-value'] = function testCanHaveMoreThanOneKeyValue() {
      var _this2 = this;

      this.render('{{#with (hash name="Sergio" lastName="Arbeo") as |person|}}{{person.name}} {{person.lastName}}{{/with}}');

      this.assertText('Sergio Arbeo');

      this.runTask(function () {
        return _this2.rerender();
      });

      this.assertText('Sergio Arbeo');
    };

    _class.prototype['@test binds values when variables are used'] = function testBindsValuesWhenVariablesAreUsed() {
      var _this3 = this;

      this.render('{{#with (hash name=model.firstName lastName="Arbeo") as |person|}}{{person.name}} {{person.lastName}}{{/with}}', {
        model: {
          firstName: 'Marisa'
        }
      });

      this.assertText('Marisa Arbeo');

      this.runTask(function () {
        return _this3.rerender();
      });

      this.assertText('Marisa Arbeo');

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'model.firstName', 'Sergio');
      });

      this.assertText('Sergio Arbeo');

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'model', { firstName: 'Marisa' });
      });

      this.assertText('Marisa Arbeo');
    };

    _class.prototype['@test binds multiple values when variables are used'] = function testBindsMultipleValuesWhenVariablesAreUsed() {
      var _this4 = this;

      this.render('{{#with (hash name=model.firstName lastName=model.lastName) as |person|}}{{person.name}} {{person.lastName}}{{/with}}', {
        model: {
          firstName: 'Marisa',
          lastName: 'Arbeo'
        }
      });

      this.assertText('Marisa Arbeo');

      this.runTask(function () {
        return _this4.rerender();
      });

      this.assertText('Marisa Arbeo');

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'model.firstName', 'Sergio');
      });

      this.assertText('Sergio Arbeo');

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'model.lastName', 'Smith');
      });

      this.assertText('Sergio Smith');

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'model', {
          firstName: 'Marisa',
          lastName: 'Arbeo'
        });
      });

      this.assertText('Marisa Arbeo');
    };

    _class.prototype['@test hash helpers can be nested'] = function testHashHelpersCanBeNested() {
      var _this5 = this;

      this.render('{{#with (hash person=(hash name=model.firstName)) as |ctx|}}{{ctx.person.name}}{{/with}}', {
        model: { firstName: 'Balint' }
      });

      this.assertText('Balint');

      this.runTask(function () {
        return _this5.rerender();
      });

      this.assertText('Balint');

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'model.firstName', 'Chad');
      });

      this.assertText('Chad');

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'model', { firstName: 'Balint' });
      });

      this.assertText('Balint');
    };

    _class.prototype['@test should yield hash of internal properties'] = function testShouldYieldHashOfInternalProperties() {
      var _this6 = this;

      var fooBarInstance = undefined;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super();
          fooBarInstance = this;
          this.model = { firstName: 'Chad' };
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{yield (hash firstName=model.firstName)}}'
      });

      this.render('{{#foo-bar as |values|}}{{values.firstName}}{{/foo-bar}}');

      this.assertText('Chad');

      this.runTask(function () {
        return _this6.rerender();
      });

      this.assertText('Chad');

      this.runTask(function () {
        return _emberMetal.set(fooBarInstance, 'model.firstName', 'Godfrey');
      });

      this.assertText('Godfrey');

      this.runTask(function () {
        return _emberMetal.set(fooBarInstance, 'model', { firstName: 'Chad' });
      });

      this.assertText('Chad');
    };

    _class.prototype['@test should yield hash of internal and external properties'] = function testShouldYieldHashOfInternalAndExternalProperties() {
      var _this7 = this;

      var fooBarInstance = undefined;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super();
          fooBarInstance = this;
          this.model = { firstName: 'Chad' };
        }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{yield (hash firstName=model.firstName lastName=lastName)}}'
      });

      this.render('{{#foo-bar lastName=model.lastName as |values|}}{{values.firstName}} {{values.lastName}}{{/foo-bar}}', {
        model: { lastName: 'Hietala' }
      });

      this.assertText('Chad Hietala');

      this.runTask(function () {
        return _this7.rerender();
      });

      this.assertText('Chad Hietala');

      this.runTask(function () {
        _emberMetal.set(fooBarInstance, 'model.firstName', 'Godfrey');
        _emberMetal.set(_this7.context, 'model.lastName', 'Chan');
      });

      this.assertText('Godfrey Chan');

      this.runTask(function () {
        _emberMetal.set(fooBarInstance, 'model', { firstName: 'Chad' });
        _emberMetal.set(_this7.context, 'model', { lastName: 'Hietala' });
      });

      this.assertText('Chad Hietala');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/helpers/hash-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/helpers/hash-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/helpers/hash-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/helpers/if-unless-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/shared-conditional-tests'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsSharedConditionalTests) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: inline {{if}}', (function (_IfUnlessHelperTest) {
    babelHelpers.inherits(_class, _IfUnlessHelperTest);

    function _class() {
      _IfUnlessHelperTest.apply(this, arguments);
    }

    _class.prototype.templateFor = function templateFor(_ref) {
      var cond = _ref.cond;
      var truthy = _ref.truthy;
      var falsy = _ref.falsy;

      return '{{if ' + cond + ' ' + truthy + ' ' + falsy + '}}';
    };

    _class.prototype['@test it raises when there are more than three arguments'] = function testItRaisesWhenThereAreMoreThanThreeArguments() {
      var _this = this;

      expectAssertion(function () {
        _this.render('{{if condition \'a\' \'b\' \'c\'}}', { condition: true });
      }, /The inline form of the `if` helper expects two or three arguments/);
    };

    _class.prototype['@test it raises when there are less than two arguments'] = function testItRaisesWhenThereAreLessThanTwoArguments() {
      var _this2 = this;

      expectAssertion(function () {
        _this2.render('{{if condition}}', { condition: true });
      }, /The inline form of the `if` helper expects two or three arguments/);
    };

    return _class;
  })(_emberGlimmerTestsUtilsSharedConditionalTests.IfUnlessHelperTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: nested {{if}} helpers (returning truthy values)', (function (_IfUnlessHelperTest2) {
    babelHelpers.inherits(_class2, _IfUnlessHelperTest2);

    function _class2() {
      _IfUnlessHelperTest2.apply(this, arguments);
    }

    _class2.prototype.templateFor = function templateFor(_ref2) {
      var cond = _ref2.cond;
      var truthy = _ref2.truthy;
      var falsy = _ref2.falsy;

      return '{{if (if ' + cond + ' ' + cond + ' false) ' + truthy + ' ' + falsy + '}}';
    };

    return _class2;
  })(_emberGlimmerTestsUtilsSharedConditionalTests.IfUnlessHelperTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: nested {{if}} helpers (returning falsy values)', (function (_IfUnlessHelperTest3) {
    babelHelpers.inherits(_class3, _IfUnlessHelperTest3);

    function _class3() {
      _IfUnlessHelperTest3.apply(this, arguments);
    }

    _class3.prototype.templateFor = function templateFor(_ref3) {
      var cond = _ref3.cond;
      var truthy = _ref3.truthy;
      var falsy = _ref3.falsy;

      return '{{if (if ' + cond + ' true ' + cond + ') ' + truthy + ' ' + falsy + '}}';
    };

    return _class3;
  })(_emberGlimmerTestsUtilsSharedConditionalTests.IfUnlessHelperTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: {{if}} used with another helper', (function (_IfUnlessHelperTest4) {
    babelHelpers.inherits(_class4, _IfUnlessHelperTest4);

    function _class4() {
      _IfUnlessHelperTest4.apply(this, arguments);
    }

    _class4.prototype.wrapperFor = function wrapperFor(templates) {
      return '{{concat ' + templates.join(' ') + '}}';
    };

    _class4.prototype.templateFor = function templateFor(_ref4) {
      var cond = _ref4.cond;
      var truthy = _ref4.truthy;
      var falsy = _ref4.falsy;

      return '(if ' + cond + ' ' + truthy + ' ' + falsy + ')';
    };

    return _class4;
  })(_emberGlimmerTestsUtilsSharedConditionalTests.IfUnlessHelperTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: {{if}} used in attribute position', (function (_IfUnlessHelperTest5) {
    babelHelpers.inherits(_class5, _IfUnlessHelperTest5);

    function _class5() {
      _IfUnlessHelperTest5.apply(this, arguments);
    }

    _class5.prototype.wrapperFor = function wrapperFor(templates) {
      return '<div data-foo="' + templates.join('') + '" />';
    };

    _class5.prototype.templateFor = function templateFor(_ref5) {
      var cond = _ref5.cond;
      var truthy = _ref5.truthy;
      var falsy = _ref5.falsy;

      return '{{if ' + cond + ' ' + truthy + ' ' + falsy + '}}';
    };

    _class5.prototype.textValue = function textValue() {
      return this.$('div').attr('data-foo');
    };

    return _class5;
  })(_emberGlimmerTestsUtilsSharedConditionalTests.IfUnlessHelperTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: inline {{if}} and {{unless}} without the inverse argument', (function (_IfUnlessHelperTest6) {
    babelHelpers.inherits(_class6, _IfUnlessHelperTest6);

    function _class6() {
      _IfUnlessHelperTest6.apply(this, arguments);
    }

    _class6.prototype.templateFor = function templateFor(_ref6) {
      var cond = _ref6.cond;
      var truthy = _ref6.truthy;
      var falsy = _ref6.falsy;

      return '{{if ' + cond + ' ' + truthy + '}}{{unless ' + cond + ' ' + falsy + '}}';
    };

    return _class6;
  })(_emberGlimmerTestsUtilsSharedConditionalTests.IfUnlessHelperTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: inline {{unless}}', (function (_IfUnlessHelperTest7) {
    babelHelpers.inherits(_class7, _IfUnlessHelperTest7);

    function _class7() {
      _IfUnlessHelperTest7.apply(this, arguments);
    }

    _class7.prototype.templateFor = function templateFor(_ref7) {
      var cond = _ref7.cond;
      var truthy = _ref7.truthy;
      var falsy = _ref7.falsy;

      return '{{unless ' + cond + ' ' + falsy + ' ' + truthy + '}}';
    };

    _class7.prototype['@test it raises when there are more than three arguments'] = function testItRaisesWhenThereAreMoreThanThreeArguments() {
      var _this3 = this;

      expectAssertion(function () {
        _this3.render('{{unless condition \'a\' \'b\' \'c\'}}', { condition: true });
      }, /The inline form of the `unless` helper expects two or three arguments/);
    };

    _class7.prototype['@test it raises when there are less than two arguments'] = function testItRaisesWhenThereAreLessThanTwoArguments() {
      var _this4 = this;

      expectAssertion(function () {
        _this4.render('{{unless condition}}', { condition: true });
      }, /The inline form of the `unless` helper expects two or three arguments/);
    };

    return _class7;
  })(_emberGlimmerTestsUtilsSharedConditionalTests.IfUnlessHelperTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: nested {{unless}} helpers (returning truthy values)', (function (_IfUnlessHelperTest8) {
    babelHelpers.inherits(_class8, _IfUnlessHelperTest8);

    function _class8() {
      _IfUnlessHelperTest8.apply(this, arguments);
    }

    _class8.prototype.templateFor = function templateFor(_ref8) {
      var cond = _ref8.cond;
      var truthy = _ref8.truthy;
      var falsy = _ref8.falsy;

      return '{{unless (unless ' + cond + ' false ' + cond + ') ' + falsy + ' ' + truthy + '}}';
    };

    return _class8;
  })(_emberGlimmerTestsUtilsSharedConditionalTests.IfUnlessHelperTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: nested {{unless}} helpers (returning falsy values)', (function (_IfUnlessHelperTest9) {
    babelHelpers.inherits(_class9, _IfUnlessHelperTest9);

    function _class9() {
      _IfUnlessHelperTest9.apply(this, arguments);
    }

    _class9.prototype.templateFor = function templateFor(_ref9) {
      var cond = _ref9.cond;
      var truthy = _ref9.truthy;
      var falsy = _ref9.falsy;

      return '{{unless (unless ' + cond + ' ' + cond + ' true) ' + falsy + ' ' + truthy + '}}';
    };

    return _class9;
  })(_emberGlimmerTestsUtilsSharedConditionalTests.IfUnlessHelperTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: {{unless}} used with another helper', (function (_IfUnlessHelperTest10) {
    babelHelpers.inherits(_class10, _IfUnlessHelperTest10);

    function _class10() {
      _IfUnlessHelperTest10.apply(this, arguments);
    }

    _class10.prototype.wrapperFor = function wrapperFor(templates) {
      return '{{concat ' + templates.join(' ') + '}}';
    };

    _class10.prototype.templateFor = function templateFor(_ref10) {
      var cond = _ref10.cond;
      var truthy = _ref10.truthy;
      var falsy = _ref10.falsy;

      return '(unless ' + cond + ' ' + falsy + ' ' + truthy + ')';
    };

    return _class10;
  })(_emberGlimmerTestsUtilsSharedConditionalTests.IfUnlessHelperTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: {{unless}} used in attribute position', (function (_IfUnlessHelperTest11) {
    babelHelpers.inherits(_class11, _IfUnlessHelperTest11);

    function _class11() {
      _IfUnlessHelperTest11.apply(this, arguments);
    }

    _class11.prototype.wrapperFor = function wrapperFor(templates) {
      return '<div data-foo="' + templates.join('') + '" />';
    };

    _class11.prototype.templateFor = function templateFor(_ref11) {
      var cond = _ref11.cond;
      var truthy = _ref11.truthy;
      var falsy = _ref11.falsy;

      return '{{unless ' + cond + ' ' + falsy + ' ' + truthy + '}}';
    };

    _class11.prototype.textValue = function textValue() {
      return this.$('div').attr('data-foo');
    };

    return _class11;
  })(_emberGlimmerTestsUtilsSharedConditionalTests.IfUnlessHelperTest));
});
enifed('ember-glimmer/tests/integration/helpers/if-unless-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/helpers/if-unless-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/helpers/if-unless-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/helpers/input-test', ['exports', 'ember-utils', 'ember-metal', 'ember-glimmer/tests/utils/helpers', 'ember-glimmer/tests/utils/test-case', 'internal-test-helpers'], function (exports, _emberUtils, _emberMetal, _emberGlimmerTestsUtilsHelpers, _emberGlimmerTestsUtilsTestCase, _internalTestHelpers) {
  'use strict';

  var InputRenderingTest = (function (_RenderingTest) {
    babelHelpers.inherits(InputRenderingTest, _RenderingTest);

    function InputRenderingTest() {
      _RenderingTest.call(this);

      this.registerComponent('-text-field', { ComponentClass: _emberGlimmerTestsUtilsHelpers.TextField });
      this.registerComponent('-checkbox', { ComponentClass: _emberGlimmerTestsUtilsHelpers.Checkbox });
    }

    InputRenderingTest.prototype.$input = function $input() {
      return this.$('input');
    };

    InputRenderingTest.prototype.inputID = function inputID() {
      return this.$input().prop('id');
    };

    InputRenderingTest.prototype.assertDisabled = function assertDisabled() {
      this.assert.ok(this.$('input').prop('disabled'), 'The input is disabled');
    };

    InputRenderingTest.prototype.assertNotDisabled = function assertNotDisabled() {
      this.assert.ok(this.$('input').is(':not(:disabled)'), 'The input is not disabled');
    };

    InputRenderingTest.prototype.assertInputId = function assertInputId(expectedId) {
      this.assert.equal(this.inputID(), expectedId, 'the input id should be `expectedId`');
    };

    InputRenderingTest.prototype.assertSingleInput = function assertSingleInput() {
      this.assert.equal(this.$('input').length, 1, 'A single text field was inserted');
    };

    InputRenderingTest.prototype.assertSingleCheckbox = function assertSingleCheckbox() {
      this.assert.equal(this.$('input[type=checkbox]').length, 1, 'A single checkbox is added');
    };

    InputRenderingTest.prototype.assertCheckboxIsChecked = function assertCheckboxIsChecked() {
      this.assert.equal(this.$input().prop('checked'), true, 'the checkbox is checked');
    };

    InputRenderingTest.prototype.assertCheckboxIsNotChecked = function assertCheckboxIsNotChecked() {
      this.assert.equal(this.$input().prop('checked'), false, 'the checkbox is not checked');
    };

    InputRenderingTest.prototype.assertValue = function assertValue(expected) {
      this.assert.equal(this.$input().val(), expected, 'the input value should be ' + expected);
    };

    InputRenderingTest.prototype.assertAttr = function assertAttr(name, expected) {
      this.assert.equal(this.$input().attr(name), expected, 'the input ' + name + ' attribute has the value \'' + expected + '\'');
    };

    InputRenderingTest.prototype.assertAllAttrs = function assertAllAttrs(names, expected) {
      var _this = this;

      names.forEach(function (name) {
        return _this.assertAttr(name, expected);
      });
    };

    InputRenderingTest.prototype.assertSelectionRange = function assertSelectionRange(start, end) {
      var input = this.$input()[0];
      this.assert.equal(input.selectionStart, start, 'the cursor start position should be ' + start);
      this.assert.equal(input.selectionEnd, end, 'the cursor end position should be ' + end);
    };

    InputRenderingTest.prototype.triggerEvent = function triggerEvent(type, options) {
      var event = document.createEvent('Events');
      event.initEvent(type, true, true);
      _emberUtils.assign(event, options);

      var element = this.$input()[0];
      this.runTask(function () {
        element.dispatchEvent(event);
      });
    };

    return InputRenderingTest;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest);

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: {{input}}', (function (_InputRenderingTest) {
    babelHelpers.inherits(_class, _InputRenderingTest);

    function _class() {
      _InputRenderingTest.apply(this, arguments);
    }

    _class.prototype['@test a single text field is inserted into the DOM'] = function testASingleTextFieldIsInsertedIntoTheDOM(assert) {
      var _this2 = this;

      this.render('{{input type="text" value=value}}', { value: 'hello' });

      var id = this.inputID();

      this.assertValue('hello');
      this.assertSingleInput();

      this.runTask(function () {
        return _this2.rerender();
      });

      this.assertValue('hello');
      this.assertSingleInput();
      this.assertInputId(id);

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'value', 'goodbye');
      });

      this.assertValue('goodbye');
      this.assertSingleInput();
      this.assertInputId(id);

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'value', 'hello');
      });

      this.assertValue('hello');
      this.assertSingleInput();
      this.assertInputId(id);
    };

    _class.prototype['@test default type'] = function testDefaultType() {
      var _this3 = this;

      this.render('{{input}}');

      this.assertAttr('type', 'text');

      this.runTask(function () {
        return _this3.rerender();
      });

      this.assertAttr('type', 'text');
    };

    _class.prototype['@test dynamic attributes'] = function testDynamicAttributes() {
      var _this4 = this;

      this.render('\n      {{input type="text"\n        disabled=disabled\n        value=value\n        placeholder=placeholder\n        name=name\n        maxlength=maxlength\n        size=size\n        tabindex=tabindex\n      }}', {
        disabled: false,
        value: 'Original value',
        placeholder: 'Original placeholder',
        name: 'original-name',
        maxlength: 10,
        size: 20,
        tabindex: 30
      });

      this.assertNotDisabled();
      this.assertValue('Original value');
      this.assertAttr('placeholder', 'Original placeholder');
      this.assertAttr('name', 'original-name');
      this.assertAttr('maxlength', '10');
      // this.assertAttr('size', '20'); //NOTE: failing in IE  (TEST_SUITE=sauce)
      // this.assertAttr('tabindex', '30'); //NOTE: failing in IE (TEST_SUITE=sauce)

      this.runTask(function () {
        return _this4.rerender();
      });

      this.assertNotDisabled();
      this.assertValue('Original value');
      this.assertAttr('placeholder', 'Original placeholder');
      this.assertAttr('name', 'original-name');
      this.assertAttr('maxlength', '10');
      // this.assertAttr('size', '20'); //NOTE: failing in IE (TEST_SUITE=sauce)
      // this.assertAttr('tabindex', '30'); //NOTE: failing in IE (TEST_SUITE=sauce)

      this.runTask(function () {
        _emberMetal.set(_this4.context, 'value', 'Updated value');
        _emberMetal.set(_this4.context, 'disabled', true);
        _emberMetal.set(_this4.context, 'placeholder', 'Updated placeholder');
        _emberMetal.set(_this4.context, 'name', 'updated-name');
        _emberMetal.set(_this4.context, 'maxlength', 11);
        // set(this.context, 'size', 21); //NOTE: failing in IE (TEST_SUITE=sauce)
        // set(this.context, 'tabindex', 31); //NOTE: failing in IE (TEST_SUITE=sauce)
      });

      this.assertDisabled();
      this.assertValue('Updated value');
      this.assertAttr('placeholder', 'Updated placeholder');
      this.assertAttr('name', 'updated-name');
      this.assertAttr('maxlength', '11');
      // this.assertAttr('size', '21'); //NOTE: failing in IE (TEST_SUITE=sauce)
      // this.assertAttr('tabindex', '31'); //NOTE: failing in IE (TEST_SUITE=sauce)

      this.runTask(function () {
        _emberMetal.set(_this4.context, 'value', 'Original value');
        _emberMetal.set(_this4.context, 'disabled', false);
        _emberMetal.set(_this4.context, 'placeholder', 'Original placeholder');
        _emberMetal.set(_this4.context, 'name', 'original-name');
        _emberMetal.set(_this4.context, 'maxlength', 10);
        // set(this.context, 'size', 20); //NOTE: failing in IE (TEST_SUITE=sauce)
        // set(this.context, 'tabindex', 30); //NOTE: failing in IE (TEST_SUITE=sauce)
      });

      this.assertNotDisabled();
      this.assertValue('Original value');
      this.assertAttr('placeholder', 'Original placeholder');
      this.assertAttr('name', 'original-name');
      this.assertAttr('maxlength', '10');
      // this.assertAttr('size', '20'); //NOTE: failing in IE (TEST_SUITE=sauce)
      // this.assertAttr('tabindex', '30'); //NOTE: failing in IE (TEST_SUITE=sauce)
    };

    _class.prototype['@test static attributes'] = function testStaticAttributes() {
      var _this5 = this;

      this.render('\n      {{input type="text"\n        disabled=true\n        value="Original value"\n        placeholder="Original placeholder"\n        name="original-name"\n        maxlength=10\n        size=20\n        tabindex=30\n      }}');

      this.assertDisabled();
      this.assertValue('Original value');
      this.assertAttr('placeholder', 'Original placeholder');
      this.assertAttr('name', 'original-name');
      this.assertAttr('maxlength', '10');
      // this.assertAttr('size', '20');  //NOTE: failing in IE (TEST_SUITE=sauce)
      // this.assertAttr('tabindex', '30');  //NOTE: failing in IE (TEST_SUITE=sauce)

      this.runTask(function () {
        return _this5.rerender();
      });

      this.assertDisabled();
      this.assertValue('Original value');
      this.assertAttr('placeholder', 'Original placeholder');
      this.assertAttr('name', 'original-name');
      this.assertAttr('maxlength', '10');
      // this.assertAttr('size', '20');  //NOTE: failing in IE (TEST_SUITE=sauce)
      // this.assertAttr('tabindex', '30');  //NOTE: failing in IE (TEST_SUITE=sauce)
    };

    _class.prototype['@test cursor selection range'] = function testCursorSelectionRange(assert) {
      var _this6 = this;

      // Modifying input.selectionStart, which is utilized in the cursor tests,
      // causes an event in Safari.
      _internalTestHelpers.runDestroy(this.owner.lookup('event_dispatcher:main'));

      this.render('{{input type="text" value=value}}', { value: 'original' });

      var input = this.$input()[0];

      // See https://ember-twiddle.com/33e506329f8176ae874422644d4cc08c?openFiles=components.input-component.js%2Ctemplates.components.input-component.hbs
      // this.assertSelectionRange(8, 8); //NOTE: this is (0, 0) on Firefox (TEST_SUITE=sauce)

      this.runTask(function () {
        return _this6.rerender();
      });

      // this.assertSelectionRange(8, 8); //NOTE: this is (0, 0) on Firefox (TEST_SUITE=sauce)

      this.runTask(function () {
        input.selectionStart = 2;
        input.selectionEnd = 4;
      });

      this.assertSelectionRange(2, 4);

      this.runTask(function () {
        return _this6.rerender();
      });

      this.assertSelectionRange(2, 4);

      // this.runTask(() => set(this.context, 'value', 'updated'));
      //
      // this.assertSelectionRange(7, 7); //NOTE: this fails in IE, the range is 0 -> 0 (TEST_SUITE=sauce)
      //
      // this.runTask(() => set(this.context, 'value', 'original'));
      //
      // this.assertSelectionRange(8, 8); //NOTE: this fails in IE, the range is 0 -> 0 (TEST_SUITE=sauce)
    };

    _class.prototype['@test specifying `on="someevent" action="foo"` results in a deprecation warning'] = function testSpecifyingOnSomeeventActionFooResultsInADeprecationWarning() {
      var _this7 = this;

      expectDeprecation(function () {
        _this7.render('{{input on="focus-in" action="doFoo" value="hello"}}');
      }, 'Using \'{{input on="focus-in" action="doFoo"}}\' (\'-top-level\' @ L1:C0) is deprecated. Please use \'{{input focus-in="doFoo"}}\' instead.');
    };

    _class.prototype['@test sends an action with `{{input action="foo"}}` when <enter> is pressed [DEPRECATED]'] = function testSendsAnActionWithInputActionFooWhenEnterIsPressedDEPRECATED(assert) {
      var _this8 = this;

      assert.expect(2);

      expectDeprecation(function () {
        _this8.render('{{input action=\'foo\'}}', {
          actions: {
            foo: function () {
              assert.ok(true, 'action was triggered');
            }
          }
        });
      }, /Please use '{{input enter="foo"}}' instead/);

      this.triggerEvent('keyup', {
        keyCode: 13
      });
    };

    _class.prototype['@test sends an action with `{{input enter="foo"}}` when <enter> is pressed'] = function testSendsAnActionWithInputEnterFooWhenEnterIsPressed(assert) {
      assert.expect(1);

      this.render('{{input enter=\'foo\'}}', {
        actions: {
          foo: function () {
            assert.ok(true, 'action was triggered');
          }
        }
      });

      this.triggerEvent('keyup', {
        keyCode: 13
      });
    };

    _class.prototype['@test sends an action with `{{input key-press="foo"}}` is pressed'] = function testSendsAnActionWithInputKeyPressFooIsPressed(assert) {
      assert.expect(1);

      this.render('{{input value=value key-press=\'foo\'}}', {
        value: 'initial',

        actions: {
          foo: function () {
            assert.ok(true, 'action was triggered');
          }
        }
      });

      this.triggerEvent('keypress', {
        keyCode: 65
      });
    };

    _class.prototype['@test sends an action to the parent level when `bubbles=true` is provided'] = function testSendsAnActionToTheParentLevelWhenBubblesTrueIsProvided(assert) {
      assert.expect(1);

      var ParentComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        change: function () {
          assert.ok(true, 'bubbled upwards');
        }
      });

      this.registerComponent('x-parent', {
        ComponentClass: ParentComponent,
        template: '{{input bubbles=true}}'
      });
      this.render('{{x-parent}}');

      this.triggerEvent('change');
    };

    _class.prototype['@test triggers `focus-in` when focused'] = function testTriggersFocusInWhenFocused(assert) {
      var _this9 = this;

      assert.expect(1);

      this.render('{{input focus-in=\'foo\'}}', {
        actions: {
          foo: function () {
            assert.ok(true, 'action was triggered');
          }
        }
      });

      this.runTask(function () {
        _this9.$input().trigger('focusin');
      });
    };

    _class.prototype['@test sends `insert-newline` when <enter> is pressed'] = function testSendsInsertNewlineWhenEnterIsPressed(assert) {
      assert.expect(1);

      this.render('{{input insert-newline=\'foo\'}}', {
        actions: {
          foo: function () {
            assert.ok(true, 'action was triggered');
          }
        }
      });

      this.triggerEvent('keyup', {
        keyCode: 13
      });
    };

    _class.prototype['@test sends an action with `{{input escape-press="foo"}}` when <escape> is pressed'] = function testSendsAnActionWithInputEscapePressFooWhenEscapeIsPressed(assert) {
      assert.expect(1);

      this.render('{{input escape-press=\'foo\'}}', {
        actions: {
          foo: function () {
            assert.ok(true, 'action was triggered');
          }
        }
      });

      this.triggerEvent('keyup', {
        keyCode: 27
      });
    };

    _class.prototype['@test sends an action with `{{input key-down="foo"}}` when a key is pressed'] = function testSendsAnActionWithInputKeyDownFooWhenAKeyIsPressed(assert) {
      assert.expect(1);

      this.render('{{input key-down=\'foo\'}}', {
        actions: {
          foo: function () {
            assert.ok(true, 'action was triggered');
          }
        }
      });

      this.triggerEvent('keydown', {
        keyCode: 65
      });
    };

    _class.prototype['@test sends an action with `{{input key-up="foo"}}` when a key is pressed'] = function testSendsAnActionWithInputKeyUpFooWhenAKeyIsPressed(assert) {
      assert.expect(1);

      this.render('{{input key-up=\'foo\'}}', {
        actions: {
          foo: function () {
            assert.ok(true, 'action was triggered');
          }
        }
      });

      this.triggerEvent('keyup', {
        keyCode: 65
      });
    };

    return _class;
  })(InputRenderingTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: {{input}} with dynamic type', (function (_InputRenderingTest2) {
    babelHelpers.inherits(_class2, _InputRenderingTest2);

    function _class2() {
      _InputRenderingTest2.apply(this, arguments);
    }

    _class2.prototype['@test a bound property can be used to determine type'] = function testABoundPropertyCanBeUsedToDetermineType() {
      var _this10 = this;

      this.render('{{input type=type}}', { type: 'password' });

      this.assertAttr('type', 'password');

      this.runTask(function () {
        return _this10.rerender();
      });

      this.assertAttr('type', 'password');

      this.runTask(function () {
        return _emberMetal.set(_this10.context, 'type', 'text');
      });

      this.assertAttr('type', 'text');

      this.runTask(function () {
        return _emberMetal.set(_this10.context, 'type', 'password');
      });

      this.assertAttr('type', 'password');
    };

    _class2.prototype['@test a subexpression can be used to determine type'] = function testASubexpressionCanBeUsedToDetermineType() {
      var _this11 = this;

      this.render('{{input type=(if isTruthy trueType falseType)}}', {
        isTruthy: true,
        trueType: 'text',
        falseType: 'password'
      });

      this.assertAttr('type', 'text');

      this.runTask(function () {
        return _this11.rerender();
      });

      this.assertAttr('type', 'text');

      this.runTask(function () {
        return _emberMetal.set(_this11.context, 'isTruthy', false);
      });

      this.assertAttr('type', 'password');

      this.runTask(function () {
        return _emberMetal.set(_this11.context, 'isTruthy', true);
      });

      this.assertAttr('type', 'text');
    };

    return _class2;
  })(InputRenderingTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: {{input type=\'checkbox\'}}', (function (_InputRenderingTest3) {
    babelHelpers.inherits(_class3, _InputRenderingTest3);

    function _class3() {
      _InputRenderingTest3.apply(this, arguments);
    }

    _class3.prototype['@test dynamic attributes'] = function testDynamicAttributes() {
      var _this12 = this;

      this.render('{{input\n      type=\'checkbox\'\n      disabled=disabled\n      name=name\n      checked=checked\n      tabindex=tabindex\n    }}', {
        disabled: false,
        name: 'original-name',
        checked: false,
        tabindex: 10
      });

      this.assertSingleCheckbox();
      this.assertNotDisabled();
      this.assertAttr('name', 'original-name');
      this.assertAttr('tabindex', '10');

      this.runTask(function () {
        return _this12.rerender();
      });

      this.assertSingleCheckbox();
      this.assertNotDisabled();
      this.assertAttr('name', 'original-name');
      this.assertAttr('tabindex', '10');

      this.runTask(function () {
        _emberMetal.set(_this12.context, 'disabled', true);
        _emberMetal.set(_this12.context, 'name', 'updated-name');
        _emberMetal.set(_this12.context, 'tabindex', 11);
      });

      this.assertSingleCheckbox();
      this.assertDisabled();
      this.assertAttr('name', 'updated-name');
      this.assertAttr('tabindex', '11');

      this.runTask(function () {
        _emberMetal.set(_this12.context, 'disabled', false);
        _emberMetal.set(_this12.context, 'name', 'original-name');
        _emberMetal.set(_this12.context, 'tabindex', 10);
      });

      this.assertSingleCheckbox();
      this.assertNotDisabled();
      this.assertAttr('name', 'original-name');
      this.assertAttr('tabindex', '10');
    };

    _class3.prototype['@test `value` property assertion'] = function testValuePropertyAssertion() {
      var _this13 = this;

      expectAssertion(function () {
        _this13.render('{{input type="checkbox" value=value}}', { value: 'value' });
      }, /you must use `checked=/);
    };

    _class3.prototype['@test with a bound type'] = function testWithABoundType(assert) {
      var _this14 = this;

      this.render('{{input type=inputType checked=isChecked}}', { inputType: 'checkbox', isChecked: true });

      this.assertSingleCheckbox();
      this.assertCheckboxIsChecked();

      this.runTask(function () {
        return _this14.rerender();
      });

      this.assertCheckboxIsChecked();

      this.runTask(function () {
        return _emberMetal.set(_this14.context, 'isChecked', false);
      });

      this.assertCheckboxIsNotChecked();

      this.runTask(function () {
        return _emberMetal.set(_this14.context, 'isChecked', true);
      });

      this.assertCheckboxIsChecked();
    };

    _class3.prototype['@test with static values'] = function testWithStaticValues(assert) {
      var _this15 = this;

      this.render('{{input type="checkbox" disabled=false tabindex=10 name="original-name" checked=false}}');

      this.assertSingleCheckbox();
      this.assertCheckboxIsNotChecked();
      this.assertNotDisabled();
      this.assertAttr('tabindex', '10');
      this.assertAttr('name', 'original-name');

      this.runTask(function () {
        return _this15.rerender();
      });

      this.assertSingleCheckbox();
      this.assertCheckboxIsNotChecked();
      this.assertNotDisabled();
      this.assertAttr('tabindex', '10');
      this.assertAttr('name', 'original-name');
    };

    return _class3;
  })(InputRenderingTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: {{input type=\'text\'}}', (function (_InputRenderingTest4) {
    babelHelpers.inherits(_class4, _InputRenderingTest4);

    function _class4() {
      _InputRenderingTest4.apply(this, arguments);
    }

    _class4.prototype['@test null values'] = function testNullValues(assert) {
      var _this16 = this;

      var attributes = ['disabled', 'placeholder', 'name', 'maxlength', 'size', 'tabindex'];

      this.render('\n      {{input type="text"\n        disabled=disabled\n        value=value\n        placeholder=placeholder\n        name=name\n        maxlength=maxlength\n        size=size\n        tabindex=tabindex\n      }}', {
        disabled: null,
        value: null,
        placeholder: null,
        name: null,
        maxlength: null,
        size: null,
        tabindex: null
      });

      this.assertValue('');
      this.assertAllAttrs(attributes, undefined);

      this.runTask(function () {
        return _this16.rerender();
      });

      this.assertValue('');
      this.assertAllAttrs(attributes, undefined);

      this.runTask(function () {
        _emberMetal.set(_this16.context, 'disabled', true);
        _emberMetal.set(_this16.context, 'value', 'Updated value');
        _emberMetal.set(_this16.context, 'placeholder', 'Updated placeholder');
        _emberMetal.set(_this16.context, 'name', 'updated-name');
        _emberMetal.set(_this16.context, 'maxlength', 11);
        _emberMetal.set(_this16.context, 'size', 21);
        _emberMetal.set(_this16.context, 'tabindex', 31);
      });

      this.assertDisabled();
      this.assertValue('Updated value');
      this.assertAttr('placeholder', 'Updated placeholder');
      this.assertAttr('name', 'updated-name');
      this.assertAttr('maxlength', '11');
      this.assertAttr('size', '21');
      this.assertAttr('tabindex', '31');

      this.runTask(function () {
        _emberMetal.set(_this16.context, 'disabled', null);
        _emberMetal.set(_this16.context, 'value', null);
        _emberMetal.set(_this16.context, 'placeholder', null);
        _emberMetal.set(_this16.context, 'name', null);
        _emberMetal.set(_this16.context, 'maxlength', null);
        // set(this.context, 'size', null); //NOTE: this fails with `Error: Failed to set the 'size' property on 'HTMLInputElement': The value provided is 0, which is an invalid size.` (TEST_SUITE=sauce)
        _emberMetal.set(_this16.context, 'tabindex', null);
      });

      this.assertAttr('disabled', undefined);
      this.assertValue('');
      // this.assertAttr('placeholder', undefined); //NOTE: this fails with a value of "null" (TEST_SUITE=sauce)
      // this.assertAttr('name', undefined); //NOTE: this fails with a value of "null" (TEST_SUITE=sauce)
      this.assertAttr('maxlength', undefined);
      // this.assertAttr('size', undefined); //NOTE: re-enable once `size` bug above has been addressed
      this.assertAttr('tabindex', undefined);
    };

    return _class4;
  })(InputRenderingTest));
});
enifed('ember-glimmer/tests/integration/helpers/input-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/helpers/input-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/helpers/input-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/helpers/loc-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-metal', 'ember'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberMetal, _ember) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: {{loc}}', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.call(this);
      this.oldString = _ember.default.STRINGS;
      _ember.default.STRINGS = {
        'Hello Friend': 'Hallo Freund',
        'Hello': 'Hallo, %@'
      };
    }

    _class.prototype.teardown = function teardown() {
      _RenderingTest.prototype.teardown.call(this);
      _ember.default.STRINGS = this.oldString;
    };

    _class.prototype['@test it lets the original value through by default'] = function testItLetsTheOriginalValueThroughByDefault() {
      var _this = this;

      this.render('{{loc "Hiya buddy!"}}');
      this.assertText('Hiya buddy!', 'the unlocalized string is correct');
      this.runTask(function () {
        return _this.rerender();
      });
      this.assertText('Hiya buddy!', 'the unlocalized string is correct after rerender');
    };

    _class.prototype['@test it localizes a simple string'] = function testItLocalizesASimpleString() {
      var _this2 = this;

      this.render('{{loc "Hello Friend"}}');
      this.assertText('Hallo Freund', 'the localized string is correct');
      this.runTask(function () {
        return _this2.rerender();
      });
      this.assertText('Hallo Freund', 'the localized string is correct after rerender');
    };

    _class.prototype['@test it takes passed formats into an account'] = function testItTakesPassedFormatsIntoAnAccount() {
      var _this3 = this;

      this.render('{{loc "%@, %@" "Hello" "Mr. Pitkin"}}');
      this.assertText('Hello, Mr. Pitkin', 'the formatted string is correct');
      this.runTask(function () {
        return _this3.rerender();
      });
      this.assertText('Hello, Mr. Pitkin', 'the formatted string is correct after rerender');
    };

    _class.prototype['@test it updates when bound params change'] = function testItUpdatesWhenBoundParamsChange() {
      var _this4 = this;

      this.render('{{loc simple}} - {{loc personal \'Mr. Pitkin\'}}', {
        simple: 'Hello Friend',
        personal: 'Hello'
      });
      this.assertText('Hallo Freund - Hallo, Mr. Pitkin', 'the bound value is correct');

      this.runTask(function () {
        return _this4.rerender();
      });
      this.assertText('Hallo Freund - Hallo, Mr. Pitkin', 'the bound value is correct after rerender');

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'simple', 'G\'day mate');
      });
      this.assertText('G\'day mate - Hallo, Mr. Pitkin', 'the bound value is correct after update');

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'simple', 'Hello Friend');
      });
      this.assertText('Hallo Freund - Hallo, Mr. Pitkin', 'the bound value is correct after reset');
    };

    _class.prototype['@test it updates when nested bound params change'] = function testItUpdatesWhenNestedBoundParamsChange() {
      var _this5 = this;

      this.render('{{loc greetings.simple}} - {{loc greetings.personal \'Mr. Pitkin\'}}', {
        greetings: {
          simple: 'Hello Friend',
          personal: 'Hello'
        }
      });
      this.assertText('Hallo Freund - Hallo, Mr. Pitkin', 'the bound value is correct');

      this.runTask(function () {
        return _this5.rerender();
      });
      this.assertText('Hallo Freund - Hallo, Mr. Pitkin', 'the bound value is correct after rerender');

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'greetings.simple', 'G\'day mate');
      });
      this.assertText('G\'day mate - Hallo, Mr. Pitkin', 'the bound value is correct after interior mutation');

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'greetings', {
          simple: 'Hello Friend',
          personal: 'Hello'
        });
      });
      this.assertText('Hallo Freund - Hallo, Mr. Pitkin', 'the bound value is correct after replacement');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/helpers/loc-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/helpers/loc-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/helpers/loc-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/helpers/log-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-console'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberConsole) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: {{log}}', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class(assert) {
      var _this = this;

      _RenderingTest.call(this);

      this.originalLog = _emberConsole.default.log;
      this.logCalls = [];
      _emberConsole.default.log = function () {
        var _logCalls;

        (_logCalls = _this.logCalls).push.apply(_logCalls, arguments);
      };
    }

    _class.prototype.teardown = function teardown() {
      _RenderingTest.prototype.teardown.call(this);
      _emberConsole.default.log = this.originalLog;
    };

    _class.prototype.assertLog = function assertLog(values) {
      this.assertText('');
      this.assert.strictEqual(this.logCalls.length, values.length);

      for (var i = 0, len = values.length; i < len; i++) {
        this.assert.strictEqual(this.logCalls[i], values[i]);
      }
    };

    _class.prototype['@test correctly logs primitives'] = function testCorrectlyLogsPrimitives() {
      this.render('{{log "one" 1 true}}');

      this.assertLog(['one', 1, true]);
    };

    _class.prototype['@test correctly logs a property'] = function testCorrectlyLogsAProperty() {
      this.render('{{log value}}', {
        value: 'one'
      });

      this.assertLog(['one']);
    };

    _class.prototype['@test correctly logs multiple arguments'] = function testCorrectlyLogsMultipleArguments() {
      this.render('{{log "my variable:" value}}', {
        value: 'one'
      });

      this.assertLog(['my variable:', 'one']);
    };

    _class.prototype['@test correctly logs `this`'] = function testCorrectlyLogsThis() {
      this.render('{{log this}}');

      this.assertLog([this.context]);
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/helpers/log-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/helpers/log-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/helpers/log-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/helpers/mut-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/helpers', 'ember-metal', 'ember-glimmer/tests/utils/test-helpers'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsHelpers, _emberMetal, _emberGlimmerTestsUtilsTestHelpers) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: {{mut}}', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test a simple mutable binding using `mut` propagates properly'] = function testASimpleMutableBindingUsingMutPropagatesProperly() {
      var _this = this;

      var bottom = undefined;

      this.registerComponent('bottom-mut', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didInsertElement: function () {
            bottom = this;
          }
        }),
        template: '{{setMe}}'
      });

      this.registerComponent('middle-mut', {
        template: '{{bottom-mut setMe=value}}'
      });

      this.render('{{middle-mut value=(mut val)}}', {
        val: 12
      });

      this.assertText('12', 'the data propagated downwards');

      this.assertStableRerender();

      this.runTask(function () {
        return bottom.attrs.setMe.update(13);
      });

      this.assertText('13', 'the set took effect');
      this.assert.strictEqual(_emberMetal.get(bottom, 'setMe'), 13, 'the set took effect on bottom\'s prop');
      this.assert.strictEqual(bottom.attrs.setMe.value, 13, 'the set took effect on bottom\'s attr');
      this.assert.strictEqual(_emberMetal.get(this.context, 'val'), 13, 'the set propagated back up');

      this.runTask(function () {
        return _emberMetal.set(bottom, 'setMe', 14);
      });

      this.assertText('14', 'the set took effect');
      this.assert.strictEqual(_emberMetal.get(bottom, 'setMe'), 14, 'the set took effect on bottom\'s prop');
      this.assert.strictEqual(bottom.attrs.setMe.value, 14, 'the set took effect on bottom\'s attr');
      this.assert.strictEqual(_emberMetal.get(this.context, 'val'), 14, 'the set propagated back up');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'val', 12);
      });

      this.assertText('12');
    };

    _class.prototype['@test a simple mutable binding using `mut` inserts into the DOM'] = function testASimpleMutableBindingUsingMutInsertsIntoTheDOM() {
      var _this2 = this;

      var bottom = undefined,
          middle = undefined;

      this.registerComponent('bottom-mut', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didInsertElement: function () {
            bottom = this;
          }
        }),
        template: '{{setMe}}'
      });

      this.registerComponent('middle-mut', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didInsertElement: function () {
            middle = this;
          }
        }),
        template: '{{bottom-mut setMe=(mut value)}}'
      });

      this.render('{{middle-mut value=(mut val)}}', {
        val: 12
      });

      this.assertText('12', 'the data propagated downwards');

      this.assertStableRerender();

      this.runTask(function () {
        return bottom.attrs.setMe.update(13);
      });

      this.assertText('13', 'the set took effect');
      this.assert.strictEqual(_emberMetal.get(bottom, 'setMe'), 13, 'the set took effect on bottom\'s prop');
      this.assert.strictEqual(bottom.attrs.setMe.value, 13, 'the set took effect on bottom\'s attr');
      this.assert.strictEqual(_emberMetal.get(middle, 'value'), 13, 'the set propagated to middle\'s prop');
      this.assert.strictEqual(middle.attrs.value.value, 13, 'the set propagated to middle\'s attr');
      this.assert.strictEqual(_emberMetal.get(this.context, 'val'), 13, 'the set propagated back up');

      this.runTask(function () {
        return _emberMetal.set(bottom, 'setMe', 14);
      });

      this.assertText('14', 'the set took effect');
      this.assert.strictEqual(_emberMetal.get(bottom, 'setMe'), 14, 'the set took effect on bottom\'s prop');
      this.assert.strictEqual(bottom.attrs.setMe.value, 14, 'the set took effect on bottom\'s attr');
      this.assert.strictEqual(_emberMetal.get(middle, 'value'), 14, 'the set propagated to middle\'s prop');
      this.assert.strictEqual(middle.attrs.value.value, 14, 'the set propagated to middle\'s attr');
      this.assert.strictEqual(_emberMetal.get(this.context, 'val'), 14, 'the set propagated back up');

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'val', 12);
      });

      this.assertText('12');
    };

    _class.prototype['@test passing a literal results in a assertion'] = function testPassingALiteralResultsInAAssertion() {
      var _this3 = this;

      this.registerComponent('bottom-mut', { template: '{{setMe}}' });

      expectAssertion(function () {
        _this3.render('{{bottom-mut setMe=(mut "foo bar")}}');
      }, 'You can only pass a path to mut');
    };

    _class.prototype['@test passing the result of a helper invocation results in an assertion'] = function testPassingTheResultOfAHelperInvocationResultsInAnAssertion() {
      var _this4 = this;

      this.registerComponent('bottom-mut', { template: '{{setMe}}' });

      expectAssertion(function () {
        _this4.render('{{bottom-mut setMe=(mut (concat "foo" " " "bar"))}}');
      }, 'You can only pass a path to mut');
    };

    // See https://github.com/emberjs/ember.js/commit/807a0cd for an explanation of this test

    _class.prototype['@test using a string value through middle tier does not trigger assertion (due to the auto-mut transform)'] = function testUsingAStringValueThroughMiddleTierDoesNotTriggerAssertionDueToTheAutoMutTransform() {
      var bottom = undefined;

      this.registerComponent('bottom-mut', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didInsertElement: function () {
            bottom = this;
          }
        }),
        template: '{{stuff}}'
      });

      this.registerComponent('middle-mut', {
        template: '{{bottom-mut stuff=value}}'
      });

      this.render('{{middle-mut value="foo"}}');

      this.assert.equal(_emberMetal.get(bottom, 'stuff'), 'foo', 'the data propagated');
      this.assertText('foo');

      this.assertStableRerender();

      // No U-R for this test
    };

    _class.prototype['@test {{readonly}} of a {{mut}} is converted into an immutable binding'] = function testReadonlyOfAMutIsConvertedIntoAnImmutableBinding() {
      var _this5 = this;

      var middle = undefined,
          bottom = undefined;

      this.registerComponent('bottom-mut', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didInsertElement: function () {
            bottom = this;
          }
        }),
        template: '{{setMe}}'
      });

      this.registerComponent('middle-mut', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didInsertElement: function () {
            middle = this;
          }
        }),
        template: '{{bottom-mut setMe=(readonly value)}}'
      });

      this.render('{{middle-mut value=(mut val)}}', {
        val: 12
      });

      this.assertText('12');

      this.assertStableRerender();

      this.runTask(function () {
        return middle.attrs.value.update(13);
      });

      this.assert.strictEqual(_emberMetal.get(middle, 'value'), 13, 'the set took effect on middle\'s prop');
      this.assert.strictEqual(middle.attrs.value.value, 13, 'the set took effect on middle\'s attr');

      this.runTask(function () {
        return _emberMetal.set(middle, 'value', 14);
      });

      this.assert.strictEqual(_emberMetal.get(middle, 'value'), 14, 'the set took effect on middle\'s prop');
      this.assert.strictEqual(middle.attrs.value.value, 14, 'the set took effect on middle\'s attr');
      this.assert.strictEqual(bottom.attrs.setMe, 14, 'the mutable binding has been converted to an immutable cell');
      this.assertText('14');
      this.assert.strictEqual(_emberMetal.get(this.context, 'val'), 14, 'the set propagated back up');

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'val', 12);
      });

      this.assertText('12');
    };

    _class.prototype['@test mutable bindings work inside of yielded content'] = function testMutableBindingsWorkInsideOfYieldedContent() {
      var _this6 = this;

      this.registerComponent('bottom-mut', {
        template: '{{yield}}'
      });

      this.registerComponent('middle-mut', {
        template: '{{#bottom-mut}}{{model.name}}{{/bottom-mut}}'
      });

      this.render('{{middle-mut model=(mut model)}}', {
        model: { name: 'Matthew Beale' }
      });

      this.assertText('Matthew Beale');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this6.context, 'model.name', 'Joel Kang');
      });

      this.assertText('Joel Kang');

      this.runTask(function () {
        return _emberMetal.set(_this6.context, 'model', { name: 'Matthew Beale' });
      });

      this.assertText('Matthew Beale');
    };

    _class.prototype['@test a simple mutable binding using {{mut}} is available in hooks'] = function testASimpleMutableBindingUsingMutIsAvailableInHooks() {
      var _this7 = this;

      var bottom = undefined;
      var willRender = [];
      var didInsert = [];

      this.registerComponent('bottom-mut', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          willRender: function () {
            willRender.push(_emberMetal.get(this, 'setMe'));
          },
          didInsertElement: function () {
            didInsert.push(_emberMetal.get(this, 'setMe'));
            bottom = this;
          }
        }),
        template: '{{setMe}}'
      });

      this.registerComponent('middle-mut', {
        template: '{{bottom-mut setMe=(mut value)}}'
      });

      this.render('{{middle-mut value=(mut val)}}', {
        val: 12
      });

      this.assert.deepEqual(willRender, [12], 'willReceive is [12]');
      this.assert.deepEqual(didInsert, [12], 'didInsert is [12]');
      this.assertText('12');

      this.assertStableRerender();

      this.assert.deepEqual(willRender, [12], 'willReceive is [12]');
      this.assert.deepEqual(didInsert, [12], 'didInsert is [12]');
      this.assert.strictEqual(_emberMetal.get(bottom, 'setMe'), 12, 'the data propagated');

      this.runTask(function () {
        return bottom.attrs.setMe.update(13);
      });

      this.assert.strictEqual(_emberMetal.get(bottom, 'setMe'), 13, 'the set took effect on bottom\'s prop');
      this.assert.strictEqual(bottom.attrs.setMe.value, 13, 'the set took effect on bottom\'s attr');
      this.assert.strictEqual(_emberMetal.get(this.context, 'val'), 13, 'the set propagated back up');

      this.runTask(function () {
        return _emberMetal.set(bottom, 'setMe', 14);
      });

      this.assert.strictEqual(_emberMetal.get(bottom, 'setMe'), 14, 'the set took effect on bottom\'s prop');
      this.assert.strictEqual(bottom.attrs.setMe.value, 14, 'the set took effect on bottom\'s attr');
      this.assert.strictEqual(_emberMetal.get(this.context, 'val'), 14, 'the set propagated back up');

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'val', 12);
      });

      this.assertText('12');
    };

    _class.prototype['@test a mutable binding with a backing computed property and attribute present in the root of the component is updated when the upstream property invalidates #11023'] = function testAMutableBindingWithABackingComputedPropertyAndAttributePresentInTheRootOfTheComponentIsUpdatedWhenTheUpstreamPropertyInvalidates11023() {
      var bottom = undefined,
          middle = undefined;

      this.registerComponent('bottom-mut', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          thingy: null,
          didInsertElement: function () {
            bottom = this;
          }
        }),
        template: '{{thingy}}'
      });

      this.registerComponent('middle-mut', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          baseValue: 12,
          val: _emberMetal.computed('baseValue', function () {
            return this.get('baseValue');
          }),
          didInsertElement: function () {
            middle = this;
          }
        }),
        template: '{{bottom-mut thingy=(mut val)}}'
      });

      this.render('{{middle-mut}}');

      this.assert.strictEqual(_emberMetal.get(bottom, 'thingy'), 12, 'data propagated');
      this.assertText('12');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(middle, 'baseValue', 13);
      });

      this.assert.strictEqual(_emberMetal.get(middle, 'val'), 13, 'the set took effect');
      this.assert.strictEqual(bottom.attrs.thingy.value, 13, 'the set propagated down to bottom\'s attrs');
      this.assert.strictEqual(_emberMetal.get(bottom, 'thingy'), 13, 'the set propagated down to bottom\'s prop');
      this.assertText('13');

      this.runTask(function () {
        return _emberMetal.set(middle, 'baseValue', 12);
      });

      this.assertText('12');
    };

    _class.prototype['@test automatic mutable bindings exposes a mut cell in attrs'] = function testAutomaticMutableBindingsExposesAMutCellInAttrs() {
      var inner = undefined;

      this.registerComponent('x-inner', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didInsertElement: function () {
            inner = this;
          }
        }),
        template: '{{foo}}'
      });

      this.registerComponent('x-outer', {
        template: '{{x-inner foo=bar}}'
      });

      this.render('{{x-outer bar=baz}}', { baz: 'foo' });

      this.assertText('foo');

      this.assertStableRerender();

      this.runTask(function () {
        return inner.attrs.foo.update('bar');
      });

      this.assert.equal(inner.attrs.foo.value, 'bar');
      this.assert.equal(_emberMetal.get(inner, 'foo'), 'bar');
      this.assertText('bar');

      this.runTask(function () {
        return inner.attrs.foo.update('foo');
      });

      this.assertText('foo');
    };

    _class.prototype['@test automatic mutable bindings tolerate undefined non-stream inputs and attempts to set them'] = function testAutomaticMutableBindingsTolerateUndefinedNonStreamInputsAndAttemptsToSetThem() {
      var inner = undefined;

      this.registerComponent('x-inner', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didInsertElement: function () {
            inner = this;
          }
        }),
        template: '{{model}}'
      });

      this.registerComponent('x-outer', {
        template: '{{x-inner model=nonexistent}}'
      });

      this.render('{{x-outer}}');

      this.assertText('');

      this.assertStableRerender();

      this.runTask(function () {
        return inner.attrs.model.update(42);
      });

      this.assert.equal(inner.attrs.model.value, 42);
      this.assert.equal(_emberMetal.get(inner, 'model'), 42);
      this.assertText('42');

      this.runTask(function () {
        return inner.attrs.model.update(undefined);
      });

      this.assertText('');
    };

    _class.prototype['@test automatic mutable bindings tolerate constant non-stream inputs and attempts to set them'] = function testAutomaticMutableBindingsTolerateConstantNonStreamInputsAndAttemptsToSetThem() {
      var inner = undefined;

      this.registerComponent('x-inner', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didInsertElement: function () {
            inner = this;
          }
        }),
        template: 'hello{{model}}'
      });

      this.registerComponent('x-outer', {
        template: '{{x-inner model=x}}'
      });

      this.render('{{x-outer x="foo"}}');

      this.assertText('hellofoo');

      this.assertStableRerender();

      this.runTask(function () {
        return inner.attrs.model.update(42);
      });

      this.assert.equal(inner.attrs.model.value, 42);
      this.assert.equal(_emberMetal.get(inner, 'model'), 42);
      this.assertText('hello42');

      this.runTask(function () {
        return inner.attrs.model.update('foo');
      });

      this.assertText('hellofoo');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Mutable Bindings used in Computed Properties that are bound as attributeBindings', (function (_RenderingTest2) {
    babelHelpers.inherits(_class2, _RenderingTest2);

    function _class2() {
      _RenderingTest2.apply(this, arguments);
    }

    _class2.prototype['@test an attribute binding of a computed property of a 2-way bound attr recomputes when the attr changes'] = function testAnAttributeBindingOfAComputedPropertyOfA2WayBoundAttrRecomputesWhenTheAttrChanges() {
      var _this8 = this;

      var input = undefined,
          output = undefined;

      this.registerComponent('x-input', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didInsertElement: function () {
            input = this;
          }
        })
      });

      this.registerComponent('x-output', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          attributeBindings: ['style'],
          didInsertElement: function () {
            output = this;
          },
          style: _emberMetal.computed('height', function () {
            var height = this.get('height');
            return 'height: ' + height + 'px;';
          }),
          height: 20
        }),
        template: '{{height}}'
      });

      this.render('{{x-output height=height}}{{x-input height=(mut height)}}', {
        height: 60
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { style: _emberGlimmerTestsUtilsTestHelpers.styles('height: 60px;') }, content: '60' });

      this.assertStableRerender();

      this.runTask(function () {
        return input.attrs.height.update(35);
      });

      this.assert.strictEqual(_emberMetal.get(output, 'height'), 35, 'the set took effect');
      this.assert.strictEqual(_emberMetal.get(this.context, 'height'), 35, 'the set propagated back up');
      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { style: _emberGlimmerTestsUtilsTestHelpers.styles('height: 35px;') }, content: '35' });

      this.runTask(function () {
        return _emberMetal.set(input, 'height', 36);
      });

      this.assert.strictEqual(_emberMetal.get(output, 'height'), 36, 'the set took effect');
      this.assert.strictEqual(_emberMetal.get(this.context, 'height'), 36, 'the set propagated back up');
      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { style: _emberGlimmerTestsUtilsTestHelpers.styles('height: 36px;') }, content: '36' });

      this.runTask(function () {
        return _emberMetal.set(_this8.context, 'height', 60);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { style: _emberGlimmerTestsUtilsTestHelpers.styles('height: 60px;') }, content: '60' });
      this.assert.strictEqual(_emberMetal.get(input, 'height'), 60);
    };

    _class2.prototype['@test an attribute binding of a computed property with a setter of a 2-way bound attr recomputes when the attr changes'] = function testAnAttributeBindingOfAComputedPropertyWithASetterOfA2WayBoundAttrRecomputesWhenTheAttrChanges() {
      var _this9 = this;

      var input = undefined,
          output = undefined;

      this.registerComponent('x-input', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didInsertElement: function () {
            input = this;
          }
        })
      });

      this.registerComponent('x-output', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          attributeBindings: ['style'],
          didInsertElement: function () {
            output = this;
          },
          style: _emberMetal.computed('height', 'width', function () {
            var height = this.get('height');
            var width = this.get('width');
            return 'height: ' + height + 'px; width: ' + width + 'px;';
          }),
          height: 20,
          width: _emberMetal.computed('height', {
            get: function () {
              return this.get('height') * 2;
            },
            set: function (keyName, width) {
              this.set('height', width / 2);
              return width;
            }
          })
        }),
        template: '{{width}}x{{height}}'
      });

      this.render('{{x-output width=width}}{{x-input width=(mut width)}}', {
        width: 70
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { style: _emberGlimmerTestsUtilsTestHelpers.styles('height: 35px; width: 70px;') }, content: '70x35' });

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(input, 'width', 80);
      });

      this.assert.strictEqual(_emberMetal.get(output, 'width'), 80, 'the set took effect');
      this.assert.strictEqual(_emberMetal.get(this.context, 'width'), 80, 'the set propagated back up');
      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { style: _emberGlimmerTestsUtilsTestHelpers.styles('height: 40px; width: 80px;') }, content: '80x40' });

      this.runTask(function () {
        return input.attrs.width.update(90);
      });

      this.assert.strictEqual(_emberMetal.get(output, 'width'), 90, 'the set took effect');
      this.assert.strictEqual(_emberMetal.get(this.context, 'width'), 90, 'the set propagated back up');
      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { style: _emberGlimmerTestsUtilsTestHelpers.styles('height: 45px; width: 90px;') }, content: '90x45' });

      this.runTask(function () {
        return _emberMetal.set(_this9.context, 'width', 70);
      });

      this.assertComponentElement(this.firstChild, { tagName: 'div', attrs: { style: _emberGlimmerTestsUtilsTestHelpers.styles('height: 35px; width: 70px;') }, content: '70x35' });
      this.assert.strictEqual(_emberMetal.get(input, 'width'), 70);
    };

    return _class2;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/helpers/mut-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/helpers/mut-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/helpers/mut-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/helpers/partial-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-metal', 'ember-glimmer/tests/utils/abstract-test-case'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberMetal, _emberGlimmerTestsUtilsAbstractTestCase) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#each model.items as |template i|}}\n        {{model.type}}: {{partial template}}\n      {{/each}}'], ['\n      {{#each model.items as |template i|}}\n        {{model.type}}: {{partial template}}\n      {{/each}}']),
      _templateObject2 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#with item.thing as |t|}}\n        {{partial t}}\n      {{else}}\n        Nothing!\n      {{/with}}'], ['\n      {{#with item.thing as |t|}}\n        {{partial t}}\n      {{else}}\n        Nothing!\n      {{/with}}']);

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: {{partial}}', (function (_RenderingTest) {
babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test should render other templates registered with the container'] = function testShouldRenderOtherTemplatesRegisteredWithTheContainer() {
      this.registerPartial('_subTemplateFromContainer', 'sub-template');

      this.render('This {{partial "subTemplateFromContainer"}} is pretty great.');

      this.assertStableRerender();

      this.assertText('This sub-template is pretty great.');
    };

    _class.prototype['@test should render other slash-separated templates registered with the container'] = function testShouldRenderOtherSlashSeparatedTemplatesRegisteredWithTheContainer() {
      this.registerPartial('child/_subTemplateFromContainer', 'sub-template');

      this.render('This {{partial "child/subTemplateFromContainer"}} is pretty great.');

      this.assertStableRerender();

      this.assertText('This sub-template is pretty great.');
    };

    _class.prototype['@test should use the current context'] = function testShouldUseTheCurrentContext() {
      var _this = this;

      this.registerPartial('_person_name', '{{model.firstName}} {{model.lastName}}');

      this.render('Who is {{partial "person_name"}}?', {
        model: {
          firstName: 'Kris',
          lastName: 'Selden'
        }
      });

      this.assertStableRerender();

      this.assertText('Who is Kris Selden?');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'model.firstName', 'Kelly');
      });

      this.assertText('Who is Kelly Selden?');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'model', { firstName: 'Kris', lastName: 'Selden' });
      });

      this.assertText('Who is Kris Selden?');
    };

    _class.prototype['@test Quoteless parameters passed to {{partial}} perform a bound property lookup of the partial name'] = function testQuotelessParametersPassedToPartialPerformABoundPropertyLookupOfThePartialName() {
      var _this2 = this;

      this.registerPartial('_subTemplate', 'sub-template');
      this.registerPartial('_otherTemplate', 'other-template');

      this.render('This {{partial templates.partialName}} is pretty {{partial nonexistent}}great.', {
        templates: { partialName: 'subTemplate' }
      });

      this.assertStableRerender();

      this.assertText('This sub-template is pretty great.');

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'templates.partialName', 'otherTemplate');
      });

      this.assertText('This other-template is pretty great.');

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'templates.partialName', null);
      });

      this.assertText('This  is pretty great.');

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'templates', { partialName: 'subTemplate' });
      });

      this.assertText('This sub-template is pretty great.');
    };

    _class.prototype['@test dynamic partials in {{#each}}'] = function testDynamicPartialsInEach() {
      var _this3 = this;

      this.registerPartial('_odd', 'ODD{{i}}');
      this.registerPartial('_even', 'EVEN{{i}}');

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject), {
        model: {
          items: ['even', 'odd', 'even', 'odd'],
          type: 'number'
        }
      });

      this.assertStableRerender();

      this.assertText('number: EVEN0number: ODD1number: EVEN2number: ODD3');

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'model.type', 'integer');
      });

      this.assertText('integer: EVEN0integer: ODD1integer: EVEN2integer: ODD3');

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'model', {
          items: ['even', 'odd', 'even', 'odd'],
          type: 'number'
        });
      });

      this.assertText('number: EVEN0number: ODD1number: EVEN2number: ODD3');
    };

    _class.prototype['@test dynamic partials in {{#with}}'] = function testDynamicPartialsInWith() {
      var _this4 = this;

      this.registerPartial('_thing', '{{t}}');

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2), {
        item: { thing: false }
      });

      this.assertStableRerender();

      this.assertText('Nothing!');

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'item.thing', 'thing');
      });

      this.assertText('thing');

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'item', { thing: false });
      });

      this.assertText('Nothing!');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/helpers/partial-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/helpers/partial-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/helpers/partial-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/helpers/readonly-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/helpers', 'ember-metal'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsHelpers, _emberMetal) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: {{readonly}}', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test {{readonly}} of a path should work'] = function testReadonlyOfAPathShouldWork() {
      var component = undefined;

      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didInsertElement: function () {
            component = this;
          }
        }),
        template: '{{value}}'
      });

      this.render('{{foo-bar value=(readonly val)}}', {
        val: 12
      });

      this.assertText('12');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(component, 'value', 13);
      });
      this.assert.notOk(component.attrs.value.update);

      this.assertText('13', 'local property is updated');
      this.assert.equal(_emberMetal.get(this.context, 'val'), 12, 'upstream attribute is not updated');

      // No U-R
    };

    _class.prototype['@test {{readonly}} of a string renders correctly'] = function testReadonlyOfAStringRendersCorrectly() {
      var component = undefined;

      this.registerComponent('foo-bar', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didInsertElement: function () {
            component = this;
          }
        }),
        template: '{{value}}'
      });

      this.render('{{foo-bar value=(readonly "12")}}');

      this.assertText('12');

      this.assertStableRerender();

      this.assert.notOk(component.attrs.value.update);
      this.assert.strictEqual(_emberMetal.get(component, 'value'), '12');

      this.runTask(function () {
        return _emberMetal.set(component, 'value', '13');
      });

      this.assertText('13', 'local property is updated');
      this.assert.strictEqual(_emberMetal.get(component, 'value'), '13');

      this.runTask(function () {
        return _emberMetal.set(component, 'value', '12');
      });

      this.assertText('12');
    };

    _class.prototype['@test {{mut}} of a {{readonly}} mutates only the middle and bottom tiers'] = function testMutOfAReadonlyMutatesOnlyTheMiddleAndBottomTiers() {
      var _this = this;

      var middle = undefined,
          bottom = undefined;

      this.registerComponent('x-bottom', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didInsertElement: function () {
            bottom = this;
          }
        }),
        template: '{{bar}}'
      });

      this.registerComponent('x-middle', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          didInsertElement: function () {
            middle = this;
          }
        }),
        template: '{{foo}} {{x-bottom bar=(mut foo)}}'
      });

      this.render('{{x-middle foo=(readonly val)}}', {
        val: 12
      });

      this.assertText('12 12');

      this.assertStableRerender();

      this.assert.equal(_emberMetal.get(bottom, 'bar'), 12, 'bottom\'s local bar received the value');
      this.assert.equal(_emberMetal.get(middle, 'foo'), 12, 'middle\'s local foo received the value');

      this.runTask(function () {
        return bottom.attrs.bar.update(13);
      });

      this.assert.equal(_emberMetal.get(bottom, 'bar'), 13, 'bottom\'s local bar was updated after set of bottom\'s bar');
      this.assert.equal(_emberMetal.get(middle, 'foo'), 13, 'middle\'s local foo was updated after set of bottom\'s bar');
      this.assertText('13 13');
      this.assert.equal(_emberMetal.get(this.context, 'val'), 12, 'But context val is not updated');

      this.runTask(function () {
        return _emberMetal.set(bottom, 'bar', 14);
      });

      this.assert.equal(_emberMetal.get(bottom, 'bar'), 14, 'bottom\'s local bar was updated after set of bottom\'s bar');
      this.assert.equal(_emberMetal.get(middle, 'foo'), 14, 'middle\'s local foo was updated after set of bottom\'s bar');
      this.assertText('14 14');
      this.assert.equal(_emberMetal.get(this.context, 'val'), 12, 'But context val is not updated');

      this.assert.notOk(middle.attrs.foo.update, 'middle\'s foo attr is not a mutable cell');
      this.runTask(function () {
        return _emberMetal.set(middle, 'foo', 15);
      });

      this.assertText('15 15');
      this.assert.equal(_emberMetal.get(middle, 'foo'), 15, 'set of middle\'s foo took effect');
      this.assert.equal(_emberMetal.get(bottom, 'bar'), 15, 'bottom\'s local bar was updated after set of middle\'s foo');
      this.assert.equal(_emberMetal.get(this.context, 'val'), 12, 'Context val remains unchanged');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'val', 10);
      });

      this.assertText('10 10');
      this.assert.equal(_emberMetal.get(bottom, 'bar'), 10, 'bottom\'s local bar was updated after set of context\'s val');
      this.assert.equal(_emberMetal.get(middle, 'foo'), 10, 'middle\'s local foo was updated after set of context\'s val');

      this.runTask(function () {
        return _emberMetal.set(bottom, 'bar', undefined);
      });

      this.assertText(' ');
      this.assert.equal(_emberMetal.get(bottom, 'bar'), undefined, 'bottom\'s local bar was updated to a falsy value');
      this.assert.equal(_emberMetal.get(middle, 'foo'), undefined, 'middle\'s local foo was updated to a falsy value');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'val', 12);
      });
      this.assertText('12 12', 'bottom and middle were both reset');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/helpers/readonly-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/helpers/readonly-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/helpers/readonly-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/helpers/render-test', ['exports', 'ember-metal', 'ember-runtime', 'ember-glimmer/tests/utils/test-case'], function (exports, _emberMetal, _emberRuntime, _emberGlimmerTestsUtilsTestCase) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: {{render}}', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test should render given template'] = function testShouldRenderGivenTemplate() {
      var _this = this;

      this.registerTemplate('home', '<p>BYE</p>');

      expectDeprecation(function () {
        _this.render('<h1>HI</h1>{{render \'home\'}}');
      }, /Please refactor [\w\{\}"` ]+ to a component/);

      this.assertText('HIBYE');
    };

    _class.prototype['@test uses `controller:basic` as the basis for a generated controller when none exists for specified name'] = function testUsesControllerBasicAsTheBasisForAGeneratedControllerWhenNoneExistsForSpecifiedName() {
      var _this2 = this;

      this.owner.register('controller:basic', _emberRuntime.Controller.extend({
        isBasicController: true
      }));
      this.registerTemplate('home', '{{isBasicController}}');

      expectDeprecation(function () {
        _this2.render('{{render \'home\'}}');
      }, /Please refactor [\w\{\}"` ]+ to a component/);

      this.assertText('true');
    };

    _class.prototype['@test generates a controller if none exists'] = function testGeneratesAControllerIfNoneExists() {
      var _this3 = this;

      this.registerTemplate('home', '<p>{{this}}</p>');

      expectDeprecation(function () {
        _this3.render('<h1>HI</h1>{{render \'home\'}}');
      }, /Please refactor [\w\{\}"` ]+ to a component/);

      this.assertText('HI(generated home controller)');
    };

    _class.prototype['@test should use controller with the same name as template if present'] = function testShouldUseControllerWithTheSameNameAsTemplateIfPresent() {
      var _this4 = this;

      this.owner.register('controller:home', _emberRuntime.Controller.extend({ name: 'home' }));
      this.registerTemplate('home', '{{name}}<p>BYE</p>');

      expectDeprecation(function () {
        _this4.render('<h1>HI</h1>{{render \'home\'}}');
      }, /Please refactor [\w\{\}"` ]+ to a component/);

      this.assertText('HIhomeBYE');
    };

    _class.prototype['@test should render nested helpers'] = function testShouldRenderNestedHelpers() {
      var _this5 = this;

      this.owner.register('controller:home', _emberRuntime.Controller.extend());
      this.owner.register('controller:foo', _emberRuntime.Controller.extend());
      this.owner.register('controller:bar', _emberRuntime.Controller.extend());
      this.owner.register('controller:baz', _emberRuntime.Controller.extend());

      this.registerTemplate('home', '<p>BYE</p>');
      this.registerTemplate('baz', '<p>BAZ</p>');

      expectDeprecation(function () {
        _this5.registerTemplate('foo', '<p>FOO</p>{{render \'bar\'}}');
        _this5.registerTemplate('bar', '<p>BAR</p>{{render \'baz\'}}');
        _this5.render('<h1>HI</h1>{{render \'foo\'}}');
      }, /Please refactor [\w\{\}"` ]+ to a component/);

      this.assertText('HIFOOBARBAZ');
    };

    _class.prototype['@test should have assertion if the template does not exist'] = function testShouldHaveAssertionIfTheTemplateDoesNotExist() {
      var _this6 = this;

      this.owner.register('controller:oops', _emberRuntime.Controller.extend());

      expectDeprecation(function () {
        expectAssertion(function () {
          _this6.render('<h1>HI</h1>{{render \'oops\'}}');
        }, 'You used `{{render \'oops\'}}`, but \'oops\' can not be found as a template.');
      }, /Please refactor [\w\{\}"` ]+ to a component/);
    };

    _class.prototype['@test should render given template with the singleton controller as its context'] = function testShouldRenderGivenTemplateWithTheSingletonControllerAsItsContext() {
      var _this7 = this;

      this.owner.register('controller:post', _emberRuntime.Controller.extend({
        init: function () {
          this.set('title', 'It\'s Simple Made Easy');
        }
      }));
      this.registerTemplate('post', '<p>{{title}}</p>');

      expectDeprecation(function () {
        _this7.render('<h1>HI</h1>{{render \'post\'}}');
      }, /Please refactor [\w\{\}"` ]+ to a component/);

      this.assertText('HIIt\'s Simple Made Easy');

      this.runTask(function () {
        return _this7.rerender();
      });

      this.assertText('HIIt\'s Simple Made Easy');

      var controller = this.owner.lookup('controller:post');

      this.runTask(function () {
        return _emberMetal.set(controller, 'title', 'Rails is omakase');
      });

      this.assertText('HIRails is omakase');

      this.runTask(function () {
        return _emberMetal.set(controller, 'title', 'It\'s Simple Made Easy');
      });

      this.assertText('HIIt\'s Simple Made Easy');
    };

    _class.prototype['@test should not destroy the singleton controller on teardown'] = function testShouldNotDestroyTheSingletonControllerOnTeardown(assert) {
      var _this8 = this;

      var willDestroyFired = 0;

      this.owner.register('controller:post', _emberRuntime.Controller.extend({
        init: function () {
          this.set('title', 'It\'s Simple Made Easy');
        },

        willDestroy: function () {
          this._super.apply(this, arguments);
          willDestroyFired++;
        }
      }));

      this.registerTemplate('post', '<p>{{title}}</p>');

      expectDeprecation(function () {
        _this8.render('{{#if showPost}}{{render \'post\'}}{{else}}Nothing here{{/if}}', { showPost: false });
      }, /Please refactor [\w\{\}"` ]+ to a component/);

      this.assertText('Nothing here');

      assert.strictEqual(willDestroyFired, 0, 'it did not destroy the controller');

      this.runTask(function () {
        return _this8.rerender();
      });

      this.assertText('Nothing here');

      assert.strictEqual(willDestroyFired, 0, 'it did not destroy the controller');

      this.runTask(function () {
        return _emberMetal.set(_this8.context, 'showPost', true);
      });

      this.assertText('It\'s Simple Made Easy');

      assert.strictEqual(willDestroyFired, 0, 'it did not destroy the controller');

      this.runTask(function () {
        return _emberMetal.set(_this8.context, 'showPost', false);
      });

      this.assertText('Nothing here');

      assert.strictEqual(willDestroyFired, 0, 'it did not destroy the controller');
    };

    _class.prototype['@test should render given template with a supplied model'] = function testShouldRenderGivenTemplateWithASuppliedModel() {
      var _this9 = this;

      this.owner.register('controller:post', _emberRuntime.Controller.extend());
      this.registerTemplate('post', '<p>{{model.title}}</p>');

      expectDeprecation(function () {
        _this9.render('<h1>HI</h1>{{render \'post\' post}}', {
          post: {
            title: 'It\'s Simple Made Easy'
          }
        });
      }, /Please refactor [\w\{\}"` ]+ to a component/);

      this.assertText('HIIt\'s Simple Made Easy');

      this.runTask(function () {
        return _this9.rerender();
      });

      this.assertText('HIIt\'s Simple Made Easy');

      this.runTask(function () {
        return _emberMetal.set(_this9.context, 'post.title', 'Rails is omakase');
      });

      this.assertText('HIRails is omakase');

      this.runTask(function () {
        return _emberMetal.set(_this9.context, 'post', { title: 'It\'s Simple Made Easy' });
      });

      this.assertText('HIIt\'s Simple Made Easy');
    };

    _class.prototype['@test should destroy the non-singleton controllers on teardown'] = function testShouldDestroyTheNonSingletonControllersOnTeardown(assert) {
      var _this10 = this;

      var willDestroyFired = 0;

      this.owner.register('controller:post', _emberRuntime.Controller.extend({
        willDestroy: function () {
          this._super.apply(this, arguments);
          willDestroyFired++;
        }
      }));

      this.registerTemplate('post', '<p>{{model.title}}</p>');

      expectDeprecation(function () {
        _this10.render('{{#if showPost}}{{render \'post\' post}}{{else}}Nothing here{{/if}}', {
          showPost: false,
          post: {
            title: 'It\'s Simple Made Easy'
          }
        });
      }, /Please refactor [\w\{\}"` ]+ to a component/);

      this.assertText('Nothing here');

      assert.strictEqual(willDestroyFired, 0, 'it did not destroy the controller');

      this.runTask(function () {
        return _this10.rerender();
      });

      this.assertText('Nothing here');

      assert.strictEqual(willDestroyFired, 0, 'it did not destroy the controller');

      this.runTask(function () {
        return _emberMetal.set(_this10.context, 'showPost', true);
      });

      this.assertText('It\'s Simple Made Easy');

      assert.strictEqual(willDestroyFired, 0, 'it did not destroy the controller');

      this.runTask(function () {
        return _emberMetal.set(_this10.context, 'showPost', false);
      });

      this.assertText('Nothing here');

      assert.strictEqual(willDestroyFired, 1, 'it did destroy the controller');

      this.runTask(function () {
        return _emberMetal.set(_this10.context, 'showPost', true);
      });

      this.assertText('It\'s Simple Made Easy');

      assert.strictEqual(willDestroyFired, 1, 'it did not destroy the controller');

      this.runTask(function () {
        return _emberMetal.set(_this10.context, 'showPost', false);
      });

      this.assertText('Nothing here');

      assert.strictEqual(willDestroyFired, 2, 'it did destroy the controller');
    };

    _class.prototype['@test with a supplied model should not fire observers on the controller'] = function testWithASuppliedModelShouldNotFireObserversOnTheController() {
      var _this11 = this;

      this.owner.register('controller:post', _emberRuntime.Controller.extend());
      this.registerTemplate('post', '<p>{{model.title}}</p>');

      var postDidChange = 0;
      expectDeprecation(function () {
        _this11.render('<h1>HI</h1>{{render \'post\' post}}', {
          postDidChange: _emberMetal.observer('post', function () {
            postDidChange++;
          }),
          post: {
            title: 'It\'s Simple Made Easy'
          }
        });
      }, /Please refactor [\w\{\}"` ]+ to a component/);

      this.assertText('HIIt\'s Simple Made Easy');

      this.runTask(function () {
        return _this11.rerender();
      });

      this.assertText('HIIt\'s Simple Made Easy');
    };

    _class.prototype['@test should raise an error when a given controller name does not resolve to a controller'] = function testShouldRaiseAnErrorWhenAGivenControllerNameDoesNotResolveToAController() {
      var _this12 = this;

      this.registerTemplate('home', '<p>BYE</p>');
      this.owner.register('controller:posts', _emberRuntime.Controller.extend());

      expectDeprecation(function () {
        expectAssertion(function () {
          _this12.render('<h1>HI</h1>{{render "home" controller="postss"}}');
        }, /The controller name you supplied \'postss\' did not resolve to a controller./);
      }, /Please refactor [\w\{\}"` ]+ to a component/);
    };

    _class.prototype['@test should render with given controller'] = function testShouldRenderWithGivenController(assert) {
      var _this13 = this;

      this.registerTemplate('home', '{{uniqueId}}');

      var id = 0;
      var model = {};

      this.owner.register('controller:posts', _emberRuntime.Controller.extend({
        init: function () {
          this._super.apply(this, arguments);
          this.uniqueId = id++;
          this.set('model', model);
        }
      }));

      expectDeprecation(function () {
        _this13.render('{{render "home" controller="posts"}}');
      }, /Please refactor [\w\{\}"` ]+ to a component/);

      var renderedController = this.owner.lookup('controller:posts');
      var uniqueId = renderedController.get('uniqueId');
      var renderedModel = renderedController.get('model');

      assert.equal(uniqueId, 0);
      assert.equal(renderedModel, model);
      this.assertText('0');

      this.runTask(function () {
        return _this13.rerender();
      });

      assert.equal(uniqueId, 0);
      assert.equal(renderedModel, model);
      this.assertText('0');
    };

    _class.prototype['@test should render templates with models multiple times'] = function testShouldRenderTemplatesWithModelsMultipleTimes(assert) {
      var _this14 = this;

      this.owner.register('controller:post', _emberRuntime.Controller.extend());

      this.registerTemplate('post', '<p>{{model.title}}</p>');
      expectDeprecation(function () {
        _this14.render('<h1>HI</h1> {{render \'post\' post1}} {{render \'post\' post2}}', {
          post1: {
            title: 'Me First'
          },
          post2: {
            title: 'Then me'
          }
        });
      }, /Please refactor [\w\{\}"` ]+ to a component/);

      this.assertText('HI Me First Then me');

      this.runTask(function () {
        return _this14.rerender();
      });

      this.assertText('HI Me First Then me');

      this.runTask(function () {
        return _emberMetal.set(_this14.context, 'post1.title', 'I am new');
      });

      this.assertText('HI I am new Then me');

      this.runTask(function () {
        return _emberMetal.set(_this14.context, 'post1', { title: 'Me First' });
      });

      this.assertText('HI Me First Then me');
    };

    _class.prototype['@test should not treat invocations with falsy contexts as context-less'] = function testShouldNotTreatInvocationsWithFalsyContextsAsContextLess(assert) {
      var _this15 = this;

      this.registerTemplate('post', '<p>{{#unless model.zero}}NOTHING{{/unless}}</p>');
      this.owner.register('controller:post', _emberRuntime.Controller.extend());

      expectDeprecation(function () {
        _this15.render('<h1>HI</h1> {{render \'post\' zero}} {{render \'post\' nonexistent}}', {
          model: {
            zero: false
          }
        });
      }, /Please refactor [\w\{\}"` ]+ to a component/);

      assert.ok(this.$().text().match(/^HI ?NOTHING ?NOTHING$/));
    };

    _class.prototype['@test should render templates both with and without models'] = function testShouldRenderTemplatesBothWithAndWithoutModels(assert) {
      var _this16 = this;

      this.registerTemplate('post', '<p>Title:{{model.title}}</p>');
      this.owner.register('controller:post', _emberRuntime.Controller.extend());

      var post = {
        title: 'Rails is omakase'
      };
      expectDeprecation(function () {
        _this16.render('<h1>HI</h1> {{render \'post\'}} {{render \'post\' post}}', {
          post: post
        });
      }, /Please refactor [\w\{\}"` ]+ to a component/);

      assert.ok(this.$().text().match(/^HI ?Title: ?Title:Rails is omakase$/));

      this.runTask(function () {
        return _this16.rerender();
      });

      assert.ok(this.$().text().match(/^HI ?Title: ?Title:Rails is omakase$/));

      this.runTask(function () {
        return _emberMetal.set(_this16.context, 'post.title', 'Simple Made Easy');
      });

      assert.ok(this.$().text().match(/^HI ?Title: ?Title:Simple Made Easy$/));

      this.runTask(function () {
        return _emberMetal.set(_this16.context, 'post', { title: 'Rails is omakase' });
      });

      assert.ok(this.$().text().match(/^HI ?Title: ?Title:Rails is omakase$/));
    };

    _class.prototype['@test works with dot notation'] = function testWorksWithDotNotation() {
      var _this17 = this;

      this.registerTemplate('blog.post', '{{uniqueId}}');

      var id = 0;
      this.owner.register('controller:blog.post', _emberRuntime.Controller.extend({
        init: function () {
          this._super.apply(this, arguments);
          this.uniqueId = id++;
        }
      }));

      expectDeprecation(function () {
        _this17.render('{{render "blog.post"}}');
      }, /Please refactor [\w\.{\}"` ]+ to a component/);

      this.assertText('0');
    };

    _class.prototype['@test throws an assertion if called with an unquoted template name'] = function testThrowsAnAssertionIfCalledWithAnUnquotedTemplateName() {
      var _this18 = this;

      this.registerTemplate('home', '<p>BYE</p>');

      expectAssertion(function () {
        _this18.render('<h1>HI</h1>{{render home}}');
      }, 'The first argument of {{render}} must be quoted, e.g. {{render "sidebar"}}.');
    };

    _class.prototype['@test throws an assertion if called with a literal for a model'] = function testThrowsAnAssertionIfCalledWithALiteralForAModel() {
      var _this19 = this;

      this.registerTemplate('home', '<p>BYE</p>');
      expectAssertion(function () {
        _this19.render('<h1>HI</h1>{{render "home" "model"}}', {
          model: {
            title: 'Simple Made Easy'
          }
        });
      }, 'The second argument of {{render}} must be a path, e.g. {{render "post" post}}.');
    };

    _class.prototype['@test should set router as target when action not found on parentController is not found'] = function testShouldSetRouterAsTargetWhenActionNotFoundOnParentControllerIsNotFound(assert) {
      var _this20 = this;

      var postController = undefined;
      this.registerTemplate('post', 'post template');
      this.owner.register('controller:post', _emberRuntime.Controller.extend({
        init: function () {
          this._super.apply(this, arguments);
          postController = this;
        }
      }));

      var routerStub = {
        send: function (actionName) {
          assert.equal(actionName, 'someAction');
          assert.ok(true, 'routerStub#send called');
        }
      };

      this.owner.register('router:main', routerStub, { instantiate: false });

      expectDeprecation(function () {
        _this20.render('{{render \'post\' post1}}');
      }, /Please refactor [\w\{\}"` ]+ to a component/);

      postController.send('someAction');
    };

    _class.prototype['@test render helper emits useful backtracking re-render assertion message'] = function testRenderHelperEmitsUsefulBacktrackingReRenderAssertionMessage(assert) {
      var _this21 = this;

      this.owner.register('controller:outer', _emberRuntime.Controller.extend());
      this.owner.register('controller:inner', _emberRuntime.Controller.extend({
        propertyWithError: _emberMetal.computed(function () {
          this.set('model.name', 'this will cause a backtracking error');
          return 'foo';
        })
      }));

      var expectedBacktrackingMessage = /modified "model\.name" twice on \[object Object\] in a single render\. It was rendered in "controller:outer \(with the render helper\)" and modified in "controller:inner \(with the render helper\)"/;

      expectDeprecation(function () {
        var person = { name: 'Ben' };

        _this21.registerTemplate('outer', 'Hi {{model.name}} | {{render \'inner\' model}}');
        _this21.registerTemplate('inner', 'Hi {{propertyWithError}}');

        if (true) {
          expectDeprecation(expectedBacktrackingMessage);
          _this21.render('{{render \'outer\' person}}', { person: person });
        } else {
          expectAssertion(function () {
            _this21.render('{{render \'outer\' person}}', { person: person });
          }, expectedBacktrackingMessage);
        }
      });
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/helpers/render-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/helpers/render-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/helpers/render-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/helpers/text-area-test', ['exports', 'ember-utils', 'ember-metal', 'ember-glimmer/tests/utils/helpers', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/test-helpers', 'ember-glimmer/tests/utils/abstract-test-case'], function (exports, _emberUtils, _emberMetal, _emberGlimmerTestsUtilsHelpers, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsTestHelpers, _emberGlimmerTestsUtilsAbstractTestCase) {
  'use strict';

  var TextAreaRenderingTest = (function (_RenderingTest) {
    babelHelpers.inherits(TextAreaRenderingTest, _RenderingTest);

    function TextAreaRenderingTest() {
      _RenderingTest.call(this);

      this.registerComponent('-text-area', { ComponentClass: _emberGlimmerTestsUtilsHelpers.TextArea });
    }

    TextAreaRenderingTest.prototype.assertTextArea = function assertTextArea() {
      var _ref2 = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

      var attrs = _ref2.attrs;
      var value = _ref2.value;

      var mergedAttrs = _emberUtils.assign({ 'class': _emberGlimmerTestsUtilsTestHelpers.classes('ember-view ember-text-area') }, attrs);
      this.assertComponentElement(this.firstChild, { tagName: 'textarea', attrs: mergedAttrs });

      if (value) {
        this.assert.strictEqual(value, this.firstChild.value);
      }
    };

    TextAreaRenderingTest.prototype.triggerEvent = function triggerEvent(type) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var event = document.createEvent('Events');
      event.initEvent(type, true, true);
      _emberUtils.assign(event, options);

      this.firstChild.dispatchEvent(event);
    };

    return TextAreaRenderingTest;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest);

  var BoundTextAreaAttributes = (function () {
    function BoundTextAreaAttributes(cases) {
      this.cases = cases;
    }

    BoundTextAreaAttributes.prototype.generate = function generate(_ref3) {
      var _ref;

      var attribute = _ref3.attribute;
      var first = _ref3.first;
      var second = _ref3.second;

      return _ref = {}, _ref['@test ' + attribute] = function (assert) {
        var _attrs,
            _attrs2,
            _attrs3,
            _this = this;

        this.render('{{textarea ' + attribute + '=value}}', {
          value: first
        });
        this.assertTextArea({ attrs: (_attrs = {}, _attrs[attribute] = first, _attrs) });

        this.assertStableRerender();

        this.runTask(function () {
          return _emberMetal.set(_this.context, 'value', second);
        });
        this.assertTextArea({ attrs: (_attrs2 = {}, _attrs2[attribute] = second, _attrs2) });

        this.runTask(function () {
          return _emberMetal.set(_this.context, 'value', first);
        });
        this.assertTextArea({ attrs: (_attrs3 = {}, _attrs3[attribute] = first, _attrs3) });
      }, _ref;
    };

    return BoundTextAreaAttributes;
  })();

  _emberGlimmerTestsUtilsAbstractTestCase.applyMixins(TextAreaRenderingTest, new BoundTextAreaAttributes([{ attribute: 'placeholder', first: 'Stuff here', second: 'Other stuff' }, { attribute: 'name', first: 'Stuff here', second: 'Other stuff' }, { attribute: 'title', first: 'Stuff here', second: 'Other stuff' }, { attribute: 'maxlength', first: '1', second: '2' }, { attribute: 'rows', first: '1', second: '2' }, { attribute: 'cols', first: '1', second: '2' }, { attribute: 'tabindex', first: '1', second: '2' }]));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: {{textarea}}', (function (_TextAreaRenderingTest) {
    babelHelpers.inherits(_class, _TextAreaRenderingTest);

    function _class() {
      _TextAreaRenderingTest.apply(this, arguments);
    }

    _class.prototype['@test Should insert a textarea'] = function testShouldInsertATextarea() {
      this.render('{{textarea}}');

      equal(this.$('textarea').length, 1);

      this.assertStableRerender();
    };

    _class.prototype['@test Should respect disabled'] = function testShouldRespectDisabled() {
      this.render('{{textarea disabled=disabled}}', {
        disabled: true
      });
      ok(this.$('textarea').is(':disabled'));
    };

    _class.prototype['@test Should respect disabled when false'] = function testShouldRespectDisabledWhenFalse() {
      this.render('{{textarea disabled=disabled}}', {
        disabled: false
      });
      ok(this.$('textarea').is(':not(:disabled)'));
    };

    _class.prototype['@test Should become disabled when the context changes'] = function testShouldBecomeDisabledWhenTheContextChanges() {
      var _this2 = this;

      this.render('{{textarea disabled=disabled}}');
      ok(this.$('textarea').is(':not(:disabled)'));

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'disabled', true);
      });
      ok(this.$('textarea').is(':disabled'));

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'disabled', false);
      });
      ok(this.$('textarea').is(':not(:disabled)'));
    };

    _class.prototype['@test Should bind its contents to the specified value'] = function testShouldBindItsContentsToTheSpecifiedValue() {
      var _this3 = this;

      this.render('{{textarea value=model.val}}', {
        model: { val: 'A beautiful day in Seattle' }
      });
      this.assertTextArea({ value: 'A beautiful day in Seattle' });

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'model.val', 'Auckland');
      });
      this.assertTextArea({ value: 'Auckland' });

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'model', { val: 'A beautiful day in Seattle' });
      });
      this.assertTextArea({ value: 'A beautiful day in Seattle' });
    };

    _class.prototype['@test GH#14001 Should correctly handle an empty string bound value'] = function testGH14001ShouldCorrectlyHandleAnEmptyStringBoundValue() {
      var _this4 = this;

      this.render('{{textarea value=message}}', { message: '' });

      this.assert.strictEqual(this.firstChild.value, '');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'message', 'hello');
      });

      this.assert.strictEqual(this.firstChild.value, 'hello');

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'message', '');
      });

      this.assert.strictEqual(this.firstChild.value, '');
    };

    _class.prototype['@test should update the value for `cut` / `input` / `change` events'] = function testShouldUpdateTheValueForCutInputChangeEvents() {
      var _this5 = this;

      this.render('{{textarea value=model.val}}', {
        model: { val: 'A beautiful day in Seattle' }
      });
      this.assertTextArea({ value: 'A beautiful day in Seattle' });

      this.assertStableRerender();

      this.runTask(function () {
        _this5.firstChild.value = 'Auckland';
        _this5.triggerEvent('cut');
      });
      this.assertTextArea({ value: 'Auckland' });

      this.runTask(function () {
        _this5.firstChild.value = 'Hope';
        _this5.triggerEvent('paste');
      });
      this.assertTextArea({ value: 'Hope' });

      this.runTask(function () {
        _this5.firstChild.value = 'Boston';
        _this5.triggerEvent('input');
      });
      this.assertTextArea({ value: 'Boston' });

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'model', { val: 'A beautiful day in Seattle' });
      });
      this.assertTextArea({ value: 'A beautiful day in Seattle' });
    };

    return _class;
  })(TextAreaRenderingTest));
});
enifed('ember-glimmer/tests/integration/helpers/text-area-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/helpers/text-area-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/helpers/text-area-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/helpers/unbound-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/abstract-test-case', 'ember-metal', 'ember-glimmer/tests/utils/helpers', 'ember-runtime'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsAbstractTestCase, _emberMetal, _emberGlimmerTestsUtilsHelpers, _emberRuntime) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n      <ul>\n        <li>\n          <a href="unsafe:javascript:bob-is-cool">Bob</a>\n        </li>\n        <li>\n          <a href="unsafe:vbscript:james-is-cool">James</a>\n        </li>\n        <li>\n          <a href="unsafe:javascript:richard-is-cool">Richard</a>\n        </li>\n      </ul>\n    '], ['\n      <ul>\n        <li>\n          <a href="unsafe:javascript:bob-is-cool">Bob</a>\n        </li>\n        <li>\n          <a href="unsafe:vbscript:james-is-cool">James</a>\n        </li>\n        <li>\n          <a href="unsafe:javascript:richard-is-cool">Richard</a>\n        </li>\n      </ul>\n    ']),
      _templateObject2 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{unbound (surround model.prefix model.value "bar")}} {{surround model.prefix model.value "bar"}} {{unbound (surround "bar" model.value model.suffix)}} {{surround "bar" model.value model.suffix}}'], ['\n      {{unbound (surround model.prefix model.value "bar")}} {{surround model.prefix model.value "bar"}} {{unbound (surround "bar" model.value model.suffix)}} {{surround "bar" model.value model.suffix}}']),
      _templateObject3 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#if (unbound model.foo)}}\n        {{#if model.bar}}true{{/if}}\n        {{#unless model.bar}}false{{/unless}}\n      {{/if}}\n      {{#unless (unbound model.notfoo)}}\n        {{#if model.bar}}true{{/if}}\n        {{#unless model.bar}}false{{/unless}}\n      {{/unless}}'], ['\n      {{#if (unbound model.foo)}}\n        {{#if model.bar}}true{{/if}}\n        {{#unless model.bar}}false{{/unless}}\n      {{/if}}\n      {{#unless (unbound model.notfoo)}}\n        {{#if model.bar}}true{{/if}}\n        {{#unless model.bar}}false{{/unless}}\n      {{/unless}}']);

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: {{unbound}}', (function (_RenderingTest) {
babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test should be able to output a property without binding'] = function testShouldBeAbleToOutputAPropertyWithoutBinding() {
      var _this = this;

      this.render('<div id="first">{{unbound content.anUnboundString}}</div>', {
        content: {
          anUnboundString: 'No spans here, son.'
        }
      });

      this.assertText('No spans here, son.');

      this.runTask(function () {
        return _this.rerender();
      });

      this.assertText('No spans here, son.');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'content.anUnboundString', 'HEY');
      });

      this.assertText('No spans here, son.');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'content', {
          anUnboundString: 'No spans here, son.'
        });
      });

      this.assertText('No spans here, son.');
    };

    _class.prototype['@test should be able to use unbound helper in #each helper'] = function testShouldBeAbleToUseUnboundHelperInEachHelper() {
      var _this2 = this;

      this.render('<ul>{{#each items as |item|}}<li>{{unbound item}}</li>{{/each}}</ul>', {
        items: _emberRuntime.A(['a', 'b', 'c', 1, 2, 3])
      });

      this.assertText('abc123');

      this.runTask(function () {
        return _this2.rerender();
      });

      this.assertText('abc123');
    };

    _class.prototype['@test should be able to use unbound helper in #each helper (with objects)'] = function testShouldBeAbleToUseUnboundHelperInEachHelperWithObjects() {
      var _this3 = this;

      this.render('<ul>{{#each items as |item|}}<li>{{unbound item.wham}}</li>{{/each}}</ul>', {
        items: _emberRuntime.A([{ wham: 'bam' }, { wham: 1 }])
      });

      this.assertText('bam1');

      this.runTask(function () {
        return _this3.rerender();
      });

      this.assertText('bam1');

      this.runTask(function () {
        return _this3.context.items.setEach('wham', 'HEY');
      });

      this.assertText('bam1');

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'items', _emberRuntime.A([{ wham: 'bam' }, { wham: 1 }]));
      });

      this.assertText('bam1');
    };

    _class.prototype['@test it should assert unbound cannot be called with multiple arguments'] = function testItShouldAssertUnboundCannotBeCalledWithMultipleArguments() {
      var _this4 = this;

      var willThrow = function () {
        _this4.render('{{unbound foo bar}}', {
          foo: 'BORK',
          bar: 'BLOOP'
        });
      };

      expectAssertion(willThrow, /unbound helper cannot be called with multiple params or hash params/);
    };

    _class.prototype['@test should render on attributes'] = function testShouldRenderOnAttributes() {
      var _this5 = this;

      this.render('<a href="{{unbound model.foo}}"></a>', {
        model: { foo: 'BORK' }
      });

      this.assertHTML('<a href="BORK"></a>');

      this.runTask(function () {
        return _this5.rerender();
      });

      this.assertHTML('<a href="BORK"></a>');

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'model.foo', 'OOF');
      });

      this.assertHTML('<a href="BORK"></a>');

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'model', { foo: 'BORK' });
      });

      this.assertHTML('<a href="BORK"></a>');
    };

    _class.prototype['@test should property escape unsafe hrefs'] = function testShouldPropertyEscapeUnsafeHrefs() {
      var _this6 = this;

      var unsafeUrls = _emberRuntime.A([{
        name: 'Bob',
        url: 'javascript:bob-is-cool' // jshint ignore:line
      }, {
        name: 'James',
        url: 'vbscript:james-is-cool' // jshint ignore:line
      }, {
        name: 'Richard',
        url: 'javascript:richard-is-cool' // jshint ignore:line
      }]);

      this.render('<ul>{{#each people as |person|}}<li><a href="{{unbound person.url}}">{{person.name}}</a></li>{{/each}}</ul>', {
        people: unsafeUrls
      });

      var escapedHtml = _emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject);

      this.assertHTML(escapedHtml);

      this.runTask(function () {
        return _this6.rerender();
      });

      this.assertHTML(escapedHtml);

      this.runTask(function () {
        return _this6.context.people.setEach('url', 'http://google.com');
      });

      this.assertHTML(escapedHtml);

      this.runTask(function () {
        return _emberMetal.set(_this6.context, 'people', unsafeUrls);
      });

      this.assertHTML(escapedHtml);
    };

    _class.prototype['@skip helper form updates on parent re-render'] = function skipHelperFormUpdatesOnParentReRender() {
      var _this7 = this;

      this.render('{{unbound foo}}', {
        foo: 'BORK'
      });

      this.assertText('BORK');

      this.runTask(function () {
        return _this7.rerender();
      });

      this.assertText('BORK');

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'foo', 'OOF');
      });

      this.assertText('BORK');

      this.runTask(function () {
        return _this7.rerender();
      });

      this.assertText('OOF');

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'foo', '');
      });

      this.assertText('OOF');

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'foo', 'BORK');
      });

      this.runTask(function () {
        return _this7.rerender();
      });

      this.assertText('BORK');
    };

    // semantics here is not guaranteed

    _class.prototype['@test sexpr form does not update no matter what'] = function testSexprFormDoesNotUpdateNoMatterWhat() {
      var _this8 = this;

      this.registerHelper('capitalize', function (args) {
        return args[0].toUpperCase();
      });

      this.render('{{capitalize (unbound foo)}}', {
        foo: 'bork'
      });

      this.assertText('BORK');

      this.runTask(function () {
        return _this8.rerender();
      });

      this.assertText('BORK');

      this.runTask(function () {
        _emberMetal.set(_this8.context, 'foo', 'oof');
        _this8.rerender();
      });

      this.assertText('BORK');

      this.runTask(function () {
        return _emberMetal.set(_this8.context, 'foo', 'blip');
      });

      this.assertText('BORK');

      this.runTask(function () {
        _emberMetal.set(_this8.context, 'foo', 'bork');
        _this8.rerender();
      });

      this.assertText('BORK');
    };

    _class.prototype['@test sexpr in helper form does not update on parent re-render'] = function testSexprInHelperFormDoesNotUpdateOnParentReRender() {
      var _this9 = this;

      this.registerHelper('capitalize', function (params) {
        return params[0].toUpperCase();
      });

      this.registerHelper('doublize', function (params) {
        return params[0] + ' ' + params[0];
      });

      this.render('{{capitalize (unbound (doublize foo))}}', {
        foo: 'bork'
      });

      this.assertText('BORK BORK');

      this.runTask(function () {
        return _this9.rerender();
      });

      this.assertText('BORK BORK');

      this.runTask(function () {
        _emberMetal.set(_this9.context, 'foo', 'oof');
        _this9.rerender();
      });

      this.assertText('BORK BORK');

      this.runTask(function () {
        return _emberMetal.set(_this9.context, 'foo', 'blip');
      });

      this.assertText('BORK BORK');

      this.runTask(function () {
        _emberMetal.set(_this9.context, 'foo', 'bork');
        _this9.rerender();
      });

      this.assertText('BORK BORK');
    };

    _class.prototype['@test should be able to render an unbound helper invocation'] = function testShouldBeAbleToRenderAnUnboundHelperInvocation() {
      var _this10 = this;

      this.registerHelper('repeat', function (_ref, _ref2) {
        var value = _ref[0];
        var count = _ref2.count;

        var a = [];
        while (a.length < count) {
          a.push(value);
        }
        return a.join('');
      });

      this.render('{{unbound (repeat foo count=bar)}} {{repeat foo count=bar}} {{unbound (repeat foo count=2)}} {{repeat foo count=4}}', {
        foo: 'X',
        bar: 5
      });

      this.assertText('XXXXX XXXXX XX XXXX');

      this.runTask(function () {
        return _this10.rerender();
      });

      this.assertText('XXXXX XXXXX XX XXXX');

      this.runTask(function () {
        return _emberMetal.set(_this10.context, 'bar', 1);
      });

      this.assertText('XXXXX X XX XXXX');

      this.runTask(function () {
        return _emberMetal.set(_this10.context, 'bar', 5);
      });

      this.assertText('XXXXX XXXXX XX XXXX');
    };

    _class.prototype['@test should be able to render an bound helper invocation mixed with static values'] = function testShouldBeAbleToRenderAnBoundHelperInvocationMixedWithStaticValues() {
      var _this11 = this;

      this.registerHelper('surround', function (_ref3) {
        var prefix = _ref3[0];
        var value = _ref3[1];
        var suffix = _ref3[2];
        return prefix + '-' + value + '-' + suffix;
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2), {
        model: {
          prefix: 'before',
          value: 'core',
          suffix: 'after'
        }
      });

      this.assertText('before-core-bar before-core-bar bar-core-after bar-core-after');

      this.runTask(function () {
        return _this11.rerender();
      });

      this.assertText('before-core-bar before-core-bar bar-core-after bar-core-after');

      this.runTask(function () {
        _emberMetal.setProperties(_this11.context.model, {
          prefix: 'beforeChanged',
          value: 'coreChanged',
          suffix: 'afterChanged'
        });
      });

      this.assertText('before-core-bar beforeChanged-coreChanged-bar bar-core-after bar-coreChanged-afterChanged');

      this.runTask(function () {
        _emberMetal.set(_this11.context, 'model', {
          prefix: 'before',
          value: 'core',
          suffix: 'after'
        });
      });

      this.assertText('before-core-bar before-core-bar bar-core-after bar-core-after');
    };

    _class.prototype['@test should be able to render unbound forms of multi-arg helpers'] = function testShouldBeAbleToRenderUnboundFormsOfMultiArgHelpers() {
      var _this12 = this;

      this.registerHelper('fauxconcat', function (params) {
        return params.join('');
      });

      this.render('{{fauxconcat model.foo model.bar model.bing}} {{unbound (fauxconcat model.foo model.bar model.bing)}}', {
        model: {
          foo: 'a',
          bar: 'b',
          bing: 'c'
        }
      });

      this.assertText('abc abc');

      this.runTask(function () {
        return _this12.rerender();
      });

      this.assertText('abc abc');

      this.runTask(function () {
        return _emberMetal.set(_this12.context, 'model.bar', 'X');
      });

      this.assertText('aXc abc');

      this.runTask(function () {
        return _emberMetal.set(_this12.context, 'model', {
          foo: 'a',
          bar: 'b',
          bing: 'c'
        });
      });

      this.assertText('abc abc');
    };

    _class.prototype['@test should be able to render an unbound helper invocation for helpers with dependent keys'] = function testShouldBeAbleToRenderAnUnboundHelperInvocationForHelpersWithDependentKeys() {
      var _this13 = this;

      this.registerHelper('capitalizeName', {
        destroy: function () {
          this.removeObserver('value.firstName');
          this._super.apply(this, arguments);
        },

        compute: function (_ref4) {
          var value = _ref4[0];

          if (this.get('value')) {
            this.removeObserver('value.firstName');
          }
          this.set('value', value);
          this.addObserver('value.firstName', this, this.recompute);
          return value ? _emberMetal.get(value, 'firstName').toUpperCase() : '';
        }
      });

      this.registerHelper('concatNames', {
        destroy: function () {
          this.teardown();
          this._super.apply(this, arguments);
        },
        teardown: function () {
          this.removeObserver('value.firstName');
          this.removeObserver('value.lastName');
        },
        compute: function (_ref5) {
          var value = _ref5[0];

          if (this.get('value')) {
            this.teardown();
          }
          this.set('value', value);
          this.addObserver('value.firstName', this, this.recompute);
          this.addObserver('value.lastName', this, this.recompute);
          return (value ? _emberMetal.get(value, 'firstName') : '') + (value ? _emberMetal.get(value, 'lastName') : '');
        }
      });

      this.render('{{capitalizeName person}} {{unbound (capitalizeName person)}} {{concatNames person}} {{unbound (concatNames person)}}', {
        person: {
          firstName: 'shooby',
          lastName: 'taylor'
        }
      });

      this.assertText('SHOOBY SHOOBY shoobytaylor shoobytaylor');

      this.runTask(function () {
        return _this13.rerender();
      });

      this.assertText('SHOOBY SHOOBY shoobytaylor shoobytaylor');

      this.runTask(function () {
        return _emberMetal.set(_this13.context, 'person.firstName', 'sally');
      });

      this.assertText('SALLY SHOOBY sallytaylor shoobytaylor');

      this.runTask(function () {
        return _emberMetal.set(_this13.context, 'person', {
          firstName: 'shooby',
          lastName: 'taylor'
        });
      });

      this.assertText('SHOOBY SHOOBY shoobytaylor shoobytaylor');
    };

    _class.prototype['@test should be able to render an unbound helper invocation in #each helper'] = function testShouldBeAbleToRenderAnUnboundHelperInvocationInEachHelper() {
      var _this14 = this;

      this.registerHelper('capitalize', function (params) {
        return params[0].toUpperCase();
      });

      this.render('{{#each people as |person|}}{{capitalize person.firstName}} {{unbound (capitalize person.firstName)}}{{/each}}', {
        people: _emberRuntime.A([{
          firstName: 'shooby',
          lastName: 'taylor'
        }, {
          firstName: 'cindy',
          lastName: 'taylor'
        }])
      });

      this.assertText('SHOOBY SHOOBYCINDY CINDY');

      this.runTask(function () {
        return _this14.rerender();
      });

      this.assertText('SHOOBY SHOOBYCINDY CINDY');

      this.runTask(function () {
        return _this14.context.people.setEach('firstName', 'chad');
      });

      this.assertText('CHAD SHOOBYCHAD CINDY');

      this.runTask(function () {
        return _emberMetal.set(_this14.context, 'people', _emberRuntime.A([{
          firstName: 'shooby',
          lastName: 'taylor'
        }, {
          firstName: 'cindy',
          lastName: 'taylor'
        }]));
      });

      this.assertText('SHOOBY SHOOBYCINDY CINDY');
    };

    _class.prototype['@test should be able to render an unbound helper invocation with bound hash options'] = function testShouldBeAbleToRenderAnUnboundHelperInvocationWithBoundHashOptions() {
      var _this15 = this;

      this.registerHelper('capitalizeName', {
        destroy: function () {
          this.removeObserver('value.firstName');
          this._super.apply(this, arguments);
        },

        compute: function (_ref6) {
          var value = _ref6[0];

          if (this.get('value')) {
            this.removeObserver('value.firstName');
          }
          this.set('value', value);
          this.addObserver('value.firstName', this, this.recompute);
          return value ? _emberMetal.get(value, 'firstName').toUpperCase() : '';
        }
      });

      this.registerHelper('concatNames', {
        destroy: function () {
          this.teardown();
          this._super.apply(this, arguments);
        },
        teardown: function () {
          this.removeObserver('value.firstName');
          this.removeObserver('value.lastName');
        },
        compute: function (_ref7) {
          var value = _ref7[0];

          if (this.get('value')) {
            this.teardown();
          }
          this.set('value', value);
          this.addObserver('value.firstName', this, this.recompute);
          this.addObserver('value.lastName', this, this.recompute);
          return (value ? _emberMetal.get(value, 'firstName') : '') + (value ? _emberMetal.get(value, 'lastName') : '');
        }
      });

      this.render('{{capitalizeName person}} {{unbound (capitalizeName person)}} {{concatNames person}} {{unbound (concatNames person)}}', {
        person: {
          firstName: 'shooby',
          lastName: 'taylor'
        }
      });

      this.assertText('SHOOBY SHOOBY shoobytaylor shoobytaylor');

      this.runTask(function () {
        return _this15.rerender();
      });

      this.assertText('SHOOBY SHOOBY shoobytaylor shoobytaylor');

      this.runTask(function () {
        return _emberMetal.set(_this15.context, 'person.firstName', 'sally');
      });

      this.assertText('SALLY SHOOBY sallytaylor shoobytaylor');

      this.runTask(function () {
        return _emberMetal.set(_this15.context, 'person', {
          firstName: 'shooby',
          lastName: 'taylor'
        });
      });

      this.assertText('SHOOBY SHOOBY shoobytaylor shoobytaylor');
    };

    _class.prototype['@test should be able to render bound form of a helper inside unbound form of same helper'] = function testShouldBeAbleToRenderBoundFormOfAHelperInsideUnboundFormOfSameHelper() {
      var _this16 = this;

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject3), {
        model: {
          foo: true,
          notfoo: false,
          bar: true
        }
      });

      this.assertText('truetrue');

      this.runTask(function () {
        return _this16.rerender();
      });

      this.assertText('truetrue');

      this.runTask(function () {
        return _emberMetal.set(_this16.context, 'model.bar', false);
      });

      this.assertText('falsefalse');

      this.runTask(function () {
        return _emberMetal.set(_this16.context, 'model', {
          foo: true,
          notfoo: false,
          bar: true
        });
      });

      this.assertText('truetrue');
    };

    _class.prototype['@test yielding unbound does not update'] = function testYieldingUnboundDoesNotUpdate() {
      var _this17 = this;

      var fooBarInstance = undefined;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          fooBarInstance = this;
        },
        model: { foo: 'bork' }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{yield (unbound model.foo)}}'
      });

      this.render('{{#foo-bar as |value|}}{{value}}{{/foo-bar}}');

      this.assertText('bork');

      this.runTask(function () {
        return _this17.rerender();
      });

      this.assertText('bork');

      this.runTask(function () {
        return _emberMetal.set(fooBarInstance, 'model.foo', 'oof');
      });

      this.assertText('bork');

      this.runTask(function () {
        return _emberMetal.set(fooBarInstance, 'model', { foo: 'bork' });
      });

      this.assertText('bork');
    };

    _class.prototype['@test yielding unbound hash does not update'] = function testYieldingUnboundHashDoesNotUpdate() {
      var _this18 = this;

      var fooBarInstance = undefined;
      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          fooBarInstance = this;
        },
        model: { foo: 'bork' }
      });

      this.registerComponent('foo-bar', {
        ComponentClass: FooBarComponent,
        template: '{{yield (unbound (hash foo=model.foo))}}'
      });

      this.render('{{#foo-bar as |value|}}{{value.foo}}{{/foo-bar}}');

      this.assertText('bork');

      this.runTask(function () {
        return _this18.rerender();
      });

      this.assertText('bork');

      this.runTask(function () {
        return _emberMetal.set(fooBarInstance, 'model.foo', 'oof');
      });

      this.assertText('bork');

      this.runTask(function () {
        return _emberMetal.set(fooBarInstance, 'model', { foo: 'bork' });
      });

      this.assertText('bork');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/helpers/unbound-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/helpers/unbound-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/helpers/unbound-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/helpers/yield-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-metal', 'ember-glimmer/tests/utils/helpers'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberMetal, _emberGlimmerTestsUtilsHelpers) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Helpers test: {{yield}} helper', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test can yield to block'] = function testCanYieldToBlock() {
      var _this = this;

      this.registerComponent('yield-comp', { template: '[In layout:] {{yield}}' });

      this.render('{{#yield-comp}}[In Block:] {{object.title}}{{/yield-comp}}', { object: { title: 'Seattle' } });
      this.assertText('[In layout:] [In Block:] Seattle');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'object.title', 'Vancouver');
      });
      this.assertText('[In layout:] [In Block:] Vancouver');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'object', { title: 'Seattle' });
      });
      this.assertText('[In layout:] [In Block:] Seattle');
    };

    _class.prototype['@test templates should yield to block inside a nested component'] = function testTemplatesShouldYieldToBlockInsideANestedComponent() {
      var _this2 = this;

      this.registerComponent('outer-comp', { template: '<div>[In layout:] {{yield}}</div>' });
      this.registerComponent('inner-comp', { template: '{{#outer-comp}}[In Block:] {{object.title}}{{/outer-comp}}' });

      this.render('{{inner-comp object=object}}', { object: { title: 'Seattle' } });
      this.assertText('[In layout:] [In Block:] Seattle');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'object.title', 'Vancouver');
      });
      this.assertText('[In layout:] [In Block:] Vancouver');

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'object', { title: 'Seattle' });
      });
      this.assertText('[In layout:] [In Block:] Seattle');
    };

    _class.prototype['@test templates should yield to block, when the yield is embedded in a each helper'] = function testTemplatesShouldYieldToBlockWhenTheYieldIsEmbeddedInAEachHelper() {
      var _this3 = this;

      var list = [1, 2, 3];

      this.registerComponent('outer-comp', { template: '{{#each list as |item|}}{{yield}}{{/each}}' });

      this.render('{{#outer-comp list=list}}Hello{{/outer-comp}}', { list: list });
      this.assertText('HelloHelloHello');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'list', [4, 5]);
      });
      this.assertText('HelloHello');

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'list', list);
      });
      this.assertText('HelloHelloHello');
    };

    _class.prototype['@test templates should yield to block, when the yield is embedded in a if helper'] = function testTemplatesShouldYieldToBlockWhenTheYieldIsEmbeddedInAIfHelper() {
      var _this4 = this;

      this.registerComponent('outer-comp', { template: '{{#if boolean}}{{yield}}{{/if}}' });

      this.render('{{#outer-comp boolean=boolean}}Hello{{/outer-comp}}', { boolean: true });
      this.assertText('Hello');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'boolean', false);
      });
      this.assertText('');

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'boolean', true);
      });
      this.assertText('Hello');
    };

    _class.prototype['@test simple curlies inside of a yielded clock should work when the yield is nested inside of another view'] = function testSimpleCurliesInsideOfAYieldedClockShouldWorkWhenTheYieldIsNestedInsideOfAnotherView() {
      var _this5 = this;

      this.registerComponent('kiwi-comp', { template: '{{#if falsy}}{{else}}{{yield}}{{/if}}' });

      this.render('{{#kiwi-comp}}{{text}}{{/kiwi-comp}}', { text: 'ohai' });
      this.assertText('ohai');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'text', 'portland');
      });
      this.assertText('portland');

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'text', 'ohai');
      });
      this.assertText('ohai');
    };

    _class.prototype['@test nested simple curlies inside of a yielded block should work when the yield is nested inside of another view'] = function testNestedSimpleCurliesInsideOfAYieldedBlockShouldWorkWhenTheYieldIsNestedInsideOfAnotherView() {
      var _this6 = this;

      this.registerComponent('parent-comp', { template: '{{#if falsy}}{{else}}{{yield}}{{/if}}' });
      this.registerComponent('child-comp', { template: '{{#if falsy}}{{else}}{{text}}{{/if}}' });

      this.render('{{#parent-comp}}{{child-comp text=text}}{{/parent-comp}}', { text: 'ohai' });
      this.assertText('ohai');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this6.context, 'text', 'portland');
      });
      this.assertText('portland');

      this.runTask(function () {
        return _emberMetal.set(_this6.context, 'text', 'ohai');
      });
      this.assertText('ohai');
    };

    _class.prototype['@test yielding to a non-existent block is not an error'] = function testYieldingToANonExistentBlockIsNotAnError() {
      var _this7 = this;

      this.registerComponent('yielding-comp', { template: 'Hello:{{yield}}' });
      this.registerComponent('outer-comp', { template: '{{yielding-comp}} {{title}}' });

      this.render('{{outer-comp title=title}}', { title: 'Mr. Selden' });

      this.assertText('Hello: Mr. Selden');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'title', 'Mr. Chag');
      });
      this.assertText('Hello: Mr. Chag');

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'title', 'Mr. Selden');
      });
      this.assertText('Hello: Mr. Selden');
    };

    _class.prototype['@test yield uses the original context'] = function testYieldUsesTheOriginalContext() {
      var _this8 = this;

      var KiwiCompComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({ boundText: 'Inner' });

      this.registerComponent('kiwi-comp', { ComponentClass: KiwiCompComponent, template: '<p>{{boundText}}</p><p>{{yield}}</p>' });

      this.render('{{#kiwi-comp}}{{boundText}}{{/kiwi-comp}}', { boundText: 'Original' });
      this.assertText('InnerOriginal');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this8.context, 'boundText', 'Otherworld');
      });
      this.assertText('InnerOtherworld');

      this.runTask(function () {
        return _emberMetal.set(_this8.context, 'boundText', 'Original');
      });
      this.assertText('InnerOriginal');
    };

    _class.prototype['@test outer block param doesn\'t mask inner component property'] = function testOuterBlockParamDoesnTMaskInnerComponentProperty() {
      var _this9 = this;

      var KiwiCompComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({ boundText: 'Inner' });

      this.registerComponent('kiwi-comp', { ComponentClass: KiwiCompComponent, template: '<p>{{boundText}}</p><p>{{yield}}</p>' });

      this.render('{{#with boundText as |item|}}{{#kiwi-comp}}{{item}}{{/kiwi-comp}}{{/with}}', { boundText: 'Outer' });
      this.assertText('InnerOuter');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this9.context, 'boundText', 'Otherworld');
      });
      this.assertText('InnerOtherworld');

      this.runTask(function () {
        return _emberMetal.set(_this9.context, 'boundText', 'Outer');
      });
      this.assertText('InnerOuter');
    };

    _class.prototype['@test inner block param doesn\'t mask yield property'] = function testInnerBlockParamDoesnTMaskYieldProperty() {
      var _this10 = this;

      var KiwiCompComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({ boundText: 'Inner' });

      this.registerComponent('kiwi-comp', { ComponentClass: KiwiCompComponent, template: '{{#with boundText as |item|}}<p>{{item}}</p><p>{{yield}}</p>{{/with}}' });

      this.render('{{#kiwi-comp}}{{item}}{{/kiwi-comp}}', { item: 'Outer' });
      this.assertText('InnerOuter');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this10.context, 'item', 'Otherworld');
      });
      this.assertText('InnerOtherworld');

      this.runTask(function () {
        return _emberMetal.set(_this10.context, 'item', 'Outer');
      });
      this.assertText('InnerOuter');
    };

    _class.prototype['@test can bind a block param to a component and use it in yield'] = function testCanBindABlockParamToAComponentAndUseItInYield() {
      var _this11 = this;

      this.registerComponent('kiwi-comp', { template: '<p>{{content}}</p><p>{{yield}}</p>' });

      this.render('{{#with boundText as |item|}}{{#kiwi-comp content=item}}{{item}}{{/kiwi-comp}}{{/with}}', { boundText: 'Outer' });
      this.assertText('OuterOuter');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this11.context, 'boundText', 'Update');
      });
      this.assertText('UpdateUpdate');

      this.runTask(function () {
        return _emberMetal.set(_this11.context, 'boundText', 'Outer');
      });
      this.assertText('OuterOuter');
    };

    // INUR not need with no data update

    _class.prototype['@test yield should not introduce a view'] = function testYieldShouldNotIntroduceAView() {
      var ParentCompComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({ isParentComponent: true });

      var ChildCompComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        didReceiveAttrs: function () {
          this._super();
          var parentView = this.get('parentView');

          ok(parentView.get('isParentComponent'));
        }
      });

      this.registerComponent('parent-comp', { ComponentClass: ParentCompComponent, template: '{{yield}}' });
      this.registerComponent('child-comp', { ComponentClass: ChildCompComponent });

      this.render('{{#parent-comp}}{{child-comp}}{{/parent-comp}}');
    };

    _class.prototype['@test yield with nested components (#3220)'] = function testYieldWithNestedComponents3220() {
      var _this12 = this;

      this.registerComponent('inner-component', { template: '{{yield}}' });
      this.registerComponent('outer-component', { template: '{{#inner-component}}<span>{{yield}}</span>{{/inner-component}}' });

      this.render('{{#outer-component}}Hello {{boundText}}{{/outer-component}}', { boundText: 'world' });
      this.assertText('Hello world');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this12.context, 'boundText', 'update');
      });
      this.assertText('Hello update');

      this.runTask(function () {
        return _emberMetal.set(_this12.context, 'boundText', 'world');
      });
      this.assertText('Hello world');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/helpers/yield-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/helpers/yield-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/helpers/yield-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/input-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-metal'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberMetal) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Input element tests', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype.runAttributeTest = function runAttributeTest(attributeName, values) {
      var _this = this;

      var template = '<input ' + attributeName + '={{value}}>';
      this.render(template, { value: values[0] });
      this.assertAttributeHasValue(attributeName, values[0], attributeName + ' is set on initial render');

      this.runTask(function () {
        return _this.rerender();
      });
      this.assertAttributeHasValue(attributeName, values[0], attributeName + ' is set on noop rerender');

      this.setComponentValue(values[1]);
      this.assertAttributeHasValue(attributeName, values[1], attributeName + ' is set on rerender');

      this.setComponentValue(values[0]);
      this.assertAttributeHasValue(attributeName, values[0], attributeName + ' can be set back to the initial value');
    };

    _class.prototype.runPropertyTest = function runPropertyTest(propertyName, values) {
      var _this2 = this;

      var attributeName = propertyName;
      var template = '<input ' + attributeName + '={{value}}>';
      this.render(template, { value: values[0] });
      this.assertPropertyHasValue(propertyName, values[0], propertyName + ' is set on initial render');

      this.runTask(function () {
        return _this2.rerender();
      });
      this.assertPropertyHasValue(propertyName, values[0], propertyName + ' is set on noop rerender');

      this.setComponentValue(values[1]);
      this.assertPropertyHasValue(propertyName, values[1], propertyName + ' is set on rerender');

      this.setComponentValue(values[0]);
      this.assertPropertyHasValue(propertyName, values[0], propertyName + ' can be set back to the initial value');
    };

    _class.prototype.runFalsyValueProperty = function runFalsyValueProperty(values) {
      var _this3 = this;

      var value = 'value';
      var template = '<input value={{value}}>';
      this.render(template, { value: values[0] });
      this.assertPropertyHasValue(value, '', value + ' is set on initial render');

      this.runTask(function () {
        return _this3.rerender();
      });
      this.assertPropertyHasValue(value, '', value + ' is set on noop rerender');
      this.setComponentValue(values[1]);

      this.assertPropertyHasValue(value, values[1], value + ' is set on rerender');

      this.setComponentValue(values[0]);
      this.assertPropertyHasValue(value, '', value + ' can be set back to the initial value');
    };

    _class.prototype['@test input disabled attribute'] = function testInputDisabledAttribute() {
      var _this4 = this;

      var model = { model: { value: false } };

      this.render('<input disabled={{model.value}}>', model);

      this.assert.equal(this.$inputElement().prop('disabled'), false);

      this.runTask(function () {
        return _this4.rerender();
      });

      this.assert.equal(this.$inputElement().prop('disabled'), false);

      this.runTask(function () {
        return _this4.context.set('model.value', true);
      });

      this.assert.equal(this.$inputElement().prop('disabled'), true);
      this.assertHTML('<input disabled="">'); // Note the DOM output is <input disabled>

      this.runTask(function () {
        return _this4.context.set('model.value', 'wat');
      });

      this.assert.equal(this.$inputElement().prop('disabled'), true);
      this.assertHTML('<input disabled="">'); // Note the DOM output is <input disabled>

      this.runTask(function () {
        return _this4.context.set('model', { value: false });
      });

      this.assert.equal(this.$inputElement().prop('disabled'), false);
      this.assertHTML('<input>');
    };

    _class.prototype['@test input value attribute'] = function testInputValueAttribute() {
      this.runPropertyTest('value', ['foo', 'bar']);
    };

    _class.prototype['@test input placeholder attribute'] = function testInputPlaceholderAttribute() {
      this.runAttributeTest('placeholder', ['foo', 'bar']);
    };

    _class.prototype['@test input name attribute'] = function testInputNameAttribute() {
      this.runAttributeTest('name', ['nam', 'name']);
    };

    _class.prototype['@test input maxlength attribute'] = function testInputMaxlengthAttribute() {
      this.runAttributeTest('maxlength', [2, 3]);
    };

    _class.prototype['@test input size attribute'] = function testInputSizeAttribute() {
      this.runAttributeTest('size', [2, 3]);
    };

    _class.prototype['@test input tabindex attribute'] = function testInputTabindexAttribute() {
      this.runAttributeTest('tabindex', [2, 3]);
    };

    _class.prototype['@test null input value'] = function testNullInputValue() {
      this.runFalsyValueProperty([null, 'hello']);
    };

    _class.prototype['@test undefined input value'] = function testUndefinedInputValue() {
      this.runFalsyValueProperty([undefined, 'hello']);
    };

    _class.prototype['@test undefined `toString` method as input value'] = function testUndefinedToStringMethodAsInputValue() {
      this.runFalsyValueProperty([Object.create(null), 'hello']);
    };

    _class.prototype['@test cursor position is not lost when updating content'] = function testCursorPositionIsNotLostWhenUpdatingContent() {
      var template = '<input value={{value}}>';
      this.render(template, { value: 'hola' });

      this.setDOMValue('hello');
      this.setSelectionRange(1, 3);

      this.setComponentValue('hello');

      this.assertSelectionRange(1, 3);

      // Note: We should eventually get around to testing reseting, however
      // browsers handle `selectionStart` and `selectionEnd` differently
      // when are synthetically testing movement of the cursor.
    };

    _class.prototype['@test input can be updated multiple times'] = function testInputCanBeUpdatedMultipleTimes() {
      var template = '<input value={{value}}>';
      this.render(template, { value: 'hola' });

      this.assertValue('hola', 'Value is initialised');

      this.setComponentValue('');
      this.assertValue('', 'Value is set in the DOM');

      this.setDOMValue('hola');
      this.setComponentValue('hola');
      this.assertValue('hola', 'Value is updated the first time');

      this.setComponentValue('');
      this.assertValue('', 'Value is updated the second time');
    };

    _class.prototype['@test DOM is SSOT if value is set'] = function testDOMIsSSOTIfValueIsSet() {
      var template = '<input value={{value}}>';
      this.render(template, { value: 'hola' });

      this.assertValue('hola', 'Value is initialised');

      this.setComponentValue('hello');

      this.assertValue('hello', 'Value is initialised');

      this.setDOMValue('hola');

      this.assertValue('hola', 'DOM is used');

      this.setComponentValue('bye');

      this.assertValue('bye', 'Value is used');

      // Simulates setting the input to the same value as it already is which won't cause a rerender

      this.setDOMValue('hola');

      this.assertValue('hola', 'DOM is used');

      this.setComponentValue('hola');

      this.assertValue('hola', 'Value is used');
    };

    // private helpers and assertions

    _class.prototype.setDOMValue = function setDOMValue(value) {
      this.inputElement().value = value;
    };

    _class.prototype.setComponentValue = function setComponentValue(value) {
      var _this5 = this;

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'value', value);
      });
    };

    _class.prototype.setSelectionRange = function setSelectionRange(start, end) {
      this.inputElement().selectionStart = start;
      this.inputElement().selectionEnd = end;
    };

    _class.prototype.inputElement = function inputElement() {
      return this.$inputElement()[0];
    };

    _class.prototype.$inputElement = function $inputElement() {
      return this.$('input');
    };

    _class.prototype.assertValue = function assertValue(value, message) {
      this.assertPropertyHasValue('value', value, message);
    };

    _class.prototype.assertAttributeHasValue = function assertAttributeHasValue(attribute, value, message) {
      this.assert.equal(this.$inputElement().attr(attribute), value, attribute + ' ' + message);
    };

    _class.prototype.assertPropertyHasValue = function assertPropertyHasValue(property, value, message) {
      this.assert.equal(this.$inputElement().prop(property), value, property + ' ' + message);
    };

    _class.prototype.assertSelectionRange = function assertSelectionRange(start, end) {
      this.assert.equal(this.inputElement().selectionStart, start);
      this.assert.equal(this.inputElement().selectionEnd, end);
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/input-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/input-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/input-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/mount-test', ['exports', 'ember-utils', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/helpers', 'ember-runtime', 'ember-metal', 'ember-application'], function (exports, _emberUtils, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsHelpers, _emberRuntime, _emberMetal, _emberApplication) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('{{mount}} assertions', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test it asserts that only a single param is passed'] = function testItAssertsThatOnlyASingleParamIsPassed() {
      var _this = this;

      expectAssertion(function () {
        _this.render('{{mount "chat" "foo"}}');
      }, /You can only pass a single argument to the {{mount}} helper, e.g. {{mount "chat-engine"}}./i);
    };

    _class.prototype['@test it asserts that the engine name argument is quoted'] = function testItAssertsThatTheEngineNameArgumentIsQuoted() {
      var _this2 = this;

      expectAssertion(function () {
        _this2.render('{{mount chat}}');
      }, /The first argument of {{mount}} must be quoted, e.g. {{mount "chat-engine"}}./i);
    };

    _class.prototype['@test it asserts that the specified engine is registered'] = function testItAssertsThatTheSpecifiedEngineIsRegistered() {
      var _this3 = this;

      expectAssertion(function () {
        _this3.render('{{mount "chat"}}');
      }, /You used `{{mount 'chat'}}`, but the engine 'chat' can not be found./i);
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('{{mount}} test', (function (_ApplicationTest) {
    babelHelpers.inherits(_class2, _ApplicationTest);

    function _class2() {
      _ApplicationTest.call(this);

      var engineRegistrations = this.engineRegistrations = {};

      this.registerEngine('chat', _emberApplication.Engine.extend({
        router: null,

        init: function () {
          var _this4 = this;

          this._super.apply(this, arguments);

          Object.keys(engineRegistrations).forEach(function (fullName) {
            _this4.register(fullName, engineRegistrations[fullName]);
          });
        }
      }));

      this.registerTemplate('index', '{{mount "chat"}}');
    }

    _class2.prototype['@test it boots an engine, instantiates its application controller, and renders its application template'] = function testItBootsAnEngineInstantiatesItsApplicationControllerAndRendersItsApplicationTemplate(assert) {
      var _this5 = this;

      this.engineRegistrations['template:application'] = _emberGlimmerTestsUtilsHelpers.compile('<h2>Chat here, {{username}}</h2>', { moduleName: 'application' });

      var controller = undefined;

      this.engineRegistrations['controller:application'] = _emberRuntime.Controller.extend({
        username: 'dgeb',

        init: function () {
          this._super();
          controller = this;
        }
      });

      return this.visit('/').then(function () {
        assert.ok(controller, 'engine\'s application controller has been instantiated');

        var engineInstance = _emberUtils.getOwner(controller);
        assert.strictEqual(_emberApplication.getEngineParent(engineInstance), _this5.applicationInstance, 'engine instance has the application instance as its parent');

        _this5.assertComponentElement(_this5.firstChild, { content: '<h2>Chat here, dgeb</h2>' });

        _this5.runTask(function () {
          return _emberMetal.set(controller, 'username', 'chancancode');
        });

        _this5.assertComponentElement(_this5.firstChild, { content: '<h2>Chat here, chancancode</h2>' });

        _this5.runTask(function () {
          return _emberMetal.set(controller, 'username', 'dgeb');
        });

        _this5.assertComponentElement(_this5.firstChild, { content: '<h2>Chat here, dgeb</h2>' });
      });
    };

    _class2.prototype['@test it emits a useful backtracking re-render assertion message'] = function testItEmitsAUsefulBacktrackingReRenderAssertionMessage(assert) {
      var _this6 = this;

      this.router.map(function () {
        this.route('route-with-mount');
      });

      this.registerTemplate('index', '');
      this.registerTemplate('route-with-mount', '{{mount "chat"}}');

      this.engineRegistrations['template:application'] = _emberGlimmerTestsUtilsHelpers.compile('hi {{person.name}} [{{component-with-backtracking-set person=person}}]', { moduleName: 'application' });
      this.engineRegistrations['controller:application'] = _emberRuntime.Controller.extend({
        person: { name: 'Alex' }
      });

      this.engineRegistrations['template:components/component-with-backtracking-set'] = _emberGlimmerTestsUtilsHelpers.compile('[component {{person.name}}]', { moduleName: 'components/component-with-backtracking-set' });
      this.engineRegistrations['component:component-with-backtracking-set'] = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          this.set('person.name', 'Ben');
        }
      });

      var expectedBacktrackingMessage = /modified "person\.name" twice on \[object Object\] in a single render\. It was rendered in "template:route-with-mount" \(in "engine:chat"\) and modified in "component:component-with-backtracking-set" \(in "engine:chat"\)/;

      if (true) {
        expectDeprecation(expectedBacktrackingMessage);
        return this.visit('/route-with-mount');
      } else {
        return this.visit('/').then(function () {
          expectAssertion(function () {
            _this6.visit('/route-with-mount');
          }, expectedBacktrackingMessage);
        });
      }
    };

    return _class2;
  })(_emberGlimmerTestsUtilsTestCase.ApplicationTest));
});
enifed('ember-glimmer/tests/integration/mount-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/mount-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/mount-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/outlet-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'internal-test-helpers', 'ember-metal'], function (exports, _emberGlimmerTestsUtilsTestCase, _internalTestHelpers, _emberMetal) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('outlet view', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);

      var CoreOutlet = undefined;
      if (true) {
        CoreOutlet = this.owner.factoryFor('view:-outlet');
      } else {
        CoreOutlet = this.owner._lookupFactory('view:-outlet');
      }

      this.component = CoreOutlet.create();
    }

    _class.prototype['@test should not error when initial rendered template is undefined'] = function testShouldNotErrorWhenInitialRenderedTemplateIsUndefined() {
      var _this = this;

      var outletState = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'application',
          controller: undefined,
          ViewClass: undefined,
          template: undefined
        },

        outlets: Object.create(null)
      };

      this.runTask(function () {
        return _this.component.setOutletState(outletState);
      });

      _internalTestHelpers.runAppend(this.component);

      this.assertText('');
    };

    _class.prototype['@test should render the outlet when set after DOM insertion'] = function testShouldRenderTheOutletWhenSetAfterDOMInsertion() {
      var _this2 = this;

      var outletState = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'application',
          controller: undefined,
          ViewClass: undefined,
          template: undefined
        },

        outlets: Object.create(null)
      };

      this.runTask(function () {
        return _this2.component.setOutletState(outletState);
      });

      _internalTestHelpers.runAppend(this.component);

      this.assertText('');

      this.registerTemplate('application', 'HI{{outlet}}');
      outletState = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'application',
          controller: {},
          ViewClass: undefined,
          template: this.owner.lookup('template:application')
        },
        outlets: Object.create(null)
      };

      this.runTask(function () {
        return _this2.component.setOutletState(outletState);
      });

      this.assertText('HI');

      this.assertStableRerender();

      this.registerTemplate('index', '<p>BYE</p>');
      outletState.outlets.main = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'index',
          controller: {},
          ViewClass: undefined,
          template: this.owner.lookup('template:index')
        },
        outlets: Object.create(null)
      };

      this.runTask(function () {
        return _this2.component.setOutletState(outletState);
      });

      this.assertText('HIBYE');
    };

    _class.prototype['@test should render the outlet when set before DOM insertion'] = function testShouldRenderTheOutletWhenSetBeforeDOMInsertion() {
      var _this3 = this;

      this.registerTemplate('application', 'HI{{outlet}}');
      var outletState = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'application',
          controller: {},
          ViewClass: undefined,
          template: this.owner.lookup('template:application')
        },
        outlets: Object.create(null)
      };

      this.runTask(function () {
        return _this3.component.setOutletState(outletState);
      });

      _internalTestHelpers.runAppend(this.component);

      this.assertText('HI');

      this.assertStableRerender();

      this.registerTemplate('index', '<p>BYE</p>');
      outletState.outlets.main = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'index',
          controller: {},
          ViewClass: undefined,
          template: this.owner.lookup('template:index')
        },
        outlets: Object.create(null)
      };

      this.runTask(function () {
        return _this3.component.setOutletState(outletState);
      });

      this.assertText('HIBYE');
    };

    _class.prototype['@test should support an optional name'] = function testShouldSupportAnOptionalName() {
      var _this4 = this;

      this.registerTemplate('application', '<h1>HI</h1>{{outlet "special"}}');
      var outletState = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'application',
          controller: {},
          ViewClass: undefined,
          template: this.owner.lookup('template:application')
        },
        outlets: Object.create(null)
      };

      this.runTask(function () {
        return _this4.component.setOutletState(outletState);
      });

      _internalTestHelpers.runAppend(this.component);

      this.assertText('HI');

      this.assertStableRerender();

      this.registerTemplate('special', '<p>BYE</p>');
      outletState.outlets.special = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'special',
          controller: {},
          ViewClass: undefined,
          template: this.owner.lookup('template:special')
        },
        outlets: Object.create(null)
      };

      this.runTask(function () {
        return _this4.component.setOutletState(outletState);
      });

      this.assertText('HIBYE');
    };

    _class.prototype['@test does not default outlet name when positional argument is present'] = function testDoesNotDefaultOutletNameWhenPositionalArgumentIsPresent() {
      var _this5 = this;

      this.registerTemplate('application', '<h1>HI</h1>{{outlet someUndefinedThing}}');
      var outletState = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'application',
          controller: {},
          ViewClass: undefined,
          template: this.owner.lookup('template:application')
        },
        outlets: Object.create(null)
      };

      this.runTask(function () {
        return _this5.component.setOutletState(outletState);
      });

      _internalTestHelpers.runAppend(this.component);

      this.assertText('HI');

      this.assertStableRerender();

      this.registerTemplate('special', '<p>BYE</p>');
      outletState.outlets.main = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'special',
          controller: {},
          ViewClass: undefined,
          template: this.owner.lookup('template:special')
        },
        outlets: Object.create(null)
      };

      this.runTask(function () {
        return _this5.component.setOutletState(outletState);
      });

      this.assertText('HI');
    };

    _class.prototype['@test should support bound outlet name'] = function testShouldSupportBoundOutletName() {
      var _this6 = this;

      var controller = { outletName: 'foo' };
      this.registerTemplate('application', '<h1>HI</h1>{{outlet outletName}}');
      var outletState = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'application',
          controller: controller,
          ViewClass: undefined,
          template: this.owner.lookup('template:application')
        },
        outlets: Object.create(null)
      };

      this.runTask(function () {
        return _this6.component.setOutletState(outletState);
      });

      _internalTestHelpers.runAppend(this.component);

      this.assertText('HI');

      this.assertStableRerender();

      this.registerTemplate('foo', '<p>FOO</p>');
      outletState.outlets.foo = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'foo',
          controller: {},
          ViewClass: undefined,
          template: this.owner.lookup('template:foo')
        },
        outlets: Object.create(null)
      };

      this.registerTemplate('bar', '<p>BAR</p>');
      outletState.outlets.bar = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'bar',
          controller: {},
          ViewClass: undefined,
          template: this.owner.lookup('template:bar')
        },
        outlets: Object.create(null)
      };

      this.runTask(function () {
        return _this6.component.setOutletState(outletState);
      });

      this.assertText('HIFOO');

      this.runTask(function () {
        return _emberMetal.set(controller, 'outletName', 'bar');
      });

      this.assertText('HIBAR');
    };

    _class.prototype['@test outletState can pass through user code (liquid-fire initimate API) '] = function testOutletStateCanPassThroughUserCodeLiquidFireInitimateAPI() {
      var _this7 = this;

      this.registerTemplate('outer', 'A{{#-with-dynamic-vars outletState=(identity (-get-dynamic-var "outletState"))}}B{{outlet}}D{{/-with-dynamic-vars}}E');
      this.registerTemplate('inner', 'C');

      // This looks like it doesn't do anything, but its presence
      // guarantees that the outletState gets converted from a reference
      // to a value and then back to a reference. That is what we're
      // testing here.
      this.registerHelper('identity', function (_ref) {
        var a = _ref[0];
        return a;
      });

      var outletState = {
        render: {
          owner: this.owner,
          into: undefined,
          outlet: 'main',
          name: 'outer',
          controller: {},
          ViewClass: undefined,
          template: this.owner.lookup('template:outer')
        },
        outlets: {
          main: {
            render: {
              owner: this.owner,
              into: undefined,
              outlet: 'main',
              name: 'inner',
              controller: {},
              ViewClass: undefined,
              template: this.owner.lookup('template:inner')
            },
            outlets: Object.create(null)
          }
        }
      };

      this.runTask(function () {
        return _this7.component.setOutletState(outletState);
      });

      _internalTestHelpers.runAppend(this.component);

      this.assertText('ABCDE');

      this.assertStableRerender();
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/outlet-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/outlet-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/outlet-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/refinements-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/abstract-test-case', 'ember-metal'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsAbstractTestCase, _emberMetal) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#with var as |foo|}}\n        {{foo}}\n      {{/with}}\n\n      ---\n\n      {{#with var as |render|}}\n        {{render}}\n      {{/with}}\n\n      ---\n\n      {{#with var as |outlet|}}\n        {{outlet}}\n      {{/with}}\n\n      ---\n\n      {{#with var as |mount|}}\n        {{mount}}\n      {{/with}}\n\n      ---\n\n      {{#with var as |component|}}\n        {{component}}\n      {{/with}}\n\n      ---\n\n      {{#with var as |input|}}\n        {{input}}\n      {{/with}}\n\n      ---\n\n      {{#with var as |-with-dynamic-vars|}}\n        {{-with-dynamic-vars}}\n      {{/with}}\n\n      ---\n\n      {{#with var as |-in-element|}}\n        {{-in-element}}\n      {{/with}}'], ['\n      {{#with var as |foo|}}\n        {{foo}}\n      {{/with}}\n\n      ---\n\n      {{#with var as |render|}}\n        {{render}}\n      {{/with}}\n\n      ---\n\n      {{#with var as |outlet|}}\n        {{outlet}}\n      {{/with}}\n\n      ---\n\n      {{#with var as |mount|}}\n        {{mount}}\n      {{/with}}\n\n      ---\n\n      {{#with var as |component|}}\n        {{component}}\n      {{/with}}\n\n      ---\n\n      {{#with var as |input|}}\n        {{input}}\n      {{/with}}\n\n      ---\n\n      {{#with var as |-with-dynamic-vars|}}\n        {{-with-dynamic-vars}}\n      {{/with}}\n\n      ---\n\n      {{#with var as |-in-element|}}\n        {{-in-element}}\n      {{/with}}']);

  _emberGlimmerTestsUtilsTestCase.moduleFor('syntax refinements', (function (_RenderingTest) {
babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test block params should not be refined'] = function testBlockParamsShouldNotBeRefined() {
      var _this = this;

      this.registerHelper('foo', function () {
        return 'bar helper';
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject), { var: 'var' });

      this.assertText('var---var---var---var---var---var---var---var');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'var', 'RARRR!!!');
      });

      this.assertText('RARRR!!!---RARRR!!!---RARRR!!!---RARRR!!!---RARRR!!!---RARRR!!!---RARRR!!!---RARRR!!!');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'var', 'var');
      });

      this.assertText('var---var---var---var---var---var---var---var');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/refinements-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/refinements-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/refinements-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/svg-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-metal', 'ember-glimmer/tests/utils/abstract-test-case'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberMetal, _emberGlimmerTestsUtilsAbstractTestCase) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n      <div>\n        <svg viewBox="', '"></svg>\n      </div>\n    '], ['\n      <div>\n        <svg viewBox="', '"></svg>\n      </div>\n    ']),
      _templateObject2 = babelHelpers.taggedTemplateLiteralLoose(['\n      <div>\n        <svg viewBox="0 0 ', '"></svg>\n      </div>\n    '], ['\n      <div>\n        <svg viewBox="0 0 ', '"></svg>\n      </div>\n    ']),
      _templateObject3 = babelHelpers.taggedTemplateLiteralLoose(['\n      <div>\n        <svg viewBox="0 0 200 200"></svg>\n      </div>\n    '], ['\n      <div>\n        <svg viewBox="0 0 200 200"></svg>\n      </div>\n    ']),
      _templateObject4 = babelHelpers.taggedTemplateLiteralLoose(['\n      <div>\n        <svg class="blue tall"></svg>\n      </div>\n    '], ['\n      <div>\n        <svg class="blue tall"></svg>\n      </div>\n    ']),
      _templateObject5 = babelHelpers.taggedTemplateLiteralLoose(['\n      <div>\n        <svg class="yellow tall"></svg>\n      </div>\n    '], ['\n      <div>\n        <svg class="yellow tall"></svg>\n      </div>\n    ']);

  _emberGlimmerTestsUtilsTestCase.moduleFor('SVG element tests', (function (_RenderingTest) {
babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test unquoted viewBox property is output'] = function testUnquotedViewBoxPropertyIsOutput(assert) {
      var _this = this;

      var viewBoxString = '0 0 100 100';

      this.render('<div><svg viewBox={{model.viewBoxString}}></svg></div>', {
        model: {
          viewBoxString: viewBoxString
        }
      });

      this.assertInnerHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject, viewBoxString));

      this.runTask(function () {
        return _this.rerender();
      });

      this.assertInnerHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject, viewBoxString));

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'model.viewBoxString', null);
      });

      assert.equal(this.firstChild.getAttribute('svg'), null);

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'model', { viewBoxString: viewBoxString });
      });

      this.assertInnerHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject, viewBoxString));
    };

    _class.prototype['@test quoted viewBox property is output'] = function testQuotedViewBoxPropertyIsOutput(assert) {
      var _this2 = this;

      var viewBoxString = '0 0 100 100';

      this.render('<div><svg viewBox="{{model.viewBoxString}}"></svg></div>', {
        model: {
          viewBoxString: viewBoxString
        }
      });

      this.assertInnerHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject, viewBoxString));

      this.runTask(function () {
        return _this2.rerender();
      });

      this.assertInnerHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject, viewBoxString));

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'model.viewBoxString', null);
      });

      assert.equal(this.firstChild.getAttribute('svg'), null);

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'model', { viewBoxString: viewBoxString });
      });

      this.assertInnerHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject, viewBoxString));
    };

    _class.prototype['@test quoted viewBox property is concat'] = function testQuotedViewBoxPropertyIsConcat() {
      var _this3 = this;

      var viewBoxString = '100 100';

      this.render('<div><svg viewBox="0 0 {{model.viewBoxString}}"></svg></div>', {
        model: {
          viewBoxString: viewBoxString
        }
      });

      this.assertInnerHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2, viewBoxString));

      this.runTask(function () {
        return _this3.rerender();
      });

      this.assertInnerHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2, viewBoxString));

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'model.viewBoxString', '200 200');
      });

      this.assertInnerHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject3));

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'model', { viewBoxString: viewBoxString });
      });

      this.assertInnerHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2, viewBoxString));
    };

    _class.prototype['@test class is output'] = function testClassIsOutput() {
      var _this4 = this;

      this.render('<div><svg class=\'{{model.color}} tall\'></svg></div>', {
        model: {
          color: 'blue'
        }
      });

      this.assertInnerHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject4));

      this.runTask(function () {
        return _this4.rerender();
      });

      this.assertInnerHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject4));

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'model.color', 'yellow');
      });

      this.assertInnerHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject5));

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'model', { color: 'blue' });
      });

      this.assertInnerHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject4));
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/svg-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/svg-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/svg-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/syntax/each-in-test', ['exports', 'ember-metal', 'ember-glimmer/tests/utils/abstract-test-case', 'ember-glimmer/tests/utils/test-case', 'ember-runtime', 'ember-glimmer/tests/utils/shared-conditional-tests'], function (exports, _emberMetal, _emberGlimmerTestsUtilsAbstractTestCase, _emberGlimmerTestsUtilsTestCase, _emberRuntime, _emberGlimmerTestsUtilsSharedConditionalTests) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n      <ul>\n        {{#each-in categories as |category count|}}\n          <li>{{category}}: {{count}}</li>\n        {{/each-in}}\n      </ul>\n    '], ['\n      <ul>\n        {{#each-in categories as |category count|}}\n          <li>{{category}}: {{count}}</li>\n        {{/each-in}}\n      </ul>\n    ']),
      _templateObject2 = babelHelpers.taggedTemplateLiteralLoose(['\n      <ul>\n        <li>Smartphones: 8203</li>\n        <li>JavaScript Frameworks: Infinity</li>\n      </ul>\n    '], ['\n      <ul>\n        <li>Smartphones: 8203</li>\n        <li>JavaScript Frameworks: Infinity</li>\n      </ul>\n    ']),
      _templateObject3 = babelHelpers.taggedTemplateLiteralLoose(['\n      <ul>\n        <li>Smartphones: 100</li>\n        <li>JavaScript Frameworks: Infinity</li>\n        <li>Tweets: 443115</li>\n      </ul>\n    '], ['\n      <ul>\n        <li>Smartphones: 100</li>\n        <li>JavaScript Frameworks: Infinity</li>\n        <li>Tweets: 443115</li>\n      </ul>\n    ']),
      _templateObject4 = babelHelpers.taggedTemplateLiteralLoose(['\n      <ul>\n        {{#each-in categories as |category data|}}\n          <li>{{category}}: {{data.reports.unitsSold}}</li>\n        {{/each-in}}\n      </ul>\n    '], ['\n      <ul>\n        {{#each-in categories as |category data|}}\n          <li>{{category}}: {{data.reports.unitsSold}}</li>\n        {{/each-in}}\n      </ul>\n    ']),
      _templateObject5 = babelHelpers.taggedTemplateLiteralLoose(['\n      <ul>\n        {{#each-in categories key=\'@identity\' as |category count|}}\n          <li>{{category}}: {{count}}</li>\n        {{/each-in}}\n      </ul>\n    '], ['\n      <ul>\n        {{#each-in categories key=\'@identity\' as |category count|}}\n          <li>{{category}}: {{count}}</li>\n        {{/each-in}}\n      </ul>\n    ']),
      _templateObject6 = babelHelpers.taggedTemplateLiteralLoose(['\n      <ul>\n        <li>Smartphones: 8203</li>\n        <li>Tablets: 8203</li>\n        <li>JavaScript Frameworks: Infinity</li>\n        <li>Bugs: Infinity</li>\n      </ul>\n    '], ['\n      <ul>\n        <li>Smartphones: 8203</li>\n        <li>Tablets: 8203</li>\n        <li>JavaScript Frameworks: Infinity</li>\n        <li>Bugs: Infinity</li>\n      </ul>\n    ']),
      _templateObject7 = babelHelpers.taggedTemplateLiteralLoose(['\n      <ul>\n        <li>Smartphones: 100</li>\n        <li>Tablets: 8203</li>\n        <li>JavaScript Frameworks: Infinity</li>\n        <li>Bugs: Infinity</li>\n        <li>Tweets: 443115</li>\n      </ul>\n    '], ['\n      <ul>\n        <li>Smartphones: 100</li>\n        <li>Tablets: 8203</li>\n        <li>JavaScript Frameworks: Infinity</li>\n        <li>Bugs: Infinity</li>\n        <li>Tweets: 443115</li>\n      </ul>\n    ']),
      _templateObject8 = babelHelpers.taggedTemplateLiteralLoose(['\n      <ul>\n        {{#each-in (get collection type) as |category count|}}\n          <li>{{category}}: {{count}}</li>\n        {{/each-in}}\n      </ul>\n    '], ['\n      <ul>\n        {{#each-in (get collection type) as |category count|}}\n          <li>{{category}}: {{count}}</li>\n        {{/each-in}}\n      </ul>\n    ']),
      _templateObject9 = babelHelpers.taggedTemplateLiteralLoose(['\n      <ul>\n        <li>Emberinios: 533462</li>\n        <li>Tweets: 7323</li>\n      </ul>\n    '], ['\n      <ul>\n        <li>Emberinios: 533462</li>\n        <li>Tweets: 7323</li>\n      </ul>\n    ']),
      _templateObject10 = babelHelpers.taggedTemplateLiteralLoose(['\n      <ul>\n        <li>Televisions: 183</li>\n        <li>Alarm Clocks: 999</li>\n      </ul>\n    '], ['\n      <ul>\n        <li>Televisions: 183</li>\n        <li>Alarm Clocks: 999</li>\n      </ul>\n    ']),
      _templateObject11 = babelHelpers.taggedTemplateLiteralLoose(['\n      <ul>\n        <li>Televisions: 183</li>\n        <li>Alarm Clocks: 999</li>\n        <li>Tweets: 443115</li>\n      </ul>\n    '], ['\n      <ul>\n        <li>Televisions: 183</li>\n        <li>Alarm Clocks: 999</li>\n        <li>Tweets: 443115</li>\n      </ul>\n    ']),
      _templateObject12 = babelHelpers.taggedTemplateLiteralLoose(['\n      <ul>\n        <li>Emberinios: 123456</li>\n      </ul>\n    '], ['\n      <ul>\n        <li>Emberinios: 123456</li>\n      </ul>\n    ']),
      _templateObject13 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#each-in foo.bar.baz as |thing|}}\n        {{thing}}\n      {{/each-in}}'], ['\n      {{#each-in foo.bar.baz as |thing|}}\n        {{thing}}\n      {{/each-in}}']),
      _templateObject14 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#each-in arr as |key value|}}\n        [{{key}}:{{value}}]\n      {{/each-in}}'], ['\n      {{#each-in arr as |key value|}}\n        [{{key}}:{{value}}]\n      {{/each-in}}']),
      _templateObject15 = babelHelpers.taggedTemplateLiteralLoose(['\n      <ul>\n        <li>Smartphones: 100</li>\n        <li>Tablets: 20</li>\n      </ul>\n    '], ['\n      <ul>\n        <li>Smartphones: 100</li>\n        <li>Tablets: 20</li>\n      </ul>\n    ']);

  var EachInTest = (function (_TogglingSyntaxConditionalsTest) {
babelHelpers.inherits(EachInTest, _TogglingSyntaxConditionalsTest);

    function EachInTest() {
      _TogglingSyntaxConditionalsTest.apply(this, arguments);
    }

    EachInTest.prototype.templateFor = function templateFor(_ref) {
      var cond = _ref.cond;
      var truthy = _ref.truthy;
      var falsy = _ref.falsy;

      return '{{#each-in ' + cond + ' as |key|}}' + truthy + '{{else}}' + falsy + '{{/each-in}}';
    };

    return EachInTest;
  })(_emberGlimmerTestsUtilsSharedConditionalTests.TogglingSyntaxConditionalsTest);

  function EmptyFunction() {}

  function NonEmptyFunction() {}
  NonEmptyFunction.foo = 'bar';

  var EmptyConstructor = function EmptyConstructor() {};

  var NonEmptyConstructor = function NonEmptyConstructor() {};

  NonEmptyConstructor.foo = 'bar';

  var BasicEachInTest = (function (_EachInTest) {
babelHelpers.inherits(BasicEachInTest, _EachInTest);

    function BasicEachInTest() {
      _EachInTest.apply(this, arguments);
    }

    return BasicEachInTest;
  })(EachInTest);

  _emberGlimmerTestsUtilsAbstractTestCase.applyMixins(BasicEachInTest, new _emberGlimmerTestsUtilsSharedConditionalTests.TruthyGenerator([{ foo: 1 }, _emberRuntime.Object.create({ 'Not Empty': 1 }), [1], NonEmptyFunction, NonEmptyConstructor]), new _emberGlimmerTestsUtilsSharedConditionalTests.FalsyGenerator([null, undefined, false, '', 0, [], EmptyFunction, EmptyConstructor, {}, Object.create(null), Object.create({}), Object.create({ 'Not Empty': 1 }), _emberRuntime.Object.create()]));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: {{#each-in}}', (function (_BasicEachInTest) {
babelHelpers.inherits(_class, _BasicEachInTest);

    function _class() {
      _BasicEachInTest.apply(this, arguments);
    }

    _class.prototype['@test it repeats the given block for each item in the hash'] = function testItRepeatsTheGivenBlockForEachItemInTheHash() {
      var _this = this;

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject), {
        categories: {
          'Smartphones': 8203,
          'JavaScript Frameworks': Infinity
        }
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2));

      this.assertStableRerender();

      this.runTask(function () {
        _emberMetal.set(_this.context, 'categories.Smartphones', 100);
        _emberMetal.set(_this.context, 'categories.Tweets', 443115);
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject3));

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'categories', {
          'Smartphones': 8203,
          'JavaScript Frameworks': Infinity
        });
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2));
    };

    _class.prototype['@test it can render sub-paths of each item'] = function testItCanRenderSubPathsOfEachItem() {
      var _this2 = this;

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject4), {
        categories: {
          'Smartphones': { reports: { unitsSold: 8203 } },
          'JavaScript Frameworks': { reports: { unitsSold: Infinity } }
        }
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2));

      this.assertStableRerender();

      this.runTask(function () {
        _emberMetal.set(_this2.context, 'categories.Smartphones.reports.unitsSold', 100);
        _emberMetal.set(_this2.context, 'categories.Tweets', { reports: { unitsSold: 443115 } });
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject3));

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'categories', {
          'Smartphones': { reports: { unitsSold: 8203 } },
          'JavaScript Frameworks': { reports: { unitsSold: Infinity } }
        });
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2));
    };

    _class.prototype['@test it can render duplicate items'] = function testItCanRenderDuplicateItems() {
      var _this3 = this;

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject5), {
        categories: {
          'Smartphones': 8203,
          'Tablets': 8203,
          'JavaScript Frameworks': Infinity,
          'Bugs': Infinity
        }
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject6));

      this.assertStableRerender();

      this.runTask(function () {
        _emberMetal.set(_this3.context, 'categories.Smartphones', 100);
        _emberMetal.set(_this3.context, 'categories.Tweets', 443115);
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject7));

      this.runTask(function () {
        return _emberMetal.set(_this3.context, 'categories', {
          'Smartphones': 8203,
          'Tablets': 8203,
          'JavaScript Frameworks': Infinity,
          'Bugs': Infinity
        });
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject6));
    };

    _class.prototype['@test it repeats the given block when the hash is dynamic'] = function testItRepeatsTheGivenBlockWhenTheHashIsDynamic() {
      var _this4 = this;

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject8), {
        collection: {
          categories: {
            'Smartphones': 8203,
            'JavaScript Frameworks': Infinity
          },
          otherCategories: {
            'Emberinios': 533462,
            'Tweets': 7323
          }
        },
        type: 'categories'
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2));

      this.assertStableRerender();

      this.runTask(function () {
        _emberMetal.set(_this4.context, 'type', 'otherCategories');
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject9));

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'type', 'categories');
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2));
    };

    _class.prototype['@test it only iterates over an object\'s own properties'] = function testItOnlyIteratesOverAnObjectSOwnProperties() {
      var _this5 = this;

      var protoCategories = {
        'Smartphones': 8203,
        'JavaScript Frameworks': Infinity
      };

      var categories = Object.create(protoCategories);
      categories['Televisions'] = 183;
      categories['Alarm Clocks'] = 999;

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject), { categories: categories });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject10));

      this.assertStableRerender();

      this.runTask(function () {
        _emberMetal.set(protoCategories, 'Robots', 666);
        _emberMetal.set(categories, 'Tweets', 443115);
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject11));

      categories = Object.create(protoCategories);
      categories['Televisions'] = 183;
      categories['Alarm Clocks'] = 999;

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'categories', categories);
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject10));
    };

    _class.prototype['@test it does not observe direct property mutations (not going through set) on the object'] = function testItDoesNotObserveDirectPropertyMutationsNotGoingThroughSetOnTheObject() {
      var _this6 = this;

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject), {
        categories: {
          'Smartphones': 8203,
          'JavaScript Frameworks': Infinity
        }
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2));

      this.assertStableRerender();

      this.runTask(function () {
        var categories = _emberMetal.get(_this6.context, 'categories');
        delete categories.Smartphones;
      });

      this.assertInvariants();

      this.runTask(function () {
        var categories = _emberMetal.get(_this6.context, 'categories');
        categories['Emberinios'] = 123456;
      });

      this.assertInvariants();

      this.runTask(function () {
        _emberMetal.set(_this6.context, 'categories', {
          Emberinios: 123456
        });
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject12));

      this.runTask(function () {
        _emberMetal.set(_this6.context, 'categories', {
          'Smartphones': 8203,
          'JavaScript Frameworks': Infinity
        });
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2));
    };

    _class.prototype['@test keying off of `undefined` does not render'] = function testKeyingOffOfUndefinedDoesNotRender(assert) {
      var _this7 = this;

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject13), { foo: {} });

      this.assertText('');

      this.runTask(function () {
        return _this7.rerender();
      });

      this.assertText('');

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'foo', { bar: { baz: { 'Here!': 1 } } });
      });

      this.assertText('Here!');

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'foo', {});
      });

      this.assertText('');
    };

    _class.prototype['@test it iterate over array with `in` instead of walking over elements'] = function testItIterateOverArrayWithInInsteadOfWalkingOverElements(assert) {
      var _this8 = this;

      var arr = [1, 2, 3];
      arr.foo = 'bar';

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject14), { arr: arr });

      this.assertText('[0:1][1:2][2:3][foo:bar]');

      this.runTask(function () {
        return _this8.rerender();
      });

      this.assertText('[0:1][1:2][2:3][foo:bar]');

      this.runTask(function () {
        _emberMetal.set(arr, 'zomg', 'lol');
      });

      this.assertText('[0:1][1:2][2:3][foo:bar][zomg:lol]');

      arr = [1, 2, 3];
      arr.foo = 'bar';

      this.runTask(function () {
        return _emberMetal.set(_this8.context, 'arr', arr);
      });

      this.assertText('[0:1][1:2][2:3][foo:bar]');
    };

    _class.prototype['@test it skips holes in sparse arrays'] = function testItSkipsHolesInSparseArrays(assert) {
      var arr = [];
      arr[5] = 'foo';
      arr[6] = 'bar';

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject14), { arr: arr });

      this.assertText('[5:foo][6:bar]');

      this.assertStableRerender();
    };

babelHelpers.createClass(_class, [{
      key: 'truthyValue',
      get: function () {
        return { 'Not Empty': 1 };
      }
    }, {
      key: 'falsyValue',
      get: function () {
        return {};
      }
    }]);
    return _class;
  })(BasicEachInTest));

  var EachInEdgeCasesTest = (function (_EachInTest2) {
babelHelpers.inherits(EachInEdgeCasesTest, _EachInTest2);

    function EachInEdgeCasesTest() {
      _EachInTest2.apply(this, arguments);
    }

    return EachInEdgeCasesTest;
  })(EachInTest);

  _emberGlimmerTestsUtilsAbstractTestCase.applyMixins(EachInEdgeCasesTest, new _emberGlimmerTestsUtilsSharedConditionalTests.FalsyGenerator([true, 1, 'hello']));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: {{#each-in}} edge cases', (function (_EachInEdgeCasesTest) {
babelHelpers.inherits(_class2, _EachInEdgeCasesTest);

    function _class2() {
      _EachInEdgeCasesTest.apply(this, arguments);
    }

babelHelpers.createClass(_class2, [{
      key: 'truthyValue',
      get: function () {
        return { 'Not Empty': 1 };
      }
    }, {
      key: 'falsyValue',
      get: function () {
        return {};
      }
    }]);
    return _class2;
  })(EachInEdgeCasesTest));

  var EachInProxyTest = (function (_EachInTest3) {
babelHelpers.inherits(EachInProxyTest, _EachInTest3);

    function EachInProxyTest() {
      _EachInTest3.apply(this, arguments);
    }

    return EachInProxyTest;
  })(EachInTest);

  _emberGlimmerTestsUtilsAbstractTestCase.applyMixins(EachInProxyTest, new _emberGlimmerTestsUtilsSharedConditionalTests.TruthyGenerator([_emberRuntime.ObjectProxy.create({ content: { 'Not empty': 1 } })]), new _emberGlimmerTestsUtilsSharedConditionalTests.FalsyGenerator([_emberRuntime.ObjectProxy.create(), _emberRuntime.ObjectProxy.create({ content: null }), _emberRuntime.ObjectProxy.create({ content: {} }), _emberRuntime.ObjectProxy.create({ content: Object.create(null) }), _emberRuntime.ObjectProxy.create({ content: Object.create({}) }), _emberRuntime.ObjectProxy.create({ content: Object.create({ 'Not Empty': 1 }) }), _emberRuntime.ObjectProxy.create({ content: _emberRuntime.Object.create() })]));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: {{#each-in}} with `ObjectProxy`', (function (_EachInProxyTest) {
babelHelpers.inherits(_class3, _EachInProxyTest);

    function _class3() {
      _EachInProxyTest.apply(this, arguments);
    }

    _class3.prototype['@test it iterates over the content, not the proxy'] = function testItIteratesOverTheContentNotTheProxy() {
      var _this9 = this;

      var content = {
        'Smartphones': 8203,
        'JavaScript Frameworks': Infinity
      };

      var proxy = _emberRuntime.ObjectProxy.create({
        content: content,
        foo: 'bar'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject), { categories: proxy });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2));

      this.assertStableRerender();

      this.runTask(function () {
        _emberMetal.set(proxy, 'content.Smartphones', 100);
        _emberMetal.set(proxy, 'content.Tweets', 443115);
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject3));

      this.runTask(function () {
        _emberMetal.set(proxy, 'content', {
          'Smartphones': 100,
          'Tablets': 20
        });
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject15));

      this.runTask(function () {
        return _emberMetal.set(_this9.context, 'categories', _emberRuntime.ObjectProxy.create({
          content: {
            'Smartphones': 8203,
            'JavaScript Frameworks': Infinity
          }
        }));
      });

      this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2));
    };

babelHelpers.createClass(_class3, [{
      key: 'truthyValue',
      get: function () {
        return _emberRuntime.ObjectProxy.create({ content: { 'Not Empty': 1 } });
      }
    }, {
      key: 'falsyValue',
      get: function () {
        return _emberRuntime.ObjectProxy.create({ content: null });
      }
    }]);
    return _class3;
  })(EachInProxyTest));
});
enifed('ember-glimmer/tests/integration/syntax/each-in-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/syntax/each-in-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/syntax/each-in-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/syntax/each-test', ['exports', 'ember-metal', 'ember-glimmer/tests/utils/abstract-test-case', 'ember-glimmer/tests/utils/test-case', 'ember-runtime', 'ember-glimmer/tests/utils/helpers', 'ember-glimmer/tests/utils/shared-conditional-tests'], function (exports, _emberMetal, _emberGlimmerTestsUtilsAbstractTestCase, _emberGlimmerTestsUtilsTestCase, _emberRuntime, _emberGlimmerTestsUtilsHelpers, _emberGlimmerTestsUtilsSharedConditionalTests) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#each list as |item|}}\n        <li>Prev</li>\n        {{foo-bar item=item}}\n        <li>Next</li>\n      {{/each}}\n    '], ['\n      {{#each list as |item|}}\n        <li>Prev</li>\n        {{foo-bar item=item}}\n        <li>Next</li>\n      {{/each}}\n    ']),
      _templateObject2 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#each content as |value|}}\n        {{value}}-\n        {{#each options as |option|}}\n          {{option.value}}:{{option.label}}\n        {{/each}}\n      {{/each}}\n      '], ['\n      {{#each content as |value|}}\n        {{value}}-\n        {{#each options as |option|}}\n          {{option.value}}:{{option.label}}\n        {{/each}}\n      {{/each}}\n      ']),
      _templateObject3 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#each foo.bar.baz as |thing|}}\n        {{thing}}\n      {{/each}}'], ['\n      {{#each foo.bar.baz as |thing|}}\n        {{thing}}\n      {{/each}}']),
      _templateObject4 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#each list as |value key|}}\n        [{{key}}:{{value}}]\n      {{/each}}'], ['\n      {{#each list as |value key|}}\n        [{{key}}:{{value}}]\n      {{/each}}']),
      _templateObject5 = babelHelpers.taggedTemplateLiteralLoose(['\n        <h1>{{page.title}}</h1>\n\n        <ul id="posts">\n          {{#each model as |post|}}\n            <li>{{post.title}}</li>\n          {{/each}}\n        </ul>\n      '], ['\n        <h1>{{page.title}}</h1>\n\n        <ul id="posts">\n          {{#each model as |post|}}\n            <li>{{post.title}}</li>\n          {{/each}}\n        </ul>\n      ']),
      _templateObject6 = babelHelpers.taggedTemplateLiteralLoose(['\n        <h1>Blog Posts</h1>\n\n        <ul id="posts">\n          <li>Rails is omakase</li>\n          <li>Ember is omakase</li>\n        </ul>\n      '], ['\n        <h1>Blog Posts</h1>\n\n        <ul id="posts">\n          <li>Rails is omakase</li>\n          <li>Ember is omakase</li>\n        </ul>\n      ']),
      _templateObject7 = babelHelpers.taggedTemplateLiteralLoose(['\n          <h1>Essays</h1>\n\n          <ul id="posts">\n            <li>Rails is omakase</li>\n            <li>Ember is omakase</li>\n          </ul>\n        '], ['\n          <h1>Essays</h1>\n\n          <ul id="posts">\n            <li>Rails is omakase</li>\n            <li>Ember is omakase</li>\n          </ul>\n        ']),
      _templateObject8 = babelHelpers.taggedTemplateLiteralLoose(['\n          <h1>Think Pieces™</h1>\n\n          <ul id="posts">\n            <li>Rails is omakase</li>\n            <li>Ember is omakase</li>\n          </ul>\n        '], ['\n          <h1>Think Pieces™</h1>\n\n          <ul id="posts">\n            <li>Rails is omakase</li>\n            <li>Ember is omakase</li>\n          </ul>\n        ']);

  var ArrayLike = (function () {
    function ArrayLike(content) {
      this._array = content;
    }

    ArrayLike.prototype.forEach = function forEach(callback) {
      this._array.forEach(callback);
    };

    // The following methods are APIs used by the tests

    ArrayLike.prototype.objectAt = function objectAt(idx) {
      return this._array[idx];
    };

    ArrayLike.prototype.clear = function clear() {
      this._array.length = 0;
      this.arrayContentDidChange();
    };

    ArrayLike.prototype.replace = function replace(idx, del, ins) {
      var _array;

      (_array = this._array).splice.apply(_array, [idx, del].concat(ins));
      this.arrayContentDidChange();
    };

    ArrayLike.prototype.unshiftObject = function unshiftObject(obj) {
      this._array.unshift(obj);
      this.arrayContentDidChange();
    };

    ArrayLike.prototype.unshiftObjects = function unshiftObjects(arr) {
      var _array2;

      (_array2 = this._array).unshift.apply(_array2, arr);
      this.arrayContentDidChange();
    };

    ArrayLike.prototype.pushObject = function pushObject(obj) {
      this._array.push(obj);
      this.arrayContentDidChange();
    };

    ArrayLike.prototype.pushObjects = function pushObjects(arr) {
      var _array3;

      (_array3 = this._array).push.apply(_array3, arr);
      this.arrayContentDidChange();
    };

    ArrayLike.prototype.shiftObject = function shiftObject() {
      var obj = this._array.shift();
      this.arrayContentDidChange();
      return obj;
    };

    ArrayLike.prototype.popObject = function popObject() {
      var obj = this._array.pop();
      this.arrayContentDidChange();
      return obj;
    };

    ArrayLike.prototype.insertAt = function insertAt(idx, obj) {
      this._array.splice(idx, 0, obj);
      this.arrayContentDidChange();
    };

    ArrayLike.prototype.removeAt = function removeAt(idx) {
      var len = arguments.length <= 1 || arguments[1] === undefined ? 1 : arguments[1];

      this._array.splice(idx, len);
      this.arrayContentDidChange();
    };

    ArrayLike.prototype.arrayContentDidChange = function arrayContentDidChange() {
      _emberMetal.propertyDidChange(this, '[]');
      _emberMetal.propertyDidChange(this, 'length');
    };

babelHelpers.createClass(ArrayLike, [{
      key: 'length',
      get: function () {
        return this._array.length;
      }
    }]);
    return ArrayLike;
  })();

  var TogglingEachTest = (function (_TogglingSyntaxConditionalsTest) {
babelHelpers.inherits(TogglingEachTest, _TogglingSyntaxConditionalsTest);

    function TogglingEachTest() {
      _TogglingSyntaxConditionalsTest.apply(this, arguments);
    }

babelHelpers.createClass(TogglingEachTest, [{
      key: 'truthyValue',
      get: function () {
        return ['non-empty'];
      }
    }, {
      key: 'falsyValue',
      get: function () {
        return [];
      }
    }]);
    return TogglingEachTest;
  })(_emberGlimmerTestsUtilsSharedConditionalTests.TogglingSyntaxConditionalsTest);

  var BasicEachTest = (function (_TogglingEachTest) {
babelHelpers.inherits(BasicEachTest, _TogglingEachTest);

    function BasicEachTest() {
      _TogglingEachTest.apply(this, arguments);
    }

    return BasicEachTest;
  })(TogglingEachTest);

  _emberGlimmerTestsUtilsAbstractTestCase.applyMixins(BasicEachTest, new _emberGlimmerTestsUtilsSharedConditionalTests.TruthyGenerator([['hello'], _emberRuntime.A(['hello']), new ArrayLike(['hello']), _emberRuntime.ArrayProxy.create({ content: ['hello'] }), _emberRuntime.ArrayProxy.create({ content: _emberRuntime.A(['hello']) })]), new _emberGlimmerTestsUtilsSharedConditionalTests.FalsyGenerator([null, undefined, false, '', 0, []]), _emberGlimmerTestsUtilsSharedConditionalTests.ArrayTestCases);

  _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: toggling {{#each}}', (function (_BasicEachTest) {
babelHelpers.inherits(_class, _BasicEachTest);

    function _class() {
      _BasicEachTest.apply(this, arguments);
    }

    _class.prototype.templateFor = function templateFor(_ref) {
      var cond = _ref.cond;
      var truthy = _ref.truthy;
      var falsy = _ref.falsy;

      return '{{#each ' + cond + '}}' + truthy + '{{else}}' + falsy + '{{/each}}';
    };

    return _class;
  })(BasicEachTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: toggling {{#each as}}', (function (_BasicEachTest2) {
babelHelpers.inherits(_class2, _BasicEachTest2);

    function _class2() {
      _BasicEachTest2.apply(this, arguments);
    }

    _class2.prototype.templateFor = function templateFor(_ref2) {
      var cond = _ref2.cond;
      var truthy = _ref2.truthy;
      var falsy = _ref2.falsy;

      return '{{#each ' + cond + ' as |test|}}' + truthy + '{{else}}' + falsy + '{{/each}}';
    };

    return _class2;
  })(BasicEachTest));

  var EachEdgeCasesTest = (function (_TogglingEachTest2) {
babelHelpers.inherits(EachEdgeCasesTest, _TogglingEachTest2);

    function EachEdgeCasesTest() {
      _TogglingEachTest2.apply(this, arguments);
    }

    return EachEdgeCasesTest;
  })(TogglingEachTest);

  _emberGlimmerTestsUtilsAbstractTestCase.applyMixins(EachEdgeCasesTest, new _emberGlimmerTestsUtilsSharedConditionalTests.FalsyGenerator([true, 'hello', 1, Object, function () {}, {}, { foo: 'bar' }, Object.create(null), Object.create({}), Object.create({ foo: 'bar' })]));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: toggling {{#each}}', (function (_EachEdgeCasesTest) {
babelHelpers.inherits(_class3, _EachEdgeCasesTest);

    function _class3() {
      _EachEdgeCasesTest.apply(this, arguments);
    }

    _class3.prototype.templateFor = function templateFor(_ref3) {
      var cond = _ref3.cond;
      var truthy = _ref3.truthy;
      var falsy = _ref3.falsy;

      return '{{#each ' + cond + '}}' + truthy + '{{else}}' + falsy + '{{/each}}';
    };

    return _class3;
  })(EachEdgeCasesTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: toggling {{#each as}}', (function (_EachEdgeCasesTest2) {
babelHelpers.inherits(_class4, _EachEdgeCasesTest2);

    function _class4() {
      _EachEdgeCasesTest2.apply(this, arguments);
    }

    _class4.prototype.templateFor = function templateFor(_ref4) {
      var cond = _ref4.cond;
      var truthy = _ref4.truthy;
      var falsy = _ref4.falsy;

      return '{{#each ' + cond + ' as |test|}}' + truthy + '{{else}}' + falsy + '{{/each}}';
    };

    return _class4;
  })(EachEdgeCasesTest));

  var AbstractEachTest = (function (_RenderingTest) {
babelHelpers.inherits(AbstractEachTest, _RenderingTest);

    function AbstractEachTest() {
      _RenderingTest.apply(this, arguments);
    }

    /* abstract */

    AbstractEachTest.prototype.makeList = function makeList() {
      // this.list = this.delegate = ...;
      throw new Error('Not implemented: `makeList`');
    };

    AbstractEachTest.prototype.replaceList = function replaceList(list) {
      var _this = this;

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'list', _this.makeList(list));
      });
    };

    AbstractEachTest.prototype.forEach = function forEach(callback) {
      return this.delegate.forEach(callback);
    };

    AbstractEachTest.prototype.objectAt = function objectAt(idx) {
      return this.delegate.objectAt(idx);
    };

    AbstractEachTest.prototype.clear = function clear() {
      return this.delegate.clear();
    };

    AbstractEachTest.prototype.replace = function replace(idx, del, ins) {
      return this.delegate.replace(idx, del, ins);
    };

    AbstractEachTest.prototype.unshiftObject = function unshiftObject(obj) {
      return this.delegate.unshiftObject(obj);
    };

    AbstractEachTest.prototype.unshiftObjects = function unshiftObjects(arr) {
      return this.delegate.unshiftObjects(arr);
    };

    AbstractEachTest.prototype.pushObject = function pushObject(obj) {
      return this.delegate.pushObject(obj);
    };

    AbstractEachTest.prototype.pushObjects = function pushObjects(arr) {
      return this.delegate.pushObjects(arr);
    };

    AbstractEachTest.prototype.shiftObject = function shiftObject() {
      return this.delegate.shiftObject();
    };

    AbstractEachTest.prototype.popObject = function popObject() {
      return this.delegate.popObject();
    };

    AbstractEachTest.prototype.insertAt = function insertAt(idx, obj) {
      return this.delegate.insertAt(idx, obj);
    };

    AbstractEachTest.prototype.removeAt = function removeAt(idx, len) {
      return this.delegate.removeAt(idx, len);
    };

    AbstractEachTest.prototype.render = function render(template) {
      var context = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      if (this.list === undefined) {
        throw new Error('Must call `this.makeList()` before calling this.render()');
      }

      context.list = this.list;

      return _RenderingTest.prototype.render.call(this, template, context);
    };

    return AbstractEachTest;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest);

  var SingleEachTest = (function (_AbstractEachTest) {
babelHelpers.inherits(SingleEachTest, _AbstractEachTest);

    function SingleEachTest() {
      _AbstractEachTest.apply(this, arguments);
    }

    SingleEachTest.prototype['@test it repeats the given block for each item in the array'] = function testItRepeatsTheGivenBlockForEachItemInTheArray() {
      var _this2 = this;

      this.makeList([{ text: 'hello' }]);

      this.render('{{#each list as |item|}}{{item.text}}{{else}}Empty{{/each}}');

      this.assertText('hello');

      this.runTask(function () {
        return _this2.rerender();
      });

      this.assertText('hello');

      this.runTask(function () {
        return _emberMetal.set(_this2.objectAt(0), 'text', 'Hello');
      });

      this.assertText('Hello');

      this.runTask(function () {
        _this2.pushObject({ text: ' ' });
        _this2.pushObject({ text: 'World' });
      });

      this.assertText('Hello World');

      this.runTask(function () {
        _this2.pushObject({ text: 'Earth' });
        _this2.removeAt(1);
        _this2.insertAt(1, { text: 'Globe' });
      });

      this.assertText('HelloGlobeWorldEarth');

      this.runTask(function () {
        _this2.pushObject({ text: 'Planet' });
        _this2.removeAt(1);
        _this2.insertAt(1, { text: ' ' });
        _this2.pushObject({ text: ' ' });
        _this2.pushObject({ text: 'Earth' });
        _this2.removeAt(3);
      });

      this.assertText('Hello WorldPlanet Earth');

      this.runTask(function () {
        _this2.pushObject({ text: 'Globe' });
        _this2.removeAt(1);
        _this2.insertAt(1, { text: ' ' });
        _this2.pushObject({ text: ' ' });
        _this2.pushObject({ text: 'World' });
        _this2.removeAt(2);
      });

      this.assertText('Hello Planet EarthGlobe World');

      this.runTask(function () {
        return _this2.replace(2, 4, { text: 'my' });
      });

      this.assertText('Hello my World');

      this.runTask(function () {
        return _this2.clear();
      });

      this.assertText('Empty');

      this.replaceList([{ text: 'hello' }]);

      this.assertText('hello');
    };

    SingleEachTest.prototype['@test it receives the index as the second parameter'] = function testItReceivesTheIndexAsTheSecondParameter() {
      var _this3 = this;

      this.makeList([{ text: 'hello' }, { text: 'world' }]);

      this.render('{{#each list as |item index|}}[{{index}}. {{item.text}}]{{/each}}');

      this.assertText('[0. hello][1. world]');

      this.assertStableRerender();

      this.runTask(function () {
        return _this3.insertAt(1, { text: 'my' });
      });

      this.assertText('[0. hello][1. my][2. world]');

      this.replaceList([{ text: 'hello' }, { text: 'world' }]);

      this.assertText('[0. hello][1. world]');
    };

    SingleEachTest.prototype['@test it accepts a string key'] = function testItAcceptsAStringKey() {
      var _this4 = this;

      this.makeList([{ text: 'hello' }, { text: 'world' }]);

      this.render('{{#each list key=\'text\' as |item|}}{{item.text}}{{/each}}');

      this.assertText('helloworld');

      this.assertStableRerender();

      this.runTask(function () {
        return _this4.pushObject({ text: 'again' });
      });

      this.assertText('helloworldagain');

      this.replaceList([{ text: 'hello' }, { text: 'world' }]);

      this.assertText('helloworld');
    };

    SingleEachTest.prototype['@test it accepts a numeric key'] = function testItAcceptsANumericKey() {
      var _this5 = this;

      this.makeList([{ id: 1 }, { id: 2 }]);

      this.render('{{#each list key=\'id\' as |item|}}{{item.id}}{{/each}}');

      this.assertText('12');

      this.assertStableRerender();

      this.runTask(function () {
        return _this5.pushObject({ id: 3 });
      });

      this.assertText('123');

      this.replaceList([{ id: 1 }, { id: 2 }]);

      this.assertText('12');
    };

    SingleEachTest.prototype['@test it can specify @index as the key'] = function testItCanSpecifyIndexAsTheKey() {
      var _this6 = this;

      this.makeList([{ id: 1 }, { id: 2 }]);

      this.render('{{#each list key=\'@index\' as |item|}}{{item.id}}{{/each}}');

      this.assertText('12');

      this.assertStableRerender();

      this.runTask(function () {
        return _this6.pushObject({ id: 3 });
      });

      this.assertText('123');

      this.replaceList([{ id: 1 }, { id: 2 }]);

      this.assertText('12');
    };

    SingleEachTest.prototype['@test it can specify @identity as the key for arrays of primitives'] = function testItCanSpecifyIdentityAsTheKeyForArraysOfPrimitives() {
      var _this7 = this;

      this.makeList([1, 2]);

      this.render('{{#each list key=\'@identity\' as |item|}}{{item}}{{/each}}');

      this.assertText('12');

      this.assertStableRerender();

      this.runTask(function () {
        return _this7.pushObject(3);
      });

      this.assertText('123');

      this.replaceList([1, 2]);

      this.assertText('12');
    };

    SingleEachTest.prototype['@test it can specify @identity as the key for mixed arrays of objects and primitives'] = function testItCanSpecifyIdentityAsTheKeyForMixedArraysOfObjectsAndPrimitives() {
      var _this8 = this;

      this.makeList([1, { id: 2 }, 3]);

      this.render('{{#each list key=\'@identity\' as |item|}}{{if item.id item.id item}}{{/each}}');

      this.assertText('123');

      this.assertStableRerender();

      this.runTask(function () {
        return _this8.insertAt(2, { id: 4 });
      });

      this.assertText('1243');

      this.replaceList([1, { id: 2 }, 3]);

      this.assertText('123');
    };

    SingleEachTest.prototype['@test it can render duplicate primitive items'] = function testItCanRenderDuplicatePrimitiveItems() {
      var _this9 = this;

      this.makeList(['a', 'a', 'a']);

      this.render('{{#each list as |item|}}{{item}}{{/each}}');

      this.assertText('aaa');

      this.assertStableRerender();

      this.runTask(function () {
        return _this9.pushObject('a');
      });

      this.assertText('aaaa');

      this.runTask(function () {
        return _this9.pushObject('a');
      });

      this.assertText('aaaaa');

      this.replaceList(['a', 'a', 'a']);

      this.assertText('aaa');
    };

    SingleEachTest.prototype['@test updating and setting within #each'] = function testUpdatingAndSettingWithinEach(assert) {
      var _this10 = this;

      this.makeList([{ value: 1 }, { value: 2 }, { value: 3 }]);

      var FooBarComponent = _emberGlimmerTestsUtilsHelpers.Component.extend({
        init: function () {
          this._super.apply(this, arguments);
          this.isEven = true;
          this.tagName = 'li';
        },

        _isEven: function () {
          this.set('isEven', this.get('item.value') % 2 === 0);
        },

        didUpdate: function () {
          this._isEven();
        }
      });

      this.registerComponent('foo-bar', { ComponentClass: FooBarComponent, template: '{{#if isEven}}{{item.value}}{{/if}}' });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject));

      this.assertText('Prev1NextPrev2NextPrev3Next');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this10.context.list.objectAt(0), 'value', 3);
      });

      this.assertText('PrevNextPrev2NextPrev3Next');

      this.replaceList([{ value: 1 }, { value: 2 }, { value: 3 }]);

      this.assertText('Prev1NextPrev2NextPrev3Next');
    };

    SingleEachTest.prototype['@test it can render duplicate objects'] = function testItCanRenderDuplicateObjects() {
      var _this11 = this;

      var duplicateItem = { text: 'foo' };

      this.makeList([duplicateItem, duplicateItem, { text: 'bar' }, { text: 'baz' }]);

      this.render('{{#each list as |item|}}{{item.text}}{{/each}}');

      this.assertText('foofoobarbaz');

      this.assertStableRerender();

      this.runTask(function () {
        return _this11.pushObject(duplicateItem);
      });

      this.assertText('foofoobarbazfoo');

      this.runTask(function () {
        return _this11.pushObject(duplicateItem);
      });

      this.assertText('foofoobarbazfoofoo');

      this.replaceList([duplicateItem, duplicateItem, { text: 'bar' }, { text: 'baz' }]);

      this.assertText('foofoobarbaz');
    };

    SingleEachTest.prototype['@test it maintains DOM stability when condition changes between objects with the same keys'] = function testItMaintainsDOMStabilityWhenConditionChangesBetweenObjectsWithTheSameKeys() {
      var _this12 = this;

      this.makeList([{ text: 'Hello' }, { text: ' ' }, { text: 'world' }]);

      this.render('{{#each list key="text" as |item|}}{{item.text}}{{/each}}');

      this.assertText('Hello world');

      this.takeSnapshot();

      this.runTask(function () {
        _this12.popObject();
        _this12.popObject();
        _this12.pushObject({ text: ' ' });
        _this12.pushObject({ text: 'world' });
      });

      this.assertText('Hello world');

      this.assertInvariants();

      this.replaceList([{ text: 'Hello' }, { text: ' ' }, { text: 'world' }]);

      this.assertText('Hello world');

      this.assertInvariants();
    };

    SingleEachTest.prototype['@test it maintains DOM stability for stable keys when list is updated'] = function testItMaintainsDOMStabilityForStableKeysWhenListIsUpdated() {
      var _this13 = this;

      this.makeList([{ text: 'Hello' }, { text: ' ' }, { text: 'world' }]);

      this.render('{{#each list key="text" as |item|}}{{item.text}}{{/each}}');

      this.assertText('Hello world');

      this.assertStableRerender();

      var oldSnapshot = this.takeSnapshot();

      this.runTask(function () {
        _this13.unshiftObject({ text: ', ' });
        _this13.unshiftObject({ text: 'Hi' });
        _this13.pushObject({ text: '!' });
        _this13.pushObject({ text: 'earth' });
      });

      this.assertText('Hi, Hello world!earth');

      this.assertPartialInvariants(2, 5);

      this.replaceList([{ text: 'Hello' }, { text: ' ' }, { text: 'world' }]);

      this.assertText('Hello world');

      this.assertInvariants(oldSnapshot, this.takeSnapshot());
    };

    SingleEachTest.prototype['@test it renders all items with duplicate key values'] = function testItRendersAllItemsWithDuplicateKeyValues() {
      var _this14 = this;

      this.makeList([{ text: 'Hello' }, { text: 'Hello' }, { text: 'Hello' }]);

      this.render('{{#each list key="text" as |item|}}{{item.text}}{{/each}}');

      this.assertText('HelloHelloHello');

      this.runTask(function () {
        _this14.forEach(function (hash) {
          return _emberMetal.set(hash, 'text', 'Goodbye');
        });
      });

      this.assertText('GoodbyeGoodbyeGoodbye');

      this.replaceList([{ text: 'Hello' }, { text: 'Hello' }, { text: 'Hello' }]);

      this.assertText('HelloHelloHello');
    };

    SingleEachTest.prototype['@test context is not changed to the inner scope inside an {{#each as}} block'] = function testContextIsNotChangedToTheInnerScopeInsideAnEachAsBlock() {
      var _this15 = this;

      this.makeList([{ name: 'Chad' }, { name: 'Zack' }, { name: 'Asa' }]);

      this.render('{{name}}-{{#each list as |person|}}{{name}}{{/each}}-{{name}}', {
        name: 'Joel'
      });

      this.assertText('Joel-JoelJoelJoel-Joel');

      this.assertStableRerender();

      this.runTask(function () {
        return _this15.shiftObject();
      });

      this.assertText('Joel-JoelJoel-Joel');

      this.runTask(function () {
        return _emberMetal.set(_this15.context, 'name', 'Godfrey');
      });

      this.assertText('Godfrey-GodfreyGodfrey-Godfrey');

      this.runTask(function () {
        return _emberMetal.set(_this15.context, 'name', 'Joel');
      });
      this.replaceList([{ name: 'Chad' }, { name: 'Zack' }, { name: 'Asa' }]);

      this.assertText('Joel-JoelJoelJoel-Joel');
    };

    SingleEachTest.prototype['@test can access the item and the original scope'] = function testCanAccessTheItemAndTheOriginalScope() {
      var _this16 = this;

      this.makeList([{ name: 'Tom Dale' }, { name: 'Yehuda Katz' }, { name: 'Godfrey Chan' }]);

      this.render('{{#each list key="name" as |person|}}[{{title}}: {{person.name}}]{{/each}}', {
        title: 'Señor Engineer'
      });

      this.assertText('[Señor Engineer: Tom Dale][Señor Engineer: Yehuda Katz][Señor Engineer: Godfrey Chan]');

      this.runTask(function () {
        return _this16.rerender();
      });

      this.assertText('[Señor Engineer: Tom Dale][Señor Engineer: Yehuda Katz][Señor Engineer: Godfrey Chan]');

      this.runTask(function () {
        _emberMetal.set(_this16.objectAt(1), 'name', 'Stefan Penner');
        _this16.removeAt(0);
        _this16.pushObject({ name: 'Tom Dale' });
        _this16.insertAt(1, { name: 'Chad Hietala' });
        _emberMetal.set(_this16.context, 'title', 'Principal Engineer');
      });

      this.assertText('[Principal Engineer: Stefan Penner][Principal Engineer: Chad Hietala][Principal Engineer: Godfrey Chan][Principal Engineer: Tom Dale]');

      this.runTask(function () {
        return _emberMetal.set(_this16.context, 'title', 'Señor Engineer');
      });
      this.replaceList([{ name: 'Tom Dale' }, { name: 'Yehuda Katz' }, { name: 'Godfrey Chan' }]);

      this.assertText('[Señor Engineer: Tom Dale][Señor Engineer: Yehuda Katz][Señor Engineer: Godfrey Chan]');
    };

    SingleEachTest.prototype['@test the scoped variable is not available outside the {{#each}} block.'] = function testTheScopedVariableIsNotAvailableOutsideTheEachBlock() {
      var _this17 = this;

      this.makeList(['Yehuda']);

      this.render('{{name}}-{{#each list as |name|}}{{name}}{{/each}}-{{name}}', {
        name: 'Stef'
      });

      this.assertText('Stef-Yehuda-Stef');

      this.runTask(function () {
        return _this17.rerender();
      });

      this.assertText('Stef-Yehuda-Stef');

      this.runTask(function () {
        return _this17.pushObjects([' ', 'Katz']);
      });

      this.assertText('Stef-Yehuda Katz-Stef');

      this.runTask(function () {
        return _emberMetal.set(_this17.context, 'name', 'Tom');
      });

      this.assertText('Tom-Yehuda Katz-Tom');

      this.runTask(function () {
        return _emberMetal.set(_this17.context, 'name', 'Stef');
      });
      this.replaceList(['Yehuda']);

      this.assertText('Stef-Yehuda-Stef');
    };

    SingleEachTest.prototype['@test inverse template is displayed with context'] = function testInverseTemplateIsDisplayedWithContext() {
      var _this18 = this;

      this.makeList([]);

      this.render('{{#each list as |thing|}}Has Thing{{else}}No Thing {{otherThing}}{{/each}}', {
        otherThing: 'bar'
      });

      this.assertText('No Thing bar');

      this.runTask(function () {
        return _this18.rerender();
      });

      this.assertText('No Thing bar');

      this.runTask(function () {
        return _emberMetal.set(_this18.context, 'otherThing', 'biz');
      });

      this.assertText('No Thing biz');

      this.runTask(function () {
        return _this18.pushObject('non-empty');
      });

      this.assertText('Has Thing');

      this.runTask(function () {
        return _emberMetal.set(_this18.context, 'otherThing', 'baz');
      });

      this.assertText('Has Thing');

      this.runTask(function () {
        return _emberMetal.set(_this18.context, 'otherThing', 'bar');
      });
      this.replaceList([]);

      this.assertText('No Thing bar');
    };

    SingleEachTest.prototype['@test content that are not initially present updates correctly GH#13983'] = function testContentThatAreNotInitiallyPresentUpdatesCorrectlyGH13983() {
      var _this19 = this;

      // The root cause of this bug is that Glimmer did not call `didInitializeChildren`
      // on the inserted `TryOpcode`, causing that `TryOpcode` to have an uninitialized
      // tag. Currently the only way to observe this the "JUMP-IF-NOT-MODIFIED", i.e. by
      // wrapping it in an component.

      this.registerComponent('x-wrapper', { template: '{{yield}}' });

      this.makeList([]);

      this.render('{{#x-wrapper}}{{#each list as |obj|}}[{{obj.text}}]{{/each}}{{/x-wrapper}}');

      this.assertText('');

      this.runTask(function () {
        return _this19.rerender();
      });

      this.assertText('');

      this.runTask(function () {
        return _this19.pushObject({ text: 'foo' });
      });

      this.assertText('[foo]');

      this.runTask(function () {
        return _emberMetal.set(_this19.objectAt(0), 'text', 'FOO');
      });

      this.assertText('[FOO]');

      this.runTask(function () {
        return _this19.pushObject({ text: 'bar' });
      });

      this.assertText('[FOO][bar]');

      this.runTask(function () {
        return _emberMetal.set(_this19.objectAt(1), 'text', 'BAR');
      });

      this.assertText('[FOO][BAR]');

      this.runTask(function () {
        return _emberMetal.set(_this19.objectAt(1), 'text', 'baz');
      });

      this.assertText('[FOO][baz]');

      this.runTask(function () {
        return _this19.replace(1, 1, [{ text: 'BAZ' }]);
      });

      this.assertText('[FOO][BAZ]');

      this.replaceList([]);

      this.assertText('');
    };

    return SingleEachTest;
  })(AbstractEachTest);

  _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: {{#each}} with arrays', (function (_SingleEachTest) {
babelHelpers.inherits(_class5, _SingleEachTest);

    function _class5() {
      _SingleEachTest.apply(this, arguments);
    }

    _class5.prototype.makeList = function makeList(list) {
      return this.list = this.delegate = _emberRuntime.A(list);
    };

    return _class5;
  })(SingleEachTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: {{#each}} with array-like objects', (function (_SingleEachTest2) {
babelHelpers.inherits(_class6, _SingleEachTest2);

    function _class6() {
      _SingleEachTest2.apply(this, arguments);
    }

    _class6.prototype.makeList = function makeList(list) {
      return this.list = this.delegate = new ArrayLike(list);
    };

    return _class6;
  })(SingleEachTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: {{#each}} with array proxies, modifying itself', (function (_SingleEachTest3) {
babelHelpers.inherits(_class7, _SingleEachTest3);

    function _class7() {
      _SingleEachTest3.apply(this, arguments);
    }

    _class7.prototype.makeList = function makeList(list) {
      return this.list = this.delegate = _emberRuntime.ArrayProxy.create({ content: _emberRuntime.A(list) });
    };

    return _class7;
  })(SingleEachTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: {{#each}} with array proxies, replacing its content', (function (_SingleEachTest4) {
babelHelpers.inherits(_class8, _SingleEachTest4);

    function _class8() {
      _SingleEachTest4.apply(this, arguments);
    }

    _class8.prototype.makeList = function makeList(list) {
      var content = this.delegate = _emberRuntime.A(list);
      return this.list = _emberRuntime.ArrayProxy.create({ content: content });
    };

    _class8.prototype.replaceList = function replaceList(list) {
      var _this20 = this;

      this.runTask(function () {
        return _this20.list.set('content', _emberRuntime.A(list));
      });
    };

    return _class8;
  })(SingleEachTest));

  // TODO: Refactor the following tests so we can run them against different kind of arrays

  _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: Multiple {{#each as}} helpers', (function (_RenderingTest2) {
babelHelpers.inherits(_class9, _RenderingTest2);

    function _class9() {
      _RenderingTest2.apply(this, arguments);
    }

    _class9.prototype['@test re-using the same variable with different {{#each}} blocks does not override each other'] = function testReUsingTheSameVariableWithDifferentEachBlocksDoesNotOverrideEachOther() {
      var _this21 = this;

      this.render('Admin: {{#each admins key="name" as |person|}}[{{person.name}}]{{/each}} User: {{#each users key="name" as |person|}}[{{person.name}}]{{/each}}', {
        admins: _emberRuntime.A([{ name: 'Tom Dale' }]),
        users: _emberRuntime.A([{ name: 'Yehuda Katz' }])
      });

      this.assertText('Admin: [Tom Dale] User: [Yehuda Katz]');

      this.runTask(function () {
        return _this21.rerender();
      });

      this.assertText('Admin: [Tom Dale] User: [Yehuda Katz]');

      this.runTask(function () {
        _emberMetal.get(_this21.context, 'admins').pushObject({ name: 'Godfrey Chan' });
        _emberMetal.set(_emberMetal.get(_this21.context, 'users').objectAt(0), 'name', 'Stefan Penner');
      });

      this.assertText('Admin: [Tom Dale][Godfrey Chan] User: [Stefan Penner]');

      this.runTask(function () {
        _emberMetal.set(_this21.context, 'admins', [{ name: 'Tom Dale' }]);
        _emberMetal.set(_this21.context, 'users', [{ name: 'Yehuda Katz' }]);
      });

      this.assertText('Admin: [Tom Dale] User: [Yehuda Katz]');
    };

    _class9.prototype['@test an outer {{#each}}\'s scoped variable does not clobber an inner {{#each}}\'s property if they share the same name - Issue #1315'] = function testAnOuterEachSScopedVariableDoesNotClobberAnInnerEachSPropertyIfTheyShareTheSameNameIssue1315() {
      var _this22 = this;

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2), {
        content: _emberRuntime.A(['X', 'Y']),
        options: _emberRuntime.A([{ label: 'One', value: 1 }, { label: 'Two', value: 2 }])
      });

      this.assertText('X-1:One2:TwoY-1:One2:Two');

      this.assertStableRerender();

      this.runTask(function () {
        _emberMetal.get(_this22.context, 'content').pushObject('Z');
        _emberMetal.set(_emberMetal.get(_this22.context, 'options').objectAt(0), 'value', 0);
      });

      this.assertText('X-0:One2:TwoY-0:One2:TwoZ-0:One2:Two');

      this.runTask(function () {
        _emberMetal.set(_this22.context, 'content', ['X', 'Y']);
        _emberMetal.set(_this22.context, 'options', [{ label: 'One', value: 1 }, { label: 'Two', value: 2 }]);
      });

      this.assertText('X-1:One2:TwoY-1:One2:Two');
    };

    _class9.prototype['@test the scoped variable is not available outside the {{#each}} block'] = function testTheScopedVariableIsNotAvailableOutsideTheEachBlock() {
      var _this23 = this;

      this.render('{{ring}}-{{#each first as |ring|}}{{ring}}-{{#each fifth as |ring|}}{{ring}}-{{#each ninth as |ring|}}{{ring}}-{{/each}}{{ring}}-{{/each}}{{ring}}-{{/each}}{{ring}}', {
        ring: 'Greed',
        first: _emberRuntime.A(['Limbo']),
        fifth: _emberRuntime.A(['Wrath']),
        ninth: _emberRuntime.A(['Treachery'])
      });

      this.assertText('Greed-Limbo-Wrath-Treachery-Wrath-Limbo-Greed');

      this.runTask(function () {
        return _this23.rerender();
      });

      this.assertText('Greed-Limbo-Wrath-Treachery-Wrath-Limbo-Greed');

      this.runTask(function () {
        _emberMetal.set(_this23.context, 'ring', 'O');
        _emberMetal.get(_this23.context, 'fifth').insertAt(0, 'D');
      });

      this.assertText('O-Limbo-D-Treachery-D-Wrath-Treachery-Wrath-Limbo-O');

      this.runTask(function () {
        _emberMetal.get(_this23.context, 'first').pushObject('I');
        _emberMetal.get(_this23.context, 'ninth').replace(0, 1, 'K');
      });

      this.assertText('O-Limbo-D-K-D-Wrath-K-Wrath-Limbo-I-D-K-D-Wrath-K-Wrath-I-O');

      this.runTask(function () {
        _emberMetal.set(_this23.context, 'ring', 'Greed');
        _emberMetal.set(_this23.context, 'first', ['Limbo']);
        _emberMetal.set(_this23.context, 'fifth', ['Wrath']);
        _emberMetal.set(_this23.context, 'ninth', ['Treachery']);
      });

      this.assertText('Greed-Limbo-Wrath-Treachery-Wrath-Limbo-Greed');
    };

    _class9.prototype['@test it should support {{#each name as |foo|}}, then {{#each foo as |bar|}}'] = function testItShouldSupportEachNameAsFooThenEachFooAsBar() {
      var _this24 = this;

      this.render('{{#each name key="@index" as |foo|}}{{#each foo as |bar|}}{{bar}}{{/each}}{{/each}}', {
        name: _emberRuntime.A([_emberRuntime.A(['caterpillar'])])
      });

      this.assertText('caterpillar');

      this.runTask(function () {
        return _this24.rerender();
      });

      this.assertText('caterpillar');

      this.runTask(function () {
        var name = _emberMetal.get(_this24.context, 'name');
        name.objectAt(0).replace(0, 1, 'lady');
        name.pushObject(['bird']);
      });

      this.assertText('ladybird');

      this.runTask(function () {
        return _emberMetal.set(_this24.context, 'name', [['caterpillar']]);
      });

      this.assertText('caterpillar');
    };

    return _class9;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: {{#each as}} undefined path', (function (_RenderingTest3) {
babelHelpers.inherits(_class10, _RenderingTest3);

    function _class10() {
      _RenderingTest3.apply(this, arguments);
    }

    _class10.prototype['@test keying off of `undefined` does not render'] = function testKeyingOffOfUndefinedDoesNotRender(assert) {
      var _this25 = this;

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject3), { foo: {} });

      this.assertText('');

      this.runTask(function () {
        return _this25.rerender();
      });

      this.assertText('');

      this.runTask(function () {
        return _emberMetal.set(_this25.context, 'foo', { bar: { baz: ['Here!'] } });
      });

      this.assertText('Here!');

      this.runTask(function () {
        return _emberMetal.set(_this25.context, 'foo', {});
      });

      this.assertText('');
    };

    return _class10;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: {{#each}} with sparse arrays', (function (_RenderingTest4) {
babelHelpers.inherits(_class11, _RenderingTest4);

    function _class11() {
      _RenderingTest4.apply(this, arguments);
    }

    _class11.prototype['@test it should itterate over holes'] = function testItShouldItterateOverHoles(assert) {
      var _this26 = this;

      var sparseArray = [];
      sparseArray[3] = 'foo';
      sparseArray[4] = 'bar';

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject4), { list: _emberRuntime.A(sparseArray) });

      this.assertText('[0:][1:][2:][3:foo][4:bar]');

      this.assertStableRerender();

      this.runTask(function () {
        var list = _emberMetal.get(_this26.context, 'list');
        list.pushObject('baz');
      });

      this.assertText('[0:][1:][2:][3:foo][4:bar][5:baz]');
    };

    return _class11;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));

  /* globals MutationObserver: false */
  if (typeof MutationObserver === 'function') {
    _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: {{#each as}} DOM mutation test', (function (_RenderingTest5) {
babelHelpers.inherits(_class12, _RenderingTest5);

      function _class12() {
        _RenderingTest5.call(this);
        this.observer = null;
      }

      _class12.prototype.observe = function observe(element) {
        var observer = this.observer = new MutationObserver(function () {});
        observer.observe(element, { childList: true, characterData: true });
      };

      _class12.prototype.teardown = function teardown() {
        if (this.observer) {
          this.observer.disconnect();
        }

        _RenderingTest5.prototype.teardown.call(this);
      };

      _class12.prototype.assertNoMutation = function assertNoMutation() {
        this.assert.deepEqual(this.observer.takeRecords(), [], 'Expected no mutations');
      };

      _class12.prototype.expectMutations = function expectMutations() {
        this.assert.ok(this.observer.takeRecords().length > 0, 'Expected some mutations');
      };

      _class12.prototype['@test {{#each}} should not mutate a subtree when the array has not changed [GH #14332]'] = function testEachShouldNotMutateASubtreeWhenTheArrayHasNotChangedGH14332(assert) {
        var _this27 = this;

        var page = { title: 'Blog Posts' };

        var model = [{ title: 'Rails is omakase' }, { title: 'Ember is omakase' }];

        this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject5), { page: page, model: model });

        this.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject6));

        this.observe(this.$('#posts')[0]);

        // MutationObserver is async
        return _emberRuntime.RSVP.Promise.resolve(function () {
          _this27.assertStableRerender();
        }).then(function () {
          _this27.assertNoMutation();

          _this27.runTask(function () {
            return _emberMetal.set(_this27.context, 'page', { title: 'Essays' });
          });

          _this27.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject7));
        }).then(function () {
          _this27.assertNoMutation();

          _this27.runTask(function () {
            return _emberMetal.set(_this27.context.page, 'title', 'Think Pieces™');
          });

          _this27.assertHTML(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject8));
        }).then(function () {
          // The last set is localized to the `page` object, so we do not expect Glimmer
          // to re-iterate the list
          _this27.assertNoMutation();
        });
      };

      return _class12;
    })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
  }
});
enifed('ember-glimmer/tests/integration/syntax/each-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/syntax/each-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/syntax/each-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/syntax/if-unless-test', ['exports', 'ember-glimmer/tests/utils/helpers', 'ember-runtime', 'ember-metal', 'ember-glimmer/tests/utils/abstract-test-case', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/shared-conditional-tests'], function (exports, _emberGlimmerTestsUtilsHelpers, _emberRuntime, _emberMetal, _emberGlimmerTestsUtilsAbstractTestCase, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsSharedConditionalTests) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#if cond}}\n        {{#each numbers as |number|}}\n          {{foo-bar number=number}}\n        {{/each}}\n      {{else}}\n        Nothing Here!\n      {{/if}}'], ['\n      {{#if cond}}\n        {{#each numbers as |number|}}\n          {{foo-bar number=number}}\n        {{/each}}\n      {{else}}\n        Nothing Here!\n      {{/if}}']),
      _templateObject2 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#if foo.bar.baz}}\n        Here!\n      {{else}}\n        Nothing Here!\n      {{/if}}'], ['\n      {{#if foo.bar.baz}}\n        Here!\n      {{else}}\n        Nothing Here!\n      {{/if}}']);

  _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: {{#if}} with inverse', (function (_IfUnlessWithSyntaxTest) {
babelHelpers.inherits(_class, _IfUnlessWithSyntaxTest);

    function _class() {
      _IfUnlessWithSyntaxTest.apply(this, arguments);
    }

    _class.prototype.templateFor = function templateFor(_ref) {
      var cond = _ref.cond;
      var truthy = _ref.truthy;
      var falsy = _ref.falsy;

      return '{{#if ' + cond + '}}' + truthy + '{{else}}' + falsy + '{{/if}}';
    };

    return _class;
  })(_emberGlimmerTestsUtilsSharedConditionalTests.IfUnlessWithSyntaxTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: {{#unless}} with inverse', (function (_IfUnlessWithSyntaxTest2) {
babelHelpers.inherits(_class2, _IfUnlessWithSyntaxTest2);

    function _class2() {
      _IfUnlessWithSyntaxTest2.apply(this, arguments);
    }

    _class2.prototype.templateFor = function templateFor(_ref2) {
      var cond = _ref2.cond;
      var truthy = _ref2.truthy;
      var falsy = _ref2.falsy;

      return '{{#unless ' + cond + '}}' + falsy + '{{else}}' + truthy + '{{/unless}}';
    };

    return _class2;
  })(_emberGlimmerTestsUtilsSharedConditionalTests.IfUnlessWithSyntaxTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: {{#if}} and {{#unless}} without inverse', (function (_IfUnlessWithSyntaxTest3) {
babelHelpers.inherits(_class3, _IfUnlessWithSyntaxTest3);

    function _class3() {
      _IfUnlessWithSyntaxTest3.apply(this, arguments);
    }

    _class3.prototype.templateFor = function templateFor(_ref3) {
      var cond = _ref3.cond;
      var truthy = _ref3.truthy;
      var falsy = _ref3.falsy;

      return '{{#if ' + cond + '}}' + truthy + '{{/if}}{{#unless ' + cond + '}}' + falsy + '{{/unless}}';
    };

    return _class3;
  })(_emberGlimmerTestsUtilsSharedConditionalTests.IfUnlessWithSyntaxTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: {{#if}}', (function (_RenderingTest) {
babelHelpers.inherits(_class4, _RenderingTest);

    function _class4() {
      _RenderingTest.apply(this, arguments);
    }

    _class4.prototype['@test using `if` with an `{{each}}` destroys components when transitioning to and from inverse (GH #12267)'] = function testUsingIfWithAnEachDestroysComponentsWhenTransitioningToAndFromInverseGH12267(assert) {
      var _this = this;

      var destroyedChildrenCount = 0;

      this.registerComponent('foo-bar', {
        template: '{{number}}',
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          willDestroy: function () {
            this._super();
            destroyedChildrenCount++;
          }
        })
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject), { cond: true, numbers: _emberRuntime.A([1, 2, 3]) });

      this.assertText('123');

      this.runTask(function () {
        return _this.rerender();
      });

      this.assertText('123');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'cond', false);
      });

      this.assertText('Nothing Here!');
      assert.equal(destroyedChildrenCount, 3, 'the children were properly destroyed');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'cond', true);
      });

      this.assertText('123');
    };

    _class4.prototype['@test looking up `undefined` property defaults to false'] = function testLookingUpUndefinedPropertyDefaultsToFalse(assert) {
      var _this2 = this;

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2), { foo: {} });

      this.assertText('Nothing Here!');

      this.runTask(function () {
        return _this2.rerender();
      });

      this.assertText('Nothing Here!');

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'foo', { bar: { baz: true } });
      });

      this.assertText('Here!');

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'foo', {});
      });

      this.assertText('Nothing Here!');
    };

    return _class4;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/syntax/if-unless-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/syntax/if-unless-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/syntax/if-unless-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/syntax/in-element-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/test-helpers', 'ember-glimmer/tests/utils/abstract-test-case', 'ember-glimmer/component', 'ember-metal'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsTestHelpers, _emberGlimmerTestsUtilsAbstractTestCase, _emberGlimmerComponent, _emberMetal) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#-in-element someElement}}\n        {{text}}\n      {{/-in-element}}\n    '], ['\n      {{#-in-element someElement}}\n        {{text}}\n      {{/-in-element}}\n    ']),
      _templateObject2 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#if showModal}}\n        {{#-in-element someElement}}\n          {{modal-display text=text}}\n        {{/-in-element}}\n      {{/if}}\n    '], ['\n      {{#if showModal}}\n        {{#-in-element someElement}}\n          {{modal-display text=text}}\n        {{/-in-element}}\n      {{/if}}\n    ']);

  _emberGlimmerTestsUtilsTestCase.moduleFor('{{-in-element}}', (function (_RenderingTest) {
babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test allows rendering into an external element'] = function testAllowsRenderingIntoAnExternalElement(assert) {
      var _this = this;

      var someElement = document.createElement('div');

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject), {
        someElement: someElement,
        text: 'Whoop!'
      });

      _emberGlimmerTestsUtilsTestHelpers.equalTokens(this.element, '<!---->');
      _emberGlimmerTestsUtilsTestHelpers.equalTokens(someElement, 'Whoop!');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'text', 'Huzzah!!');
      });

      _emberGlimmerTestsUtilsTestHelpers.equalTokens(this.element, '<!---->');
      _emberGlimmerTestsUtilsTestHelpers.equalTokens(someElement, 'Huzzah!!');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'text', 'Whoop!');
      });

      _emberGlimmerTestsUtilsTestHelpers.equalTokens(this.element, '<!---->');
      _emberGlimmerTestsUtilsTestHelpers.equalTokens(someElement, 'Whoop!');
    };

    _class.prototype['@test components are cleaned up properly'] = function testComponentsAreCleanedUpProperly(assert) {
      var _this2 = this;

      var hooks = [];

      var someElement = document.createElement('div');

      this.registerComponent('modal-display', {
        ComponentClass: _emberGlimmerComponent.default.extend({
          didInsertElement: function () {
            hooks.push('didInsertElement');
          },

          willDestroyElement: function () {
            hooks.push('willDestroyElement');
          }
        }),

        template: '{{text}}'
      });

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2), {
        someElement: someElement,
        text: 'Whoop!',
        showModal: false
      });

      _emberGlimmerTestsUtilsTestHelpers.equalTokens(this.element, '<!---->');
      _emberGlimmerTestsUtilsTestHelpers.equalTokens(someElement, '');

      this.assertStableRerender();

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'showModal', true);
      });

      _emberGlimmerTestsUtilsTestHelpers.equalTokens(this.element, '<!---->');
      this.assertComponentElement(someElement.firstChild, { content: 'Whoop!' });

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'text', 'Huzzah!');
      });

      _emberGlimmerTestsUtilsTestHelpers.equalTokens(this.element, '<!---->');
      this.assertComponentElement(someElement.firstChild, { content: 'Huzzah!' });

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'text', 'Whoop!');
      });

      _emberGlimmerTestsUtilsTestHelpers.equalTokens(this.element, '<!---->');
      this.assertComponentElement(someElement.firstChild, { content: 'Whoop!' });

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'showModal', false);
      });

      _emberGlimmerTestsUtilsTestHelpers.equalTokens(this.element, '<!---->');
      _emberGlimmerTestsUtilsTestHelpers.equalTokens(someElement, '');

      assert.deepEqual(hooks, ['didInsertElement', 'willDestroyElement']);
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/syntax/in-element-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/syntax/in-element-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/syntax/in-element-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/syntax/with-dynamic-var-test', ['exports', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/abstract-test-case'], function (exports, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsAbstractTestCase) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n        {{#-with-dynamic-vars foo="bar"}}\n          {{-get-dynamic-var \'foo\'}}\n        {{/-with-dynamic-vars}}\n      '], ['\n        {{#-with-dynamic-vars foo="bar"}}\n          {{-get-dynamic-var \'foo\'}}\n        {{/-with-dynamic-vars}}\n      ']),
      _templateObject2 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#-with-dynamic-vars outletState="bar"}}\n        {{-get-dynamic-var \'outletState\'}}\n      {{/-with-dynamic-vars}}\n    '], ['\n      {{#-with-dynamic-vars outletState="bar"}}\n        {{-get-dynamic-var \'outletState\'}}\n      {{/-with-dynamic-vars}}\n    ']);

  _emberGlimmerTestsUtilsTestCase.moduleFor('{{-with-dynamic-var}}', (function (_RenderingTest) {
babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test does not allow setting values other than outletState'] = function testDoesNotAllowSettingValuesOtherThanOutletState(assert) {
      var _this = this;

      expectAssertion(function () {
        _this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject));
      }, /Using `-with-dynamic-scope` is only supported for `outletState` \(you used `foo`\)./);
    };

    _class.prototype['@test allows setting/getting outletState'] = function testAllowsSettingGettingOutletState(assert) {
      // this is simply asserting that we can write and read outletState
      // the actual value being used here is not what is used in real life
      // feel free to change the value being set and asserted as needed
      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2));

      this.assertText('bar');
    };

    _class.prototype['@test does not allow setting values other than outletState'] = function testDoesNotAllowSettingValuesOtherThanOutletState(assert) {
      var _this2 = this;

      expectAssertion(function () {
        _this2.render('{{-get-dynamic-var \'foo\'}}');
      }, /Using `-get-dynamic-scope` is only supported for `outletState` \(you used `foo`\)./);
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/syntax/with-dynamic-var-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/syntax/with-dynamic-var-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/syntax/with-dynamic-var-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/integration/syntax/with-test', ['exports', 'ember-metal', 'ember-runtime', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/shared-conditional-tests', 'ember-glimmer/tests/utils/abstract-test-case'], function (exports, _emberMetal, _emberRuntime, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsSharedConditionalTests, _emberGlimmerTestsUtilsAbstractTestCase) {
  'use strict';

  var _templateObject = babelHelpers.taggedTemplateLiteralLoose(['\n      {{#with foo.bar.baz as |thing|}}\n        {{thing}}\n      {{/with}}'], ['\n      {{#with foo.bar.baz as |thing|}}\n        {{thing}}\n      {{/with}}']),
      _templateObject2 = babelHelpers.taggedTemplateLiteralLoose(['\n      {{name}}\n      {{#with committer1.name as |name|}}\n        [{{name}}\n        {{#with committer2.name as |name|}}\n          [{{name}}]\n        {{/with}}\n        {{name}}]\n      {{/with}}\n      {{name}}\n      {{#with committer2.name as |name|}}\n        [{{name}}\n        {{#with committer1.name as |name|}}\n          [{{name}}]\n        {{/with}}\n        {{name}}]\n      {{/with}}\n      {{name}}\n    '], ['\n      {{name}}\n      {{#with committer1.name as |name|}}\n        [{{name}}\n        {{#with committer2.name as |name|}}\n          [{{name}}]\n        {{/with}}\n        {{name}}]\n      {{/with}}\n      {{name}}\n      {{#with committer2.name as |name|}}\n        [{{name}}\n        {{#with committer1.name as |name|}}\n          [{{name}}]\n        {{/with}}\n        {{name}}]\n      {{/with}}\n      {{name}}\n    ']);

  _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: {{#with}}', (function (_IfUnlessWithSyntaxTest) {
babelHelpers.inherits(_class, _IfUnlessWithSyntaxTest);

    function _class() {
      _IfUnlessWithSyntaxTest.apply(this, arguments);
    }

    _class.prototype.templateFor = function templateFor(_ref) {
      var cond = _ref.cond;
      var truthy = _ref.truthy;
      var falsy = _ref.falsy;

      return '{{#with ' + cond + '}}' + truthy + '{{else}}' + falsy + '{{/with}}';
    };

    return _class;
  })(_emberGlimmerTestsUtilsSharedConditionalTests.IfUnlessWithSyntaxTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: {{#with as}}', (function (_IfUnlessWithSyntaxTest2) {
babelHelpers.inherits(_class2, _IfUnlessWithSyntaxTest2);

    function _class2() {
      _IfUnlessWithSyntaxTest2.apply(this, arguments);
    }

    _class2.prototype.templateFor = function templateFor(_ref2) {
      var cond = _ref2.cond;
      var truthy = _ref2.truthy;
      var falsy = _ref2.falsy;

      return '{{#with ' + cond + ' as |test|}}' + truthy + '{{else}}' + falsy + '{{/with}}';
    };

    _class2.prototype['@test keying off of `undefined` does not render'] = function testKeyingOffOfUndefinedDoesNotRender(assert) {
      var _this = this;

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject), { foo: {} });

      this.assertText('');

      this.runTask(function () {
        return _this.rerender();
      });

      this.assertText('');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'foo', { bar: { baz: 'Here!' } });
      });

      this.assertText('Here!');

      this.runTask(function () {
        return _emberMetal.set(_this.context, 'foo', {});
      });

      this.assertText('');
    };

    _class2.prototype['@test it renders and hides the given block based on the conditional'] = function testItRendersAndHidesTheGivenBlockBasedOnTheConditional() {
      var _this2 = this;

      this.render('{{#with cond1 as |cond|}}{{cond.greeting}}{{else}}False{{/with}}', {
        cond1: { greeting: 'Hello' }
      });

      this.assertText('Hello');

      this.runTask(function () {
        return _this2.rerender();
      });

      this.assertText('Hello');

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'cond1.greeting', 'Hello world');
      });

      this.assertText('Hello world');

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'cond1', false);
      });

      this.assertText('False');

      this.runTask(function () {
        return _emberMetal.set(_this2.context, 'cond1', { greeting: 'Hello' });
      });

      this.assertText('Hello');
    };

    _class2.prototype['@test can access alias and original scope'] = function testCanAccessAliasAndOriginalScope() {
      var _this3 = this;

      this.render('{{#with person as |tom|}}{{title}}: {{tom.name}}{{/with}}', {
        title: 'Señor Engineer',
        person: { name: 'Tom Dale' }
      });

      this.assertText('Señor Engineer: Tom Dale');

      this.runTask(function () {
        return _this3.rerender();
      });

      this.assertText('Señor Engineer: Tom Dale');

      this.runTask(function () {
        _emberMetal.set(_this3.context, 'person.name', 'Yehuda Katz');
        _emberMetal.set(_this3.context, 'title', 'Principal Engineer');
      });

      this.assertText('Principal Engineer: Yehuda Katz');

      this.runTask(function () {
        _emberMetal.set(_this3.context, 'person', { name: 'Tom Dale' });
        _emberMetal.set(_this3.context, 'title', 'Señor Engineer');
      });

      this.assertText('Señor Engineer: Tom Dale');
    };

    _class2.prototype['@test the scoped variable is not available outside the {{#with}} block.'] = function testTheScopedVariableIsNotAvailableOutsideTheWithBlock() {
      var _this4 = this;

      this.render('{{name}}-{{#with other as |name|}}{{name}}{{/with}}-{{name}}', {
        name: 'Stef',
        other: 'Yehuda'
      });

      this.assertText('Stef-Yehuda-Stef');

      this.runTask(function () {
        return _this4.rerender();
      });

      this.assertText('Stef-Yehuda-Stef');

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'other', 'Chad');
      });

      this.assertText('Stef-Chad-Stef');

      this.runTask(function () {
        return _emberMetal.set(_this4.context, 'name', 'Tom');
      });

      this.assertText('Tom-Chad-Tom');

      this.runTask(function () {
        _emberMetal.set(_this4.context, 'name', 'Stef');
        _emberMetal.set(_this4.context, 'other', 'Yehuda');
      });

      this.assertText('Stef-Yehuda-Stef');
    };

    _class2.prototype['@test inverse template is displayed with context'] = function testInverseTemplateIsDisplayedWithContext() {
      var _this5 = this;

      this.render('{{#with falsyThing as |thing|}}Has Thing{{else}}No Thing {{otherThing}}{{/with}}', {
        falsyThing: null,
        otherThing: 'bar'
      });

      this.assertText('No Thing bar');

      this.runTask(function () {
        return _this5.rerender();
      });

      this.assertText('No Thing bar');

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'otherThing', 'biz');
      });

      this.assertText('No Thing biz');

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'falsyThing', true);
      });

      this.assertText('Has Thing');

      this.runTask(function () {
        return _emberMetal.set(_this5.context, 'otherThing', 'baz');
      });

      this.assertText('Has Thing');

      this.runTask(function () {
        _emberMetal.set(_this5.context, 'otherThing', 'bar');
        _emberMetal.set(_this5.context, 'falsyThing', null);
      });

      this.assertText('No Thing bar');
    };

    _class2.prototype['@test can access alias of a proxy'] = function testCanAccessAliasOfAProxy() {
      var _this6 = this;

      this.render('{{#with proxy as |person|}}{{person.name}}{{/with}}', {
        proxy: _emberRuntime.ObjectProxy.create({ content: { name: 'Tom Dale' } })
      });

      this.assertText('Tom Dale');

      this.runTask(function () {
        return _this6.rerender();
      });

      this.assertText('Tom Dale');

      this.runTask(function () {
        return _emberMetal.set(_this6.context, 'proxy.name', 'Yehuda Katz');
      });

      this.assertText('Yehuda Katz');

      this.runTask(function () {
        return _emberMetal.set(_this6.context, 'proxy.content', { name: 'Godfrey Chan' });
      });

      this.assertText('Godfrey Chan');

      this.runTask(function () {
        return _emberMetal.set(_this6.context, 'proxy.content.name', 'Stefan Penner');
      });

      this.assertText('Stefan Penner');

      this.runTask(function () {
        return _emberMetal.set(_this6.context, 'proxy.content', null);
      });

      this.assertText('');

      this.runTask(function () {
        return _emberMetal.set(_this6.context, 'proxy', _emberRuntime.ObjectProxy.create({ content: { name: 'Tom Dale' } }));
      });

      this.assertText('Tom Dale');
    };

    _class2.prototype['@test can access alias of an array'] = function testCanAccessAliasOfAnArray() {
      var _this7 = this;

      this.render('{{#with arrayThing as |words|}}{{#each words as |word|}}{{word}}{{/each}}{{/with}}', {
        arrayThing: _emberRuntime.A(['Hello', ' ', 'world'])
      });

      this.assertText('Hello world');

      this.runTask(function () {
        return _this7.rerender();
      });

      this.assertText('Hello world');

      this.runTask(function () {
        var array = _emberMetal.get(_this7.context, 'arrayThing');
        array.replace(0, 1, 'Goodbye');
        _emberRuntime.removeAt(array, 1);
        array.insertAt(1, ', ');
        array.pushObject('!');
      });

      this.assertText('Goodbye, world!');

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'arrayThing', ['Hello', ' ', 'world']);
      });

      this.assertText('Hello world');
    };

    _class2.prototype['@test `attrs` can be used as a block param [GH#14678]'] = function testAttrsCanBeUsedAsABlockParamGH14678() {
      var _this8 = this;

      this.render('{{#with hash as |attrs|}}[{{hash.foo}}-{{attrs.foo}}]{{/with}}', {
        hash: { foo: 'foo' }
      });

      this.assertText('[foo-foo]');

      this.runTask(function () {
        return _this8.rerender();
      });

      this.assertText('[foo-foo]');

      this.runTask(function () {
        return _this8.context.set('hash.foo', 'FOO');
      });

      this.assertText('[FOO-FOO]');

      this.runTask(function () {
        return _this8.context.set('hash.foo', 'foo');
      });

      this.assertText('[foo-foo]');
    };

    return _class2;
  })(_emberGlimmerTestsUtilsSharedConditionalTests.IfUnlessWithSyntaxTest));

  _emberGlimmerTestsUtilsTestCase.moduleFor('Syntax test: Multiple {{#with as}} helpers', (function (_RenderingTest) {
babelHelpers.inherits(_class3, _RenderingTest);

    function _class3() {
      _RenderingTest.apply(this, arguments);
    }

    _class3.prototype['@test re-using the same variable with different {{#with}} blocks does not override each other'] = function testReUsingTheSameVariableWithDifferentWithBlocksDoesNotOverrideEachOther() {
      var _this9 = this;

      this.render('Admin: {{#with admin as |person|}}{{person.name}}{{/with}} User: {{#with user as |person|}}{{person.name}}{{/with}}', {
        admin: { name: 'Tom Dale' },
        user: { name: 'Yehuda Katz' }
      });

      this.assertText('Admin: Tom Dale User: Yehuda Katz');

      this.runTask(function () {
        return _this9.rerender();
      });

      this.assertText('Admin: Tom Dale User: Yehuda Katz');

      this.runTask(function () {
        _emberMetal.set(_this9.context, 'admin.name', 'Godfrey Chan');
        _emberMetal.set(_this9.context, 'user.name', 'Stefan Penner');
      });

      this.assertText('Admin: Godfrey Chan User: Stefan Penner');

      this.runTask(function () {
        _emberMetal.set(_this9.context, 'admin', { name: 'Tom Dale' });
        _emberMetal.set(_this9.context, 'user', { name: 'Yehuda Katz' });
      });

      this.assertText('Admin: Tom Dale User: Yehuda Katz');
    };

    _class3.prototype['@test the scoped variable is not available outside the {{#with}} block'] = function testTheScopedVariableIsNotAvailableOutsideTheWithBlock() {
      var _this10 = this;

      this.render('{{ring}}-{{#with first as |ring|}}{{ring}}-{{#with fifth as |ring|}}{{ring}}-{{#with ninth as |ring|}}{{ring}}-{{/with}}{{ring}}-{{/with}}{{ring}}-{{/with}}{{ring}}', {
        ring: 'Greed',
        first: 'Limbo',
        fifth: 'Wrath',
        ninth: 'Treachery'
      });

      this.assertText('Greed-Limbo-Wrath-Treachery-Wrath-Limbo-Greed');

      this.runTask(function () {
        return _this10.rerender();
      });

      this.assertText('Greed-Limbo-Wrath-Treachery-Wrath-Limbo-Greed');

      this.runTask(function () {
        _emberMetal.set(_this10.context, 'ring', 'O');
        _emberMetal.set(_this10.context, 'fifth', 'D');
      });

      this.assertText('O-Limbo-D-Treachery-D-Limbo-O');

      this.runTask(function () {
        _emberMetal.set(_this10.context, 'first', 'I');
        _emberMetal.set(_this10.context, 'ninth', 'K');
      });

      this.assertText('O-I-D-K-D-I-O');

      this.runTask(function () {
        _emberMetal.set(_this10.context, 'ring', 'Greed');
        _emberMetal.set(_this10.context, 'first', 'Limbo');
        _emberMetal.set(_this10.context, 'fifth', 'Wrath');
        _emberMetal.set(_this10.context, 'ninth', 'Treachery');
      });

      this.assertText('Greed-Limbo-Wrath-Treachery-Wrath-Limbo-Greed');
    };

    _class3.prototype['@test it should support {{#with name as |foo|}}, then {{#with foo as |bar|}}'] = function testItShouldSupportWithNameAsFooThenWithFooAsBar() {
      var _this11 = this;

      this.render('{{#with name as |foo|}}{{#with foo as |bar|}}{{bar}}{{/with}}{{/with}}', {
        name: 'caterpillar'
      });

      this.assertText('caterpillar');

      this.runTask(function () {
        return _this11.rerender();
      });

      this.assertText('caterpillar');

      this.runTask(function () {
        return _emberMetal.set(_this11.context, 'name', 'butterfly');
      });

      this.assertText('butterfly');

      this.runTask(function () {
        return _emberMetal.set(_this11.context, 'name', 'caterpillar');
      });

      this.assertText('caterpillar');
    };

    _class3.prototype['@test updating the context should update the alias'] = function testUpdatingTheContextShouldUpdateTheAlias() {
      var _this12 = this;

      this.render('{{#with this as |person|}}{{person.name}}{{/with}}', {
        name: 'Los Pivots'
      });

      this.assertText('Los Pivots');

      this.runTask(function () {
        return _this12.rerender();
      });

      this.assertText('Los Pivots');

      this.runTask(function () {
        return _emberMetal.set(_this12.context, 'name', 'l\'Pivots');
      });

      this.assertText('l\'Pivots');

      this.runTask(function () {
        return _emberMetal.set(_this12.context, 'name', 'Los Pivots');
      });

      this.assertText('Los Pivots');
    };

    _class3.prototype['@test nested {{#with}} blocks should have access to root context'] = function testNestedWithBlocksShouldHaveAccessToRootContext() {
      var _this13 = this;

      this.render(_emberGlimmerTestsUtilsAbstractTestCase.strip(_templateObject2), {
        name: 'ebryn',
        committer1: { name: 'trek' },
        committer2: { name: 'machty' }
      });

      this.assertText('ebryn[trek[machty]trek]ebryn[machty[trek]machty]ebryn');

      this.runTask(function () {
        return _this13.rerender();
      });

      this.assertText('ebryn[trek[machty]trek]ebryn[machty[trek]machty]ebryn');

      this.runTask(function () {
        return _emberMetal.set(_this13.context, 'name', 'chancancode');
      });

      this.assertText('chancancode[trek[machty]trek]chancancode[machty[trek]machty]chancancode');

      this.runTask(function () {
        return _emberMetal.set(_this13.context, 'committer1', { name: 'krisselden' });
      });

      this.assertText('chancancode[krisselden[machty]krisselden]chancancode[machty[krisselden]machty]chancancode');

      this.runTask(function () {
        _emberMetal.set(_this13.context, 'committer1.name', 'wycats');
        _emberMetal.set(_this13.context, 'committer2', { name: 'rwjblue' });
      });

      this.assertText('chancancode[wycats[rwjblue]wycats]chancancode[rwjblue[wycats]rwjblue]chancancode');

      this.runTask(function () {
        _emberMetal.set(_this13.context, 'name', 'ebryn');
        _emberMetal.set(_this13.context, 'committer1', { name: 'trek' });
        _emberMetal.set(_this13.context, 'committer2', { name: 'machty' });
      });

      this.assertText('ebryn[trek[machty]trek]ebryn[machty[trek]machty]ebryn');
    };

    return _class3;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/integration/syntax/with-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/integration/syntax/with-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/integration/syntax/with-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/unit/layout-cache-test', ['exports', 'ember-utils', 'ember-glimmer/tests/utils/test-case', '@glimmer/runtime'], function (exports, _emberUtils, _emberGlimmerTestsUtilsTestCase, _glimmerRuntime) {
  'use strict';

  var Counter = (function () {
    function Counter() {
      this.reset();
    }

    Counter.prototype.increment = function increment(key) {
      this.total++;
      return this.counts[key] = (this.counts[key] || 0) + 1;
    };

    Counter.prototype.get = function get(key) {
      return this.counts[key] || 0;
    };

    Counter.prototype.reset = function reset() {
      this.total = 0;
      this.counts = new _emberUtils.EmptyObject();
    };

    return Counter;
  })();

  var COUNTER = new Counter();

  var BasicCompiler = (function () {
    function BasicCompiler(template) {
      this.template = template;
    }

    BasicCompiler.prototype.compile = function compile(builder) {
      var template = this.template;

      COUNTER.increment(this.constructor.id + '+' + template.id);
      builder.wrapLayout(template.asLayout());
    };

    return BasicCompiler;
  })();

  var TypeOneCompiler = (function (_BasicCompiler) {
    babelHelpers.inherits(TypeOneCompiler, _BasicCompiler);

    function TypeOneCompiler() {
      _BasicCompiler.apply(this, arguments);
    }

    return TypeOneCompiler;
  })(BasicCompiler);

  var TypeTwoCompiler = (function (_BasicCompiler2) {
    babelHelpers.inherits(TypeTwoCompiler, _BasicCompiler2);

    function TypeTwoCompiler() {
      _BasicCompiler2.apply(this, arguments);
    }

    return TypeTwoCompiler;
  })(BasicCompiler);

  TypeOneCompiler.id = 'type-one';
  TypeTwoCompiler.id = 'type-two';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Layout cache test', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.call(this);
      COUNTER.reset();
    }

    _class.prototype.templateFor = function templateFor(content) {
      var Factory = this.compile(content);
      return this.env.getTemplate(Factory, this.owner);
    };

    _class.prototype['@test each template is only compiled once'] = function testEachTemplateIsOnlyCompiledOnce(assert) {
      var env = this.env;

      var template1 = this.templateFor('Hello world!');
      var template2 = this.templateFor('{{foo}} {{bar}}');

      assert.ok(env.getCompiledBlock(TypeOneCompiler, template1) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
      assert.strictEqual(COUNTER.get('type-one+' + template1.id), 1);
      assert.strictEqual(COUNTER.get('type-one+' + template2.id), 0);
      assert.strictEqual(COUNTER.total, 1);

      assert.ok(env.getCompiledBlock(TypeOneCompiler, template1) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
      assert.strictEqual(COUNTER.get('type-one+' + template1.id), 1);
      assert.strictEqual(COUNTER.get('type-one+' + template2.id), 0);
      assert.strictEqual(COUNTER.total, 1);

      assert.ok(env.getCompiledBlock(TypeOneCompiler, template2) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
      assert.strictEqual(COUNTER.get('type-one+' + template1.id), 1);
      assert.strictEqual(COUNTER.get('type-one+' + template2.id), 1);
      assert.strictEqual(COUNTER.total, 2);

      assert.ok(env.getCompiledBlock(TypeOneCompiler, template1) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
      assert.ok(env.getCompiledBlock(TypeOneCompiler, template1) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
      assert.ok(env.getCompiledBlock(TypeOneCompiler, template2) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
      assert.ok(env.getCompiledBlock(TypeOneCompiler, template1) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
      assert.ok(env.getCompiledBlock(TypeOneCompiler, template1) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
      assert.ok(env.getCompiledBlock(TypeOneCompiler, template1) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
      assert.ok(env.getCompiledBlock(TypeOneCompiler, template2) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
      assert.ok(env.getCompiledBlock(TypeOneCompiler, template2) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');

      assert.strictEqual(COUNTER.get('type-one+' + template1.id), 1);
      assert.strictEqual(COUNTER.get('type-one+' + template2.id), 1);
      assert.strictEqual(COUNTER.total, 2);
    };

    _class.prototype['@test each template/compiler pair is treated as unique'] = function testEachTemplateCompilerPairIsTreatedAsUnique(assert) {
      var env = this.env;

      var template = this.templateFor('Hello world!');

      assert.ok(env.getCompiledBlock(TypeOneCompiler, template) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
      assert.strictEqual(COUNTER.get('type-one+' + template.id), 1);
      assert.strictEqual(COUNTER.get('type-two+' + template.id), 0);
      assert.strictEqual(COUNTER.total, 1);

      assert.ok(env.getCompiledBlock(TypeOneCompiler, template) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
      assert.strictEqual(COUNTER.get('type-one+' + template.id), 1);
      assert.strictEqual(COUNTER.get('type-two+' + template.id), 0);
      assert.strictEqual(COUNTER.total, 1);

      assert.ok(env.getCompiledBlock(TypeTwoCompiler, template) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
      assert.strictEqual(COUNTER.get('type-one+' + template.id), 1);
      assert.strictEqual(COUNTER.get('type-two+' + template.id), 1);
      assert.strictEqual(COUNTER.total, 2);

      assert.ok(env.getCompiledBlock(TypeOneCompiler, template) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
      assert.ok(env.getCompiledBlock(TypeOneCompiler, template) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
      assert.ok(env.getCompiledBlock(TypeTwoCompiler, template) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
      assert.ok(env.getCompiledBlock(TypeOneCompiler, template) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
      assert.ok(env.getCompiledBlock(TypeOneCompiler, template) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
      assert.ok(env.getCompiledBlock(TypeOneCompiler, template) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
      assert.ok(env.getCompiledBlock(TypeTwoCompiler, template) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
      assert.ok(env.getCompiledBlock(TypeTwoCompiler, template) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');

      assert.strictEqual(COUNTER.get('type-one+' + template.id), 1);
      assert.strictEqual(COUNTER.get('type-two+' + template.id), 1);
      assert.strictEqual(COUNTER.total, 2);
    };

    _class.prototype['@test a template instance is returned (ensures templates can be injected into layout property)'] = function testATemplateInstanceIsReturnedEnsuresTemplatesCanBeInjectedIntoLayoutProperty(assert) {
      var _this = this;

      var owner = this.owner;
      var env = this.env;

      var templateInstanceFor = function (content) {
        var _Factory$create;

        var Factory = _this.compile(content);
        return Factory.create((_Factory$create = {}, _Factory$create[_emberUtils.OWNER] = owner, _Factory$create.env = env, _Factory$create));
      };

      var template1 = templateInstanceFor('Hello world!');
      var template2 = templateInstanceFor('{{foo}} {{bar}}');

      assert.ok(env.getCompiledBlock(TypeOneCompiler, template1) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
      assert.ok(env.getCompiledBlock(TypeOneCompiler, template2) instanceof _glimmerRuntime.CompiledBlock, 'should return a CompiledBlock');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/unit/layout-cache-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/unit/layout-cache-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/unit/layout-cache-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/unit/outlet-test', ['exports', 'ember-glimmer/views/outlet', 'ember-metal'], function (exports, _emberGlimmerViewsOutlet, _emberMetal) {
  'use strict';

  QUnit.module('Glimmer OutletView');

  QUnit.test('render in the render queue', function (assert) {
    var didAppendOutletView = 0;
    var expectedOutlet = '#foo.bar';

    var renderer = {
      appendOutletView: function (view, target) {
        didAppendOutletView++;
        assert.equal(view, outletView);
        assert.equal(target, expectedOutlet);
      }
    };

    var outletView = new _emberGlimmerViewsOutlet.default({}, renderer);

    _emberMetal.run(function () {
      assert.equal(didAppendOutletView, 0, 'appendOutletView should not yet have been called (before appendTo)');
      outletView.appendTo(expectedOutlet);
      assert.equal(didAppendOutletView, 0, 'appendOutletView should not yet have been called (sync after appendTo)');

      _emberMetal.run.schedule('actions', function () {
        return assert.equal(didAppendOutletView, 0, 'appendOutletView should not yet have been called (in actions)');
      });
      _emberMetal.run.schedule('render', function () {
        return assert.equal(didAppendOutletView, 1, 'appendOutletView should be invoked in render');
      });
    });
  });
});
enifed('ember-glimmer/tests/unit/outlet-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/unit/outlet-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/unit/outlet-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/unit/template-factory-test', ['exports', 'ember-template-compiler', 'ember-glimmer/index', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/tests/utils/helpers'], function (exports, _emberTemplateCompiler, _emberGlimmerIndex, _emberGlimmerTestsUtilsTestCase, _emberGlimmerTestsUtilsHelpers) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Template factory test', (function (_RenderingTest) {
    babelHelpers.inherits(_class, _RenderingTest);

    function _class() {
      _RenderingTest.apply(this, arguments);
    }

    _class.prototype['@test the template factory returned from precompile is the same as compile'] = function testTheTemplateFactoryReturnedFromPrecompileIsTheSameAsCompile(assert) {
      var env = this.env;

      var templateStr = 'Hello {{name}}';
      var options = { moduleName: 'some-module' };

      var spec = _emberTemplateCompiler.precompile(templateStr, options);
      var body = 'exports.default = template(' + spec + ');';
      var module = new Function('exports', 'template', body);
      var exports = {};
      module(exports, _emberGlimmerIndex.template);
      var Precompiled = exports['default'];

      var Compiled = _emberTemplateCompiler.compile(templateStr, options);

      assert.equal(typeof Precompiled.create, 'function', 'precompiled is a factory');
      assert.ok(Precompiled.id, 'precompiled has id');

      assert.equal(typeof Compiled.create, 'function', 'compiled is a factory');
      assert.ok(Compiled.id, 'compiled has id');

      assert.equal(env._templateCache.misses, 0, 'misses 0');
      assert.equal(env._templateCache.hits, 0, 'hits 0');

      var precompiled = env.getTemplate(Precompiled, env.owner);

      assert.equal(env._templateCache.misses, 1, 'misses 1');
      assert.equal(env._templateCache.hits, 0, 'hits 0');

      var compiled = env.getTemplate(Compiled, env.owner);

      assert.equal(env._templateCache.misses, 2, 'misses 2');
      assert.equal(env._templateCache.hits, 0, 'hits 0');

      assert.ok(typeof precompiled.spec !== 'string', 'Spec has been parsed');
      assert.ok(typeof compiled.spec !== 'string', 'Spec has been parsed');

      this.registerComponent('x-precompiled', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          layout: Precompiled
        })
      });

      this.registerComponent('x-compiled', {
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          layout: Compiled
        })
      });

      this.render('{{x-precompiled name="precompiled"}} {{x-compiled name="compiled"}}');

      assert.equal(env._templateCache.misses, 2, 'misses 2');
      assert.equal(env._templateCache.hits, 2, 'hits 2');

      this.assertText('Hello precompiled Hello compiled');
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest));
});
enifed('ember-glimmer/tests/unit/template-factory-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/unit/template-factory-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/unit/template-factory-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/unit/utils/debug-stack-test', ['exports', 'ember-glimmer/utils/debug-stack', 'ember-metal'], function (exports, _emberGlimmerUtilsDebugStack, _emberMetal) {
  'use strict';
});
enifed('ember-glimmer/tests/unit/utils/debug-stack-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/unit/utils/debug-stack-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/unit/utils/debug-stack-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/unit/utils/iterable-test', ['exports', 'ember', 'ember-glimmer/tests/utils/test-case', 'ember-glimmer/utils/iterable', 'ember-glimmer/utils/references', 'ember-glimmer/helpers/each-in', '@glimmer/runtime'], function (exports, _ember, _emberGlimmerTestsUtilsTestCase, _emberGlimmerUtilsIterable, _emberGlimmerUtilsReferences, _emberGlimmerHelpersEachIn, _glimmerRuntime) {
  'use strict';

  var ITERATOR_KEY_GUID = 'be277757-bbbe-4620-9fcb-213ef433cca2';

  _emberGlimmerTestsUtilsTestCase.moduleFor('Iterable', (function (_TestCase) {
    babelHelpers.inherits(_class, _TestCase);

    function _class() {
      _TestCase.apply(this, arguments);
    }

    _class.prototype['@test iterates over an array'] = function testIteratesOverAnArray() {
      var iterator = iteratorForArray(['foo', 'bar']);

      this.assert.deepEqual(iterator.next(), { key: 'foo', memo: 0, value: 'foo' });
      this.assert.deepEqual(iterator.next(), { key: 'bar', memo: 1, value: 'bar' });
    };

    _class.prototype['@test iterates over an `Ember.A`'] = function testIteratesOverAnEmberA() {
      var iterator = iteratorForArray(_ember.default.A(['foo', 'bar']));

      this.assert.deepEqual(iterator.next(), { key: 'foo', memo: 0, value: 'foo' });
      this.assert.deepEqual(iterator.next(), { key: 'bar', memo: 1, value: 'bar' });
    };

    _class.prototype['@test returns `null` when out of items'] = function testReturnsNullWhenOutOfItems() {
      var iterator = iteratorForArray(['foo']);

      this.assert.deepEqual(iterator.next(), { key: 'foo', memo: 0, value: 'foo' });
      this.assert.deepEqual(iterator.next(), null);
    };

    _class.prototype['@test iterates over an array with indices as keys'] = function testIteratesOverAnArrayWithIndicesAsKeys() {
      var iterator = iteratorForArray(['foo', 'bar'], '@index');

      this.assert.deepEqual(iterator.next(), { key: '0', memo: 0, value: 'foo' });
      this.assert.deepEqual(iterator.next(), { key: '1', memo: 1, value: 'bar' });
    };

    _class.prototype['@test iterates over an array with identities as keys'] = function testIteratesOverAnArrayWithIdentitiesAsKeys() {
      var iterator = iteratorForArray(['foo', 'bar'], '@identity');

      this.assert.deepEqual(iterator.next(), { key: 'foo', memo: 0, value: 'foo' });
      this.assert.deepEqual(iterator.next(), { key: 'bar', memo: 1, value: 'bar' });
    };

    _class.prototype['@test iterates over an array with arbitrary properties as keys'] = function testIteratesOverAnArrayWithArbitraryPropertiesAsKeys() {
      var iterator = iteratorForArray([{ k: 'first', v: 'foo' }, { k: 'second', v: 'bar' }], 'k');

      this.assert.deepEqual(iterator.next(), { key: 'first', memo: 0, value: { k: 'first', v: 'foo' } });
      this.assert.deepEqual(iterator.next(), { key: 'second', memo: 1, value: { k: 'second', v: 'bar' } });
    };

    _class.prototype['@test errors on `#next` with an undefined ref'] = function testErrorsOnNextWithAnUndefinedRef() {
      var iterator = iteratorForArray(undefined);

      this.assert.expect(1);

      try {
        iterator.next();
      } catch (_ref) {
        var _message = _ref.message;

        this.assert.equal(_message, 'Cannot call next() on an empty iterator');
      }
    };

    _class.prototype['@test errors on `#next` with a null ref'] = function testErrorsOnNextWithANullRef() {
      var iterator = iteratorForArray(null);

      this.assert.expect(1);

      try {
        iterator.next();
      } catch (_ref2) {
        var _message2 = _ref2.message;

        this.assert.equal(_message2, 'Cannot call next() on an empty iterator');
      }
    };

    _class.prototype['@test errors on `#next` with an invalid ref type'] = function testErrorsOnNextWithAnInvalidRefType() {
      var iterator = iteratorForArray('string');

      this.assert.expect(1);

      try {
        iterator.next();
      } catch (_ref3) {
        var _message3 = _ref3.message;

        this.assert.equal(_message3, 'Cannot call next() on an empty iterator');
      }
    };

    _class.prototype['@test errors on `#next` with an empty array'] = function testErrorsOnNextWithAnEmptyArray() {
      var iterator = iteratorForArray([]);

      this.assert.expect(1);

      try {
        iterator.next();
      } catch (_ref4) {
        var _message4 = _ref4.message;

        this.assert.equal(_message4, 'Cannot call next() on an empty iterator');
      }
    };

    _class.prototype['@test iterates over an object\'s own properties'] = function testIteratesOverAnObjectSOwnProperties() {
      var iterator = iteratorForObject({ first: 'foo', second: 'bar' });

      this.assert.deepEqual(iterator.next(), { key: 'first', memo: 'first', value: 'foo' });
      this.assert.deepEqual(iterator.next(), { key: 'second', memo: 'second', value: 'bar' });
    };

    _class.prototype['@test iterates over an object\'s own properties with indices as keys'] = function testIteratesOverAnObjectSOwnPropertiesWithIndicesAsKeys() {
      var iterator = iteratorForObject({ first: 'foo', second: 'bar' }, '@index');

      this.assert.deepEqual(iterator.next(), { key: 'first', memo: 'first', value: 'foo' });
      this.assert.deepEqual(iterator.next(), { key: 'second', memo: 'second', value: 'bar' });
    };

    _class.prototype['@test iterates over an object\'s own properties with identities as keys'] = function testIteratesOverAnObjectSOwnPropertiesWithIdentitiesAsKeys() {
      var iterator = iteratorForObject({ first: 'foo', second: 'bar' }, '@identity');

      this.assert.deepEqual(iterator.next(), { key: 'foo', memo: 'first', value: 'foo' });
      this.assert.deepEqual(iterator.next(), { key: 'bar', memo: 'second', value: 'bar' });
    };

    _class.prototype['@test iterates over an object\'s own properties with arbitrary properties as keys'] = function testIteratesOverAnObjectSOwnPropertiesWithArbitraryPropertiesAsKeys() {
      var iterator = iteratorForObject({ first: { k: 'uno', v: 'foo' }, second: { k: 'dos', v: 'bar' } }, 'k');

      this.assert.deepEqual(iterator.next(), { key: 'uno', memo: 'first', value: { k: 'uno', v: 'foo' } });
      this.assert.deepEqual(iterator.next(), { key: 'dos', memo: 'second', value: { k: 'dos', v: 'bar' } });
    };

    _class.prototype['@test each-in errors on `#next` with an undefined ref'] = function testEachInErrorsOnNextWithAnUndefinedRef() {
      var iterator = iteratorForObject(undefined);

      this.assert.expect(1);

      try {
        iterator.next();
      } catch (_ref5) {
        var _message5 = _ref5.message;

        this.assert.equal(_message5, 'Cannot call next() on an empty iterator');
      }
    };

    _class.prototype['@test each-in errors on `#next` with a null ref'] = function testEachInErrorsOnNextWithANullRef() {
      var iterator = iteratorForObject(null);

      this.assert.expect(1);

      try {
        iterator.next();
      } catch (_ref6) {
        var _message6 = _ref6.message;

        this.assert.equal(_message6, 'Cannot call next() on an empty iterator');
      }
    };

    _class.prototype['@test each-in errors on `#next` with an invalid ref type'] = function testEachInErrorsOnNextWithAnInvalidRefType() {
      var iterator = iteratorForObject('string');

      this.assert.expect(1);

      try {
        iterator.next();
      } catch (_ref7) {
        var _message7 = _ref7.message;

        this.assert.equal(_message7, 'Cannot call next() on an empty iterator');
      }
    };

    _class.prototype['@test ensures keys are unique'] = function testEnsuresKeysAreUnique() {
      var iterator = iteratorForArray([{ k: 'qux', v: 'foo' }, { k: 'qux', v: 'bar' }, { k: 'qux', v: 'baz' }], 'k');

      this.assert.deepEqual(iterator.next(), { key: 'qux', memo: 0, value: { k: 'qux', v: 'foo' } });
      this.assert.deepEqual(iterator.next(), { key: 'qux' + ITERATOR_KEY_GUID + '1', memo: 1, value: { k: 'qux', v: 'bar' } });
      this.assert.deepEqual(iterator.next(), { key: 'qux' + ITERATOR_KEY_GUID + '2', memo: 2, value: { k: 'qux', v: 'baz' } });
    };

    return _class;
  })(_emberGlimmerTestsUtilsTestCase.TestCase));

  function iteratorForArray(arr, keyPath) {
    var ref = new _emberGlimmerUtilsReferences.UpdatableReference(arr);
    var iterable = _emberGlimmerUtilsIterable.default(ref, keyPath);

    return iterable.iterate();
  }

  function iteratorForObject(obj, keyPath) {
    var vm = null;
    var positionalArgs = _glimmerRuntime.EvaluatedPositionalArgs.create([new _emberGlimmerUtilsReferences.UpdatableReference(obj)]);
    var ref = _emberGlimmerHelpersEachIn.default(vm, { positional: positionalArgs });
    var iterable = _emberGlimmerUtilsIterable.default(ref, keyPath);

    return iterable.iterate();
  }
});
enifed('ember-glimmer/tests/unit/utils/iterable-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/unit/utils/iterable-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/unit/utils/iterable-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/utils/abstract-test-case', ['exports', 'internal-test-helpers'], function (exports, _internalTestHelpers) {
  'use strict';

  exports.TestCase = _internalTestHelpers.AbstractTestCase;
  exports.applyMixins = _internalTestHelpers.applyMixins;
  exports.strip = _internalTestHelpers.strip;
});
enifed('ember-glimmer/tests/utils/abstract-test-case.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/utils/abstract-test-case.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/utils/abstract-test-case.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/utils/helpers', ['exports', 'ember-template-compiler', 'ember-glimmer'], function (exports, _emberTemplateCompiler, _emberGlimmer) {
  'use strict';

  exports.compile = _emberTemplateCompiler.compile;
  exports.precompile = _emberTemplateCompiler.precompile;
  exports.INVOKE = _emberGlimmer.INVOKE;
  exports.Helper = _emberGlimmer.Helper;
  exports.helper = _emberGlimmer.helper;
  exports.Component = _emberGlimmer.Component;
  exports.TextArea = _emberGlimmer.TextArea;
  exports.LinkComponent = _emberGlimmer.LinkComponent;
  exports.TextField = _emberGlimmer.TextField;
  exports.InteractiveRender = _emberGlimmer.InteractiveRender;
  exports.InertRenderer = _emberGlimmer.InertRenderer;
  exports.makeBoundHelper = _emberGlimmer.makeBoundHelper;
  exports.htmlSafe = _emberGlimmer.htmlSafe;
  exports.SafeString = _emberGlimmer.SafeString;
  exports.DOMChanges = _emberGlimmer.DOMChanges;
  exports.isHTMLSafe = _emberGlimmer.isHTMLSafe;
});
enifed('ember-glimmer/tests/utils/helpers.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/utils/helpers.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/utils/helpers.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/utils/shared-conditional-tests', ['exports', 'ember-utils', 'ember-glimmer/tests/utils/abstract-test-case', 'ember-glimmer/tests/utils/test-case', 'ember-metal', 'ember-runtime', 'ember-glimmer/tests/utils/helpers'], function (exports, _emberUtils, _emberGlimmerTestsUtilsAbstractTestCase, _emberGlimmerTestsUtilsTestCase, _emberMetal, _emberRuntime, _emberGlimmerTestsUtilsHelpers) {
  'use strict';

  var _ObjectTestCases, _ArrayTestCases;

  var AbstractConditionalsTest = (function (_RenderingTest) {
    babelHelpers.inherits(AbstractConditionalsTest, _RenderingTest);

    function AbstractConditionalsTest() {
      _RenderingTest.apply(this, arguments);
    }

    AbstractConditionalsTest.prototype.wrapperFor = function wrapperFor(templates) {
      return templates.join('');
    };

    AbstractConditionalsTest.prototype.wrappedTemplateFor = function wrappedTemplateFor(options) {
      return this.wrapperFor([this.templateFor(options)]);
    };

    /* abstract */

    AbstractConditionalsTest.prototype.templateFor = function templateFor(_ref5) {
      var cond = _ref5.cond;
      var truthy = _ref5.truthy;
      var falsy = _ref5.falsy;

      // e.g. `{{#if ${cond}}}${truthy}{{else}}${falsy}{{/if}}`
      throw new Error('Not implemented: `templateFor`');
    };

    /* abstract */

    AbstractConditionalsTest.prototype.renderValues = function renderValues() {
      throw new Error('Not implemented: `renderValues`');
    };

    babelHelpers.createClass(AbstractConditionalsTest, [{
      key: 'truthyValue',
      get: function () {
        return true;
      }
    }, {
      key: 'falsyValue',
      get: function () {
        return false;
      }
    }]);
    return AbstractConditionalsTest;
  })(_emberGlimmerTestsUtilsTestCase.RenderingTest);

  var AbstractGenerator = (function () {
    function AbstractGenerator(cases) {
      this.cases = cases;
    }

    /*
      The test cases in this file generally follow the following pattern:
    
      1. Render with [ truthy, ...(other truthy variations), falsy, ...(other falsy variations) ]
      2. No-op rerender
      3. Make all of them falsy (through interior mutation)
      4. Make all of them truthy (through interior mutation, sometimes with some slight variations)
      5. Reset them to their original values (through replacement)
    */

    /* abstract */

    AbstractGenerator.prototype.generate = function generate(value, idx) {
      throw new Error('Not implemented: `generate`');
    };

    return AbstractGenerator;
  })();

  var TruthyGenerator = (function (_AbstractGenerator) {
    babelHelpers.inherits(TruthyGenerator, _AbstractGenerator);

    function TruthyGenerator() {
      _AbstractGenerator.apply(this, arguments);
    }

    TruthyGenerator.prototype.generate = function generate(value, idx) {
      var _ref;

      return _ref = {}, _ref['@test it should consider ' + JSON.stringify(value) + ' truthy [' + idx + ']'] = function () {
        var _this = this;

        this.renderValues(value);

        this.assertText('T1');

        this.runTask(function () {
          return _this.rerender();
        });

        this.assertText('T1');

        this.runTask(function () {
          return _emberMetal.set(_this.context, 'cond1', _this.falsyValue);
        });

        this.assertText('F1');

        this.runTask(function () {
          return _emberMetal.set(_this.context, 'cond1', value);
        });

        this.assertText('T1');
      }, _ref;
    };

    return TruthyGenerator;
  })(AbstractGenerator);

  exports.TruthyGenerator = TruthyGenerator;

  var FalsyGenerator = (function (_AbstractGenerator2) {
    babelHelpers.inherits(FalsyGenerator, _AbstractGenerator2);

    function FalsyGenerator() {
      _AbstractGenerator2.apply(this, arguments);
    }

    FalsyGenerator.prototype.generate = function generate(value, idx) {
      var _ref2;

      return _ref2 = {}, _ref2['@test it should consider ' + JSON.stringify(value) + ' falsy [' + idx + ']'] = function () {
        var _this2 = this;

        this.renderValues(value);

        this.assertText('F1');

        this.runTask(function () {
          return _this2.rerender();
        });

        this.assertText('F1');

        this.runTask(function () {
          return _emberMetal.set(_this2.context, 'cond1', _this2.truthyValue);
        });

        this.assertText('T1');

        this.runTask(function () {
          return _emberMetal.set(_this2.context, 'cond1', value);
        });

        this.assertText('F1');
      }, _ref2;
    };

    return FalsyGenerator;
  })(AbstractGenerator);

  exports.FalsyGenerator = FalsyGenerator;

  var StableTruthyGenerator = (function (_TruthyGenerator) {
    babelHelpers.inherits(StableTruthyGenerator, _TruthyGenerator);

    function StableTruthyGenerator() {
      _TruthyGenerator.apply(this, arguments);
    }

    StableTruthyGenerator.prototype.generate = function generate(value, idx) {
      var _assign;

      return _emberUtils.assign(_TruthyGenerator.prototype.generate.call(this, value, idx), (_assign = {}, _assign['@test it maintains DOM stability when condition changes from ' + value + ' to another truthy value and back [' + idx + ']'] = function () {
        var _this3 = this;

        this.renderValues(value);

        this.assertText('T1');

        this.takeSnapshot();

        this.runTask(function () {
          return _emberMetal.set(_this3.context, 'cond1', _this3.truthyValue);
        });

        this.assertText('T1');

        this.assertInvariants();

        this.runTask(function () {
          return _emberMetal.set(_this3.context, 'cond1', value);
        });

        this.assertText('T1');

        this.assertInvariants();
      }, _assign));
    };

    return StableTruthyGenerator;
  })(TruthyGenerator);

  exports.StableTruthyGenerator = StableTruthyGenerator;

  var StableFalsyGenerator = (function (_FalsyGenerator) {
    babelHelpers.inherits(StableFalsyGenerator, _FalsyGenerator);

    function StableFalsyGenerator() {
      _FalsyGenerator.apply(this, arguments);
    }

    StableFalsyGenerator.prototype.generate = function generate(value, idx) {
      var _assign2;

      return _emberUtils.assign(_FalsyGenerator.prototype.generate.call(this, value), (_assign2 = {}, _assign2['@test it maintains DOM stability when condition changes from ' + value + ' to another falsy value and back [' + idx + ']'] = function () {
        var _this4 = this;

        this.renderValues(value);

        this.assertText('F1');

        this.takeSnapshot();

        this.runTask(function () {
          return _emberMetal.set(_this4.context, 'cond1', _this4.falsyValue);
        });

        this.assertText('F1');

        this.assertInvariants();

        this.runTask(function () {
          return _emberMetal.set(_this4.context, 'cond1', value);
        });

        this.assertText('F1');

        this.assertInvariants();
      }, _assign2));
    };

    return StableFalsyGenerator;
  })(FalsyGenerator);

  exports.StableFalsyGenerator = StableFalsyGenerator;

  var ObjectProxyGenerator = (function (_AbstractGenerator3) {
    babelHelpers.inherits(ObjectProxyGenerator, _AbstractGenerator3);

    function ObjectProxyGenerator() {
      _AbstractGenerator3.apply(this, arguments);
    }

    // Testing behaviors shared across all conditionals, i.e. {{#if}}, {{#unless}},
    // {{#with}}, {{#each}}, {{#each-in}}, (if) and (unless)

    ObjectProxyGenerator.prototype.generate = function generate(value, idx) {
      // This is inconsistent with our usual to-bool policy, but the current proxy implementation
      // simply uses !!content to determine truthiness
      if (value) {
        var _ref3;

        return _ref3 = {}, _ref3['@test it should consider an object proxy with `' + JSON.stringify(value) + '` truthy [' + idx + ']'] = function () {
          var _this5 = this;

          this.renderValues(_emberRuntime.ObjectProxy.create({ content: value }));

          this.assertText('T1');

          this.runTask(function () {
            return _this5.rerender();
          });

          this.assertText('T1');

          this.runTask(function () {
            return _emberMetal.set(_this5.context, 'cond1.content', _this5.falsyValue);
          });

          this.assertText('F1');

          this.runTask(function () {
            return _emberMetal.set(_this5.context, 'cond1', _emberRuntime.ObjectProxy.create({ content: value }));
          });

          this.assertText('T1');
        }, _ref3;
      } else {
        var _ref4;

        return _ref4 = {}, _ref4['@test it should consider an object proxy with `' + JSON.stringify(value) + '` falsy [' + idx + ']'] = function () {
          var _this6 = this;

          this.renderValues(_emberRuntime.ObjectProxy.create({ content: value }));

          this.assertText('F1');

          this.runTask(function () {
            return _this6.rerender();
          });

          this.assertText('F1');

          this.runTask(function () {
            return _emberMetal.set(_this6.context, 'cond1.content', _this6.truthyValue);
          });

          this.assertText('T1');

          this.runTask(function () {
            return _emberMetal.set(_this6.context, 'cond1', _emberRuntime.ObjectProxy.create({ content: value }));
          });

          this.assertText('F1');
        }, _ref4;
      }
    };

    return ObjectProxyGenerator;
  })(AbstractGenerator);

  var BasicConditionalsTest = (function (_AbstractConditionalsTest) {
    babelHelpers.inherits(BasicConditionalsTest, _AbstractConditionalsTest);

    function BasicConditionalsTest() {
      _AbstractConditionalsTest.apply(this, arguments);
    }

    // Testing behaviors related to ember objects, object proxies, etc

    BasicConditionalsTest.prototype['@test it renders the corresponding block based on the conditional'] = function testItRendersTheCorrespondingBlockBasedOnTheConditional() {
      var _this7 = this;

      this.renderValues(this.truthyValue, this.falsyValue);

      this.assertText('T1F2');

      this.runTask(function () {
        return _this7.rerender();
      });

      this.assertText('T1F2');

      this.runTask(function () {
        return _emberMetal.set(_this7.context, 'cond1', _this7.falsyValue);
      });

      this.assertText('F1F2');

      this.runTask(function () {
        _emberMetal.set(_this7.context, 'cond1', _this7.truthyValue);
        _emberMetal.set(_this7.context, 'cond2', _this7.truthyValue);
      });

      this.assertText('T1T2');

      this.runTask(function () {
        _emberMetal.set(_this7.context, 'cond1', _this7.truthyValue);
        _emberMetal.set(_this7.context, 'cond2', _this7.falsyValue);
      });

      this.assertText('T1F2');
    };

    return BasicConditionalsTest;
  })(AbstractConditionalsTest);

  exports.BasicConditionalsTest = BasicConditionalsTest;
  var ObjectTestCases = (_ObjectTestCases = {}, _ObjectTestCases['@test it considers object proxies without content falsy'] = function () {
    var _this8 = this;

    this.renderValues(_emberRuntime.ObjectProxy.create({ content: {} }), _emberRuntime.ObjectProxy.create({ content: _emberRuntime.Object.create() }), _emberRuntime.ObjectProxy.create({ content: null }));

    this.assertText('T1T2F3');

    this.runTask(function () {
      return _this8.rerender();
    });

    this.assertText('T1T2F3');

    this.runTask(function () {
      _emberMetal.set(_this8.context, 'cond1.content', null);
      _emberMetal.set(_this8.context, 'cond2.content', null);
    });

    this.assertText('F1F2F3');

    this.runTask(function () {
      _emberMetal.set(_this8.context, 'cond1.content', _emberRuntime.Object.create());
      _emberMetal.set(_this8.context, 'cond2.content', {});
      _emberMetal.set(_this8.context, 'cond3.content', { foo: 'bar' });
    });

    this.assertText('T1T2T3');

    this.runTask(function () {
      _emberMetal.set(_this8.context, 'cond1', _emberRuntime.ObjectProxy.create({ content: {} }));
      _emberMetal.set(_this8.context, 'cond2', _emberRuntime.ObjectProxy.create({ content: _emberRuntime.Object.create() }));
      _emberMetal.set(_this8.context, 'cond3', _emberRuntime.ObjectProxy.create({ content: null }));
    });

    this.assertText('T1T2F3');
  }, _ObjectTestCases);

  exports.ObjectTestCases = ObjectTestCases;
  // Testing behaviors related to arrays and array proxies
  var ArrayTestCases = (_ArrayTestCases = {}, _ArrayTestCases['@test it considers empty arrays falsy'] = function () {
    var _this9 = this;

    this.renderValues(_emberRuntime.A(['hello']), _emberRuntime.A());

    this.assertText('T1F2');

    this.runTask(function () {
      return _this9.rerender();
    });

    this.assertText('T1F2');

    this.runTask(function () {
      return _emberRuntime.removeAt(_emberMetal.get(_this9.context, 'cond1'), 0);
    });

    this.assertText('F1F2');

    this.runTask(function () {
      _emberMetal.get(_this9.context, 'cond1').pushObject('hello');
      _emberMetal.get(_this9.context, 'cond2').pushObjects([1]);
    });

    this.assertText('T1T2');

    this.runTask(function () {
      _emberMetal.set(_this9.context, 'cond1', _emberRuntime.A(['hello']));
      _emberMetal.set(_this9.context, 'cond2', _emberRuntime.A());
    });

    this.assertText('T1F2');
  }, _ArrayTestCases['@test it considers array proxies without content falsy'] = function () {
    var _this10 = this;

    this.renderValues(_emberRuntime.ArrayProxy.create({ content: _emberRuntime.A(['hello']) }), _emberRuntime.ArrayProxy.create({ content: null }));

    this.assertText('T1F2');

    this.runTask(function () {
      return _this10.rerender();
    });

    this.assertText('T1F2');

    this.runTask(function () {
      _emberMetal.set(_this10.context, 'cond1.content', null);
      _emberMetal.set(_this10.context, 'cond2.content', null);
    });

    this.assertText('F1F2');

    this.runTask(function () {
      _emberMetal.set(_this10.context, 'cond1.content', _emberRuntime.A(['hello']));
      _emberMetal.set(_this10.context, 'cond2.content', _emberRuntime.A([1]));
    });

    this.assertText('T1T2');

    this.runTask(function () {
      _emberMetal.set(_this10.context, 'cond1', _emberRuntime.ArrayProxy.create({ content: _emberRuntime.A(['hello']) }));
      _emberMetal.set(_this10.context, 'cond2', _emberRuntime.ArrayProxy.create({ content: null }));
    });

    this.assertText('T1F2');
  }, _ArrayTestCases['@test it considers array proxies with empty arrays falsy'] = function () {
    var _this11 = this;

    this.renderValues(_emberRuntime.ArrayProxy.create({ content: _emberRuntime.A(['hello']) }), _emberRuntime.ArrayProxy.create({ content: _emberRuntime.A() }));

    this.assertText('T1F2');

    this.runTask(function () {
      return _this11.rerender();
    });

    this.assertText('T1F2');

    this.runTask(function () {
      return _emberRuntime.removeAt(_emberMetal.get(_this11.context, 'cond1.content'), 0);
    });

    this.assertText('F1F2');

    this.runTask(function () {
      _emberMetal.get(_this11.context, 'cond1.content').pushObject('hello');
      _emberMetal.get(_this11.context, 'cond2.content').pushObjects([1]);
    });

    this.assertText('T1T2');

    this.runTask(function () {
      _emberMetal.set(_this11.context, 'cond1', _emberRuntime.ArrayProxy.create({ content: _emberRuntime.A(['hello']) }));
      _emberMetal.set(_this11.context, 'cond2', _emberRuntime.ArrayProxy.create({ content: _emberRuntime.A() }));
    });

    this.assertText('T1F2');
  }, _ArrayTestCases);

  exports.ArrayTestCases = ArrayTestCases;
  var IfUnlessWithTestCases = [new StableTruthyGenerator([true, ' ', 'hello', 'false', 'null', 'undefined', 1, ['hello'], _emberRuntime.A(['hello']), {}, { foo: 'bar' }, _emberRuntime.Object.create(), _emberRuntime.Object.create({ foo: 'bar' }), _emberRuntime.ObjectProxy.create({ content: true }), Object, function () {},
  /*jshint -W053 */
  new String('hello'), new String(''), new Boolean(true), new Boolean(false),
  /*jshint +W053 */
  new Date()]), new StableFalsyGenerator([false, null, undefined, '', 0, [], _emberRuntime.A(), _emberRuntime.ObjectProxy.create({ content: undefined })]), new ObjectProxyGenerator([true, ' ', 'hello', 'false', 'null', 'undefined', 1, ['hello'], _emberRuntime.A(['hello']), _emberRuntime.ArrayProxy.create({ content: ['hello'] }), _emberRuntime.ArrayProxy.create({ content: [] }), {}, { foo: 'bar' }, _emberRuntime.Object.create(), _emberRuntime.Object.create({ foo: 'bar' }), _emberRuntime.ObjectProxy.create({ content: true }), _emberRuntime.ObjectProxy.create({ content: undefined }),
  /*jshint -W053 */
  new String('hello'), new String(''), new Boolean(true), new Boolean(false),
  /*jshint +W053 */
  new Date(), false, null, undefined, '', 0, [], _emberRuntime.A()]), ObjectTestCases, ArrayTestCases];

  // Testing behaviors shared across the "toggling" conditionals, i.e. {{#if}},
  // {{#unless}}, {{#with}}, {{#each}}, {{#each-in}}, (if) and (unless)

  var TogglingConditionalsTest = (function (_BasicConditionalsTest) {
    babelHelpers.inherits(TogglingConditionalsTest, _BasicConditionalsTest);

    function TogglingConditionalsTest() {
      _BasicConditionalsTest.apply(this, arguments);
    }

    // Testing behaviors shared across the (if) and (unless) helpers
    return TogglingConditionalsTest;
  })(BasicConditionalsTest);

  exports.TogglingConditionalsTest = TogglingConditionalsTest;

  var TogglingHelperConditionalsTest = (function (_TogglingConditionalsTest) {
    babelHelpers.inherits(TogglingHelperConditionalsTest, _TogglingConditionalsTest);

    function TogglingHelperConditionalsTest() {
      _TogglingConditionalsTest.apply(this, arguments);
    }

    TogglingHelperConditionalsTest.prototype.renderValues = function renderValues() {
      var templates = [];
      var context = {};

      for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {
        values[_key] = arguments[_key];
      }

      for (var i = 1; i <= values.length; i++) {
        templates.push(this.templateFor({ cond: 'cond' + i, truthy: 't' + i, falsy: 'f' + i }));
        context['t' + i] = 'T' + i;
        context['f' + i] = 'F' + i;
        context['cond' + i] = values[i - 1];
      }

      var wrappedTemplate = this.wrapperFor(templates);
      this.render(wrappedTemplate, context);
    };

    TogglingHelperConditionalsTest.prototype['@test it has access to the outer scope from both templates'] = function testItHasAccessToTheOuterScopeFromBothTemplates() {
      var _this12 = this;

      var template = this.wrapperFor([this.templateFor({ cond: 'cond1', truthy: 'truthy', falsy: 'falsy' }), this.templateFor({ cond: 'cond2', truthy: 'truthy', falsy: 'falsy' })]);

      this.render(template, { cond1: this.truthyValue, cond2: this.falsyValue, truthy: 'YES', falsy: 'NO' });

      this.assertText('YESNO');

      this.runTask(function () {
        return _this12.rerender();
      });

      this.assertText('YESNO');

      this.runTask(function () {
        _emberMetal.set(_this12.context, 'truthy', 'YASS');
        _emberMetal.set(_this12.context, 'falsy', 'NOPE');
      });

      this.assertText('YASSNOPE');

      this.runTask(function () {
        _emberMetal.set(_this12.context, 'cond1', _this12.falsyValue);
        _emberMetal.set(_this12.context, 'cond2', _this12.truthyValue);
      });

      this.assertText('NOPEYASS');

      this.runTask(function () {
        _emberMetal.set(_this12.context, 'truthy', 'YES');
        _emberMetal.set(_this12.context, 'falsy', 'NO');
        _emberMetal.set(_this12.context, 'cond1', _this12.truthyValue);
        _emberMetal.set(_this12.context, 'cond2', _this12.falsyValue);
      });

      this.assertText('YESNO');
    };

    TogglingHelperConditionalsTest.prototype['@test it does not update when the unbound helper is used'] = function testItDoesNotUpdateWhenTheUnboundHelperIsUsed() {
      var _this13 = this;

      var template = this.wrapperFor([this.templateFor({ cond: '(unbound cond1)', truthy: '"T1"', falsy: '"F1"' }), this.templateFor({ cond: '(unbound cond2)', truthy: '"T2"', falsy: '"F2"' })]);

      this.render(template, { cond1: this.truthyValue, cond2: this.falsyValue });

      this.assertText('T1F2');

      this.runTask(function () {
        return _this13.rerender();
      });

      this.assertText('T1F2');

      this.runTask(function () {
        return _emberMetal.set(_this13.context, 'cond1', _this13.falsyValue);
      });

      this.assertText('T1F2');

      this.runTask(function () {
        _emberMetal.set(_this13.context, 'cond1', _this13.truthyValue);
        _emberMetal.set(_this13.context, 'cond2', _this13.truthyValue);
      });

      this.assertText('T1F2');

      this.runTask(function () {
        _emberMetal.set(_this13.context, 'cond1', _this13.truthyValue);
        _emberMetal.set(_this13.context, 'cond2', _this13.falsyValue);
      });

      this.assertText('T1F2');
    };

    TogglingHelperConditionalsTest.prototype['@test evaluation should be lazy'] = function testEvaluationShouldBeLazy(assert) {
      var _this14 = this;

      var truthyEvaluated = undefined;
      var falsyEvaluated = undefined;

      var withoutEvaluatingTruthy = function (callback) {
        truthyEvaluated = false;
        callback();
        assert.ok(!truthyEvaluated, 'x-truthy is not evaluated');
      };

      var withoutEvaluatingFalsy = function (callback) {
        falsyEvaluated = false;
        callback();
        assert.ok(!falsyEvaluated, 'x-falsy is not evaluated');
      };

      this.registerHelper('x-truthy', {
        compute: function () {
          truthyEvaluated = true;
          return 'T';
        }
      });

      this.registerHelper('x-falsy', {
        compute: function () {
          falsyEvaluated = true;
          return 'F';
        }
      });

      var template = this.wrappedTemplateFor({ cond: 'cond', truthy: '(x-truthy)', falsy: '(x-falsy)' });

      withoutEvaluatingFalsy(function () {
        return _this14.render(template, { cond: _this14.truthyValue });
      });

      this.assertText('T');

      withoutEvaluatingFalsy(function () {
        return _this14.runTask(function () {
          return _this14.rerender();
        });
      });

      this.assertText('T');

      withoutEvaluatingTruthy(function () {
        return _this14.runTask(function () {
          return _emberMetal.set(_this14.context, 'cond', _this14.falsyValue);
        });
      });

      this.assertText('F');

      withoutEvaluatingTruthy(function () {
        return _this14.runTask(function () {
          return _this14.rerender();
        });
      });

      this.assertText('F');

      withoutEvaluatingFalsy(function () {
        return _this14.runTask(function () {
          return _emberMetal.set(_this14.context, 'cond', _this14.truthyValue);
        });
      });

      this.assertText('T');
    };

    return TogglingHelperConditionalsTest;
  })(TogglingConditionalsTest);

  exports.TogglingHelperConditionalsTest = TogglingHelperConditionalsTest;

  var IfUnlessHelperTest = (function (_TogglingHelperConditionalsTest) {
    babelHelpers.inherits(IfUnlessHelperTest, _TogglingHelperConditionalsTest);

    function IfUnlessHelperTest() {
      _TogglingHelperConditionalsTest.apply(this, arguments);
    }

    return IfUnlessHelperTest;
  })(TogglingHelperConditionalsTest);

  exports.IfUnlessHelperTest = IfUnlessHelperTest;

  _emberGlimmerTestsUtilsAbstractTestCase.applyMixins.apply(undefined, [IfUnlessHelperTest].concat(IfUnlessWithTestCases));

  // Testing behaviors shared across the "toggling" syntatical constructs,
  // i.e. {{#if}}, {{#unless}}, {{#with}}, {{#each}} and {{#each-in}}

  var TogglingSyntaxConditionalsTest = (function (_TogglingConditionalsTest2) {
    babelHelpers.inherits(TogglingSyntaxConditionalsTest, _TogglingConditionalsTest2);

    function TogglingSyntaxConditionalsTest() {
      _TogglingConditionalsTest2.apply(this, arguments);
    }

    TogglingSyntaxConditionalsTest.prototype.renderValues = function renderValues() {
      var templates = [];
      var context = {};

      for (var _len2 = arguments.length, values = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        values[_key2] = arguments[_key2];
      }

      for (var i = 1; i <= values.length; i++) {
        templates.push(this.templateFor({ cond: 'cond' + i, truthy: '{{t}}' + i, falsy: '{{f}}' + i }));
        context['cond' + i] = values[i - 1];
      }

      var wrappedTemplate = this.wrapperFor(templates);
      this.render(wrappedTemplate, _emberUtils.assign({ t: 'T', f: 'F' }, context));
    };

    TogglingSyntaxConditionalsTest.prototype['@test it does not update when the unbound helper is used'] = function testItDoesNotUpdateWhenTheUnboundHelperIsUsed() {
      var _this15 = this;

      var template = '' + this.templateFor({ cond: '(unbound cond1)', truthy: 'T1', falsy: 'F1' }) + this.templateFor({ cond: '(unbound cond2)', truthy: 'T2', falsy: 'F2' });

      this.render(template, { cond1: this.truthyValue, cond2: this.falsyValue });

      this.assertText('T1F2');

      this.runTask(function () {
        return _this15.rerender();
      });

      this.assertText('T1F2');

      this.runTask(function () {
        return _emberMetal.set(_this15.context, 'cond1', _this15.falsyValue);
      });

      this.assertText('T1F2');

      this.runTask(function () {
        _emberMetal.set(_this15.context, 'cond1', _this15.truthyValue);
        _emberMetal.set(_this15.context, 'cond2', _this15.truthyValue);
      });

      this.assertText('T1F2');

      this.runTask(function () {
        _emberMetal.set(_this15.context, 'cond1', _this15.truthyValue);
        _emberMetal.set(_this15.context, 'cond2', _this15.falsyValue);
      });

      this.assertText('T1F2');
    };

    TogglingSyntaxConditionalsTest.prototype['@test it has access to the outer scope from both templates'] = function testItHasAccessToTheOuterScopeFromBothTemplates() {
      var _this16 = this;

      var template = this.wrapperFor([this.templateFor({ cond: 'cond1', truthy: '{{truthy}}', falsy: '{{falsy}}' }), this.templateFor({ cond: 'cond2', truthy: '{{truthy}}', falsy: '{{falsy}}' })]);

      this.render(template, { cond1: this.truthyValue, cond2: this.falsyValue, truthy: 'YES', falsy: 'NO' });

      this.assertText('YESNO');

      this.runTask(function () {
        return _this16.rerender();
      });

      this.assertText('YESNO');

      this.runTask(function () {
        _emberMetal.set(_this16.context, 'truthy', 'YASS');
        _emberMetal.set(_this16.context, 'falsy', 'NOPE');
      });

      this.assertText('YASSNOPE');

      this.runTask(function () {
        _emberMetal.set(_this16.context, 'cond1', _this16.falsyValue);
        _emberMetal.set(_this16.context, 'cond2', _this16.truthyValue);
      });

      this.assertText('NOPEYASS');

      this.runTask(function () {
        _emberMetal.set(_this16.context, 'truthy', 'YES');
        _emberMetal.set(_this16.context, 'falsy', 'NO');
        _emberMetal.set(_this16.context, 'cond1', _this16.truthyValue);
        _emberMetal.set(_this16.context, 'cond2', _this16.falsyValue);
      });

      this.assertText('YESNO');
    };

    TogglingSyntaxConditionalsTest.prototype['@test it updates correctly when enclosing another conditional'] = function testItUpdatesCorrectlyWhenEnclosingAnotherConditional() {
      var _this17 = this;

      // This tests whether the outer conditional tracks its bounds correctly as its inner bounds changes
      var inner = this.templateFor({ cond: 'inner', truthy: 'T-inner', falsy: 'F-inner' });
      var template = this.wrappedTemplateFor({ cond: 'outer', truthy: inner, falsy: 'F-outer' });

      this.render(template, { outer: this.truthyValue, inner: this.truthyValue });

      this.assertText('T-inner');

      this.runTask(function () {
        return _this17.rerender();
      });

      this.assertText('T-inner');

      // Changes the inner bounds
      this.runTask(function () {
        return _emberMetal.set(_this17.context, 'inner', _this17.falsyValue);
      });

      this.assertText('F-inner');

      // Now rerender the outer conditional, which require first clearing its bounds
      this.runTask(function () {
        return _emberMetal.set(_this17.context, 'outer', _this17.falsyValue);
      });

      this.assertText('F-outer');
    };

    TogglingSyntaxConditionalsTest.prototype['@test it updates correctly when enclosing #each'] = function testItUpdatesCorrectlyWhenEnclosingEach() {
      var _this18 = this;

      // This tests whether the outer conditional tracks its bounds correctly as its inner bounds changes
      var template = this.wrappedTemplateFor({ cond: 'outer', truthy: '{{#each inner as |text|}}{{text}}{{/each}}', falsy: 'F-outer' });

      this.render(template, { outer: this.truthyValue, inner: ['inner', '-', 'before'] });

      this.assertText('inner-before');

      this.runTask(function () {
        return _this18.rerender();
      });

      this.assertText('inner-before');

      // Changes the inner bounds
      this.runTask(function () {
        return _emberMetal.set(_this18.context, 'inner', ['inner-after']);
      });

      this.assertText('inner-after');

      // Now rerender the outer conditional, which require first clearing its bounds
      this.runTask(function () {
        return _emberMetal.set(_this18.context, 'outer', _this18.falsyValue);
      });

      this.assertText('F-outer');

      // Reset
      this.runTask(function () {
        _emberMetal.set(_this18.context, 'inner', ['inner-again']);
        _emberMetal.set(_this18.context, 'outer', _this18.truthyValue);
      });

      this.assertText('inner-again');

      // Now clear the inner bounds
      this.runTask(function () {
        return _emberMetal.set(_this18.context, 'inner', []);
      });

      this.assertText('');

      // Now rerender the outer conditional, which require first clearing its bounds
      this.runTask(function () {
        return _emberMetal.set(_this18.context, 'outer', _this18.falsyValue);
      });

      this.assertText('F-outer');
    };

    TogglingSyntaxConditionalsTest.prototype['@test it updates correctly when enclosing triple-curlies'] = function testItUpdatesCorrectlyWhenEnclosingTripleCurlies() {
      var _this19 = this;

      // This tests whether the outer conditional tracks its bounds correctly as its inner bounds changes
      var template = this.wrappedTemplateFor({ cond: 'outer', truthy: '{{{inner}}}', falsy: 'F-outer' });

      this.render(template, { outer: this.truthyValue, inner: '<b>inner</b>-<b>before</b>' });

      this.assertText('inner-before');

      this.runTask(function () {
        return _this19.rerender();
      });

      this.assertText('inner-before');

      // Changes the inner bounds
      this.runTask(function () {
        return _emberMetal.set(_this19.context, 'inner', '<p>inner-after</p>');
      });

      this.assertText('inner-after');

      // Now rerender the outer conditional, which require first clearing its bounds
      this.runTask(function () {
        return _emberMetal.set(_this19.context, 'outer', _this19.falsyValue);
      });

      this.assertText('F-outer');
    };

    TogglingSyntaxConditionalsTest.prototype['@test child conditional should not render children if parent conditional becomes false'] = function testChildConditionalShouldNotRenderChildrenIfParentConditionalBecomesFalse(assert) {
      var _this20 = this;

      var childCreated = false;

      this.registerComponent('foo-bar', {
        template: 'foo-bar',
        ComponentClass: _emberGlimmerTestsUtilsHelpers.Component.extend({
          init: function () {
            this._super.apply(this, arguments);
            childCreated = true;
          }
        })
      });

      var innerTemplate = this.templateFor({ cond: 'cond2', truthy: '{{foo-bar}}', falsy: '' });
      var wrappedTemplate = this.wrappedTemplateFor({ cond: 'cond1', truthy: innerTemplate, falsy: '' });

      this.render(wrappedTemplate, { cond1: this.truthyValue, cond2: this.falsyValue });

      assert.ok(!childCreated);
      this.assertText('');

      this.runTask(function () {
        return _this20.rerender();
      });

      assert.ok(!childCreated);
      this.assertText('');

      this.runTask(function () {
        _emberMetal.set(_this20.context, 'cond2', _this20.truthyValue);
        _emberMetal.set(_this20.context, 'cond1', _this20.falsyValue);
      });

      assert.ok(!childCreated);
      this.assertText('');

      this.runTask(function () {
        _emberMetal.set(_this20.context, 'cond2', _this20.falsyValue);
        _emberMetal.set(_this20.context, 'cond1', _this20.truthyValue);
      });

      assert.ok(!childCreated);
      this.assertText('');
    };

    TogglingSyntaxConditionalsTest.prototype['@test evaluation should be lazy'] = function testEvaluationShouldBeLazy(assert) {
      var _this21 = this;

      var truthyEvaluated = undefined;
      var falsyEvaluated = undefined;

      var withoutEvaluatingTruthy = function (callback) {
        truthyEvaluated = false;
        callback();
        assert.ok(!truthyEvaluated, 'x-truthy is not evaluated');
      };

      var withoutEvaluatingFalsy = function (callback) {
        falsyEvaluated = false;
        callback();
        assert.ok(!falsyEvaluated, 'x-falsy is not evaluated');
      };

      this.registerHelper('x-truthy', {
        compute: function () {
          truthyEvaluated = true;
          return 'T';
        }
      });

      this.registerHelper('x-falsy', {
        compute: function () {
          falsyEvaluated = true;
          return 'F';
        }
      });

      var template = this.wrappedTemplateFor({ cond: 'cond', truthy: '{{x-truthy}}', falsy: '{{x-falsy}}' });

      withoutEvaluatingFalsy(function () {
        return _this21.render(template, { cond: _this21.truthyValue });
      });

      this.assertText('T');

      withoutEvaluatingFalsy(function () {
        return _this21.runTask(function () {
          return _this21.rerender();
        });
      });

      this.assertText('T');

      withoutEvaluatingTruthy(function () {
        return _this21.runTask(function () {
          return _emberMetal.set(_this21.context, 'cond', _this21.falsyValue);
        });
      });

      this.assertText('F');

      withoutEvaluatingTruthy(function () {
        return _this21.runTask(function () {
          return _this21.rerender();
        });
      });

      this.assertText('F');

      withoutEvaluatingFalsy(function () {
        return _this21.runTask(function () {
          return _emberMetal.set(_this21.context, 'cond', _this21.truthyValue);
        });
      });

      this.assertText('T');
    };

    return TogglingSyntaxConditionalsTest;
  })(TogglingConditionalsTest);

  exports.TogglingSyntaxConditionalsTest = TogglingSyntaxConditionalsTest;

  var IfUnlessWithSyntaxTest = (function (_TogglingSyntaxConditionalsTest) {
    babelHelpers.inherits(IfUnlessWithSyntaxTest, _TogglingSyntaxConditionalsTest);

    function IfUnlessWithSyntaxTest() {
      _TogglingSyntaxConditionalsTest.apply(this, arguments);
    }

    return IfUnlessWithSyntaxTest;
  })(TogglingSyntaxConditionalsTest);

  exports.IfUnlessWithSyntaxTest = IfUnlessWithSyntaxTest;

  _emberGlimmerTestsUtilsAbstractTestCase.applyMixins.apply(undefined, [IfUnlessWithSyntaxTest].concat(IfUnlessWithTestCases));
});
enifed('ember-glimmer/tests/utils/shared-conditional-tests.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/utils/shared-conditional-tests.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/utils/shared-conditional-tests.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/utils/string-test', ['exports', 'ember-glimmer/tests/utils/helpers', 'ember-glimmer/tests/utils/abstract-test-case', 'ember-glimmer/tests/utils/test-case'], function (exports, _emberGlimmerTestsUtilsHelpers, _emberGlimmerTestsUtilsAbstractTestCase, _emberGlimmerTestsUtilsTestCase) {
  'use strict';

  _emberGlimmerTestsUtilsTestCase.moduleFor('SafeString', (function (_TestCase) {
    babelHelpers.inherits(_class, _TestCase);

    function _class() {
      _TestCase.apply(this, arguments);
    }

    _class.prototype['@test htmlSafe should return an instance of SafeString'] = function testHtmlSafeShouldReturnAnInstanceOfSafeString() {
      var safeString = _emberGlimmerTestsUtilsHelpers.htmlSafe('you need to be more <b>bold</b>');

      this.assert.ok(safeString instanceof _emberGlimmerTestsUtilsHelpers.SafeString, 'should be a SafeString');
    };

    _class.prototype['@test htmlSafe should return an empty string for null'] = function testHtmlSafeShouldReturnAnEmptyStringForNull() {
      var safeString = _emberGlimmerTestsUtilsHelpers.htmlSafe(null);

      this.assert.equal(safeString instanceof _emberGlimmerTestsUtilsHelpers.SafeString, true, 'should be a SafeString');
      this.assert.equal(safeString.toString(), '', 'should return an empty string');
    };

    _class.prototype['@test htmlSafe should return an instance of SafeString'] = function testHtmlSafeShouldReturnAnInstanceOfSafeString() {
      var safeString = _emberGlimmerTestsUtilsHelpers.htmlSafe();

      this.assert.equal(safeString instanceof _emberGlimmerTestsUtilsHelpers.SafeString, true, 'should be a SafeString');
      this.assert.equal(safeString.toString(), '', 'should return an empty string');
    };

    return _class;
  })(_emberGlimmerTestsUtilsAbstractTestCase.TestCase));

  _emberGlimmerTestsUtilsTestCase.moduleFor('SafeString isHTMLSafe', (function (_TestCase2) {
    babelHelpers.inherits(_class2, _TestCase2);

    function _class2() {
      _TestCase2.apply(this, arguments);
    }

    _class2.prototype['@test isHTMLSafe should detect SafeString'] = function testIsHTMLSafeShouldDetectSafeString() {
      var safeString = _emberGlimmerTestsUtilsHelpers.htmlSafe('<em>Emphasize</em> the important things.');

      this.assert.ok(_emberGlimmerTestsUtilsHelpers.isHTMLSafe(safeString));
    };

    _class2.prototype['@test isHTMLSafe should not detect SafeString on primatives'] = function testIsHTMLSafeShouldNotDetectSafeStringOnPrimatives() {
      this.assert.notOk(_emberGlimmerTestsUtilsHelpers.isHTMLSafe('Hello World'));
      this.assert.notOk(_emberGlimmerTestsUtilsHelpers.isHTMLSafe({}));
      this.assert.notOk(_emberGlimmerTestsUtilsHelpers.isHTMLSafe([]));
      this.assert.notOk(_emberGlimmerTestsUtilsHelpers.isHTMLSafe(10));
      this.assert.notOk(_emberGlimmerTestsUtilsHelpers.isHTMLSafe(null));
    };

    return _class2;
  })(_emberGlimmerTestsUtilsAbstractTestCase.TestCase));
});
enifed('ember-glimmer/tests/utils/string-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/utils/string-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/utils/string-test.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/utils/test-case', ['exports', 'internal-test-helpers'], function (exports, _internalTestHelpers) {
  'use strict';

  exports.TestCase = _internalTestHelpers.AbstractTestCase;
  exports.ApplicationTest = _internalTestHelpers.ApplicationTestCase;
  exports.RenderingTest = _internalTestHelpers.RenderingTestCase;
  exports.moduleFor = _internalTestHelpers.moduleFor;
});
enifed('ember-glimmer/tests/utils/test-case.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/utils/test-case.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/utils/test-case.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/tests/utils/test-helpers', ['exports', 'internal-test-helpers'], function (exports, _internalTestHelpers) {
  'use strict';

  exports.styles = _internalTestHelpers.styles;
  exports.classes = _internalTestHelpers.classes;
  exports.equalTokens = _internalTestHelpers.equalTokens;
  exports.equalsElement = _internalTestHelpers.equalsElement;
});
enifed('ember-glimmer/tests/utils/test-helpers.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/tests/utils/test-helpers.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/tests/utils/test-helpers.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/utils/bindings.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/utils/bindings.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/utils/bindings.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/utils/debug-stack.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/utils/debug-stack.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/utils/debug-stack.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/utils/iterable.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/utils/iterable.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/utils/iterable.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/utils/process-args.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/utils/process-args.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/utils/process-args.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/utils/references.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/utils/references.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/utils/references.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/utils/string.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/utils/string.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/utils/string.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/utils/to-bool.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/utils/to-bool.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/utils/to-bool.js should pass ESLint\n\n');
  });
});
enifed('ember-glimmer/views/outlet.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-glimmer/views/outlet.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-glimmer/views/outlet.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/alias.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/alias.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/alias.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/binding.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/binding.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/binding.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/cache.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/cache.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/cache.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/chains.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/chains.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/chains.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/computed.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/computed.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/computed.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/core.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/core.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/core.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/debug.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/debug.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/debug.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/dependent_keys.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/dependent_keys.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/dependent_keys.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/deprecate_property.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/deprecate_property.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/deprecate_property.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/descriptor.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/descriptor.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/descriptor.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/error.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/error.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/error.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/error_handler.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/error_handler.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/error_handler.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/events.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/events.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/events.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/expand_properties.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/expand_properties.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/expand_properties.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/features.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/features.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/features.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/get_properties.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/get_properties.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/get_properties.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/index.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/index.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/index.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/injected_property.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/injected_property.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/injected_property.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/instrumentation.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/instrumentation.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/instrumentation.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/is_blank.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/is_blank.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/is_blank.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/is_empty.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/is_empty.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/is_empty.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/is_none.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/is_none.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/is_none.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/is_present.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/is_present.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/is_present.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/is_proxy.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/is_proxy.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/is_proxy.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/libraries.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/libraries.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/libraries.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/map.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/map.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/map.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/merge.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/merge.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/merge.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/meta.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/meta.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/meta.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/meta_listeners.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/meta_listeners.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/meta_listeners.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/mixin.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/mixin.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/mixin.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/observer.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/observer.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/observer.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/observer_set.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/observer_set.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/observer_set.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/path_cache.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/path_cache.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/path_cache.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/properties.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/properties.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/properties.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/property_events.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/property_events.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/property_events.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/property_get.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/property_get.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/property_get.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/property_set.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/property_set.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/property_set.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/replace.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/replace.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/replace.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/run_loop.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/run_loop.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/run_loop.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/set_properties.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/set_properties.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/set_properties.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tags.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tags.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tags.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/testing.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/testing.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/testing.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/accessors/get_path_test', ['exports', 'ember-metal/property_get'], function (exports, _emberMetalProperty_get) {
  'use strict';

  var obj = undefined;
  var moduleOpts = {
    setup: function () {
      obj = {
        foo: {
          bar: {
            baz: { biff: 'BIFF' }
          }
        },
        foothis: {
          bar: {
            baz: { biff: 'BIFF' }
          }
        },
        falseValue: false,
        emptyString: '',
        Wuz: {
          nar: 'foo'
        },
        nullValue: null
      };
    },

    teardown: function () {
      obj = undefined;
    }
  };

  QUnit.module('Ember.get with path', moduleOpts);

  // ..........................................................
  // LOCAL PATHS
  //

  QUnit.test('[obj, foo] -> obj.foo', function () {
    deepEqual(_emberMetalProperty_get.get(obj, 'foo'), obj.foo);
  });

  QUnit.test('[obj, foo.bar] -> obj.foo.bar', function () {
    deepEqual(_emberMetalProperty_get.get(obj, 'foo.bar'), obj.foo.bar);
  });

  QUnit.test('[obj, foothis.bar] -> obj.foothis.bar', function () {
    deepEqual(_emberMetalProperty_get.get(obj, 'foothis.bar'), obj.foothis.bar);
  });

  QUnit.test('[obj, falseValue.notDefined] -> (undefined)', function () {
    strictEqual(_emberMetalProperty_get.get(obj, 'falseValue.notDefined'), undefined);
  });

  QUnit.test('[obj, emptyString.length] -> 0', function () {
    strictEqual(_emberMetalProperty_get.get(obj, 'emptyString.length'), 0);
  });

  QUnit.test('[obj, nullValue.notDefined] -> (undefined)', function () {
    strictEqual(_emberMetalProperty_get.get(obj, 'nullValue.notDefined'), undefined);
  });

  // ..........................................................
  // GLOBAL PATHS TREATED LOCAL WITH GET
  //

  QUnit.test('[obj, Wuz] -> obj.Wuz', function () {
    deepEqual(_emberMetalProperty_get.get(obj, 'Wuz'), obj.Wuz);
  });

  QUnit.test('[obj, Wuz.nar] -> obj.Wuz.nar', function () {
    deepEqual(_emberMetalProperty_get.get(obj, 'Wuz.nar'), obj.Wuz.nar);
  });

  QUnit.test('[obj, Foo] -> (undefined)', function () {
    strictEqual(_emberMetalProperty_get.get(obj, 'Foo'), undefined);
  });

  QUnit.test('[obj, Foo.bar] -> (undefined)', function () {
    strictEqual(_emberMetalProperty_get.get(obj, 'Foo.bar'), undefined);
  });
});
enifed('ember-metal/tests/accessors/get_path_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/accessors/get_path_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/accessors/get_path_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/accessors/get_properties_test', ['exports', 'ember-metal/get_properties'], function (exports, _emberMetalGet_properties) {
  'use strict';

  QUnit.module('Ember.getProperties');

  QUnit.test('can retrieve a hash of properties from an object via an argument list or array of property names', function () {
    var obj = {
      firstName: 'Steve',
      lastName: 'Jobs',
      companyName: 'Apple, Inc.'
    };

    deepEqual(_emberMetalGet_properties.default(obj, 'firstName', 'lastName'), { firstName: 'Steve', lastName: 'Jobs' });
    deepEqual(_emberMetalGet_properties.default(obj, 'firstName', 'lastName'), { firstName: 'Steve', lastName: 'Jobs' });
    deepEqual(_emberMetalGet_properties.default(obj, 'lastName'), { lastName: 'Jobs' });
    deepEqual(_emberMetalGet_properties.default(obj), {});
    deepEqual(_emberMetalGet_properties.default(obj, ['firstName', 'lastName']), { firstName: 'Steve', lastName: 'Jobs' });
    deepEqual(_emberMetalGet_properties.default(obj, ['firstName']), { firstName: 'Steve' });
    deepEqual(_emberMetalGet_properties.default(obj, []), {});
  });
});
enifed('ember-metal/tests/accessors/get_properties_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/accessors/get_properties_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/accessors/get_properties_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/accessors/get_test', ['exports', 'internal-test-helpers', 'ember-metal/property_get', 'ember-metal/mixin', 'ember-metal/observer'], function (exports, _internalTestHelpers, _emberMetalProperty_get, _emberMetalMixin, _emberMetalObserver) {
  'use strict';

  QUnit.module('Ember.get');

  QUnit.test('should get arbitrary properties on an object', function () {
    var obj = {
      string: 'string',
      number: 23,
      boolTrue: true,
      boolFalse: false,
      nullValue: null
    };

    for (var key in obj) {
      if (!obj.hasOwnProperty(key)) {
        continue;
      }
      equal(_emberMetalProperty_get.get(obj, key), obj[key], key);
    }
  });

  QUnit.test('should not access a property more than once', function () {
    var count = 0;
    var obj = {
      get id() {
        return ++count;
      }
    };

    _emberMetalProperty_get.get(obj, 'id');

    equal(count, 1);
  });

  _internalTestHelpers.testBoth('should call unknownProperty on watched values if the value is undefined', function (get, set) {
    var obj = {
      count: 0,
      unknownProperty: function (key) {
        equal(key, 'foo', 'should pass key');
        this.count++;
        return 'FOO';
      }
    };

    var count = 0;
    _emberMetalObserver.addObserver(obj, 'foo', function () {
      count++;
    });

    equal(get(obj, 'foo'), 'FOO', 'should return value from unknown');
  });

  QUnit.test('warn on attemps to call get with no arguments', function () {
    expectAssertion(function () {
      _emberMetalProperty_get.get('aProperty');
    }, /Get must be called with two arguments;/i);
  });

  QUnit.test('warn on attemps to call get with only one argument', function () {
    expectAssertion(function () {
      _emberMetalProperty_get.get('aProperty');
    }, /Get must be called with two arguments;/i);
  });

  QUnit.test('warn on attemps to call get with more then two arguments', function () {
    expectAssertion(function () {
      _emberMetalProperty_get.get({}, 'aProperty', true);
    }, /Get must be called with two arguments;/i);
  });

  QUnit.test('warn on attempts to get a property of undefined', function () {
    expectAssertion(function () {
      _emberMetalProperty_get.get(undefined, 'aProperty');
    }, /Cannot call get with 'aProperty' on an undefined object/i);
  });

  QUnit.test('warn on attempts to get a property path of undefined', function () {
    expectAssertion(function () {
      _emberMetalProperty_get.get(undefined, 'aProperty.on.aPath');
    }, /Cannot call get with 'aProperty.on.aPath' on an undefined object/);
  });

  QUnit.test('warn on attempts to get a property of null', function () {
    expectAssertion(function () {
      _emberMetalProperty_get.get(null, 'aProperty');
    }, /Cannot call get with 'aProperty' on an undefined object/);
  });

  QUnit.test('warn on attempts to get a property path of null', function () {
    expectAssertion(function () {
      _emberMetalProperty_get.get(null, 'aProperty.on.aPath');
    }, /Cannot call get with 'aProperty.on.aPath' on an undefined object/);
  });

  QUnit.test('warn on attempts to use get with an unsupported property path', function () {
    var obj = {};
    expectAssertion(function () {
      return _emberMetalProperty_get.get(obj, null);
    }, /The key provided to get must be a string, you passed null/);
    expectAssertion(function () {
      return _emberMetalProperty_get.get(obj, NaN);
    }, /The key provided to get must be a string, you passed NaN/);
    expectAssertion(function () {
      return _emberMetalProperty_get.get(obj, undefined);
    }, /The key provided to get must be a string, you passed undefined/);
    expectAssertion(function () {
      return _emberMetalProperty_get.get(obj, false);
    }, /The key provided to get must be a string, you passed false/);
    expectAssertion(function () {
      return _emberMetalProperty_get.get(obj, 42);
    }, /The key provided to get must be a string, you passed 42/);
    expectAssertion(function () {
      return _emberMetalProperty_get.get(obj, '');
    }, /Cannot call `Ember.get` with an empty string/);
  });

  // ..........................................................
  // BUGS
  //

  QUnit.test('(regression) watched properties on unmodified inherited objects should still return their original value', function () {
    var MyMixin = _emberMetalMixin.Mixin.create({
      someProperty: 'foo',
      propertyDidChange: _emberMetalMixin.observer('someProperty', function () {})
    });

    var baseObject = MyMixin.apply({});
    var theRealObject = Object.create(baseObject);

    equal(_emberMetalProperty_get.get(theRealObject, 'someProperty'), 'foo', 'should return the set value, not false');
  });

  QUnit.module('Ember.getWithDefault');

  QUnit.test('should get arbitrary properties on an object', function () {
    var obj = {
      string: 'string',
      number: 23,
      boolTrue: true,
      boolFalse: false,
      nullValue: null
    };

    for (var key in obj) {
      if (!obj.hasOwnProperty(key)) {
        continue;
      }
      equal(_emberMetalProperty_get.getWithDefault(obj, key, 'fail'), obj[key], key);
    }

    obj = {
      undef: undefined
    };

    equal(_emberMetalProperty_get.getWithDefault(obj, 'undef', 'default'), 'default', 'explicit undefined retrieves the default');
    equal(_emberMetalProperty_get.getWithDefault(obj, 'not-present', 'default'), 'default', 'non-present key retrieves the default');
  });

  QUnit.test('should call unknownProperty if defined and value is undefined', function () {
    var obj = {
      count: 0,
      unknownProperty: function (key) {
        equal(key, 'foo', 'should pass key');
        this.count++;
        return 'FOO';
      }
    };

    equal(_emberMetalProperty_get.get(obj, 'foo'), 'FOO', 'should return value from unknown');
    equal(obj.count, 1, 'should have invoked');
  });

  _internalTestHelpers.testBoth('if unknownProperty is present, it is called', function (get, set) {
    var obj = {
      count: 0,
      unknownProperty: function (key) {
        if (key === 'foo') {
          equal(key, 'foo', 'should pass key');
          this.count++;
          return 'FOO';
        }
      }
    };

    var count = 0;
    _emberMetalObserver.addObserver(obj, 'foo', function () {
      return count++;
    });

    equal(_emberMetalProperty_get.getWithDefault(obj, 'foo', 'fail'), 'FOO', 'should return value from unknownProperty');
    equal(_emberMetalProperty_get.getWithDefault(obj, 'bar', 'default'), 'default', 'should convert undefined from unknownProperty into default');
  });

  // ..........................................................
  // BUGS
  //

  QUnit.test('(regression) watched properties on unmodified inherited objects should still return their original value', function () {
    var MyMixin = _emberMetalMixin.Mixin.create({
      someProperty: 'foo',
      propertyDidChange: _emberMetalMixin.observer('someProperty', function () {/* nothing to do */})
    });

    var baseObject = MyMixin.apply({});
    var theRealObject = Object.create(baseObject);

    equal(_emberMetalProperty_get.getWithDefault(theRealObject, 'someProperty', 'fail'), 'foo', 'should return the set value, not false');
  });
});
enifed('ember-metal/tests/accessors/get_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/accessors/get_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/accessors/get_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/accessors/is_global_path_test', ['exports', 'ember-metal/path_cache'], function (exports, _emberMetalPath_cache) {
  'use strict';

  QUnit.module('Ember.isGlobalPath');

  QUnit.test('global path\'s are recognized', function () {
    ok(_emberMetalPath_cache.isGlobalPath('App.myProperty'));
    ok(_emberMetalPath_cache.isGlobalPath('App.myProperty.subProperty'));
  });

  QUnit.test('if there is a \'this\' in the path, it\'s not a global path', function () {
    ok(!_emberMetalPath_cache.isGlobalPath('this.myProperty'));
    ok(!_emberMetalPath_cache.isGlobalPath('this'));
  });

  QUnit.test('if the path starts with a lowercase character, it is not a global path', function () {
    ok(!_emberMetalPath_cache.isGlobalPath('myObj'));
    ok(!_emberMetalPath_cache.isGlobalPath('myObj.SecondProperty'));
  });
});
enifed('ember-metal/tests/accessors/is_global_path_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/accessors/is_global_path_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/accessors/is_global_path_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/accessors/mandatory_setters_test', ['exports', 'ember-metal/features', 'ember-metal/property_get', 'ember-metal/property_set', 'ember-metal/watching', 'ember-metal/meta'], function (exports, _emberMetalFeatures, _emberMetalProperty_get, _emberMetalProperty_set, _emberMetalWatching, _emberMetalMeta) {
  'use strict';

  QUnit.module('mandatory-setters');

  function hasMandatorySetter(object, property) {
    try {
      return Object.getOwnPropertyDescriptor(object, property).set.isMandatorySetter === true;
    } catch (e) {
      return false;
    }
  }

  function hasMetaValue(object, property) {
    return _emberMetalMeta.meta(object).hasInValues(property);
  }

  if (false) {
    QUnit.test('does not assert if property is not being watched', function () {
      var obj = {
        someProp: null,
        toString: function () {
          return 'custom-object';
        }
      };

      obj.someProp = 'blastix';
      equal(_emberMetalProperty_get.get(obj, 'someProp'), 'blastix');
    });

    QUnit.test('should not setup mandatory-setter if property is not writable', function () {
      expect(6);

      var obj = {};

      Object.defineProperty(obj, 'a', { value: true });
      Object.defineProperty(obj, 'b', { value: false });
      Object.defineProperty(obj, 'c', { value: undefined });
      Object.defineProperty(obj, 'd', { value: undefined, writable: false });
      Object.defineProperty(obj, 'e', { value: undefined, configurable: false });
      Object.defineProperty(obj, 'f', { value: undefined, configurable: true });

      _emberMetalWatching.watch(obj, 'a');
      _emberMetalWatching.watch(obj, 'b');
      _emberMetalWatching.watch(obj, 'c');
      _emberMetalWatching.watch(obj, 'd');
      _emberMetalWatching.watch(obj, 'e');
      _emberMetalWatching.watch(obj, 'f');

      ok(!hasMandatorySetter(obj, 'a'), 'mandatory-setter should not be installed');
      ok(!hasMandatorySetter(obj, 'b'), 'mandatory-setter should not be installed');
      ok(!hasMandatorySetter(obj, 'c'), 'mandatory-setter should not be installed');
      ok(!hasMandatorySetter(obj, 'd'), 'mandatory-setter should not be installed');
      ok(!hasMandatorySetter(obj, 'e'), 'mandatory-setter should not be installed');
      ok(!hasMandatorySetter(obj, 'f'), 'mandatory-setter should not be installed');
    });

    QUnit.test('should not teardown non mandatory-setter descriptor', function () {
      expect(1);

      var obj = { get a() {
          return 'hi';
        } };

      _emberMetalWatching.watch(obj, 'a');
      _emberMetalWatching.unwatch(obj, 'a');

      equal(obj.a, 'hi');
    });

    QUnit.test('should not confuse non descriptor watched gets', function () {
      expect(2);

      var obj = { get a() {
          return 'hi';
        } };

      _emberMetalWatching.watch(obj, 'a');
      equal(_emberMetalProperty_get.get(obj, 'a'), 'hi');
      equal(obj.a, 'hi');
    });

    QUnit.test('should not setup mandatory-setter if setter is already setup on property', function () {
      expect(2);

      var obj = { someProp: null };

      Object.defineProperty(obj, 'someProp', {
        get: function () {
          return null;
        },

        set: function (value) {
          equal(value, 'foo-bar', 'custom setter was called');
        }
      });

      _emberMetalWatching.watch(obj, 'someProp');
      ok(!hasMandatorySetter(obj, 'someProp'), 'mandatory-setter should not be installed');

      obj.someProp = 'foo-bar';
    });

    QUnit.test('watched ES5 setter should not be smashed by mandatory setter', function () {
      var value = undefined;
      var obj = {
        get foo() {},
        set foo(_value) {
          value = _value;
        }
      };

      _emberMetalWatching.watch(obj, 'foo');

      _emberMetalProperty_set.set(obj, 'foo', 2);
      equal(value, 2);
    });

    QUnit.test('should not setup mandatory-setter if setter is already setup on property in parent prototype', function () {
      expect(2);

      function Foo() {}

      Object.defineProperty(Foo.prototype, 'someProp', {
        get: function () {
          return null;
        },

        set: function (value) {
          equal(value, 'foo-bar', 'custom setter was called');
        }
      });

      var obj = new Foo();

      _emberMetalWatching.watch(obj, 'someProp');
      ok(!hasMandatorySetter(obj, 'someProp'), 'mandatory-setter should not be installed');

      obj.someProp = 'foo-bar';
    });

    QUnit.test('should not setup mandatory-setter if setter is already setup on property in grandparent prototype', function () {
      expect(2);

      function Foo() {}

      Object.defineProperty(Foo.prototype, 'someProp', {
        get: function () {
          return null;
        },

        set: function (value) {
          equal(value, 'foo-bar', 'custom setter was called');
        }
      });

      function Bar() {}
      Bar.prototype = Object.create(Foo.prototype);
      Bar.prototype.constructor = Bar;

      var obj = new Bar();

      _emberMetalWatching.watch(obj, 'someProp');
      ok(!hasMandatorySetter(obj, 'someProp'), 'mandatory-setter should not be installed');

      obj.someProp = 'foo-bar';
    });

    QUnit.test('should not setup mandatory-setter if setter is already setup on property in great grandparent prototype', function () {
      expect(2);

      function Foo() {}

      Object.defineProperty(Foo.prototype, 'someProp', {
        get: function () {
          return null;
        },

        set: function (value) {
          equal(value, 'foo-bar', 'custom setter was called');
        }
      });

      function Bar() {}
      Bar.prototype = Object.create(Foo.prototype);
      Bar.prototype.constructor = Bar;

      function Qux() {}
      Qux.prototype = Object.create(Bar.prototype);
      Qux.prototype.constructor = Qux;

      var obj = new Qux();

      _emberMetalWatching.watch(obj, 'someProp');
      ok(!hasMandatorySetter(obj, 'someProp'), 'mandatory-setter should not be installed');

      obj.someProp = 'foo-bar';
    });

    QUnit.test('should assert if set without Ember.set when property is being watched', function () {
      var obj = {
        someProp: null,
        toString: function () {
          return 'custom-object';
        }
      };

      _emberMetalWatching.watch(obj, 'someProp');

      expectAssertion(function () {
        obj.someProp = 'foo-bar';
      }, 'You must use Ember.set() to set the `someProp` property (of custom-object) to `foo-bar`.');
    });

    QUnit.test('should not assert if set with Ember.set when property is being watched', function () {
      var obj = {
        someProp: null,
        toString: function () {
          return 'custom-object';
        }
      };

      _emberMetalWatching.watch(obj, 'someProp');
      _emberMetalProperty_set.set(obj, 'someProp', 'foo-bar');

      equal(_emberMetalProperty_get.get(obj, 'someProp'), 'foo-bar');
    });

    QUnit.test('does not setup mandatory-setter if non-configurable', function () {
      var obj = {
        someProp: null,
        toString: function () {
          return 'custom-object';
        }
      };

      Object.defineProperty(obj, 'someProp', {
        configurable: false,
        enumerable: true,
        value: 'blastix'
      });

      _emberMetalWatching.watch(obj, 'someProp');
      ok(!hasMandatorySetter(obj, 'someProp'), 'blastix');
    });

    QUnit.test('ensure after watch the property is restored (and the value is no-longer stored in meta) [non-enumerable]', function () {
      var obj = {
        someProp: null,
        toString: function () {
          return 'custom-object';
        }
      };

      Object.defineProperty(obj, 'someProp', {
        configurable: true,
        enumerable: false,
        value: 'blastix'
      });

      _emberMetalWatching.watch(obj, 'someProp');
      equal(hasMandatorySetter(obj, 'someProp'), true, 'should have a mandatory setter');

      var descriptor = Object.getOwnPropertyDescriptor(obj, 'someProp');

      equal(descriptor.enumerable, false, 'property should remain non-enumerable');
      equal(descriptor.configurable, true, 'property should remain configurable');
      equal(obj.someProp, 'blastix', 'expected value to be the getter');

      equal(descriptor.value, undefined, 'expected existing value to NOT remain');

      ok(hasMetaValue(obj, 'someProp'), 'someProp is stored in meta.values');

      _emberMetalWatching.unwatch(obj, 'someProp');

      ok(!hasMetaValue(obj, 'someProp'), 'someProp is no longer stored in meta.values');

      descriptor = Object.getOwnPropertyDescriptor(obj, 'someProp');

      equal(hasMandatorySetter(obj, 'someProp'), false, 'should no longer have a mandatory setter');

      equal(descriptor.enumerable, false, 'property should remain non-enumerable');
      equal(descriptor.configurable, true, 'property should remain configurable');
      equal(obj.someProp, 'blastix', 'expected value to be the getter');
      equal(descriptor.value, 'blastix', 'expected existing value to remain');

      obj.someProp = 'new value';

      // make sure the descriptor remains correct (nothing funky, like a redefined, happened in the setter);
      descriptor = Object.getOwnPropertyDescriptor(obj, 'someProp');

      equal(descriptor.enumerable, false, 'property should remain non-enumerable');
      equal(descriptor.configurable, true, 'property should remain configurable');
      equal(descriptor.value, 'new value', 'expected existing value to NOT remain');
      equal(obj.someProp, 'new value', 'expected value to be the getter');
      equal(obj.someProp, 'new value');
    });

    QUnit.test('ensure after watch the property is restored (and the value is no-longer stored in meta) [enumerable]', function () {
      var obj = {
        someProp: null,
        toString: function () {
          return 'custom-object';
        }
      };

      Object.defineProperty(obj, 'someProp', {
        configurable: true,
        enumerable: true,
        value: 'blastix'
      });

      _emberMetalWatching.watch(obj, 'someProp');
      equal(hasMandatorySetter(obj, 'someProp'), true, 'should have a mandatory setter');

      var descriptor = Object.getOwnPropertyDescriptor(obj, 'someProp');

      equal(descriptor.enumerable, true, 'property should remain enumerable');
      equal(descriptor.configurable, true, 'property should remain configurable');
      equal(obj.someProp, 'blastix', 'expected value to be the getter');

      equal(descriptor.value, undefined, 'expected existing value to NOT remain');

      ok(hasMetaValue(obj, 'someProp'), 'someProp is stored in meta.values');

      _emberMetalWatching.unwatch(obj, 'someProp');

      ok(!hasMetaValue(obj, 'someProp'), 'someProp is no longer stored in meta.values');

      descriptor = Object.getOwnPropertyDescriptor(obj, 'someProp');

      equal(hasMandatorySetter(obj, 'someProp'), false, 'should no longer have a mandatory setter');

      equal(descriptor.enumerable, true, 'property should remain enumerable');
      equal(descriptor.configurable, true, 'property should remain configurable');
      equal(obj.someProp, 'blastix', 'expected value to be the getter');
      equal(descriptor.value, 'blastix', 'expected existing value to remain');

      obj.someProp = 'new value';

      // make sure the descriptor remains correct (nothing funky, like a redefined, happened in the setter);
      descriptor = Object.getOwnPropertyDescriptor(obj, 'someProp');

      equal(descriptor.enumerable, true, 'property should remain enumerable');
      equal(descriptor.configurable, true, 'property should remain configurable');
      equal(descriptor.value, 'new value', 'expected existing value to NOT remain');
      equal(obj.someProp, 'new value');
    });

    QUnit.test('sets up mandatory-setter if property comes from prototype', function () {
      expect(2);

      var obj = {
        someProp: null,
        toString: function () {
          return 'custom-object';
        }
      };

      var obj2 = Object.create(obj);

      _emberMetalWatching.watch(obj2, 'someProp');

      ok(hasMandatorySetter(obj2, 'someProp'), 'mandatory setter has been setup');

      expectAssertion(function () {
        obj2.someProp = 'foo-bar';
      }, 'You must use Ember.set() to set the `someProp` property (of custom-object) to `foo-bar`.');
    });

    QUnit.test('inheritance remains live', function () {
      function Parent() {}
      Parent.prototype.food = 'chips';

      var child = new Parent();

      equal(child.food, 'chips');

      _emberMetalWatching.watch(child, 'food');

      equal(child.food, 'chips');

      Parent.prototype.food = 'icecreame';

      equal(child.food, 'icecreame');

      _emberMetalWatching.unwatch(child, 'food');

      equal(child.food, 'icecreame');

      Parent.prototype.food = 'chips';

      equal(child.food, 'chips');
    });

    QUnit.test('inheritance remains live and preserves this', function () {
      function Parent(food) {
        this._food = food;
      }

      Object.defineProperty(Parent.prototype, 'food', {
        get: function () {
          return this._food;
        }
      });

      var child = new Parent('chips');

      equal(child.food, 'chips');

      _emberMetalWatching.watch(child, 'food');

      equal(child.food, 'chips');

      child._food = 'icecreame';

      equal(child.food, 'icecreame');

      _emberMetalWatching.unwatch(child, 'food');

      equal(child.food, 'icecreame');

      var foodDesc = Object.getOwnPropertyDescriptor(Parent.prototype, 'food');
      ok(!foodDesc.configurable, 'Parent.prototype.food desc should be non configable');
      ok(!foodDesc.enumerable, 'Parent.prototype.food desc should be non enumerable');

      equal(foodDesc.get.call({
        _food: 'hi'
      }), 'hi');
      equal(foodDesc.set, undefined);

      equal(child.food, 'icecreame');
    });
  }
});
enifed('ember-metal/tests/accessors/mandatory_setters_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/accessors/mandatory_setters_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/accessors/mandatory_setters_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/accessors/set_path_test', ['exports', 'ember-environment', 'ember-metal/property_set', 'ember-metal/property_get'], function (exports, _emberEnvironment, _emberMetalProperty_set, _emberMetalProperty_get) {
  'use strict';

  var originalLookup = _emberEnvironment.context.lookup;
  var lookup = undefined;

  var obj = undefined;
  function commonSetup() {
    _emberEnvironment.context.lookup = lookup = {};
    obj = {
      foo: {
        bar: {
          baz: { biff: 'BIFF' }
        }
      }
    };
  }

  function commonTeardown() {
    _emberEnvironment.context.lookup = originalLookup;
    obj = null;
  }

  QUnit.module('set with path', {
    setup: commonSetup,
    teardown: commonTeardown
  });

  QUnit.test('[Foo, bar] -> Foo.bar', function () {
    lookup.Foo = { toString: function () {
        return 'Foo';
      } }; // Behave like an Ember.Namespace

    _emberMetalProperty_set.set(lookup.Foo, 'bar', 'baz');
    equal(_emberMetalProperty_get.get(lookup.Foo, 'bar'), 'baz');
  });

  // ..........................................................
  //
  // LOCAL PATHS

  QUnit.test('[obj, foo] -> obj.foo', function () {
    _emberMetalProperty_set.set(obj, 'foo', 'BAM');
    equal(_emberMetalProperty_get.get(obj, 'foo'), 'BAM');
  });

  QUnit.test('[obj, foo.bar] -> obj.foo.bar', function () {
    _emberMetalProperty_set.set(obj, 'foo.bar', 'BAM');
    equal(_emberMetalProperty_get.get(obj, 'foo.bar'), 'BAM');
  });

  // ..........................................................
  // DEPRECATED
  //

  QUnit.module('set with path - deprecated', {
    setup: commonSetup,
    teardown: commonTeardown
  });

  QUnit.test('[obj, bla.bla] gives a proper exception message', function () {
    var exceptionMessage = 'Property set failed: object in path \"bla\" could not be found or was destroyed.';
    try {
      _emberMetalProperty_set.set(obj, 'bla.bla', 'BAM');
    } catch (ex) {
      equal(ex.message, exceptionMessage);
    }
  });

  QUnit.test('[obj, foo.baz.bat] -> EXCEPTION', function () {
    throws(function () {
      return _emberMetalProperty_set.set(obj, 'foo.baz.bat', 'BAM');
    });
  });

  QUnit.test('[obj, foo.baz.bat] -> EXCEPTION', function () {
    _emberMetalProperty_set.trySet(obj, 'foo.baz.bat', 'BAM');
    ok(true, 'does not raise');
  });
});
enifed('ember-metal/tests/accessors/set_path_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/accessors/set_path_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/accessors/set_path_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/accessors/set_test', ['exports', 'ember-metal/property_get', 'ember-metal/property_set', 'ember-metal/tags'], function (exports, _emberMetalProperty_get, _emberMetalProperty_set, _emberMetalTags) {
  'use strict';

  QUnit.module('set', {
    teardown: function () {
      _emberMetalTags.setHasViews(function () {
        return false;
      });
    }
  });

  QUnit.test('should set arbitrary properties on an object', function () {
    var obj = {
      string: 'string',
      number: 23,
      boolTrue: true,
      boolFalse: false,
      nullValue: null,
      undefinedValue: undefined
    };

    var newObj = {
      undefinedValue: 'emberjs'
    };

    for (var key in obj) {
      if (!obj.hasOwnProperty(key)) {
        continue;
      }

      equal(_emberMetalProperty_set.set(newObj, key, obj[key]), obj[key], 'should return value');
      equal(_emberMetalProperty_get.get(newObj, key), obj[key], 'should set value');
    }
  });

  QUnit.test('should call setUnknownProperty if defined and value is undefined', function () {
    var obj = {
      count: 0,

      unknownProperty: function (key, value) {
        ok(false, 'should not invoke unknownProperty if setUnknownProperty is defined');
      },

      setUnknownProperty: function (key, value) {
        equal(key, 'foo', 'should pass key');
        equal(value, 'BAR', 'should pass key');
        this.count++;
        return 'FOO';
      }
    };

    equal(_emberMetalProperty_set.set(obj, 'foo', 'BAR'), 'BAR', 'should return set value');
    equal(obj.count, 1, 'should have invoked');
  });

  QUnit.test('warn on attempts to call set with undefined as object', function () {
    expectAssertion(function () {
      return _emberMetalProperty_set.set(undefined, 'aProperty', 'BAM');
    }, /Cannot call set with 'aProperty' on an undefined object./);
  });

  QUnit.test('warn on attempts to call set with null as object', function () {
    expectAssertion(function () {
      return _emberMetalProperty_set.set(null, 'aProperty', 'BAM');
    }, /Cannot call set with 'aProperty' on an undefined object./);
  });

  QUnit.test('warn on attempts to use set with an unsupported property path', function () {
    var obj = {};
    expectAssertion(function () {
      return _emberMetalProperty_set.set(obj, null, 42);
    }, /The key provided to set must be a string, you passed null/);
    expectAssertion(function () {
      return _emberMetalProperty_set.set(obj, NaN, 42);
    }, /The key provided to set must be a string, you passed NaN/);
    expectAssertion(function () {
      return _emberMetalProperty_set.set(obj, undefined, 42);
    }, /The key provided to set must be a string, you passed undefined/);
    expectAssertion(function () {
      return _emberMetalProperty_set.set(obj, false, 42);
    }, /The key provided to set must be a string, you passed false/);
    expectAssertion(function () {
      return _emberMetalProperty_set.set(obj, 42, 42);
    }, /The key provided to set must be a string, you passed 42/);
  });

  QUnit.test('warn on attempts of calling set on a destroyed object', function () {
    var obj = { isDestroyed: true };

    expectAssertion(function () {
      return _emberMetalProperty_set.set(obj, 'favoriteFood', 'hot dogs');
    }, 'calling set on destroyed object: [object Object].favoriteFood = hot dogs');
  });

  QUnit.test('does not trigger auto-run assertion for objects that have not been tagged', function (assert) {
    _emberMetalTags.setHasViews(function () {
      return true;
    });
    var obj = {};

    _emberMetalProperty_set.set(obj, 'foo', 'bar');

    assert.equal(obj.foo, 'bar');
  });
});
enifed('ember-metal/tests/accessors/set_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/accessors/set_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/accessors/set_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/alias_test', ['exports', 'ember-metal/alias', 'ember-metal/properties', 'ember-metal/property_get', 'ember-metal/property_set', 'ember-metal/meta', 'ember-metal/watching', 'ember-metal/observer', 'ember-metal/tags'], function (exports, _emberMetalAlias, _emberMetalProperties, _emberMetalProperty_get, _emberMetalProperty_set, _emberMetalMeta, _emberMetalWatching, _emberMetalObserver, _emberMetalTags) {
  'use strict';

  var obj = undefined,
      count = undefined;

  QUnit.module('ember-metal/alias', {
    setup: function () {
      obj = { foo: { faz: 'FOO' } };
      count = 0;
    },
    teardown: function () {
      obj = null;
    }
  });

  function incrementCount() {
    count++;
  }

  QUnit.test('should proxy get to alt key', function () {
    _emberMetalProperties.defineProperty(obj, 'bar', _emberMetalAlias.default('foo.faz'));
    equal(_emberMetalProperty_get.get(obj, 'bar'), 'FOO');
  });

  QUnit.test('should proxy set to alt key', function () {
    _emberMetalProperties.defineProperty(obj, 'bar', _emberMetalAlias.default('foo.faz'));
    _emberMetalProperty_set.set(obj, 'bar', 'BAR');
    equal(_emberMetalProperty_get.get(obj, 'foo.faz'), 'BAR');
  });

  QUnit.test('old dependent keys should not trigger property changes', function () {
    var obj1 = Object.create(null);
    _emberMetalProperties.defineProperty(obj1, 'foo', null, null);
    _emberMetalProperties.defineProperty(obj1, 'bar', _emberMetalAlias.default('foo'));
    _emberMetalProperties.defineProperty(obj1, 'baz', _emberMetalAlias.default('foo'));
    _emberMetalProperties.defineProperty(obj1, 'baz', _emberMetalAlias.default('bar')); // redefine baz
    _emberMetalObserver.addObserver(obj1, 'baz', incrementCount);

    _emberMetalProperty_set.set(obj1, 'foo', 'FOO');
    equal(count, 1);

    _emberMetalObserver.removeObserver(obj1, 'baz', incrementCount);

    _emberMetalProperty_set.set(obj1, 'foo', 'OOF');
    equal(count, 1);
  });

  QUnit.test('inheriting an observer of the alias from the prototype then\n            redefining the alias on the instance to another property dependent on same key\n            does not call the observer twice', function () {
    var obj1 = Object.create(null);

    _emberMetalMeta.meta(obj1).proto = obj1;

    _emberMetalProperties.defineProperty(obj1, 'foo', null, null);
    _emberMetalProperties.defineProperty(obj1, 'bar', _emberMetalAlias.default('foo'));
    _emberMetalProperties.defineProperty(obj1, 'baz', _emberMetalAlias.default('foo'));
    _emberMetalObserver.addObserver(obj1, 'baz', incrementCount);

    var obj2 = Object.create(obj1);
    _emberMetalProperties.defineProperty(obj2, 'baz', _emberMetalAlias.default('bar')); // override baz

    _emberMetalProperty_set.set(obj2, 'foo', 'FOO');
    equal(count, 1);

    _emberMetalObserver.removeObserver(obj2, 'baz', incrementCount);

    _emberMetalProperty_set.set(obj2, 'foo', 'OOF');
    equal(count, 1);
  });

  QUnit.test('an observer of the alias works if added after defining the alias', function () {
    _emberMetalProperties.defineProperty(obj, 'bar', _emberMetalAlias.default('foo.faz'));
    _emberMetalObserver.addObserver(obj, 'bar', incrementCount);
    ok(_emberMetalWatching.isWatching(obj, 'foo.faz'));
    _emberMetalProperty_set.set(obj, 'foo.faz', 'BAR');
    equal(count, 1);
  });

  QUnit.test('an observer of the alias works if added before defining the alias', function () {
    _emberMetalObserver.addObserver(obj, 'bar', incrementCount);
    _emberMetalProperties.defineProperty(obj, 'bar', _emberMetalAlias.default('foo.faz'));
    ok(_emberMetalWatching.isWatching(obj, 'foo.faz'));
    _emberMetalProperty_set.set(obj, 'foo.faz', 'BAR');
    equal(count, 1);
  });

  QUnit.test('object with alias is dirtied if interior object of alias is set after consumption', function () {
    _emberMetalProperties.defineProperty(obj, 'bar', _emberMetalAlias.default('foo.faz'));
    _emberMetalProperty_get.get(obj, 'bar');
    assertDirty(obj, function () {
      return _emberMetalProperty_set.set(obj, 'foo.faz', 'BAR');
    }, 'setting the aliased key should dirty the object');
  });

  QUnit.test('setting alias on self should fail assertion', function () {
    expectAssertion(function () {
      return _emberMetalProperties.defineProperty(obj, 'bar', _emberMetalAlias.default('bar'));
    }, 'Setting alias \'bar\' on self');
  });

  function assertDirty(obj, callback, label) {
    var tag = _emberMetalTags.tagFor(obj);
    var tagValue = tag.value();
    callback();
    ok(!tag.validate(tagValue), label);
  }
});
enifed('ember-metal/tests/alias_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/alias_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/alias_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/binding/connect_test', ['exports', 'ember-environment', 'internal-test-helpers', 'ember-metal/binding', 'ember-metal/run_loop', 'ember-metal/property_set', 'ember-metal/property_get'], function (exports, _emberEnvironment, _internalTestHelpers, _emberMetalBinding, _emberMetalRun_loop, _emberMetalProperty_set, _emberMetalProperty_get) {
  'use strict';

  function performTest(binding, a, b, get, set, connect) {
    if (connect === undefined) {
      connect = function () {
        return binding.connect(a);
      };
    }

    ok(!_emberMetalRun_loop.default.currentRunLoop, 'performTest should not have a currentRunLoop');

    equal(get(a, 'foo'), 'FOO', 'a should not have changed');
    equal(get(b, 'bar'), 'BAR', 'b should not have changed');

    connect();

    equal(get(a, 'foo'), 'BAR', 'a should have changed');
    equal(get(b, 'bar'), 'BAR', 'b should have changed');
    //
    // make sure changes sync both ways
    _emberMetalRun_loop.default(function () {
      return set(b, 'bar', 'BAZZ');
    });
    equal(get(a, 'foo'), 'BAZZ', 'a should have changed');

    _emberMetalRun_loop.default(function () {
      return set(a, 'foo', 'BARF');
    });
    equal(get(b, 'bar'), 'BARF', 'a should have changed');
  }

  var originalLookup = undefined,
      lookup = undefined,
      GlobalB = undefined;

  QUnit.module('Ember.Binding', {
    setup: function () {
      originalLookup = _emberEnvironment.context.lookup;
      _emberEnvironment.context.lookup = lookup = {};
    },
    teardown: function () {
      lookup = null;
      _emberEnvironment.context.lookup = originalLookup;
    }
  });

  _internalTestHelpers.testBoth('Connecting a binding between two properties', function (get, set) {
    var a = { foo: 'FOO', bar: 'BAR' };

    // a.bar -> a.foo
    var binding = new _emberMetalBinding.Binding('foo', 'bar');

    expectDeprecation(function () {
      performTest(binding, a, a, get, set);
    }, /`Ember\.Binding` is deprecated./);
  });

  _internalTestHelpers.testBoth('Connecting a oneWay binding raises a deprecation', function (get, set) {
    var a = { foo: 'FOO', bar: 'BAR', toString: function () {
        return '<custom object ID here>';
      } };

    // a.bar -> a.foo
    var binding = new _emberMetalBinding.Binding('foo', 'bar').oneWay();

    expectDeprecation(function () {
      binding.connect(a);
    }, /`Ember.Binding` is deprecated/);
  });

  _internalTestHelpers.testBoth('Connecting a binding between two objects', function (get, set) {
    var b = { bar: 'BAR' };
    var a = { foo: 'FOO', b: b };

    // b.bar -> a.foo
    var binding = new _emberMetalBinding.Binding('foo', 'b.bar');

    expectDeprecation(function () {
      performTest(binding, a, b, get, set);
    }, /`Ember\.Binding` is deprecated./);
  });

  _internalTestHelpers.testBoth('Connecting a binding to path', function (get, set) {
    var a = { foo: 'FOO' };
    lookup['GlobalB'] = GlobalB = {
      b: { bar: 'BAR' }
    };

    var b = get(GlobalB, 'b');

    // globalB.b.bar -> a.foo
    var binding = new _emberMetalBinding.Binding('foo', 'GlobalB.b.bar');

    expectDeprecation(function () {
      performTest(binding, a, b, get, set);
    }, /`Ember\.Binding` is deprecated./);

    // make sure modifications update
    b = { bar: 'BIFF' };

    _emberMetalRun_loop.default(function () {
      return set(GlobalB, 'b', b);
    });

    equal(get(a, 'foo'), 'BIFF', 'a should have changed');
  });

  _internalTestHelpers.testBoth('Calling connect more than once', function (get, set) {
    var b = { bar: 'BAR' };
    var a = { foo: 'FOO', b: b };

    // b.bar -> a.foo
    var binding = new _emberMetalBinding.Binding('foo', 'b.bar');

    expectDeprecation(function () {
      performTest(binding, a, b, get, set, function () {
        binding.connect(a);
        binding.connect(a);
      });
    }, /`Ember\.Binding` is deprecated./);
  });

  QUnit.test('inherited bindings should sync on create', function () {
    var a = undefined;
    _emberMetalRun_loop.default(function () {
      function A() {
        _emberMetalBinding.bind(this, 'foo', 'bar.baz');
      }

      expectDeprecation(function () {
        return a = new A();
      }, /`Ember\.Binding` is deprecated/);

      _emberMetalProperty_set.set(a, 'bar', { baz: 'BAZ' });
    });

    equal(_emberMetalProperty_get.get(a, 'foo'), 'BAZ', 'should have synced binding on new obj');
  });
});
enifed('ember-metal/tests/binding/connect_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/binding/connect_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/binding/connect_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/binding/sync_test', ['exports', 'internal-test-helpers', 'ember-metal/run_loop', 'ember-metal/observer', 'ember-metal/binding', 'ember-metal/computed', 'ember-metal/properties', 'ember-metal/property_events'], function (exports, _internalTestHelpers, _emberMetalRun_loop, _emberMetalObserver, _emberMetalBinding, _emberMetalComputed, _emberMetalProperties, _emberMetalProperty_events) {
  'use strict';

  QUnit.module('system/binding/sync_test.js');

  _internalTestHelpers.testBoth('bindings should not sync twice in a single run loop', function (get, set) {
    var a = undefined,
        b = undefined,
        setValue = undefined;
    var setCalled = 0;
    var getCalled = 0;

    _emberMetalRun_loop.default(function () {
      a = {};

      _emberMetalProperties.defineProperty(a, 'foo', _emberMetalComputed.computed({
        get: function (key) {
          getCalled++;
          return setValue;
        },
        set: function (key, value) {
          setCalled++;
          _emberMetalProperty_events.propertyWillChange(this, key);
          setValue = value;
          _emberMetalProperty_events.propertyDidChange(this, key);
          return value;
        }
      }).volatile());

      b = {
        a: a
      };

      expectDeprecation(function () {
        return _emberMetalBinding.bind(b, 'foo', 'a.foo');
      }, /`Ember.Binding` is deprecated/);
    });

    // reset after initial binding synchronization
    getCalled = 0;

    _emberMetalRun_loop.default(function () {
      set(a, 'foo', 'trollface');
    });

    equal(get(b, 'foo'), 'trollface', 'the binding should sync');
    equal(setCalled, 1, 'Set should only be called once');
    equal(getCalled, 1, 'Get should only be called once');
  });

  _internalTestHelpers.testBoth('bindings should not infinite loop if computed properties return objects', function (get, set) {
    var a = undefined,
        b = undefined;
    var getCalled = 0;

    _emberMetalRun_loop.default(function () {
      a = {};

      _emberMetalProperties.defineProperty(a, 'foo', _emberMetalComputed.computed(function () {
        getCalled++;
        if (getCalled > 1000) {
          throw 'infinite loop detected';
        }
        return ['foo', 'bar'];
      }));

      b = {
        a: a
      };

      expectDeprecation(function () {
        return _emberMetalBinding.bind(b, 'foo', 'a.foo');
      }, /`Ember.Binding` is deprecated/);
    });

    deepEqual(get(b, 'foo'), ['foo', 'bar'], 'the binding should sync');
    equal(getCalled, 1, 'Get should only be called once');
  });

  _internalTestHelpers.testBoth('bindings should do the right thing when observers trigger bindings in the opposite direction', function (get, set) {
    var a = undefined,
        b = undefined,
        c = undefined;

    _emberMetalRun_loop.default(function () {
      a = {
        foo: 'trololol'
      };

      b = {
        a: a
      };

      var deprecationMessage = /`Ember.Binding` is deprecated/;

      expectDeprecation(function () {
        return _emberMetalBinding.bind(b, 'foo', 'a.foo');
      }, deprecationMessage);

      c = {
        a: a
      };

      expectDeprecation(function () {
        _emberMetalBinding.bind(c, 'foo', 'a.foo');
      }, deprecationMessage);
    });

    _emberMetalObserver.addObserver(b, 'foo', function () {
      return set(c, 'foo', 'what is going on');
    });

    _emberMetalRun_loop.default(function () {
      return set(a, 'foo', 'trollface');
    });

    equal(get(a, 'foo'), 'what is going on');
  });

  _internalTestHelpers.testBoth('bindings should not try to sync destroyed objects', function (get, set) {
    var a = undefined,
        b = undefined;

    _emberMetalRun_loop.default(function () {
      a = {
        foo: 'trololol'
      };

      b = {
        a: a
      };

      var deprecationMessage = /`Ember.Binding` is deprecated/;

      expectDeprecation(function () {
        return _emberMetalBinding.bind(b, 'foo', 'a.foo');
      }, deprecationMessage);
    });

    _emberMetalRun_loop.default(function () {
      set(a, 'foo', 'trollface');
      set(b, 'isDestroyed', true);
      ok(true, 'should not raise');
    });

    _emberMetalRun_loop.default(function () {
      a = {
        foo: 'trololol'
      };

      b = {
        a: a
      };

      var deprecationMessage = /`Ember.Binding` is deprecated/;

      expectDeprecation(function () {
        return _emberMetalBinding.bind(b, 'foo', 'a.foo');
      }, deprecationMessage);
    });

    _emberMetalRun_loop.default(function () {
      set(b, 'foo', 'trollface');
      set(a, 'isDestroyed', true);
      ok(true, 'should not raise');
    });
  });
});
enifed('ember-metal/tests/binding/sync_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/binding/sync_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/binding/sync_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/cache_test', ['exports', 'ember-metal/cache'], function (exports, _emberMetalCache) {
  'use strict';

  QUnit.module('Cache');

  QUnit.test('basic', function () {
    var cache = new _emberMetalCache.default(100, function (key) {
      return key.toUpperCase();
    });

    equal(cache.get('foo'), 'FOO');
    equal(cache.get('bar'), 'BAR');
    equal(cache.get('foo'), 'FOO');
  });

  QUnit.test('explicit sets', function () {
    var cache = new _emberMetalCache.default(100, function (key) {
      return key.toUpperCase();
    });

    equal(cache.get('foo'), 'FOO');

    equal(cache.set('foo', 'FOO!!!'), 'FOO!!!');

    equal(cache.get('foo'), 'FOO!!!');

    strictEqual(cache.set('foo', undefined), undefined);

    strictEqual(cache.get('foo'), undefined);
  });

  QUnit.test('caches computation correctly', function () {
    var count = 0;
    var cache = new _emberMetalCache.default(100, function (key) {
      count++;
      return key.toUpperCase();
    });

    equal(count, 0);
    cache.get('foo');
    equal(count, 1);
    cache.get('bar');
    equal(count, 2);
    cache.get('bar');
    equal(count, 2);
    cache.get('foo');
    equal(count, 2);
  });

  QUnit.test('caches computation correctly with custom cache keys', function () {
    var count = 0;
    var cache = new _emberMetalCache.default(100, function (obj) {
      count++;
      return obj.value.toUpperCase();
    }, function (obj) {
      return obj.key;
    });

    equal(count, 0);
    cache.get({ key: 'foo', value: 'foo' });
    equal(count, 1);
    cache.get({ key: 'bar', value: 'bar' });
    equal(count, 2);
    cache.get({ key: 'bar', value: 'bar' });
    equal(count, 2);
    cache.get({ key: 'foo', value: 'foo' });
    equal(count, 2);
  });

  QUnit.test('handles undefined value correctly', function () {
    var count = 0;
    var cache = new _emberMetalCache.default(100, function (key) {
      count++;
    });

    equal(count, 0);
    strictEqual(cache.get('foo'), undefined);
    equal(count, 1);
    strictEqual(cache.get('bar'), undefined);
    equal(count, 2);
    strictEqual(cache.get('bar'), undefined);
    equal(count, 2);
    strictEqual(cache.get('foo'), undefined);
    equal(count, 2);
  });

  QUnit.test('continues working after reaching cache limit', function () {
    var cache = new _emberMetalCache.default(3, function (key) {
      return key.toUpperCase();
    });

    cache.get('a');
    cache.get('b');
    cache.get('c');

    equal(cache.get('d'), 'D');
    equal(cache.get('a'), 'A');
    equal(cache.get('b'), 'B');
    equal(cache.get('c'), 'C');
  });
});
enifed('ember-metal/tests/cache_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/cache_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/cache_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/chains_test', ['exports', 'ember-metal/observer', 'ember-metal/property_get', 'ember-metal/chains', 'ember-metal/properties', 'ember-metal/computed', 'ember-metal/property_events', 'ember-metal/meta'], function (exports, _emberMetalObserver, _emberMetalProperty_get, _emberMetalChains, _emberMetalProperties, _emberMetalComputed, _emberMetalProperty_events, _emberMetalMeta) {
  'use strict';

  QUnit.module('Chains');

  QUnit.test('finishChains should properly copy chains from prototypes to instances', function () {
    function didChange() {}

    var obj = {};
    _emberMetalObserver.addObserver(obj, 'foo.bar', null, didChange);

    var childObj = Object.create(obj);
    _emberMetalChains.finishChains(childObj);
    ok(_emberMetalMeta.peekMeta(obj) !== _emberMetalMeta.peekMeta(childObj).readableChains(), 'The chains object is copied');
  });

  QUnit.test('does not observe primative values', function (assert) {
    var obj = {
      foo: { bar: 'STRING' }
    };

    _emberMetalObserver.addObserver(obj, 'foo.bar.baz', null, function () {});
    var meta = _emberMetalMeta.peekMeta(obj);
    assert.notOk(meta._object);
  });

  QUnit.test('observer and CP chains', function () {
    var obj = {};

    _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.default('qux.[]', function () {}));
    _emberMetalProperties.defineProperty(obj, 'qux', _emberMetalComputed.default(function () {}));

    // create DK chains
    _emberMetalProperty_get.get(obj, 'foo');

    // create observer chain
    _emberMetalObserver.addObserver(obj, 'qux.length', function () {});

    /*
               +-----+
               | qux |   root CP
               +-----+
                  ^
           +------+-----+
           |            |
       +--------+    +----+
       | length |    | [] |  chainWatchers
       +--------+    +----+
        observer       CP(foo, 'qux.[]')
    */

    // invalidate qux
    _emberMetalProperty_events.propertyDidChange(obj, 'qux');

    // CP chain is blown away

    /*
               +-----+
               | qux |   root CP
               +-----+
                  ^
           +------+xxxxxx
           |            x
       +--------+    xxxxxx
       | length |    x [] x  chainWatchers
       +--------+    xxxxxx
        observer       CP(foo, 'qux.[]')
    */

    _emberMetalProperty_get.get(obj, 'qux'); // CP chain re-recreated
    ok(true, 'no crash');
  });

  QUnit.test('checks cache correctly', function (assert) {
    var obj = {};
    var parentChainNode = new _emberMetalChains.ChainNode(null, null, obj);
    var chainNode = new _emberMetalChains.ChainNode(parentChainNode, 'foo');

    _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.default(function () {
      return undefined;
    }));
    _emberMetalProperty_get.get(obj, 'foo');

    assert.strictEqual(chainNode.value(), undefined);
  });
});
enifed('ember-metal/tests/chains_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/chains_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/chains_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/computed_test', ['exports', 'ember-runtime', 'internal-test-helpers', 'ember-metal/computed', 'ember-metal/properties', 'ember-metal/property_get', 'ember-metal/property_set', 'ember-metal/watching', 'ember-metal/observer'], function (exports, _emberRuntime, _internalTestHelpers, _emberMetalComputed, _emberMetalProperties, _emberMetalProperty_get, _emberMetalProperty_set, _emberMetalWatching, _emberMetalObserver) {
  'use strict';

  var obj = undefined,
      count = undefined;

  QUnit.module('computed');

  QUnit.test('computed property should be an instance of descriptor', function () {
    ok(_emberMetalComputed.computed(function () {}) instanceof _emberMetalProperties.Descriptor);
  });

  QUnit.test('computed properties assert the presence of a getter or setter function', function () {
    expectAssertion(function () {
      _emberMetalComputed.computed('nogetternorsetter', {});
    }, 'Computed properties must receive a getter or a setter, you passed none.');
  });

  QUnit.test('computed properties check for the presence of a function or configuration object', function () {
    expectAssertion(function () {
      _emberMetalComputed.computed('nolastargument');
    }, 'Ember.computed expects a function or an object as last argument.');
  });

  QUnit.test('computed properties defined with an object only allow `get` and `set` keys', function () {
    expectAssertion(function () {
      _emberMetalComputed.computed({
        get: function () {},
        set: function () {},
        other: function () {}
      });
    }, 'Config object passed to an Ember.computed can only contain `get` or `set` keys.');
  });

  QUnit.test('defining computed property should invoke property on get', function () {
    var obj = {};
    var count = 0;
    _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.computed(function (key) {
      count++;
      return 'computed ' + key;
    }));

    equal(_emberMetalProperty_get.get(obj, 'foo'), 'computed foo', 'should return value');
    equal(count, 1, 'should have invoked computed property');
  });

  QUnit.test('defining computed property should invoke property on set', function () {
    var obj = {};
    var count = 0;
    _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.computed({
      get: function (key) {
        return this['__' + key];
      },
      set: function (key, value) {
        count++;
        this['__' + key] = 'computed ' + value;
        return this['__' + key];
      }
    }));

    equal(_emberMetalProperty_set.set(obj, 'foo', 'bar'), 'bar', 'should return set value');
    equal(count, 1, 'should have invoked computed property');
    equal(_emberMetalProperty_get.get(obj, 'foo'), 'computed bar', 'should return new value');
  });

  QUnit.test('defining a computed property with a dependent key ending with @each is expanded to []', function () {
    var cp = _emberMetalComputed.computed('blazo.@each', function () {});

    deepEqual(cp._dependentKeys, ['blazo.[]']);

    cp = _emberMetalComputed.computed('qux', 'zoopa.@each', function () {});

    deepEqual(cp._dependentKeys, ['qux', 'zoopa.[]']);
  });

  QUnit.test('defining a computed property with a dependent key more than one level deep beyond @each is not supported', function () {
    expectNoWarning(function () {
      _emberMetalComputed.computed('todos', function () {});
    });

    expectNoWarning(function () {
      _emberMetalComputed.computed('todos.@each.owner', function () {});
    });

    expectWarning(function () {
      _emberMetalComputed.computed('todos.@each.owner.name', function () {});
    }, /You used the key "todos\.@each\.owner\.name" which is invalid\. /);

    expectWarning(function () {
      _emberMetalComputed.computed('todos.@each.owner.@each.name', function () {});
    }, /You used the key "todos\.@each\.owner\.@each\.name" which is invalid\. /);
  });

  var objA = undefined,
      objB = undefined;
  QUnit.module('computed should inherit through prototype', {
    setup: function () {
      objA = { __foo: 'FOO' };
      _emberMetalProperties.defineProperty(objA, 'foo', _emberMetalComputed.computed({
        get: function (key) {
          return this['__' + key];
        },
        set: function (key, value) {
          this['__' + key] = 'computed ' + value;
          return this['__' + key];
        }
      }));

      objB = Object.create(objA);
      objB.__foo = 'FOO'; // make a copy;
    },

    teardown: function () {
      objA = objB = null;
    }
  });

  _internalTestHelpers.testBoth('using get() and set()', function (get, set) {
    equal(get(objA, 'foo'), 'FOO', 'should get FOO from A');
    equal(get(objB, 'foo'), 'FOO', 'should get FOO from B');

    set(objA, 'foo', 'BIFF');
    equal(get(objA, 'foo'), 'computed BIFF', 'should change A');
    equal(get(objB, 'foo'), 'FOO', 'should NOT change B');

    set(objB, 'foo', 'bar');
    equal(get(objB, 'foo'), 'computed bar', 'should change B');
    equal(get(objA, 'foo'), 'computed BIFF', 'should NOT change A');

    set(objA, 'foo', 'BAZ');
    equal(get(objA, 'foo'), 'computed BAZ', 'should change A');
    equal(get(objB, 'foo'), 'computed bar', 'should NOT change B');
  });

  QUnit.module('redefining computed property to normal', {
    setup: function () {
      objA = { __foo: 'FOO' };
      _emberMetalProperties.defineProperty(objA, 'foo', _emberMetalComputed.computed({
        get: function (key) {
          return this['__' + key];
        },
        set: function (key, value) {
          this['__' + key] = 'computed ' + value;
          return this['__' + key];
        }
      }));

      objB = Object.create(objA);
      _emberMetalProperties.defineProperty(objB, 'foo'); // make this just a normal property.
    },

    teardown: function () {
      objA = objB = null;
    }
  });

  _internalTestHelpers.testBoth('using get() and set()', function (get, set) {
    equal(get(objA, 'foo'), 'FOO', 'should get FOO from A');
    equal(get(objB, 'foo'), undefined, 'should get undefined from B');

    set(objA, 'foo', 'BIFF');
    equal(get(objA, 'foo'), 'computed BIFF', 'should change A');
    equal(get(objB, 'foo'), undefined, 'should NOT change B');

    set(objB, 'foo', 'bar');
    equal(get(objB, 'foo'), 'bar', 'should change B');
    equal(get(objA, 'foo'), 'computed BIFF', 'should NOT change A');

    set(objA, 'foo', 'BAZ');
    equal(get(objA, 'foo'), 'computed BAZ', 'should change A');
    equal(get(objB, 'foo'), 'bar', 'should NOT change B');
  });

  QUnit.module('redefining computed property to another property', {
    setup: function () {
      objA = { __foo: 'FOO' };
      _emberMetalProperties.defineProperty(objA, 'foo', _emberMetalComputed.computed({
        get: function (key) {
          return this['__' + key];
        },
        set: function (key, value) {
          this['__' + key] = 'A ' + value;
          return this['__' + key];
        }
      }));

      objB = Object.create(objA);
      objB.__foo = 'FOO';
      _emberMetalProperties.defineProperty(objB, 'foo', _emberMetalComputed.computed({
        get: function (key) {
          return this['__' + key];
        },
        set: function (key, value) {
          this['__' + key] = 'B ' + value;
          return this['__' + key];
        }
      }));
    },

    teardown: function () {
      objA = objB = null;
    }
  });

  _internalTestHelpers.testBoth('using get() and set()', function (get, set) {
    equal(get(objA, 'foo'), 'FOO', 'should get FOO from A');
    equal(get(objB, 'foo'), 'FOO', 'should get FOO from B');

    set(objA, 'foo', 'BIFF');
    equal(get(objA, 'foo'), 'A BIFF', 'should change A');
    equal(get(objB, 'foo'), 'FOO', 'should NOT change B');

    set(objB, 'foo', 'bar');
    equal(get(objB, 'foo'), 'B bar', 'should change B');
    equal(get(objA, 'foo'), 'A BIFF', 'should NOT change A');

    set(objA, 'foo', 'BAZ');
    equal(get(objA, 'foo'), 'A BAZ', 'should change A');
    equal(get(objB, 'foo'), 'B bar', 'should NOT change B');
  });

  QUnit.module('computed - metadata');

  QUnit.test('can set metadata on a computed property', function () {
    var computedProperty = _emberMetalComputed.computed(function () {});
    computedProperty.meta({ key: 'keyValue' });

    equal(computedProperty.meta().key, 'keyValue', 'saves passed meta hash to the _meta property');
  });

  QUnit.test('meta should return an empty hash if no meta is set', function () {
    var computedProperty = _emberMetalComputed.computed(function () {});
    deepEqual(computedProperty.meta(), {}, 'returned value is an empty hash');
  });

  // ..........................................................
  // CACHEABLE
  //

  QUnit.module('computed - cacheable', {
    setup: function () {
      obj = {};
      count = 0;
      var func = function (key, value) {
        count++;
        return 'bar ' + count;
      };
      _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.computed({ get: func, set: func }));
    },

    teardown: function () {
      obj = count = null;
    }
  });

  _internalTestHelpers.testBoth('cacheable should cache', function (get, set) {
    equal(get(obj, 'foo'), 'bar 1', 'first get');
    equal(get(obj, 'foo'), 'bar 1', 'second get');
    equal(count, 1, 'should only invoke once');
  });

  _internalTestHelpers.testBoth('modifying a cacheable property should update cache', function (get, set) {
    equal(get(obj, 'foo'), 'bar 1', 'first get');
    equal(get(obj, 'foo'), 'bar 1', 'second get');

    equal(set(obj, 'foo', 'baz'), 'baz', 'setting');
    equal(get(obj, 'foo'), 'bar 2', 'third get');
    equal(count, 2, 'should not invoke again');
  });

  _internalTestHelpers.testBoth('inherited property should not pick up cache', function (get, set) {
    var objB = Object.create(obj);

    equal(get(obj, 'foo'), 'bar 1', 'obj first get');
    equal(get(objB, 'foo'), 'bar 2', 'objB first get');

    equal(get(obj, 'foo'), 'bar 1', 'obj second get');
    equal(get(objB, 'foo'), 'bar 2', 'objB second get');

    set(obj, 'foo', 'baz'); // modify A
    equal(get(obj, 'foo'), 'bar 3', 'obj third get');
    equal(get(objB, 'foo'), 'bar 2', 'objB third get');
  });

  _internalTestHelpers.testBoth('cacheFor should return the cached value', function (get, set) {
    equal(_emberMetalComputed.cacheFor(obj, 'foo'), undefined, 'should not yet be a cached value');

    get(obj, 'foo');

    equal(_emberMetalComputed.cacheFor(obj, 'foo'), 'bar 1', 'should retrieve cached value');
  });

  _internalTestHelpers.testBoth('cacheFor should return falsy cached values', function (get, set) {
    _emberMetalProperties.defineProperty(obj, 'falsy', _emberMetalComputed.computed(function () {
      return false;
    }));

    equal(_emberMetalComputed.cacheFor(obj, 'falsy'), undefined, 'should not yet be a cached value');

    get(obj, 'falsy');

    equal(_emberMetalComputed.cacheFor(obj, 'falsy'), false, 'should retrieve cached value');
  });

  _internalTestHelpers.testBoth('setting a cached computed property passes the old value as the third argument', function (get, set) {
    var obj = {
      foo: 0
    };

    var receivedOldValue = undefined;

    _emberMetalProperties.defineProperty(obj, 'plusOne', _emberMetalComputed.computed({
      get: function () {},
      set: function (key, value, oldValue) {
        receivedOldValue = oldValue;
        return value;
      } }).property('foo'));

    set(obj, 'plusOne', 1);
    strictEqual(receivedOldValue, undefined, 'oldValue should be undefined');

    set(obj, 'plusOne', 2);
    strictEqual(receivedOldValue, 1, 'oldValue should be 1');

    set(obj, 'plusOne', 3);
    strictEqual(receivedOldValue, 2, 'oldValue should be 2');
  });

  // ..........................................................
  // DEPENDENT KEYS
  //

  QUnit.module('computed - dependentkey', {
    setup: function () {
      obj = { bar: 'baz' };
      count = 0;
      var getterAndSetter = function (key, value) {
        count++;
        _emberMetalProperty_get.get(this, 'bar');
        return 'bar ' + count;
      };
      _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.computed({
        get: getterAndSetter,
        set: getterAndSetter
      }).property('bar'));
    },

    teardown: function () {
      obj = count = null;
    }
  });

  _internalTestHelpers.testBoth('should lazily watch dependent keys on set', function (get, set) {
    equal(_emberMetalWatching.isWatching(obj, 'bar'), false, 'precond not watching dependent key');
    set(obj, 'foo', 'bar');
    equal(_emberMetalWatching.isWatching(obj, 'bar'), true, 'lazily watching dependent key');
  });

  _internalTestHelpers.testBoth('should lazily watch dependent keys on get', function (get, set) {
    equal(_emberMetalWatching.isWatching(obj, 'bar'), false, 'precond not watching dependent key');
    get(obj, 'foo');
    equal(_emberMetalWatching.isWatching(obj, 'bar'), true, 'lazily watching dependent key');
  });

  _internalTestHelpers.testBoth('local dependent key should invalidate cache', function (get, set) {
    equal(_emberMetalWatching.isWatching(obj, 'bar'), false, 'precond not watching dependent key');
    equal(get(obj, 'foo'), 'bar 1', 'get once');
    equal(_emberMetalWatching.isWatching(obj, 'bar'), true, 'lazily setup watching dependent key');
    equal(get(obj, 'foo'), 'bar 1', 'cached retrieve');

    set(obj, 'bar', 'BIFF'); // should invalidate foo

    equal(get(obj, 'foo'), 'bar 2', 'should recache');
    equal(get(obj, 'foo'), 'bar 2', 'cached retrieve');
  });

  _internalTestHelpers.testBoth('should invalidate multiple nested dependent keys', function (get, set) {
    var count = 0;
    _emberMetalProperties.defineProperty(obj, 'bar', _emberMetalComputed.computed(function () {
      count++;
      get(this, 'baz');
      return 'baz ' + count;
    }).property('baz'));

    equal(_emberMetalWatching.isWatching(obj, 'bar'), false, 'precond not watching dependent key');
    equal(_emberMetalWatching.isWatching(obj, 'baz'), false, 'precond not watching dependent key');
    equal(get(obj, 'foo'), 'bar 1', 'get once');
    equal(_emberMetalWatching.isWatching(obj, 'bar'), true, 'lazily setup watching dependent key');
    equal(_emberMetalWatching.isWatching(obj, 'baz'), true, 'lazily setup watching dependent key');
    equal(get(obj, 'foo'), 'bar 1', 'cached retrieve');

    set(obj, 'baz', 'BIFF'); // should invalidate bar -> foo
    equal(_emberMetalWatching.isWatching(obj, 'bar'), false, 'should not be watching dependent key after cache cleared');
    equal(_emberMetalWatching.isWatching(obj, 'baz'), false, 'should not be watching dependent key after cache cleared');

    equal(get(obj, 'foo'), 'bar 2', 'should recache');
    equal(get(obj, 'foo'), 'bar 2', 'cached retrieve');
    equal(_emberMetalWatching.isWatching(obj, 'bar'), true, 'lazily setup watching dependent key');
    equal(_emberMetalWatching.isWatching(obj, 'baz'), true, 'lazily setup watching dependent key');
  });

  _internalTestHelpers.testBoth('circular keys should not blow up', function (get, set) {
    var func = function (key, value) {
      count++;
      return 'bar ' + count;
    };
    _emberMetalProperties.defineProperty(obj, 'bar', _emberMetalComputed.computed({ get: func, set: func }).property('foo'));

    _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.computed(function (key) {
      count++;
      return 'foo ' + count;
    }).property('bar'));

    equal(get(obj, 'foo'), 'foo 1', 'get once');
    equal(get(obj, 'foo'), 'foo 1', 'cached retrieve');

    set(obj, 'bar', 'BIFF'); // should invalidate bar -> foo -> bar

    equal(get(obj, 'foo'), 'foo 3', 'should recache');
    equal(get(obj, 'foo'), 'foo 3', 'cached retrieve');
  });

  _internalTestHelpers.testBoth('redefining a property should undo old dependent keys', function (get, set) {
    equal(_emberMetalWatching.isWatching(obj, 'bar'), false, 'precond not watching dependent key');
    equal(get(obj, 'foo'), 'bar 1');
    equal(_emberMetalWatching.isWatching(obj, 'bar'), true, 'lazily watching dependent key');

    _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.computed(function () {
      count++;
      return 'baz ' + count;
    }).property('baz'));

    equal(_emberMetalWatching.isWatching(obj, 'bar'), false, 'after redefining should not be watching dependent key');

    equal(get(obj, 'foo'), 'baz 2');

    set(obj, 'bar', 'BIFF'); // should not kill cache
    equal(get(obj, 'foo'), 'baz 2');

    set(obj, 'baz', 'BOP');
    equal(get(obj, 'foo'), 'baz 3');
  });

  _internalTestHelpers.testBoth('can watch multiple dependent keys specified declaratively via brace expansion', function (get, set) {
    _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.computed(function (key) {
      count++;
      return 'foo ' + count;
    }).property('qux.{bar,baz}'));

    equal(get(obj, 'foo'), 'foo 1', 'get once');
    equal(get(obj, 'foo'), 'foo 1', 'cached retrieve');

    set(obj, 'qux', {});
    set(obj, 'qux.bar', 'bar'); // invalidate foo

    equal(get(obj, 'foo'), 'foo 2', 'foo invalidated from bar');

    set(obj, 'qux.baz', 'baz'); // invalidate foo

    equal(get(obj, 'foo'), 'foo 3', 'foo invalidated from baz');

    set(obj, 'qux.quux', 'quux'); // do not invalidate foo

    equal(get(obj, 'foo'), 'foo 3', 'foo not invalidated by quux');
  });

  _internalTestHelpers.testBoth('throws assertion if brace expansion notation has spaces', function (get, set) {
    expectAssertion(function () {
      _emberMetalProperties.defineProperty(obj, 'roo', _emberMetalComputed.computed(function (key) {
        count++;
        return 'roo ' + count;
      }).property('fee.{bar, baz,bop , }'));
    }, /cannot contain spaces/);
  });

  // ..........................................................
  // CHAINED DEPENDENT KEYS
  //

  var func = undefined;
  var moduleOpts = {
    setup: function () {
      obj = {
        foo: {
          bar: {
            baz: {
              biff: 'BIFF'
            }
          }
        }
      };

      count = 0;
      func = function () {
        count++;
        return _emberMetalProperty_get.get(obj, 'foo.bar.baz.biff') + ' ' + count;
      };
    },

    teardown: function () {
      obj = count = func = null;
    }
  };

  QUnit.module('computed - dependentkey with chained properties', moduleOpts);

  _internalTestHelpers.testBoth('depending on simple chain', function (get, set) {
    // assign computed property
    _emberMetalProperties.defineProperty(obj, 'prop', _emberMetalComputed.computed(func).property('foo.bar.baz.biff'));

    equal(get(obj, 'prop'), 'BIFF 1');

    set(get(obj, 'foo.bar.baz'), 'biff', 'BUZZ');
    equal(get(obj, 'prop'), 'BUZZ 2');
    equal(get(obj, 'prop'), 'BUZZ 2');

    set(get(obj, 'foo.bar'), 'baz', { biff: 'BLOB' });
    equal(get(obj, 'prop'), 'BLOB 3');
    equal(get(obj, 'prop'), 'BLOB 3');

    set(get(obj, 'foo.bar.baz'), 'biff', 'BUZZ');
    equal(get(obj, 'prop'), 'BUZZ 4');
    equal(get(obj, 'prop'), 'BUZZ 4');

    set(get(obj, 'foo'), 'bar', { baz: { biff: 'BOOM' } });
    equal(get(obj, 'prop'), 'BOOM 5');
    equal(get(obj, 'prop'), 'BOOM 5');

    set(get(obj, 'foo.bar.baz'), 'biff', 'BUZZ');
    equal(get(obj, 'prop'), 'BUZZ 6');
    equal(get(obj, 'prop'), 'BUZZ 6');

    set(obj, 'foo', { bar: { baz: { biff: 'BLARG' } } });
    equal(get(obj, 'prop'), 'BLARG 7');
    equal(get(obj, 'prop'), 'BLARG 7');

    set(get(obj, 'foo.bar.baz'), 'biff', 'BUZZ');
    equal(get(obj, 'prop'), 'BUZZ 8');
    equal(get(obj, 'prop'), 'BUZZ 8');

    _emberMetalProperties.defineProperty(obj, 'prop');
    set(obj, 'prop', 'NONE');
    equal(get(obj, 'prop'), 'NONE');

    set(obj, 'foo', { bar: { baz: { biff: 'BLARG' } } });
    equal(get(obj, 'prop'), 'NONE'); // should do nothing
    equal(count, 8, 'should be not have invoked computed again');
  });

  _internalTestHelpers.testBoth('chained dependent keys should evaluate computed properties lazily', function (get, set) {
    _emberMetalProperties.defineProperty(obj.foo.bar, 'b', _emberMetalComputed.computed(func));
    _emberMetalProperties.defineProperty(obj.foo, 'c', _emberMetalComputed.computed(function () {}).property('bar.b'));
    equal(count, 0, 'b should not run');
  });

  // ..........................................................
  // improved-cp-syntax
  //

  QUnit.module('computed - improved cp syntax');

  QUnit.test('setter and getters are passed using an object', function () {
    var testObj = _emberRuntime.Object.extend({
      a: '1',
      b: '2',
      aInt: _emberMetalComputed.computed('a', {
        get: function (keyName) {
          equal(keyName, 'aInt', 'getter receives the keyName');
          return parseInt(this.get('a'));
        },
        set: function (keyName, value, oldValue) {
          equal(keyName, 'aInt', 'setter receives the keyName');
          equal(value, 123, 'setter receives the new value');
          equal(oldValue, 1, 'setter receives the old value');
          this.set('a', '' + value); // side effect
          return parseInt(this.get('a'));
        }
      })
    }).create();

    ok(testObj.get('aInt') === 1, 'getter works');
    testObj.set('aInt', 123);
    ok(testObj.get('a') === '123', 'setter works');
    ok(testObj.get('aInt') === 123, 'cp has been updated too');
  });

  QUnit.test('setter can be omited', function () {
    var testObj = _emberRuntime.Object.extend({
      a: '1',
      b: '2',
      aInt: _emberMetalComputed.computed('a', {
        get: function (keyName) {
          equal(keyName, 'aInt', 'getter receives the keyName');
          return parseInt(this.get('a'));
        }
      })
    }).create();

    ok(testObj.get('aInt') === 1, 'getter works');
    ok(testObj.get('a') === '1');
    testObj.set('aInt', '123');
    ok(testObj.get('aInt') === '123', 'cp has been updated too');
  });

  QUnit.test('the return value of the setter gets cached', function () {
    var testObj = _emberRuntime.Object.extend({
      a: '1',
      sampleCP: _emberMetalComputed.computed('a', {
        get: function (keyName) {
          ok(false, 'The getter should not be invoked');
          return 'get-value';
        },
        set: function (keyName, value, oldValue) {
          return 'set-value';
        }
      })
    }).create();

    testObj.set('sampleCP', 'abcd');
    ok(testObj.get('sampleCP') === 'set-value', 'The return value of the CP was cached');
  });

  // ..........................................................
  // BUGS
  //

  QUnit.module('computed edge cases');

  QUnit.test('adding a computed property should show up in key iteration', function () {
    var obj = {};
    _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.computed(function () {}));

    var found = [];
    for (var key in obj) {
      found.push(key);
    }
    ok(found.indexOf('foo') >= 0, 'should find computed property in iteration found=' + found);
    ok('foo' in obj, 'foo in obj should pass');
  });

  _internalTestHelpers.testBoth('when setting a value after it had been retrieved empty don\'t pass function UNDEFINED as oldValue', function (get, set) {
    var obj = {};
    var oldValueIsNoFunction = true;

    _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.computed({
      get: function () {},
      set: function (key, value, oldValue) {
        if (typeof oldValue === 'function') {
          oldValueIsNoFunction = false;
        }
        return undefined;
      }
    }));

    get(obj, 'foo');
    set(obj, 'foo', undefined);

    ok(oldValueIsNoFunction);
  });

  QUnit.module('computed - setter');

  _internalTestHelpers.testBoth('setting a watched computed property', function (get, set) {
    var obj = {
      firstName: 'Yehuda',
      lastName: 'Katz'
    };

    _emberMetalProperties.defineProperty(obj, 'fullName', _emberMetalComputed.computed({
      get: function () {
        return get(this, 'firstName') + ' ' + get(this, 'lastName');
      },
      set: function (key, value) {
        var values = value.split(' ');
        set(this, 'firstName', values[0]);
        set(this, 'lastName', values[1]);
        return value;
      }
    }).property('firstName', 'lastName'));

    var fullNameWillChange = 0;
    var fullNameDidChange = 0;
    var firstNameWillChange = 0;
    var firstNameDidChange = 0;
    var lastNameWillChange = 0;
    var lastNameDidChange = 0;
    _emberMetalObserver._addBeforeObserver(obj, 'fullName', function () {
      fullNameWillChange++;
    });
    _emberMetalObserver.addObserver(obj, 'fullName', function () {
      fullNameDidChange++;
    });
    _emberMetalObserver._addBeforeObserver(obj, 'firstName', function () {
      firstNameWillChange++;
    });
    _emberMetalObserver.addObserver(obj, 'firstName', function () {
      firstNameDidChange++;
    });
    _emberMetalObserver._addBeforeObserver(obj, 'lastName', function () {
      lastNameWillChange++;
    });
    _emberMetalObserver.addObserver(obj, 'lastName', function () {
      lastNameDidChange++;
    });

    equal(get(obj, 'fullName'), 'Yehuda Katz');

    set(obj, 'fullName', 'Yehuda Katz');

    set(obj, 'fullName', 'Kris Selden');

    equal(get(obj, 'fullName'), 'Kris Selden');
    equal(get(obj, 'firstName'), 'Kris');
    equal(get(obj, 'lastName'), 'Selden');

    equal(fullNameWillChange, 1);
    equal(fullNameDidChange, 1);
    equal(firstNameWillChange, 1);
    equal(firstNameDidChange, 1);
    equal(lastNameWillChange, 1);
    equal(lastNameDidChange, 1);
  });

  _internalTestHelpers.testBoth('setting a cached computed property that modifies the value you give it', function (get, set) {
    var obj = {
      foo: 0
    };

    _emberMetalProperties.defineProperty(obj, 'plusOne', _emberMetalComputed.computed({
      get: function (key) {
        return get(this, 'foo') + 1;
      },
      set: function (key, value) {
        set(this, 'foo', value);
        return value + 1;
      }
    }).property('foo'));

    var plusOneWillChange = 0;
    var plusOneDidChange = 0;
    _emberMetalObserver._addBeforeObserver(obj, 'plusOne', function () {
      plusOneWillChange++;
    });
    _emberMetalObserver.addObserver(obj, 'plusOne', function () {
      plusOneDidChange++;
    });

    equal(get(obj, 'plusOne'), 1);
    set(obj, 'plusOne', 1);
    equal(get(obj, 'plusOne'), 2);
    set(obj, 'plusOne', 1);
    equal(get(obj, 'plusOne'), 2);

    equal(plusOneWillChange, 1);
    equal(plusOneDidChange, 1);

    set(obj, 'foo', 5);
    equal(get(obj, 'plusOne'), 6);

    equal(plusOneWillChange, 2);
    equal(plusOneDidChange, 2);
  });

  QUnit.module('computed - default setter');

  _internalTestHelpers.testBoth('when setting a value on a computed property that doesn\'t handle sets', function (get, set) {
    var obj = {};
    var observerFired = false;

    _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.computed(function () {
      return 'foo';
    }));

    _emberMetalObserver.addObserver(obj, 'foo', null, function () {
      return observerFired = true;
    });

    set(obj, 'foo', 'bar');

    equal(get(obj, 'foo'), 'bar', 'The set value is properly returned');
    ok(typeof obj.foo === 'string', 'The computed property was removed');
    ok(observerFired, 'The observer was still notified');
  });

  QUnit.module('computed - readOnly');

  QUnit.test('is chainable', function () {
    var cp = _emberMetalComputed.computed(function () {}).readOnly();

    ok(cp instanceof _emberMetalProperties.Descriptor);
    ok(cp instanceof _emberMetalComputed.ComputedProperty);
  });

  QUnit.test('throws assertion if called over a CP with a setter defined with the new syntax', function () {
    expectAssertion(function () {
      _emberMetalComputed.computed({
        get: function () {},
        set: function () {}
      }).readOnly();
    }, /Computed properties that define a setter using the new syntax cannot be read-only/);
  });

  _internalTestHelpers.testBoth('protects against setting', function (get, set) {
    var obj = {};

    _emberMetalProperties.defineProperty(obj, 'bar', _emberMetalComputed.computed(function (key) {
      return 'barValue';
    }).readOnly());

    equal(get(obj, 'bar'), 'barValue');

    throws(function () {
      set(obj, 'bar', 'newBar');
    }, /Cannot set read\-only property "bar" on object:/);

    equal(get(obj, 'bar'), 'barValue');
  });
});
enifed('ember-metal/tests/computed_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/computed_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/computed_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/descriptor_test', ['exports', 'ember-runtime', 'ember-metal/mixin', 'ember-metal/properties', 'ember-metal/descriptor'], function (exports, _emberRuntime, _emberMetalMixin, _emberMetalProperties, _emberMetalDescriptor) {
  'use strict';

  // IE9 soft-fails when trying to delete a non-configurable property
  var hasCompliantDelete = (function () {
    var obj = {};

    Object.defineProperty(obj, 'zomg', { configurable: false, value: 'zomg' });

    try {
      delete obj.zomg;
    } catch (e) {
      return true;
    }

    return false;
  })();

  // IE9 soft-fails when trying to assign to a non-writable property
  var hasCompliantAssign = (function () {
    var obj = {};

    Object.defineProperty(obj, 'zomg', { writable: false, value: 'zomg' });

    try {
      obj.zomg = 'lol';
    } catch (e) {
      return true;
    }

    return false;
  })();

  var DescriptorTest = (function () {

    /* abstract static module(title: string); */

    DescriptorTest.test = function test(title, callback) {
      var _this = this;

      QUnit.test(title, function (assert) {
        callback(assert, new _this(assert));
      });
    };

    function DescriptorTest(assert) {
      this.assert = assert;
    }

    /* abstract install(key: string, desc: Descriptor); */

    /* abstract set(key: string, value: any); */

    /* abstract finalize(): Object; */
    return DescriptorTest;
  })();

  var classes = [(function (_DescriptorTest) {
    babelHelpers.inherits(_class, _DescriptorTest);

    _class.module = function module(title) {
      QUnit.module(title + ': using defineProperty on an object directly');
    };

    function _class(assert) {
      _DescriptorTest.call(this, assert);
      this.object = {};
    }

    _class.prototype.install = function install(key, desc) {
      var object = this.object;
      var assert = this.assert;

      _emberMetalProperties.defineProperty(object, key, desc);

      assert.ok(object.hasOwnProperty(key));
    };

    _class.prototype.set = function set(key, value) {
      this.object[key] = value;
    };

    _class.prototype.finalize = function finalize() {
      return this.object;
    };

    _class.prototype.source = function source() {
      return this.object;
    };

    return _class;
  })(DescriptorTest), (function (_DescriptorTest2) {
    babelHelpers.inherits(_class2, _DescriptorTest2);

    _class2.module = function module(title) {
      QUnit.module(title + ': using defineProperty on a prototype');
    };

    function _class2(assert) {
      _DescriptorTest2.call(this, assert);
      this.proto = {};
    }

    _class2.prototype.install = function install(key, desc) {
      var proto = this.proto;
      var assert = this.assert;

      _emberMetalProperties.defineProperty(proto, key, desc);

      assert.ok(proto.hasOwnProperty(key));
    };

    _class2.prototype.set = function set(key, value) {
      this.proto[key] = value;
    };

    _class2.prototype.finalize = function finalize() {
      return Object.create(this.proto);
    };

    _class2.prototype.source = function source() {
      return this.proto;
    };

    return _class2;
  })(DescriptorTest), (function (_DescriptorTest3) {
    babelHelpers.inherits(_class3, _DescriptorTest3);

    _class3.module = function module(title) {
      QUnit.module(title + ': in EmberObject.extend()');
    };

    function _class3(assert) {
      _DescriptorTest3.call(this, assert);
      this.klass = null;
      this.props = {};
    }

    _class3.prototype.install = function install(key, desc) {
      this.props[key] = desc;
    };

    _class3.prototype.set = function set(key, value) {
      this.props[key] = value;
    };

    _class3.prototype.finalize = function finalize() {
      this.klass = _emberRuntime.Object.extend(this.props);
      return this.klass.create();
    };

    _class3.prototype.source = function source() {
      return this.klass.prototype;
    };

    return _class3;
  })(DescriptorTest), (function (_DescriptorTest4) {
    babelHelpers.inherits(_class4, _DescriptorTest4);

    _class4.module = function module(title) {
      QUnit.module(title + ': in EmberObject.extend() through a mixin');
    };

    function _class4(assert) {
      _DescriptorTest4.call(this, assert);
      this.klass = null;
      this.props = {};
    }

    _class4.prototype.install = function install(key, desc) {
      this.props[key] = desc;
    };

    _class4.prototype.set = function set(key, value) {
      this.props[key] = value;
    };

    _class4.prototype.finalize = function finalize() {
      this.klass = _emberRuntime.Object.extend(_emberMetalMixin.Mixin.create(this.props));
      return this.klass.create();
    };

    _class4.prototype.source = function source() {
      return this.klass.prototype;
    };

    return _class4;
  })(DescriptorTest), (function (_DescriptorTest5) {
    babelHelpers.inherits(_class5, _DescriptorTest5);

    _class5.module = function module(title) {
      QUnit.module(title + ': inherited from another EmberObject super class');
    };

    function _class5(assert) {
      _DescriptorTest5.call(this, assert);
      this.superklass = null;
      this.props = {};
    }

    _class5.prototype.install = function install(key, desc) {
      this.props[key] = desc;
    };

    _class5.prototype.set = function set(key, value) {
      this.props[key] = value;
    };

    _class5.prototype.finalize = function finalize() {
      this.superklass = _emberRuntime.Object.extend(this.props);
      return this.superklass.extend().create();
    };

    _class5.prototype.source = function source() {
      return this.superklass.prototype;
    };

    return _class5;
  })(DescriptorTest)];

  classes.forEach(function (TestClass) {
    TestClass.module('ember-metal/descriptor');

    TestClass.test('defining a configurable property', function (assert, factory) {
      factory.install('foo', _emberMetalDescriptor.default({ configurable: true, value: 'bar' }));

      var obj = factory.finalize();

      assert.equal(obj.foo, 'bar');

      var source = factory.source();

      delete source.foo;

      assert.strictEqual(obj.foo, undefined);

      Object.defineProperty(source, 'foo', { configurable: true, value: 'baz' });

      assert.equal(obj.foo, 'baz');
    });

    TestClass.test('defining a non-configurable property', function (assert, factory) {
      factory.install('foo', _emberMetalDescriptor.default({ configurable: false, value: 'bar' }));

      var obj = factory.finalize();

      assert.equal(obj.foo, 'bar');

      var source = factory.source();

      if (hasCompliantDelete) {
        assert.throws(function () {
          return delete source.foo;
        }, TypeError);
      } else {
        delete source.foo;
      }

      assert.throws(function () {
        return Object.defineProperty(source, 'foo', { configurable: true, value: 'baz' });
      }, TypeError);

      assert.equal(obj.foo, 'bar');
    });

    TestClass.test('defining an enumerable property', function (assert, factory) {
      factory.install('foo', _emberMetalDescriptor.default({ enumerable: true, value: 'bar' }));

      var obj = factory.finalize();

      assert.equal(obj.foo, 'bar');

      var source = factory.source();

      assert.ok(Object.keys(source).indexOf('foo') !== -1);
    });

    TestClass.test('defining a non-enumerable property', function (assert, factory) {
      factory.install('foo', _emberMetalDescriptor.default({ enumerable: false, value: 'bar' }));

      var obj = factory.finalize();

      assert.equal(obj.foo, 'bar');

      var source = factory.source();

      assert.ok(Object.keys(source).indexOf('foo') === -1);
    });

    TestClass.test('defining a writable property', function (assert, factory) {
      factory.install('foo', _emberMetalDescriptor.default({ writable: true, value: 'bar' }));

      var obj = factory.finalize();

      assert.equal(obj.foo, 'bar');

      var source = factory.source();

      source.foo = 'baz';

      assert.equal(obj.foo, 'baz');

      obj.foo = 'bat';

      assert.equal(obj.foo, 'bat');
    });

    TestClass.test('defining a non-writable property', function (assert, factory) {
      factory.install('foo', _emberMetalDescriptor.default({ writable: false, value: 'bar' }));

      var obj = factory.finalize();

      assert.equal(obj.foo, 'bar');

      var source = factory.source();

      if (hasCompliantAssign) {
        assert.throws(function () {
          return source.foo = 'baz';
        }, TypeError);
        assert.throws(function () {
          return obj.foo = 'baz';
        }, TypeError);
      } else {
        source.foo = 'baz';
        obj.foo = 'baz';
      }

      assert.equal(obj.foo, 'bar');
    });

    TestClass.test('defining a getter', function (assert, factory) {
      factory.install('foo', _emberMetalDescriptor.default({
        get: function () {
          return this.__foo__;
        }
      }));

      factory.set('__foo__', 'bar');

      var obj = factory.finalize();

      assert.equal(obj.foo, 'bar');

      obj.__foo__ = 'baz';

      assert.equal(obj.foo, 'baz');
    });

    TestClass.test('defining a setter', function (assert, factory) {
      factory.install('foo', _emberMetalDescriptor.default({
        set: function (value) {
          this.__foo__ = value;
        }
      }));

      factory.set('__foo__', 'bar');

      var obj = factory.finalize();

      assert.equal(obj.__foo__, 'bar');

      obj.foo = 'baz';

      assert.equal(obj.__foo__, 'baz');
    });

    TestClass.test('combining multiple setter and getters', function (assert, factory) {
      factory.install('foo', _emberMetalDescriptor.default({
        get: function () {
          return this.__foo__;
        },

        set: function (value) {
          this.__foo__ = value;
        }
      }));

      factory.set('__foo__', 'foo');

      factory.install('bar', _emberMetalDescriptor.default({
        get: function () {
          return this.__bar__;
        },

        set: function (value) {
          this.__bar__ = value;
        }
      }));

      factory.set('__bar__', 'bar');

      factory.install('fooBar', _emberMetalDescriptor.default({
        get: function () {
          return this.foo + '-' + this.bar;
        }
      }));

      var obj = factory.finalize();

      assert.equal(obj.fooBar, 'foo-bar');

      obj.foo = 'FOO';

      assert.equal(obj.fooBar, 'FOO-bar');

      obj.__bar__ = 'BAR';

      assert.equal(obj.fooBar, 'FOO-BAR');

      if (hasCompliantAssign) {
        assert.throws(function () {
          return obj.fooBar = 'foobar';
        }, TypeError);
      } else {
        obj.fooBar = 'foobar';
      }

      assert.equal(obj.fooBar, 'FOO-BAR');
    });
  });
});
enifed('ember-metal/tests/descriptor_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/descriptor_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/descriptor_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/error_test', ['exports', 'ember-metal/error'], function (exports, _emberMetalError) {
  'use strict';

  QUnit.module('Ember Error Throwing');

  QUnit.test('new Ember.Error displays provided message', function () {
    throws(function () {
      throw new _emberMetalError.default('A Message');
    }, function (e) {
      return e.message === 'A Message';
    }, 'the assigned message was displayed');
  });
});
enifed('ember-metal/tests/error_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/error_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/error_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/events_test', ['exports', 'ember-metal/mixin', 'ember-metal/meta', 'ember-metal/events'], function (exports, _emberMetalMixin, _emberMetalMeta, _emberMetalEvents) {
  'use strict';

  QUnit.module('system/props/events_test');

  QUnit.test('listener should receive event - removing should remove', function () {
    var obj = {};
    var count = 0;

    function F() {
      count++;
    }

    _emberMetalEvents.addListener(obj, 'event!', F);
    equal(count, 0, 'nothing yet');

    _emberMetalEvents.sendEvent(obj, 'event!');
    equal(count, 1, 'received event');

    _emberMetalEvents.removeListener(obj, 'event!', F);

    count = 0;
    _emberMetalEvents.sendEvent(obj, 'event!');
    equal(count, 0, 'received event');
  });

  QUnit.test('listeners should be inherited', function () {
    var obj = {};
    var count = 0;
    var F = function () {
      count++;
    };

    _emberMetalEvents.addListener(obj, 'event!', F);

    var obj2 = Object.create(obj);

    equal(count, 0, 'nothing yet');

    _emberMetalEvents.sendEvent(obj2, 'event!');
    equal(count, 1, 'received event');

    _emberMetalEvents.removeListener(obj2, 'event!', F);

    count = 0;
    _emberMetalEvents.sendEvent(obj2, 'event!');
    equal(count, 0, 'did not receive event');

    _emberMetalEvents.sendEvent(obj, 'event!');
    equal(count, 1, 'should still invoke on parent');
  });

  QUnit.test('adding a listener more than once should only invoke once', function () {
    var obj = {};
    var count = 0;
    function F() {
      count++;
    }
    _emberMetalEvents.addListener(obj, 'event!', F);
    _emberMetalEvents.addListener(obj, 'event!', F);

    _emberMetalEvents.sendEvent(obj, 'event!');
    equal(count, 1, 'should only invoke once');
  });

  QUnit.test('adding a listener with a target should invoke with target', function () {
    var obj = {};
    var target = undefined;

    target = {
      count: 0,
      method: function () {
        this.count++;
      }
    };

    _emberMetalEvents.addListener(obj, 'event!', target, target.method);
    _emberMetalEvents.sendEvent(obj, 'event!');
    equal(target.count, 1, 'should invoke');
  });

  QUnit.test('suspending a listener should not invoke during callback', function () {
    var obj = {};
    var target = undefined,
        otherTarget = undefined;

    target = {
      count: 0,
      method: function () {
        this.count++;
      }
    };

    otherTarget = {
      count: 0,
      method: function () {
        this.count++;
      }
    };

    _emberMetalEvents.addListener(obj, 'event!', target, target.method);
    _emberMetalEvents.addListener(obj, 'event!', otherTarget, otherTarget.method);

    function callback() {
      /*jshint validthis:true */
      equal(this, target);

      _emberMetalEvents.sendEvent(obj, 'event!');

      return 'result';
    }

    _emberMetalEvents.sendEvent(obj, 'event!');

    equal(_emberMetalEvents.suspendListener(obj, 'event!', target, target.method, callback), 'result');

    _emberMetalEvents.sendEvent(obj, 'event!');

    equal(target.count, 2, 'should invoke');
    equal(otherTarget.count, 3, 'should invoke');
  });

  QUnit.test('adding a listener with string method should lookup method on event delivery', function () {
    var obj = {};
    var target = undefined;

    target = {
      count: 0,
      method: function () {}
    };

    _emberMetalEvents.addListener(obj, 'event!', target, 'method');
    _emberMetalEvents.sendEvent(obj, 'event!');
    equal(target.count, 0, 'should invoke but do nothing');

    target.method = function () {
      this.count++;
    };
    _emberMetalEvents.sendEvent(obj, 'event!');
    equal(target.count, 1, 'should invoke now');
  });

  QUnit.test('calling sendEvent with extra params should be passed to listeners', function () {
    var obj = {};
    var params = null;
    _emberMetalEvents.addListener(obj, 'event!', function () {
      params = Array.prototype.slice.call(arguments);
    });

    _emberMetalEvents.sendEvent(obj, 'event!', ['foo', 'bar']);
    deepEqual(params, ['foo', 'bar'], 'params should be saved');
  });

  QUnit.test('hasListeners tells you if there are listeners for a given event', function () {
    var obj = {};

    function F() {}
    function F2() {}

    equal(_emberMetalEvents.hasListeners(obj, 'event!'), false, 'no listeners at first');

    _emberMetalEvents.addListener(obj, 'event!', F);
    _emberMetalEvents.addListener(obj, 'event!', F2);

    equal(_emberMetalEvents.hasListeners(obj, 'event!'), true, 'has listeners');

    _emberMetalEvents.removeListener(obj, 'event!', F);
    equal(_emberMetalEvents.hasListeners(obj, 'event!'), true, 'has listeners');

    _emberMetalEvents.removeListener(obj, 'event!', F2);
    equal(_emberMetalEvents.hasListeners(obj, 'event!'), false, 'has no more listeners');

    _emberMetalEvents.addListener(obj, 'event!', F);
    equal(_emberMetalEvents.hasListeners(obj, 'event!'), true, 'has listeners');
  });

  QUnit.test('calling removeListener without method should remove all listeners', function () {
    var obj = {};
    function F() {}
    function F2() {}

    equal(_emberMetalEvents.hasListeners(obj, 'event!'), false, 'no listeners at first');

    _emberMetalEvents.addListener(obj, 'event!', F);
    _emberMetalEvents.addListener(obj, 'event!', F2);

    equal(_emberMetalEvents.hasListeners(obj, 'event!'), true, 'has listeners');
    _emberMetalEvents.removeListener(obj, 'event!');

    equal(_emberMetalEvents.hasListeners(obj, 'event!'), false, 'has no more listeners');
  });

  QUnit.test('while suspended, it should not be possible to add a duplicate listener', function () {
    var obj = {};
    var target = undefined;

    target = {
      count: 0,
      method: function () {
        this.count++;
      }
    };

    _emberMetalEvents.addListener(obj, 'event!', target, target.method);

    function callback() {
      _emberMetalEvents.addListener(obj, 'event!', target, target.method);
    }

    _emberMetalEvents.sendEvent(obj, 'event!');

    _emberMetalEvents.suspendListener(obj, 'event!', target, target.method, callback);

    equal(target.count, 1, 'should invoke');
    equal(_emberMetalMeta.meta(obj).matchingListeners('event!').length, 3, 'a duplicate listener wasn\'t added');

    // now test suspendListeners...

    _emberMetalEvents.sendEvent(obj, 'event!');

    _emberMetalEvents.suspendListeners(obj, ['event!'], target, target.method, callback);

    equal(target.count, 2, 'should have invoked again');
    equal(_emberMetalMeta.meta(obj).matchingListeners('event!').length, 3, 'a duplicate listener wasn\'t added');
  });

  QUnit.test('a listener can be added as part of a mixin', function () {
    var triggered = 0;
    var MyMixin = _emberMetalMixin.Mixin.create({
      foo1: _emberMetalEvents.on('bar', function () {
        triggered++;
      }),

      foo2: _emberMetalEvents.on('bar', function () {
        triggered++;
      })
    });

    var obj = {};
    MyMixin.apply(obj);

    _emberMetalEvents.sendEvent(obj, 'bar');
    equal(triggered, 2, 'should invoke listeners');
  });

  QUnit.test('a listener added as part of a mixin may be overridden', function () {
    var triggered = 0;
    var FirstMixin = _emberMetalMixin.Mixin.create({
      foo: _emberMetalEvents.on('bar', function () {
        triggered++;
      })
    });
    var SecondMixin = _emberMetalMixin.Mixin.create({
      foo: _emberMetalEvents.on('baz', function () {
        triggered++;
      })
    });

    var obj = {};
    FirstMixin.apply(obj);
    SecondMixin.apply(obj);

    _emberMetalEvents.sendEvent(obj, 'bar');
    equal(triggered, 0, 'should not invoke from overriden property');

    _emberMetalEvents.sendEvent(obj, 'baz');
    equal(triggered, 1, 'should invoke from subclass property');
  });
});
enifed('ember-metal/tests/events_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/events_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/events_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/expand_properties_test', ['exports', 'ember-metal/expand_properties'], function (exports, _emberMetalExpand_properties) {
  'use strict';

  var foundProperties = [];

  function addProperty(property) {
    foundProperties.push(property);
  }

  QUnit.module('Property Brace Expansion Test', {
    setup: function () {
      foundProperties = [];
    }
  });

  QUnit.test('Properties without expansions are unaffected', function () {
    expect(1);

    _emberMetalExpand_properties.default('a', addProperty);
    _emberMetalExpand_properties.default('a.b', addProperty);
    _emberMetalExpand_properties.default('a.b.[]', addProperty);
    _emberMetalExpand_properties.default('a.b.@each.c', addProperty);

    deepEqual(['a', 'a.b', 'a.b.[]', 'a.b.@each.c'].sort(), foundProperties.sort());
  });

  QUnit.test('A single expansion at the end expands properly', function () {
    expect(1);

    _emberMetalExpand_properties.default('a.b.{c,d}', addProperty);

    deepEqual(['a.b.c', 'a.b.d'].sort(), foundProperties.sort());
  });

  QUnit.test('A property with only a brace expansion expands correctly', function () {
    expect(1);

    _emberMetalExpand_properties.default('{a,b,c}', addProperty);

    var expected = ['a', 'b', 'c'];
    deepEqual(expected.sort(), foundProperties.sort());
  });

  QUnit.test('Expansions with single properties only expand once', function () {
    expect(1);

    _emberMetalExpand_properties.default('a.b.{c}.d.{e}', addProperty);

    deepEqual(['a.b.c.d.e'], foundProperties);
  });

  QUnit.test('A single brace expansion expands correctly', function () {
    expect(1);

    _emberMetalExpand_properties.default('a.{b,c,d}.e', addProperty);

    var expected = ['a.b.e', 'a.c.e', 'a.d.e'];
    deepEqual(expected.sort(), foundProperties.sort());
  });

  QUnit.test('Multiple brace expansions work correctly', function () {
    expect(1);

    _emberMetalExpand_properties.default('{a,b,c}.d.{e,f}.g', addProperty);

    var expected = ['a.d.e.g', 'a.d.f.g', 'b.d.e.g', 'b.d.f.g', 'c.d.e.g', 'c.d.f.g'];
    deepEqual(expected.sort(), foundProperties.sort());
  });

  QUnit.test('A property with only brace expansions expands correctly', function () {
    expect(1);

    _emberMetalExpand_properties.default('{a,b,c}.{d}.{e,f}', addProperty);

    var expected = ['a.d.e', 'a.d.f', 'b.d.e', 'b.d.f', 'c.d.e', 'c.d.f'];
    deepEqual(expected.sort(), foundProperties.sort());
  });

  QUnit.test('Nested brace expansions are not allowed', function () {
    var nestedBraceProperties = ['a.{b.{c,d}}', 'a.{{b}.c}', 'a.{b,c}.{d.{e,f}.g', 'a.{b.{c}', 'a.{b,c}}'];

    nestedBraceProperties.forEach(function (invalidProperties) {
      expectAssertion(function () {
        return _emberMetalExpand_properties.default(invalidProperties, addProperty);
      });
    }, /Brace expanded properties have to be balanced and cannot be nested/);
  });

  QUnit.test('A pattern must be a string', function () {
    expect(1);

    expectAssertion(function () {
      _emberMetalExpand_properties.default([], addProperty);
    }, /A computed property key must be a string/);
  });

  QUnit.test('A pattern must not contain a space', function () {
    expect(1);

    expectAssertion(function () {
      _emberMetalExpand_properties.default('a, b', addProperty);
    }, /Brace expanded properties cannot contain spaces, e.g. "user.{firstName, lastName}" should be "user.{firstName,lastName}"/);
  });
});
enifed('ember-metal/tests/expand_properties_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/expand_properties_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/expand_properties_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/injected_property_test', ['exports', 'ember-utils', 'ember-metal/properties', 'ember-metal/property_get', 'ember-metal/property_set', 'ember-metal/injected_property'], function (exports, _emberUtils, _emberMetalProperties, _emberMetalProperty_get, _emberMetalProperty_set, _emberMetalInjected_property) {
  'use strict';

  QUnit.module('InjectedProperty');

  QUnit.test('injected properties should be descriptors', function () {
    ok(new _emberMetalInjected_property.default() instanceof _emberMetalProperties.Descriptor);
  });

  QUnit.test('injected properties should be overridable', function () {
    var obj = {};
    _emberMetalProperties.defineProperty(obj, 'foo', new _emberMetalInjected_property.default());

    _emberMetalProperty_set.set(obj, 'foo', 'bar');

    equal(_emberMetalProperty_get.get(obj, 'foo'), 'bar', 'should return the overriden value');
  });

  QUnit.test('getting on an object without an owner or container should fail assertion', function () {
    var obj = {};
    _emberMetalProperties.defineProperty(obj, 'foo', new _emberMetalInjected_property.default('type', 'name'));

    expectAssertion(function () {
      _emberMetalProperty_get.get(obj, 'foo');
    }, /Attempting to lookup an injected property on an object without a container, ensure that the object was instantiated via a container./);
  });

  QUnit.test('getting on an object without an owner but with a container should not fail', function () {
    var obj = {
      container: {
        lookup: function (key) {
          ok(true, 'should call container.lookup');
          return key;
        }
      }
    };

    _emberMetalProperties.defineProperty(obj, 'foo', new _emberMetalInjected_property.default('type', 'name'));

    equal(_emberMetalProperty_get.get(obj, 'foo'), 'type:name', 'should return the value of container.lookup');
  });

  QUnit.test('getting should return a lookup on the container', function () {
    expect(2);

    var obj = {};

    _emberUtils.setOwner(obj, {
      lookup: function (key) {
        ok(true, 'should call container.lookup');
        return key;
      }
    });

    _emberMetalProperties.defineProperty(obj, 'foo', new _emberMetalInjected_property.default('type', 'name'));

    equal(_emberMetalProperty_get.get(obj, 'foo'), 'type:name', 'should return the value of container.lookup');
  });

  QUnit.test('omitting the lookup name should default to the property name', function () {
    var obj = {};

    _emberUtils.setOwner(obj, {
      lookup: function (key) {
        return key;
      }
    });

    _emberMetalProperties.defineProperty(obj, 'foo', new _emberMetalInjected_property.default('type'));

    equal(_emberMetalProperty_get.get(obj, 'foo'), 'type:foo', 'should lookup the type using the property name');
  });
});
enifed('ember-metal/tests/injected_property_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/injected_property_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/injected_property_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/instrumentation_test', ['exports', 'ember-metal/instrumentation'], function (exports, _emberMetalInstrumentation) {
  'use strict';

  QUnit.module('Ember Instrumentation', {
    teardown: function () {
      _emberMetalInstrumentation.reset();
    }
  });

  QUnit.test('execute block even if no listeners', function () {
    var result = _emberMetalInstrumentation.instrument('render', {}, function () {
      return 'hello';
    });
    equal(result, 'hello', 'called block');
  });

  QUnit.test('subscribing to a simple path receives the listener', function () {
    expect(12);

    var sentPayload = {};
    var count = 0;

    _emberMetalInstrumentation.subscribe('render', {
      before: function (name, timestamp, payload) {
        if (count === 0) {
          strictEqual(name, 'render');
        } else {
          strictEqual(name, 'render.handlebars');
        }

        ok(typeof timestamp === 'number');
        strictEqual(payload, sentPayload);
      },

      after: function (name, timestamp, payload) {
        if (count === 0) {
          strictEqual(name, 'render');
        } else {
          strictEqual(name, 'render.handlebars');
        }

        ok(typeof timestamp === 'number');
        strictEqual(payload, sentPayload);

        count++;
      }
    });

    _emberMetalInstrumentation.instrument('render', sentPayload, function () {});

    _emberMetalInstrumentation.instrument('render.handlebars', sentPayload, function () {});
  });

  QUnit.test('returning a value from the before callback passes it to the after callback', function () {
    expect(2);

    var passthru1 = {};
    var passthru2 = {};

    _emberMetalInstrumentation.subscribe('render', {
      before: function (name, timestamp, payload) {
        return passthru1;
      },
      after: function (name, timestamp, payload, beforeValue) {
        strictEqual(beforeValue, passthru1);
      }
    });

    _emberMetalInstrumentation.subscribe('render', {
      before: function (name, timestamp, payload) {
        return passthru2;
      },
      after: function (name, timestamp, payload, beforeValue) {
        strictEqual(beforeValue, passthru2);
      }
    });

    _emberMetalInstrumentation.instrument('render', null, function () {});
  });

  QUnit.test('instrument with 2 args (name, callback) no payload', function () {
    expect(1);

    _emberMetalInstrumentation.subscribe('render', {
      before: function (name, timestamp, payload) {
        deepEqual(payload, {});
      },
      after: function () {}
    });

    _emberMetalInstrumentation.instrument('render', function () {});
  });

  QUnit.test('instrument with 3 args (name, callback, binding) no payload', function () {
    expect(2);

    var binding = {};
    _emberMetalInstrumentation.subscribe('render', {
      before: function (name, timestamp, payload) {
        deepEqual(payload, {});
      },
      after: function () {}
    });

    _emberMetalInstrumentation.instrument('render', function () {
      deepEqual(this, binding);
    }, binding);
  });

  QUnit.test('instrument with 3 args (name, payload, callback) with payload', function () {
    expect(1);

    var expectedPayload = { hi: 1 };
    _emberMetalInstrumentation.subscribe('render', {
      before: function (name, timestamp, payload) {
        deepEqual(payload, expectedPayload);
      },
      after: function () {}
    });

    _emberMetalInstrumentation.instrument('render', expectedPayload, function () {});
  });

  QUnit.test('instrument with 4 args (name, payload, callback, binding) with payload', function () {
    expect(2);

    var expectedPayload = { hi: 1 };
    var binding = {};
    _emberMetalInstrumentation.subscribe('render', {
      before: function (name, timestamp, payload) {
        deepEqual(payload, expectedPayload);
      },
      after: function () {}
    });

    _emberMetalInstrumentation.instrument('render', expectedPayload, function () {
      deepEqual(this, binding);
    }, binding);
  });

  QUnit.test('raising an exception in the instrumentation attaches it to the payload', function () {
    expect(2);

    var error = new Error('Instrumentation');

    _emberMetalInstrumentation.subscribe('render', {
      before: function () {},
      after: function (name, timestamp, payload) {
        strictEqual(payload.exception, error);
      }
    });

    _emberMetalInstrumentation.subscribe('render', {
      before: function () {},
      after: function (name, timestamp, payload) {
        strictEqual(payload.exception, error);
      }
    });

    _emberMetalInstrumentation.instrument('render.handlebars', null, function () {
      throw error;
    });
  });

  QUnit.test('it is possible to add a new subscriber after the first instrument', function () {
    _emberMetalInstrumentation.instrument('render.handlebars', null, function () {});

    _emberMetalInstrumentation.subscribe('render', {
      before: function () {
        ok(true, 'Before callback was called');
      },
      after: function () {
        ok(true, 'After callback was called');
      }
    });

    _emberMetalInstrumentation.instrument('render.handlebars', null, function () {});
  });

  QUnit.test('it is possible to remove a subscriber', function () {
    expect(4);

    var count = 0;

    var subscriber = _emberMetalInstrumentation.subscribe('render', {
      before: function () {
        equal(count, 0);
        ok(true, 'Before callback was called');
      },
      after: function () {
        equal(count, 0);
        ok(true, 'After callback was called');
        count++;
      }
    });

    _emberMetalInstrumentation.instrument('render.handlebars', null, function () {});

    _emberMetalInstrumentation.unsubscribe(subscriber);

    _emberMetalInstrumentation.instrument('render.handlebars', null, function () {});
  });
});
enifed('ember-metal/tests/instrumentation_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/instrumentation_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/instrumentation_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/is_blank_test', ['exports', 'ember-metal/is_blank'], function (exports, _emberMetalIs_blank) {
  'use strict';

  QUnit.module('Ember.isBlank');

  QUnit.test('Ember.isBlank', function () {
    var string = 'string';
    var fn = function () {};
    var object = { length: 0 };

    equal(true, _emberMetalIs_blank.default(null), 'for null');
    equal(true, _emberMetalIs_blank.default(undefined), 'for undefined');
    equal(true, _emberMetalIs_blank.default(''), 'for an empty String');
    equal(true, _emberMetalIs_blank.default('  '), 'for a whitespace String');
    equal(true, _emberMetalIs_blank.default('\n\t'), 'for another whitespace String');
    equal(false, _emberMetalIs_blank.default('\n\t Hi'), 'for a String with whitespaces');
    equal(false, _emberMetalIs_blank.default(true), 'for true');
    equal(false, _emberMetalIs_blank.default(false), 'for false');
    equal(false, _emberMetalIs_blank.default(string), 'for a String');
    equal(false, _emberMetalIs_blank.default(fn), 'for a Function');
    equal(false, _emberMetalIs_blank.default(0), 'for 0');
    equal(true, _emberMetalIs_blank.default([]), 'for an empty Array');
    equal(false, _emberMetalIs_blank.default({}), 'for an empty Object');
    equal(true, _emberMetalIs_blank.default(object), 'for an Object that has zero \'length\'');
    equal(false, _emberMetalIs_blank.default([1, 2, 3]), 'for a non-empty array');
  });
});
enifed('ember-metal/tests/is_blank_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/is_blank_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/is_blank_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/is_empty_test', ['exports', 'ember-metal/is_empty', 'ember-metal/map'], function (exports, _emberMetalIs_empty, _emberMetalMap) {
  'use strict';

  QUnit.module('Ember.isEmpty');

  QUnit.test('Ember.isEmpty', function () {
    var string = 'string';
    var fn = function () {};
    var object = { length: 0 };

    equal(true, _emberMetalIs_empty.default(null), 'for null');
    equal(true, _emberMetalIs_empty.default(undefined), 'for undefined');
    equal(true, _emberMetalIs_empty.default(''), 'for an empty String');
    equal(false, _emberMetalIs_empty.default('  '), 'for a whitespace String');
    equal(false, _emberMetalIs_empty.default('\n\t'), 'for another whitespace String');
    equal(false, _emberMetalIs_empty.default(true), 'for true');
    equal(false, _emberMetalIs_empty.default(false), 'for false');
    equal(false, _emberMetalIs_empty.default(string), 'for a String');
    equal(false, _emberMetalIs_empty.default(fn), 'for a Function');
    equal(false, _emberMetalIs_empty.default(0), 'for 0');
    equal(true, _emberMetalIs_empty.default([]), 'for an empty Array');
    equal(false, _emberMetalIs_empty.default({}), 'for an empty Object');
    equal(true, _emberMetalIs_empty.default(object), 'for an Object that has zero \'length\'');
  });

  QUnit.test('Ember.isEmpty Ember.Map', function () {
    var map = new _emberMetalMap.Map();
    equal(true, _emberMetalIs_empty.default(map), 'Empty map is empty');
    map.set('foo', 'bar');
    equal(false, _emberMetalIs_empty.default(map), 'Map is not empty');
  });

  QUnit.test('Ember.isEmpty Ember.OrderedSet', function () {
    var orderedSet = new _emberMetalMap.OrderedSet();
    equal(true, _emberMetalIs_empty.default(orderedSet), 'Empty ordered set is empty');
    orderedSet.add('foo');
    equal(false, _emberMetalIs_empty.default(orderedSet), 'Ordered set is not empty');
  });
});
enifed('ember-metal/tests/is_empty_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/is_empty_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/is_empty_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/is_none_test', ['exports', 'ember-metal/is_none'], function (exports, _emberMetalIs_none) {
  'use strict';

  QUnit.module('Ember.isNone');

  QUnit.test('Ember.isNone', function () {
    var string = 'string';
    var fn = function () {};

    equal(true, _emberMetalIs_none.default(null), 'for null');
    equal(true, _emberMetalIs_none.default(undefined), 'for undefined');
    equal(false, _emberMetalIs_none.default(''), 'for an empty String');
    equal(false, _emberMetalIs_none.default(true), 'for true');
    equal(false, _emberMetalIs_none.default(false), 'for false');
    equal(false, _emberMetalIs_none.default(string), 'for a String');
    equal(false, _emberMetalIs_none.default(fn), 'for a Function');
    equal(false, _emberMetalIs_none.default(0), 'for 0');
    equal(false, _emberMetalIs_none.default([]), 'for an empty Array');
    equal(false, _emberMetalIs_none.default({}), 'for an empty Object');
  });
});
enifed('ember-metal/tests/is_none_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/is_none_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/is_none_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/is_present_test', ['exports', 'ember-metal/is_present'], function (exports, _emberMetalIs_present) {
  'use strict';

  QUnit.module('Ember.isPresent');

  QUnit.test('Ember.isPresent', function () {
    var string = 'string';
    var fn = function () {};
    var object = { length: 0 };

    equal(false, _emberMetalIs_present.default(), 'for no params');
    equal(false, _emberMetalIs_present.default(null), 'for null');
    equal(false, _emberMetalIs_present.default(undefined), 'for undefined');
    equal(false, _emberMetalIs_present.default(''), 'for an empty String');
    equal(false, _emberMetalIs_present.default('  '), 'for a whitespace String');
    equal(false, _emberMetalIs_present.default('\n\t'), 'for another whitespace String');
    equal(true, _emberMetalIs_present.default('\n\t Hi'), 'for a String with whitespaces');
    equal(true, _emberMetalIs_present.default(true), 'for true');
    equal(true, _emberMetalIs_present.default(false), 'for false');
    equal(true, _emberMetalIs_present.default(string), 'for a String');
    equal(true, _emberMetalIs_present.default(fn), 'for a Function');
    equal(true, _emberMetalIs_present.default(0), 'for 0');
    equal(false, _emberMetalIs_present.default([]), 'for an empty Array');
    equal(true, _emberMetalIs_present.default({}), 'for an empty Object');
    equal(false, _emberMetalIs_present.default(object), 'for an Object that has zero \'length\'');
    equal(true, _emberMetalIs_present.default([1, 2, 3]), 'for a non-empty array');
  });
});
enifed('ember-metal/tests/is_present_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/is_present_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/is_present_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/libraries_test', ['exports', 'ember-metal/debug', 'ember-metal/features', 'ember-metal/libraries'], function (exports, _emberMetalDebug, _emberMetalFeatures, _emberMetalLibraries) {
  /* globals EmberDev */
  'use strict';

  var libs = undefined,
      registry = undefined;
  var originalWarn = _emberMetalDebug.getDebugFunction('warn');

  QUnit.module('Libraries registry', {
    setup: function () {
      libs = new _emberMetalLibraries.Libraries();
      registry = libs._registry;
    },

    teardown: function () {
      libs = null;
      registry = null;

      _emberMetalDebug.setDebugFunction('warn', originalWarn);
    }
  });

  QUnit.test('core libraries come before other libraries', function () {
    expect(2);

    libs.register('my-lib', '2.0.0a');
    libs.registerCoreLibrary('DS', '1.0.0-beta.2');

    equal(registry[0].name, 'DS');
    equal(registry[1].name, 'my-lib');
  });

  QUnit.test('only the first registration of a library is stored', function () {
    expect(3);

    libs.register('magic', 1.23);
    libs.register('magic', 2.23);

    equal(registry[0].name, 'magic');
    equal(registry[0].version, 1.23);
    equal(registry.length, 1);
  });

  if (_emberMetalFeatures.default('ember-libraries-isregistered')) {
    QUnit.test('isRegistered returns correct value', function () {
      expect(3);

      equal(libs.isRegistered('magic'), false);

      libs.register('magic', 1.23);
      equal(libs.isRegistered('magic'), true);

      libs.deRegister('magic');
      equal(libs.isRegistered('magic'), false);
    });
  }

  QUnit.test('attempting to register a library that is already registered warns you', function () {
    if (EmberDev && EmberDev.runningProdBuild) {
      ok(true, 'Logging does not occur in production builds');
      return;
    }

    expect(1);

    libs.register('magic', 1.23);

    _emberMetalDebug.setDebugFunction('warn', function (msg, test) {
      if (!test) {
        equal(msg, 'Library "magic" is already registered with Ember.');
      }
    });

    // Should warn us
    libs.register('magic', 2.23);
  });

  QUnit.test('libraries can be de-registered', function () {
    expect(2);

    libs.register('lib1', '1.0.0b');
    libs.register('lib2', '1.0.0b');
    libs.register('lib3', '1.0.0b');

    libs.deRegister('lib1');
    libs.deRegister('lib3');

    equal(registry[0].name, 'lib2');
    equal(registry.length, 1);
  });
});
enifed('ember-metal/tests/libraries_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/libraries_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/libraries_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/main_test', ['exports', 'ember-metal/index'], function (exports, _emberMetalIndex) {
  'use strict';

  // testing reexports

  // From sindresourhus/semver-regex https://github.com/sindresorhus/semver-regex/blob/795b05628d96597ebcbe6d31ef4a432858365582/index.js#L3
  var SEMVER_REGEX = /^\bv?(?:0|[1-9][0-9]*)\.(?:0|[1-9][0-9]*)\.(?:0|[1-9][0-9]*)(?:-[\da-z\-]+(?:\.[\da-z\-]+)*)?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?\b$/;

  QUnit.module('ember-metal/core/main');

  QUnit.test('Ember registers itself', function () {
    var lib = _emberMetalIndex.default.libraries._registry[0];

    equal(lib.name, 'Ember');
    equal(lib.version, _emberMetalIndex.default.VERSION);
  });

  QUnit.test('Ember.VERSION is in alignment with SemVer v2.0.0', function () {
    ok(SEMVER_REGEX.test(_emberMetalIndex.default.VERSION), 'Ember.VERSION (' + _emberMetalIndex.default.VERSION + ')is valid SemVer v2.0.0');
  });

  QUnit.test('SEMVER_REGEX properly validates and invalidates version numbers', function () {
    function validateVersionString(versionString, expectedResult) {
      equal(SEMVER_REGEX.test(versionString), expectedResult);
    }

    // Postive test cases
    validateVersionString('1.11.3', true);
    validateVersionString('1.0.0-beta.16.1', true);
    validateVersionString('1.12.1+canary.aba1412', true);
    validateVersionString('2.0.0-beta.1+canary.bb344775', true);

    // Negative test cases
    validateVersionString('1.11.3.aba18a', false);
    validateVersionString('1.11', false);
  });

  QUnit.test('Ember.keys is deprecated', function () {
    expectDeprecation(function () {
      _emberMetalIndex.default.keys({});
    }, 'Ember.keys is deprecated in favor of Object.keys');
  });

  QUnit.test('Ember.create is deprecated', function () {
    expectDeprecation(function () {
      _emberMetalIndex.default.create(null);
    }, 'Ember.create is deprecated in favor of Object.create');
  });

  QUnit.test('Ember.Backburner is deprecated', function () {
    expectDeprecation(function () {
      new _emberMetalIndex.default.Backburner(['foo']);
    }, 'Usage of Ember.Backburner is deprecated.');
  });

  QUnit.test('Ember.K is deprecated', function (assert) {
    expectDeprecation(function () {
      var obj = {
        noop: _emberMetalIndex.default.K
      };

      assert.equal(obj, obj.noop());
    }, 'Ember.K is deprecated in favor of defining a function inline.');
  });
});
enifed('ember-metal/tests/main_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/main_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/main_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/map_test', ['exports', 'ember-metal/map'], function (exports, _emberMetalMap) {
  'use strict';

  var object = undefined,
      number = undefined,
      string = undefined,
      map = undefined,
      variety = undefined;
  var varieties = [['Map', _emberMetalMap.Map], ['MapWithDefault', _emberMetalMap.MapWithDefault]];

  function testMap(nameAndFunc) {
    variety = nameAndFunc[0];

    QUnit.module('Ember.' + variety + ' (forEach and get are implicitly tested)', {
      setup: function () {
        object = {};
        number = 42;
        string = 'foo';

        map = nameAndFunc[1].create();
      }
    });

    var mapHasLength = function (expected, theMap) {
      theMap = theMap || map;

      var length = 0;
      theMap.forEach(function () {
        length++;
      });

      equal(length, expected, 'map should contain ' + expected + ' items');
    };

    var mapHasEntries = function (entries, theMap) {
      theMap = theMap || map;

      for (var i = 0; i < entries.length; i++) {
        equal(theMap.get(entries[i][0]), entries[i][1]);
        equal(theMap.has(entries[i][0]), true);
      }

      mapHasLength(entries.length, theMap);
    };

    var unboundThis = undefined;

    (function () {
      unboundThis = this;
    })();

    QUnit.test('set', function () {
      map.set(object, 'winning');
      map.set(number, 'winning');
      map.set(string, 'winning');

      mapHasEntries([[object, 'winning'], [number, 'winning'], [string, 'winning']]);

      map.set(object, 'losing');
      map.set(number, 'losing');
      map.set(string, 'losing');

      mapHasEntries([[object, 'losing'], [number, 'losing'], [string, 'losing']]);

      equal(map.has('nope'), false, 'expected the key `nope` to not be present');
      equal(map.has({}), false, 'expected they key `{}` to not be present');
    });

    QUnit.test('set chaining', function () {
      map.set(object, 'winning').set(number, 'winning').set(string, 'winning');

      mapHasEntries([[object, 'winning'], [number, 'winning'], [string, 'winning']]);

      map.set(object, 'losing').set(number, 'losing').set(string, 'losing');

      mapHasEntries([[object, 'losing'], [number, 'losing'], [string, 'losing']]);

      equal(map.has('nope'), false, 'expected the key `nope` to not be present');
      equal(map.has({}), false, 'expected they key `{}` to not be present');
    });

    QUnit.test('with key with undefined value', function () {
      map.set('foo', undefined);

      map.forEach(function (value, key) {
        equal(value, undefined);
        equal(key, 'foo');
      });

      ok(map.has('foo'), 'has key foo, even with undefined value');

      equal(map.size, 1);
    });

    QUnit.test('arity of forEach is 1 – es6 23.1.3.5', function () {
      equal(map.forEach.length, 1, 'expected arity for map.forEach is 1');
    });

    QUnit.test('forEach throws without a callback as the first argument', function () {
      equal(map.forEach.length, 1, 'expected arity for map.forEach is 1');
    });

    QUnit.test('has empty collection', function () {
      equal(map.has('foo'), false);
      equal(map.has(), false);
    });

    QUnit.test('delete', function () {
      expectNoDeprecation();

      map.set(object, 'winning');
      map.set(number, 'winning');
      map.set(string, 'winning');

      map.delete(object);
      map.delete(number);
      map.delete(string);

      // doesn't explode
      map.delete({});

      mapHasEntries([]);
    });

    QUnit.test('copy and then update', function () {
      map.set(object, 'winning');
      map.set(number, 'winning');
      map.set(string, 'winning');

      var map2 = map.copy();

      map2.set(object, 'losing');
      map2.set(number, 'losing');
      map2.set(string, 'losing');

      mapHasEntries([[object, 'winning'], [number, 'winning'], [string, 'winning']]);

      mapHasEntries([[object, 'losing'], [number, 'losing'], [string, 'losing']], map2);
    });

    QUnit.test('copy and then delete', function () {
      map.set(object, 'winning');
      map.set(number, 'winning');
      map.set(string, 'winning');

      var map2 = map.copy();

      map2.delete(object);
      map2.delete(number);
      map2.delete(string);

      mapHasEntries([[object, 'winning'], [number, 'winning'], [string, 'winning']]);

      mapHasEntries([], map2);
    });

    QUnit.test('size', function () {
      //Add a key twice
      equal(map.size, 0);
      map.set(string, 'a string');
      equal(map.size, 1);
      map.set(string, 'the same string');
      equal(map.size, 1);

      //Add another
      map.set(number, 'a number');
      equal(map.size, 2);

      //Remove one that doesn't exist
      map.delete('does not exist');
      equal(map.size, 2);

      //Check copy
      var copy = map.copy();
      equal(copy.size, 2);

      //Remove a key twice
      map.delete(number);
      equal(map.size, 1);
      map.delete(number);
      equal(map.size, 1);

      //Remove the last key
      map.delete(string);
      equal(map.size, 0);
      map.delete(string);
      equal(map.size, 0);
    });

    QUnit.test('forEach without proper callback', function () {
      QUnit.throws(function () {
        map.forEach();
      }, '[object Undefined] is not a function');

      QUnit.throws(function () {
        map.forEach(undefined);
      }, '[object Undefined] is not a function');

      QUnit.throws(function () {
        map.forEach(1);
      }, '[object Number] is not a function');

      QUnit.throws(function () {
        map.forEach({});
      }, '[object Object] is not a function');

      map.forEach(function (value, key) {
        map.delete(key);
      });
      // ensure the error happens even if no data is present
      equal(map.size, 0);
      QUnit.throws(function () {
        map.forEach({});
      }, '[object Object] is not a function');
    });

    QUnit.test('forEach basic', function () {
      map.set('a', 1);
      map.set('b', 2);
      map.set('c', 3);

      var iteration = 0;

      var expectations = [{ value: 1, key: 'a', context: unboundThis }, { value: 2, key: 'b', context: unboundThis }, { value: 3, key: 'c', context: unboundThis }];

      map.forEach(function (value, key, theMap) {
        var expectation = expectations[iteration];

        equal(value, expectation.value, 'value should be correct');
        equal(key, expectation.key, 'key should be correct');
        equal(this, expectation.context, 'context should be as if it was unbound');
        equal(map, theMap, 'map being iterated over should be passed in');

        iteration++;
      });

      equal(iteration, 3, 'expected 3 iterations');
    });

    QUnit.test('forEach basic /w context', function () {
      map.set('a', 1);
      map.set('b', 2);
      map.set('c', 3);

      var iteration = 0;
      var context = {};
      var expectations = [{ value: 1, key: 'a', context: context }, { value: 2, key: 'b', context: context }, { value: 3, key: 'c', context: context }];

      map.forEach(function (value, key, theMap) {
        var expectation = expectations[iteration];

        equal(value, expectation.value, 'value should be correct');
        equal(key, expectation.key, 'key should be correct');
        equal(this, expectation.context, 'context should be as if it was unbound');
        equal(map, theMap, 'map being iterated over should be passed in');

        iteration++;
      }, context);

      equal(iteration, 3, 'expected 3 iterations');
    });

    QUnit.test('forEach basic /w deletion while enumerating', function () {
      map.set('a', 1);
      map.set('b', 2);
      map.set('c', 3);

      var iteration = 0;

      var expectations = [{ value: 1, key: 'a', context: unboundThis }, { value: 2, key: 'b', context: unboundThis }];

      map.forEach(function (value, key, theMap) {
        if (iteration === 0) {
          map.delete('c');
        }

        var expectation = expectations[iteration];

        equal(value, expectation.value, 'value should be correct');
        equal(key, expectation.key, 'key should be correct');
        equal(this, expectation.context, 'context should be as if it was unbound');
        equal(map, theMap, 'map being iterated over should be passed in');

        iteration++;
      });

      equal(iteration, 2, 'expected 3 iterations');
    });

    QUnit.test('forEach basic /w addition while enumerating', function () {
      map.set('a', 1);
      map.set('b', 2);
      map.set('c', 3);

      var iteration = 0;

      var expectations = [{ value: 1, key: 'a', context: unboundThis }, { value: 2, key: 'b', context: unboundThis }, { value: 3, key: 'c', context: unboundThis }, { value: 4, key: 'd', context: unboundThis }];

      map.forEach(function (value, key, theMap) {
        if (iteration === 0) {
          map.set('d', 4);
        }

        var expectation = expectations[iteration];

        equal(value, expectation.value, 'value should be correct');
        equal(key, expectation.key, 'key should be correct');
        equal(this, expectation.context, 'context should be as if it was unbound');
        equal(map, theMap, 'map being iterated over should be passed in');

        iteration++;
      });

      equal(iteration, 4, 'expected 3 iterations');
    });

    QUnit.test('clear', function () {
      var iterations = 0;

      map.set('a', 1);
      map.set('b', 2);
      map.set('c', 3);
      map.set('d', 4);

      equal(map.size, 4);

      map.forEach(function () {
        iterations++;
      });
      equal(iterations, 4);

      map.clear();
      equal(map.size, 0);
      iterations = 0;
      map.forEach(function () {
        iterations++;
      });
      equal(iterations, 0);
    });

    QUnit.test('-0', function () {
      equal(map.has(-0), false);
      equal(map.has(0), false);

      map.set(-0, 'zero');

      equal(map.has(-0), true);
      equal(map.has(0), true);

      equal(map.get(0), 'zero');
      equal(map.get(-0), 'zero');

      map.forEach(function (value, key) {
        equal(1 / key, Infinity, 'spec says key should be positive zero');
      });
    });

    QUnit.test('NaN', function () {
      equal(map.has(NaN), false);

      map.set(NaN, 'not-a-number');

      equal(map.has(NaN), true);

      equal(map.get(NaN), 'not-a-number');
    });

    QUnit.test('NaN Boxed', function () {
      //jshint -W053
      var boxed = new Number(NaN);
      equal(map.has(boxed), false);

      map.set(boxed, 'not-a-number');

      equal(map.has(boxed), true);
      equal(map.has(NaN), false);

      equal(map.get(NaN), undefined);
      equal(map.get(boxed), 'not-a-number');
    });

    QUnit.test('0 value', function () {
      var obj = {};
      equal(map.has(obj), false);

      equal(map.size, 0);
      map.set(obj, 0);
      equal(map.size, 1);

      equal(map.has(obj), true);
      equal(map.get(obj), 0);

      map.delete(obj);
      equal(map.has(obj), false);
      equal(map.get(obj), undefined);
      equal(map.size, 0);
    });
  }

  for (var i = 0; i < varieties.length; i++) {
    testMap(varieties[i]);
  }

  QUnit.module('MapWithDefault - default values');

  QUnit.test('Retrieving a value that has not been set returns and sets a default value', function () {
    var map = _emberMetalMap.MapWithDefault.create({
      defaultValue: function (key) {
        return [key];
      }
    });

    var value = map.get('ohai');
    deepEqual(value, ['ohai']);

    strictEqual(value, map.get('ohai'));
  });

  QUnit.test('Map.prototype.constructor', function () {
    var map = new _emberMetalMap.Map();
    equal(map.constructor, _emberMetalMap.Map);
  });

  QUnit.test('Map() without `new`', function () {
    QUnit.throws(function () {
      // jshint newcap:false
      _emberMetalMap.Map();
    }, /Constructor Map requires 'new'/);
  });

  QUnit.test('MapWithDefault.prototype.constructor', function () {
    var map = new _emberMetalMap.MapWithDefault({
      defaultValue: function (key) {
        return key;
      }
    });
    equal(map.constructor, _emberMetalMap.MapWithDefault);
  });

  QUnit.test('Copying a MapWithDefault copies the default value', function () {
    var map = _emberMetalMap.MapWithDefault.create({
      defaultValue: function (key) {
        return [key];
      }
    });

    map.set('ohai', 1);
    map.get('bai');

    var map2 = map.copy();

    equal(map2.get('ohai'), 1);
    deepEqual(map2.get('bai'), ['bai']);

    map2.set('kthx', 3);

    deepEqual(map.get('kthx'), ['kthx']);
    equal(map2.get('kthx'), 3);

    deepEqual(map2.get('default'), ['default']);

    map2.defaultValue = function (key) {
      return ['tom is on', key];
    };

    deepEqual(map2.get('drugs'), ['tom is on', 'drugs']);
  });

  QUnit.module('OrderedSet', {
    setup: function () {
      object = {};
      number = 42;
      string = 'foo';

      map = _emberMetalMap.OrderedSet.create();
    }
  });

  QUnit.test('OrderedSet() without `new`', function () {
    QUnit.throws(function () {
      // jshint newcap:false
      _emberMetalMap.OrderedSet();
    }, /Constructor OrderedSet requires 'new'/);
  });

  QUnit.test('add returns the set', function () {
    var obj = {};
    equal(map.add(obj), map);
    equal(map.add(obj), map, 'when it is already in the set');
  });
});
enifed('ember-metal/tests/map_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/map_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/map_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/meta_test', ['exports', 'ember-metal/meta'], function (exports, _emberMetalMeta) {
  'use strict';

  QUnit.module('Ember.meta');

  QUnit.test('should return the same hash for an object', function () {
    var obj = {};

    _emberMetalMeta.meta(obj).foo = 'bar';

    equal(_emberMetalMeta.meta(obj).foo, 'bar', 'returns same hash with multiple calls to Ember.meta()');
  });

  QUnit.test('meta is not enumerable', function () {
    var proto = undefined,
        obj = undefined,
        props = undefined,
        prop = undefined;
    proto = { foo: 'bar' };
    _emberMetalMeta.meta(proto);
    obj = Object.create(proto);
    _emberMetalMeta.meta(obj);
    obj.bar = 'baz';
    props = [];
    for (prop in obj) {
      props.push(prop);
    }
    deepEqual(props.sort(), ['bar', 'foo']);
    if (typeof JSON !== 'undefined' && 'stringify' in JSON) {
      try {
        JSON.stringify(obj);
      } catch (e) {
        ok(false, 'meta should not fail JSON.stringify');
      }
    }
  });

  QUnit.test('meta.listeners basics', function (assert) {
    var t = {};
    var m = _emberMetalMeta.meta({});
    m.addToListeners('hello', t, 'm', 0);
    var matching = m.matchingListeners('hello');
    assert.equal(matching.length, 3);
    assert.equal(matching[0], t);
    m.removeFromListeners('hello', t, 'm');
    matching = m.matchingListeners('hello');
    assert.equal(matching.length, 0);
  });

  QUnit.test('meta.listeners inheritance', function (assert) {
    var target = {};
    var parent = {};
    var parentMeta = _emberMetalMeta.meta(parent);
    parentMeta.addToListeners('hello', target, 'm', 0);

    var child = Object.create(parent);
    var m = _emberMetalMeta.meta(child);

    var matching = m.matchingListeners('hello');
    assert.equal(matching.length, 3);
    assert.equal(matching[0], target);
    assert.equal(matching[1], 'm');
    assert.equal(matching[2], 0);
    m.removeFromListeners('hello', target, 'm');
    matching = m.matchingListeners('hello');
    assert.equal(matching.length, 0);
    matching = parentMeta.matchingListeners('hello');
    assert.equal(matching.length, 3);
  });

  QUnit.test('meta.listeners deduplication', function (assert) {
    var t = {};
    var m = _emberMetalMeta.meta({});
    m.addToListeners('hello', t, 'm', 0);
    m.addToListeners('hello', t, 'm', 0);
    var matching = m.matchingListeners('hello');
    assert.equal(matching.length, 3);
    assert.equal(matching[0], t);
  });
});
enifed('ember-metal/tests/meta_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/meta_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/meta_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/mixin/alias_method_test', ['exports', 'ember-metal/property_get', 'ember-metal/mixin'], function (exports, _emberMetalProperty_get, _emberMetalMixin) {
  'use strict';

  QUnit.module('aliasMethod');

  function validateAliasMethod(obj) {
    equal(obj.fooMethod(), 'FOO', 'obj.fooMethod()');
    equal(obj.barMethod(), 'FOO', 'obj.barMethod should be a copy of foo');
  }

  QUnit.test('methods of another name are aliased when the mixin is applied', function () {
    var MyMixin = _emberMetalMixin.Mixin.create({
      fooMethod: function () {
        return 'FOO';
      },
      barMethod: _emberMetalMixin.aliasMethod('fooMethod')
    });

    var obj = MyMixin.apply({});
    validateAliasMethod(obj);
  });

  QUnit.test('should follow aliasMethods all the way down', function () {
    var MyMixin = _emberMetalMixin.Mixin.create({
      bar: _emberMetalMixin.aliasMethod('foo'), // put first to break ordered iteration
      baz: function () {
        return 'baz';
      },
      foo: _emberMetalMixin.aliasMethod('baz')
    });

    var obj = MyMixin.apply({});
    equal(_emberMetalProperty_get.get(obj, 'bar')(), 'baz', 'should have followed aliasMethods');
  });

  QUnit.test('should alias methods from other dependent mixins', function () {
    var BaseMixin = _emberMetalMixin.Mixin.create({
      fooMethod: function () {
        return 'FOO';
      }
    });

    var MyMixin = _emberMetalMixin.Mixin.create(BaseMixin, {
      barMethod: _emberMetalMixin.aliasMethod('fooMethod')
    });

    var obj = MyMixin.apply({});
    validateAliasMethod(obj);
  });

  QUnit.test('should alias methods from other mixins applied at same time', function () {
    var BaseMixin = _emberMetalMixin.Mixin.create({
      fooMethod: function () {
        return 'FOO';
      }
    });

    var MyMixin = _emberMetalMixin.Mixin.create({
      barMethod: _emberMetalMixin.aliasMethod('fooMethod')
    });

    var obj = _emberMetalMixin.mixin({}, BaseMixin, MyMixin);
    validateAliasMethod(obj);
  });

  QUnit.test('should alias methods from mixins already applied on object', function () {
    var BaseMixin = _emberMetalMixin.Mixin.create({
      quxMethod: function () {
        return 'qux';
      }
    });

    var MyMixin = _emberMetalMixin.Mixin.create({
      bar: _emberMetalMixin.aliasMethod('foo'),
      barMethod: _emberMetalMixin.aliasMethod('fooMethod')
    });

    var obj = {
      fooMethod: function () {
        return 'FOO';
      }
    };

    BaseMixin.apply(obj);
    MyMixin.apply(obj);

    validateAliasMethod(obj);
  });
});
enifed('ember-metal/tests/mixin/alias_method_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/mixin/alias_method_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/mixin/alias_method_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/mixin/apply_test', ['exports', 'ember-metal/property_get', 'ember-metal/mixin'], function (exports, _emberMetalProperty_get, _emberMetalMixin) {
  'use strict';

  QUnit.module('Ember.Mixin.apply');

  function K() {}

  QUnit.test('using apply() should apply properties', function () {
    var MixinA = _emberMetalMixin.Mixin.create({ foo: 'FOO', baz: K });
    var obj = {};
    _emberMetalMixin.mixin(obj, MixinA);

    equal(_emberMetalProperty_get.default(obj, 'foo'), 'FOO', 'should apply foo');
    equal(_emberMetalProperty_get.default(obj, 'baz'), K, 'should apply foo');
  });

  QUnit.test('applying anonymous properties', function () {
    var obj = {};
    _emberMetalMixin.mixin(obj, {
      foo: 'FOO',
      baz: K
    });

    equal(_emberMetalProperty_get.default(obj, 'foo'), 'FOO', 'should apply foo');
    equal(_emberMetalProperty_get.default(obj, 'baz'), K, 'should apply foo');
  });

  QUnit.test('applying null values', function () {
    expectAssertion(function () {
      return _emberMetalMixin.mixin({}, null);
    });
  });

  QUnit.test('applying a property with an undefined value', function () {
    var obj = { tagName: '' };
    _emberMetalMixin.mixin(obj, { tagName: undefined });

    strictEqual(_emberMetalProperty_get.default(obj, 'tagName'), '');
  });
});
enifed('ember-metal/tests/mixin/apply_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/mixin/apply_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/mixin/apply_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/mixin/computed_test', ['exports', 'ember-metal/property_get', 'ember-metal/property_set', 'ember-metal/mixin', 'ember-metal/computed', 'ember-metal/properties'], function (exports, _emberMetalProperty_get, _emberMetalProperty_set, _emberMetalMixin, _emberMetalComputed, _emberMetalProperties) {
  'use strict';

  function K() {
    return this;
  }

  QUnit.module('Mixin Computed Properties');

  QUnit.test('overriding computed properties', function () {
    var MixinA = undefined,
        MixinB = undefined,
        MixinC = undefined,
        MixinD = undefined;
    var obj = undefined;

    MixinA = _emberMetalMixin.Mixin.create({
      aProp: _emberMetalComputed.computed(function () {
        return 'A';
      })
    });

    MixinB = _emberMetalMixin.Mixin.create(MixinA, {
      aProp: _emberMetalComputed.computed(function () {
        return this._super.apply(this, arguments) + 'B';
      })
    });

    MixinC = _emberMetalMixin.Mixin.create(MixinA, {
      aProp: _emberMetalComputed.computed(function () {
        return this._super.apply(this, arguments) + 'C';
      })
    });

    MixinD = _emberMetalMixin.Mixin.create({
      aProp: _emberMetalComputed.computed(function () {
        return this._super.apply(this, arguments) + 'D';
      })
    });

    obj = {};
    MixinB.apply(obj);
    equal(_emberMetalProperty_get.get(obj, 'aProp'), 'AB', 'should expose super for B');

    obj = {};
    MixinC.apply(obj);
    equal(_emberMetalProperty_get.get(obj, 'aProp'), 'AC', 'should expose super for C');

    obj = {};

    MixinA.apply(obj);
    MixinD.apply(obj);
    equal(_emberMetalProperty_get.get(obj, 'aProp'), 'AD', 'should define super for D');

    obj = {};
    _emberMetalProperties.defineProperty(obj, 'aProp', _emberMetalComputed.computed(function (key) {
      return 'obj';
    }));
    MixinD.apply(obj);
    equal(_emberMetalProperty_get.get(obj, 'aProp'), 'objD', 'should preserve original computed property');
  });

  QUnit.test('calling set on overridden computed properties', function () {
    var SuperMixin = undefined,
        SubMixin = undefined;
    var obj = undefined;

    var superGetOccurred = false;
    var superSetOccurred = false;

    SuperMixin = _emberMetalMixin.Mixin.create({
      aProp: _emberMetalComputed.computed({
        get: function (key) {
          superGetOccurred = true;
        },
        set: function (key, value) {
          superSetOccurred = true;
        }
      })
    });

    SubMixin = _emberMetalMixin.Mixin.create(SuperMixin, {
      aProp: _emberMetalComputed.computed({
        get: function (key) {
          return this._super.apply(this, arguments);
        },
        set: function (key, value) {
          return this._super.apply(this, arguments);
        }
      })
    });

    obj = {};
    SubMixin.apply(obj);

    _emberMetalProperty_set.set(obj, 'aProp', 'set thyself');
    ok(superSetOccurred, 'should pass set to _super');

    superSetOccurred = false; // reset the set assertion

    obj = {};
    SubMixin.apply(obj);

    _emberMetalProperty_get.get(obj, 'aProp');
    ok(superGetOccurred, 'should pass get to _super');

    _emberMetalProperty_set.set(obj, 'aProp', 'set thyself');
    ok(superSetOccurred, 'should pass set to _super after getting');
  });

  QUnit.test('setter behavior works properly when overriding computed properties', function () {
    var obj = {};

    var MixinA = _emberMetalMixin.Mixin.create({
      cpWithSetter2: _emberMetalComputed.computed(K),
      cpWithSetter3: _emberMetalComputed.computed(K),
      cpWithoutSetter: _emberMetalComputed.computed(K)
    });

    var cpWasCalled = false;

    var MixinB = _emberMetalMixin.Mixin.create({
      cpWithSetter2: _emberMetalComputed.computed({
        get: K,
        set: function (k, v) {
          cpWasCalled = true;
        }
      }),

      cpWithSetter3: _emberMetalComputed.computed({
        get: K,
        set: function (k, v) {
          cpWasCalled = true;
        }
      }),

      cpWithoutSetter: _emberMetalComputed.computed(function (k) {
        cpWasCalled = true;
      })
    });

    MixinA.apply(obj);
    MixinB.apply(obj);

    _emberMetalProperty_set.set(obj, 'cpWithSetter2', 'test');
    ok(cpWasCalled, 'The computed property setter was called when defined with two args');
    cpWasCalled = false;

    _emberMetalProperty_set.set(obj, 'cpWithSetter3', 'test');
    ok(cpWasCalled, 'The computed property setter was called when defined with three args');
    cpWasCalled = false;

    _emberMetalProperty_set.set(obj, 'cpWithoutSetter', 'test');
    equal(_emberMetalProperty_get.get(obj, 'cpWithoutSetter'), 'test', 'The default setter was called, the value is correct');
    ok(!cpWasCalled, 'The default setter was called, not the CP itself');
  });
});
enifed('ember-metal/tests/mixin/computed_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/mixin/computed_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/mixin/computed_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/mixin/concatenated_properties_test', ['exports', 'ember-metal/property_get', 'ember-metal/mixin'], function (exports, _emberMetalProperty_get, _emberMetalMixin) {
  'use strict';

  QUnit.module('Mixin concatenatedProperties');

  QUnit.test('defining concatenated properties should concat future version', function () {
    var MixinA = _emberMetalMixin.Mixin.create({
      concatenatedProperties: ['foo'],
      foo: ['a', 'b', 'c']
    });

    var MixinB = _emberMetalMixin.Mixin.create({
      foo: ['d', 'e', 'f']
    });

    var obj = _emberMetalMixin.mixin({}, MixinA, MixinB);
    deepEqual(_emberMetalProperty_get.default(obj, 'foo'), ['a', 'b', 'c', 'd', 'e', 'f']);
  });

  QUnit.test('defining concatenated properties should concat future version', function () {
    var MixinA = _emberMetalMixin.Mixin.create({
      concatenatedProperties: null
    });

    var MixinB = _emberMetalMixin.Mixin.create({
      concatenatedProperties: null
    });

    var obj = _emberMetalMixin.mixin({}, MixinA, MixinB);

    deepEqual(obj.concatenatedProperties, []);
  });

  QUnit.test('concatenatedProperties should be concatenated', function () {
    var MixinA = _emberMetalMixin.Mixin.create({
      concatenatedProperties: ['foo'],
      foo: ['a', 'b', 'c']
    });

    var MixinB = _emberMetalMixin.Mixin.create({
      concatenatedProperties: 'bar',
      foo: ['d', 'e', 'f'],
      bar: [1, 2, 3]
    });

    var MixinC = _emberMetalMixin.Mixin.create({
      bar: [4, 5, 6]
    });

    var obj = _emberMetalMixin.mixin({}, MixinA, MixinB, MixinC);
    deepEqual(_emberMetalProperty_get.default(obj, 'concatenatedProperties'), ['foo', 'bar'], 'get concatenatedProperties');
    deepEqual(_emberMetalProperty_get.default(obj, 'foo'), ['a', 'b', 'c', 'd', 'e', 'f'], 'get foo');
    deepEqual(_emberMetalProperty_get.default(obj, 'bar'), [1, 2, 3, 4, 5, 6], 'get bar');
  });

  QUnit.test('adding a prop that is not an array should make array', function () {
    var MixinA = _emberMetalMixin.Mixin.create({
      concatenatedProperties: ['foo'],
      foo: [1, 2, 3]
    });

    var MixinB = _emberMetalMixin.Mixin.create({
      foo: 4
    });

    var obj = _emberMetalMixin.mixin({}, MixinA, MixinB);
    deepEqual(_emberMetalProperty_get.default(obj, 'foo'), [1, 2, 3, 4]);
  });

  QUnit.test('adding a prop that is not an array should make array', function () {
    var MixinA = _emberMetalMixin.Mixin.create({
      concatenatedProperties: ['foo'],
      foo: 'bar'
    });

    var obj = _emberMetalMixin.mixin({}, MixinA);
    deepEqual(_emberMetalProperty_get.default(obj, 'foo'), ['bar']);
  });

  QUnit.test('adding a non-concatenable property that already has a defined value should result in an array with both values', function () {
    var mixinA = _emberMetalMixin.Mixin.create({
      foo: 1
    });

    var mixinB = _emberMetalMixin.Mixin.create({
      concatenatedProperties: ['foo'],
      foo: 2
    });

    var obj = _emberMetalMixin.mixin({}, mixinA, mixinB);
    deepEqual(_emberMetalProperty_get.default(obj, 'foo'), [1, 2]);
  });

  QUnit.test('adding a concatenable property that already has a defined value should result in a concatenated value', function () {
    var mixinA = _emberMetalMixin.Mixin.create({
      foobar: 'foo'
    });

    var mixinB = _emberMetalMixin.Mixin.create({
      concatenatedProperties: ['foobar'],
      foobar: 'bar'
    });

    var obj = _emberMetalMixin.mixin({}, mixinA, mixinB);
    deepEqual(_emberMetalProperty_get.default(obj, 'foobar'), ['foo', 'bar']);
  });
});
enifed('ember-metal/tests/mixin/concatenated_properties_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/mixin/concatenated_properties_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/mixin/concatenated_properties_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/mixin/detect_test', ['exports', 'ember-metal/mixin'], function (exports, _emberMetalMixin) {
  'use strict';

  QUnit.module('Mixin.detect');

  QUnit.test('detect() finds a directly applied mixin', function () {
    var MixinA = _emberMetalMixin.Mixin.create();
    var obj = {};

    equal(MixinA.detect(obj), false, 'MixinA.detect(obj) before apply()');

    MixinA.apply(obj);
    equal(MixinA.detect(obj), true, 'MixinA.detect(obj) after apply()');
  });

  QUnit.test('detect() finds nested mixins', function () {
    var MixinA = _emberMetalMixin.Mixin.create({});
    var MixinB = _emberMetalMixin.Mixin.create(MixinA);
    var obj = {};

    equal(MixinA.detect(obj), false, 'MixinA.detect(obj) before apply()');

    MixinB.apply(obj);
    equal(MixinA.detect(obj), true, 'MixinA.detect(obj) after apply()');
  });

  QUnit.test('detect() finds mixins on other mixins', function () {
    var MixinA = _emberMetalMixin.Mixin.create({});
    var MixinB = _emberMetalMixin.Mixin.create(MixinA);
    equal(MixinA.detect(MixinB), true, 'MixinA is part of MixinB');
    equal(MixinB.detect(MixinA), false, 'MixinB is not part of MixinA');
  });

  QUnit.test('detect handles null values', function () {
    var MixinA = _emberMetalMixin.Mixin.create();
    equal(MixinA.detect(null), false);
  });
});
enifed('ember-metal/tests/mixin/detect_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/mixin/detect_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/mixin/detect_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/mixin/introspection_test', ['exports', 'ember-utils', 'ember-metal/mixin'], function (exports, _emberUtils, _emberMetalMixin) {
  // NOTE: A previous iteration differentiated between public and private props
  // as well as methods vs props.  We are just keeping these for testing; the
  // current impl doesn't care about the differences as much...

  'use strict';

  var PrivateProperty = _emberMetalMixin.Mixin.create({
    _foo: '_FOO'
  });
  var PublicProperty = _emberMetalMixin.Mixin.create({
    foo: 'FOO'
  });
  var PrivateMethod = _emberMetalMixin.Mixin.create({
    _fooMethod: function () {}
  });
  var PublicMethod = _emberMetalMixin.Mixin.create({
    fooMethod: function () {}
  });
  var BarProperties = _emberMetalMixin.Mixin.create({
    _bar: '_BAR',
    bar: 'bar'
  });
  var BarMethods = _emberMetalMixin.Mixin.create({
    _barMethod: function () {},
    barMethod: function () {}
  });

  var Combined = _emberMetalMixin.Mixin.create(BarProperties, BarMethods);

  var obj = undefined;

  QUnit.module('Basic introspection', {
    setup: function () {
      obj = {};
      _emberMetalMixin.mixin(obj, PrivateProperty, PublicProperty, PrivateMethod, PublicMethod, Combined);
    }
  });

  QUnit.test('Ember.mixins()', function () {
    function mapGuids(ary) {
      return ary.map(function (x) {
        return _emberUtils.guidFor(x);
      });
    }

    deepEqual(mapGuids(_emberMetalMixin.Mixin.mixins(obj)), mapGuids([PrivateProperty, PublicProperty, PrivateMethod, PublicMethod, Combined, BarProperties, BarMethods]), 'should return included mixins');
  });
});
enifed('ember-metal/tests/mixin/introspection_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/mixin/introspection_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/mixin/introspection_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/mixin/merged_properties_test', ['exports', 'ember-runtime', 'ember-metal/property_get', 'ember-metal/mixin'], function (exports, _emberRuntime, _emberMetalProperty_get, _emberMetalMixin) {
  'use strict';

  QUnit.module('Mixin mergedProperties');

  QUnit.test('defining mergedProperties should merge future version', function () {
    var MixinA = _emberMetalMixin.Mixin.create({
      mergedProperties: ['foo'],
      foo: { a: true, b: true, c: true }
    });

    var MixinB = _emberMetalMixin.Mixin.create({
      foo: { d: true, e: true, f: true }
    });

    var obj = _emberMetalMixin.mixin({}, MixinA, MixinB);
    deepEqual(_emberMetalProperty_get.get(obj, 'foo'), { a: true, b: true, c: true, d: true, e: true, f: true });
  });

  QUnit.test('defining mergedProperties on future mixin should merged into past', function () {
    var MixinA = _emberMetalMixin.Mixin.create({
      foo: { a: true, b: true, c: true }
    });

    var MixinB = _emberMetalMixin.Mixin.create({
      mergedProperties: ['foo'],
      foo: { d: true, e: true, f: true }
    });

    var obj = _emberMetalMixin.mixin({}, MixinA, MixinB);
    deepEqual(_emberMetalProperty_get.get(obj, 'foo'), { a: true, b: true, c: true, d: true, e: true, f: true });
  });

  QUnit.test('defining mergedProperties with null properties should keep properties null', function () {
    var MixinA = _emberMetalMixin.Mixin.create({
      mergedProperties: ['foo'],
      foo: null
    });

    var MixinB = _emberMetalMixin.Mixin.create({
      foo: null
    });

    var obj = _emberMetalMixin.mixin({}, MixinA, MixinB);
    equal(_emberMetalProperty_get.get(obj, 'foo'), null);
  });

  QUnit.test('mergedProperties\' properties can get overwritten', function () {
    var MixinA = _emberMetalMixin.Mixin.create({
      mergedProperties: ['foo'],
      foo: { a: 1 }
    });

    var MixinB = _emberMetalMixin.Mixin.create({
      foo: { a: 2 }
    });

    var obj = _emberMetalMixin.mixin({}, MixinA, MixinB);
    deepEqual(_emberMetalProperty_get.get(obj, 'foo'), { a: 2 });
  });

  QUnit.test('mergedProperties should be concatenated', function () {
    var MixinA = _emberMetalMixin.Mixin.create({
      mergedProperties: ['foo'],
      foo: { a: true, b: true, c: true }
    });

    var MixinB = _emberMetalMixin.Mixin.create({
      mergedProperties: 'bar',
      foo: { d: true, e: true, f: true },
      bar: { a: true, l: true }
    });

    var MixinC = _emberMetalMixin.Mixin.create({
      bar: { e: true, x: true }
    });

    var obj = _emberMetalMixin.mixin({}, MixinA, MixinB, MixinC);
    deepEqual(_emberMetalProperty_get.get(obj, 'mergedProperties'), ['foo', 'bar'], 'get mergedProperties');
    deepEqual(_emberMetalProperty_get.get(obj, 'foo'), { a: true, b: true, c: true, d: true, e: true, f: true }, 'get foo');
    deepEqual(_emberMetalProperty_get.get(obj, 'bar'), { a: true, l: true, e: true, x: true }, 'get bar');
  });

  QUnit.test('mergedProperties should exist even if not explicitly set on create', function () {
    var AnObj = _emberRuntime.Object.extend({
      mergedProperties: ['options'],
      options: {
        a: 'a',
        b: {
          c: 'ccc'
        }
      }
    });

    var obj = AnObj.create({
      options: {
        a: 'A'
      }
    });

    equal(_emberMetalProperty_get.get(obj, 'options').a, 'A');
    equal(_emberMetalProperty_get.get(obj, 'options').b.c, 'ccc');
  });

  QUnit.test('defining mergedProperties at create time should not modify the prototype', function () {
    var AnObj = _emberRuntime.Object.extend({
      mergedProperties: ['options'],
      options: {
        a: 1
      }
    });

    var objA = AnObj.create({
      options: {
        a: 2
      }
    });
    var objB = AnObj.create({
      options: {
        a: 3
      }
    });

    equal(_emberMetalProperty_get.get(objA, 'options').a, 2);
    equal(_emberMetalProperty_get.get(objB, 'options').a, 3);
  });

  QUnit.test('mergedProperties\' overwriting methods can call _super', function () {
    expect(4);

    var MixinA = _emberMetalMixin.Mixin.create({
      mergedProperties: ['foo'],
      foo: {
        meth: function (a) {
          equal(a, 'WOOT', '_super successfully called MixinA\'s `foo.meth` method');
          return 'WAT';
        }
      }
    });

    var MixinB = _emberMetalMixin.Mixin.create({
      foo: {
        meth: function (a) {
          ok(true, 'MixinB\'s `foo.meth` method called');
          return this._super.apply(this, arguments);
        }
      }
    });

    var MixinC = _emberMetalMixin.Mixin.create({
      foo: {
        meth: function (a) {
          ok(true, 'MixinC\'s `foo.meth` method called');
          return this._super(a);
        }
      }
    });

    var obj = _emberMetalMixin.mixin({}, MixinA, MixinB, MixinC);
    equal(obj.foo.meth('WOOT'), 'WAT');
  });

  QUnit.test('Merging an Array should raise an error', function () {
    expect(1);

    var MixinA = _emberMetalMixin.Mixin.create({
      mergedProperties: ['foo'],
      foo: { a: true, b: true, c: true }
    });

    var MixinB = _emberMetalMixin.Mixin.create({
      foo: ['a']
    });

    expectAssertion(function () {
      _emberMetalMixin.mixin({}, MixinA, MixinB);
    }, 'You passed in `["a"]` as the value for `foo` but `foo` cannot be an Array');
  });
});
enifed('ember-metal/tests/mixin/merged_properties_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/mixin/merged_properties_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/mixin/merged_properties_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/mixin/method_test', ['exports', 'ember-metal/mixin'], function (exports, _emberMetalMixin) {
  'use strict';

  QUnit.module('Mixin Methods');

  QUnit.test('defining simple methods', function () {
    var MixinA = undefined,
        obj = undefined,
        props = undefined;

    props = {
      publicMethod: function () {
        return 'publicMethod';
      },
      _privateMethod: function () {
        return 'privateMethod';
      }
    };

    MixinA = _emberMetalMixin.Mixin.create(props);
    obj = {};
    MixinA.apply(obj);

    // but should be defined
    equal(props.publicMethod(), 'publicMethod', 'publicMethod is func');
    equal(props._privateMethod(), 'privateMethod', 'privateMethod is func');
  });

  QUnit.test('overriding public methods', function () {
    var MixinA = undefined,
        MixinB = undefined,
        MixinD = undefined,
        MixinF = undefined,
        obj = undefined;

    MixinA = _emberMetalMixin.Mixin.create({
      publicMethod: function () {
        return 'A';
      }
    });

    MixinB = _emberMetalMixin.Mixin.create(MixinA, {
      publicMethod: function () {
        return this._super.apply(this, arguments) + 'B';
      }
    });

    MixinD = _emberMetalMixin.Mixin.create(MixinA, {
      publicMethod: function () {
        return this._super.apply(this, arguments) + 'D';
      }
    });

    MixinF = _emberMetalMixin.Mixin.create({
      publicMethod: function () {
        return this._super.apply(this, arguments) + 'F';
      }
    });

    obj = {};
    MixinB.apply(obj);
    equal(obj.publicMethod(), 'AB', 'should define super for A and B');

    obj = {};
    MixinD.apply(obj);
    equal(obj.publicMethod(), 'AD', 'should define super for A and B');

    obj = {};
    MixinA.apply(obj);
    MixinF.apply(obj);
    equal(obj.publicMethod(), 'AF', 'should define super for A and F');

    obj = { publicMethod: function () {
        return 'obj';
      } };
    MixinF.apply(obj);
    equal(obj.publicMethod(), 'objF', 'should define super for F');
  });

  QUnit.test('overriding inherited objects', function () {
    var cnt = 0;
    var MixinA = _emberMetalMixin.Mixin.create({
      foo: function () {
        cnt++;
      }
    });

    var MixinB = _emberMetalMixin.Mixin.create({
      foo: function () {
        this._super.apply(this, arguments);
        cnt++;
      }
    });

    var objA = {};
    MixinA.apply(objA);

    var objB = Object.create(objA);
    MixinB.apply(objB);

    cnt = 0;
    objB.foo();
    equal(cnt, 2, 'should invoke both methods');

    cnt = 0;
    objA.foo();
    equal(cnt, 1, 'should not screw w/ parent obj');
  });

  QUnit.test('Including the same mixin more than once will only run once', function () {
    var cnt = 0;
    var MixinA = _emberMetalMixin.Mixin.create({
      foo: function () {
        cnt++;
      }
    });

    var MixinB = _emberMetalMixin.Mixin.create(MixinA, {
      foo: function () {
        this._super.apply(this, arguments);
      }
    });

    var MixinC = _emberMetalMixin.Mixin.create(MixinA, {
      foo: function () {
        this._super.apply(this, arguments);
      }
    });

    var MixinD = _emberMetalMixin.Mixin.create(MixinB, MixinC, MixinA, {
      foo: function () {
        this._super.apply(this, arguments);
      }
    });

    var obj = {};
    MixinD.apply(obj);
    MixinA.apply(obj); // try to apply again..

    cnt = 0;
    obj.foo();

    equal(cnt, 1, 'should invoke MixinA.foo one time');
  });

  QUnit.test('_super from a single mixin with no superclass does not error', function () {
    var MixinA = _emberMetalMixin.Mixin.create({
      foo: function () {
        this._super.apply(this, arguments);
      }
    });

    var obj = {};
    MixinA.apply(obj);

    obj.foo();
    ok(true);
  });

  QUnit.test('_super from a first-of-two mixins with no superclass function does not error', function () {
    // _super was previously calling itself in the second assertion.
    // Use remaining count of calls to ensure it doesn't loop indefinitely.
    var remaining = 3;
    var MixinA = _emberMetalMixin.Mixin.create({
      foo: function () {
        if (remaining-- > 0) {
          this._super.apply(this, arguments);
        }
      }
    });

    var MixinB = _emberMetalMixin.Mixin.create({
      foo: function () {
        this._super.apply(this, arguments);
      }
    });

    var obj = {};
    MixinA.apply(obj);
    MixinB.apply(obj);

    obj.foo();
    ok(true);
  });

  // ..........................................................
  // CONFLICTS
  //

  QUnit.module('Method Conflicts');

  QUnit.test('overriding toString', function () {
    var MixinA = _emberMetalMixin.Mixin.create({
      toString: function () {
        return 'FOO';
      }
    });

    var obj = {};
    MixinA.apply(obj);
    equal(obj.toString(), 'FOO', 'should override toString w/o error');

    obj = {};
    _emberMetalMixin.mixin(obj, { toString: function () {
        return 'FOO';
      } });
    equal(obj.toString(), 'FOO', 'should override toString w/o error');
  });

  // ..........................................................
  // BUGS
  //

  QUnit.module('system/mixin/method_test BUGS');

  QUnit.test('applying several mixins at once with sup already defined causes infinite loop', function () {
    var cnt = 0;
    var MixinA = _emberMetalMixin.Mixin.create({
      foo: function () {
        cnt++;
      }
    });

    var MixinB = _emberMetalMixin.Mixin.create({
      foo: function () {
        this._super.apply(this, arguments);
        cnt++;
      }
    });

    var MixinC = _emberMetalMixin.Mixin.create({
      foo: function () {
        this._super.apply(this, arguments);
        cnt++;
      }
    });

    var obj = {};
    _emberMetalMixin.mixin(obj, MixinA); // sup already exists
    _emberMetalMixin.mixin(obj, MixinB, MixinC); // must be more than one mixin

    cnt = 0;
    obj.foo();
    equal(cnt, 3, 'should invoke all 3 methods');
  });
});
enifed('ember-metal/tests/mixin/method_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/mixin/method_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/mixin/method_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/mixin/observer_test', ['exports', 'internal-test-helpers', 'ember-metal/mixin', 'ember-metal/watching'], function (exports, _internalTestHelpers, _emberMetalMixin, _emberMetalWatching) {
  'use strict';

  QUnit.module('Mixin observer');

  _internalTestHelpers.testBoth('global observer helper', function (get, set) {
    var MyMixin = _emberMetalMixin.Mixin.create({

      count: 0,

      foo: _emberMetalMixin.observer('bar', function () {
        set(this, 'count', get(this, 'count') + 1);
      })

    });

    var obj = _emberMetalMixin.mixin({}, MyMixin);
    equal(get(obj, 'count'), 0, 'should not invoke observer immediately');

    set(obj, 'bar', 'BAZ');
    equal(get(obj, 'count'), 1, 'should invoke observer after change');
  });

  _internalTestHelpers.testBoth('global observer helper takes multiple params', function (get, set) {
    var MyMixin = _emberMetalMixin.Mixin.create({

      count: 0,

      foo: _emberMetalMixin.observer('bar', 'baz', function () {
        set(this, 'count', get(this, 'count') + 1);
      })

    });

    var obj = _emberMetalMixin.mixin({}, MyMixin);
    equal(get(obj, 'count'), 0, 'should not invoke observer immediately');

    set(obj, 'bar', 'BAZ');
    set(obj, 'baz', 'BAZ');
    equal(get(obj, 'count'), 2, 'should invoke observer after change');
  });

  _internalTestHelpers.testBoth('replacing observer should remove old observer', function (get, set) {
    var MyMixin = _emberMetalMixin.Mixin.create({

      count: 0,

      foo: _emberMetalMixin.observer('bar', function () {
        set(this, 'count', get(this, 'count') + 1);
      })

    });

    var Mixin2 = _emberMetalMixin.Mixin.create({
      foo: _emberMetalMixin.observer('baz', function () {
        set(this, 'count', get(this, 'count') + 10);
      })
    });

    var obj = _emberMetalMixin.mixin({}, MyMixin, Mixin2);
    equal(get(obj, 'count'), 0, 'should not invoke observer immediately');

    set(obj, 'bar', 'BAZ');
    equal(get(obj, 'count'), 0, 'should not invoke observer after change');

    set(obj, 'baz', 'BAZ');
    equal(get(obj, 'count'), 10, 'should invoke observer after change');
  });

  _internalTestHelpers.testBoth('observing chain with property before', function (get, set) {
    var obj2 = { baz: 'baz' };

    var MyMixin = _emberMetalMixin.Mixin.create({
      count: 0,
      bar: obj2,
      foo: _emberMetalMixin.observer('bar.baz', function () {
        set(this, 'count', get(this, 'count') + 1);
      })
    });

    var obj = _emberMetalMixin.mixin({}, MyMixin);
    equal(get(obj, 'count'), 0, 'should not invoke observer immediately');

    set(obj2, 'baz', 'BAZ');
    equal(get(obj, 'count'), 1, 'should invoke observer after change');
  });

  _internalTestHelpers.testBoth('observing chain with property after', function (get, set) {
    var obj2 = { baz: 'baz' };

    var MyMixin = _emberMetalMixin.Mixin.create({
      count: 0,
      foo: _emberMetalMixin.observer('bar.baz', function () {
        set(this, 'count', get(this, 'count') + 1);
      }),
      bar: obj2
    });

    var obj = _emberMetalMixin.mixin({}, MyMixin);
    equal(get(obj, 'count'), 0, 'should not invoke observer immediately');

    set(obj2, 'baz', 'BAZ');
    equal(get(obj, 'count'), 1, 'should invoke observer after change');
  });

  _internalTestHelpers.testBoth('observing chain with property in mixin applied later', function (get, set) {
    var obj2 = { baz: 'baz' };

    var MyMixin = _emberMetalMixin.Mixin.create({

      count: 0,
      foo: _emberMetalMixin.observer('bar.baz', function () {
        set(this, 'count', get(this, 'count') + 1);
      })
    });

    var MyMixin2 = _emberMetalMixin.Mixin.create({ bar: obj2 });

    var obj = _emberMetalMixin.mixin({}, MyMixin);
    equal(get(obj, 'count'), 0, 'should not invoke observer immediately');

    MyMixin2.apply(obj);
    equal(get(obj, 'count'), 0, 'should not invoke observer immediately');

    set(obj2, 'baz', 'BAZ');
    equal(get(obj, 'count'), 1, 'should invoke observer after change');
  });

  _internalTestHelpers.testBoth('observing chain with existing property', function (get, set) {
    var obj2 = { baz: 'baz' };

    var MyMixin = _emberMetalMixin.Mixin.create({
      count: 0,
      foo: _emberMetalMixin.observer('bar.baz', function () {
        set(this, 'count', get(this, 'count') + 1);
      })
    });

    var obj = _emberMetalMixin.mixin({ bar: obj2 }, MyMixin);
    equal(get(obj, 'count'), 0, 'should not invoke observer immediately');

    set(obj2, 'baz', 'BAZ');
    equal(get(obj, 'count'), 1, 'should invoke observer after change');
  });

  _internalTestHelpers.testBoth('observing chain with property in mixin before', function (get, set) {
    var obj2 = { baz: 'baz' };
    var MyMixin2 = _emberMetalMixin.Mixin.create({ bar: obj2 });

    var MyMixin = _emberMetalMixin.Mixin.create({
      count: 0,
      foo: _emberMetalMixin.observer('bar.baz', function () {
        set(this, 'count', get(this, 'count') + 1);
      })
    });

    var obj = _emberMetalMixin.mixin({}, MyMixin2, MyMixin);
    equal(get(obj, 'count'), 0, 'should not invoke observer immediately');

    set(obj2, 'baz', 'BAZ');
    equal(get(obj, 'count'), 1, 'should invoke observer after change');
  });

  _internalTestHelpers.testBoth('observing chain with property in mixin after', function (get, set) {
    var obj2 = { baz: 'baz' };
    var MyMixin2 = _emberMetalMixin.Mixin.create({ bar: obj2 });

    var MyMixin = _emberMetalMixin.Mixin.create({
      count: 0,
      foo: _emberMetalMixin.observer('bar.baz', function () {
        set(this, 'count', get(this, 'count') + 1);
      })
    });

    var obj = _emberMetalMixin.mixin({}, MyMixin, MyMixin2);
    equal(get(obj, 'count'), 0, 'should not invoke observer immediately');

    set(obj2, 'baz', 'BAZ');
    equal(get(obj, 'count'), 1, 'should invoke observer after change');
  });

  _internalTestHelpers.testBoth('observing chain with overriden property', function (get, set) {
    var obj2 = { baz: 'baz' };
    var obj3 = { baz: 'foo' };

    var MyMixin2 = _emberMetalMixin.Mixin.create({ bar: obj3 });

    var MyMixin = _emberMetalMixin.Mixin.create({
      count: 0,
      foo: _emberMetalMixin.observer('bar.baz', function () {
        set(this, 'count', get(this, 'count') + 1);
      })
    });

    var obj = _emberMetalMixin.mixin({ bar: obj2 }, MyMixin, MyMixin2);
    equal(get(obj, 'count'), 0, 'should not invoke observer immediately');

    equal(_emberMetalWatching.isWatching(obj2, 'baz'), false, 'should not be watching baz');
    equal(_emberMetalWatching.isWatching(obj3, 'baz'), true, 'should be watching baz');

    set(obj2, 'baz', 'BAZ');
    equal(get(obj, 'count'), 0, 'should not invoke observer after change');

    set(obj3, 'baz', 'BEAR');
    equal(get(obj, 'count'), 1, 'should invoke observer after change');
  });

  _internalTestHelpers.testBoth('providing the arguments in reverse order is deprecated', function (get, set) {
    expectDeprecation(/Passing the dependentKeys after the callback function in Ember\.observer is deprecated. Ensure the callback function is the last argument/);

    _emberMetalMixin.Mixin.create({
      count: 0,
      foo: _emberMetalMixin.observer(function () {
        set(this, 'count', get(this, 'count') + 1);
      }, 'bar.baz')
    });
  });
});
enifed('ember-metal/tests/mixin/observer_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/mixin/observer_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/mixin/observer_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/mixin/reopen_test', ['exports', 'ember-metal/run_loop', 'ember-metal/property_get', 'ember-runtime', 'ember-metal/mixin'], function (exports, _emberMetalRun_loop, _emberMetalProperty_get, _emberRuntime, _emberMetalMixin) {
  'use strict';

  QUnit.module('Ember.Mixin#reopen');

  QUnit.test('using reopen() to add more properties to a simple', function () {
    var MixinA = _emberMetalMixin.default.create({ foo: 'FOO', baz: 'BAZ' });
    MixinA.reopen({ bar: 'BAR', foo: 'FOO2' });
    var obj = {};
    MixinA.apply(obj);

    equal(_emberMetalProperty_get.default(obj, 'foo'), 'FOO2', 'mixin() should override');
    equal(_emberMetalProperty_get.default(obj, 'baz'), 'BAZ', 'preserve MixinA props');
    equal(_emberMetalProperty_get.default(obj, 'bar'), 'BAR', 'include MixinB props');
  });

  QUnit.test('using reopen() and calling _super where there is not a super function does not cause infinite recursion', function () {
    var Taco = _emberRuntime.Object.extend({
      createBreakfast: function () {
        // There is no original createBreakfast function.
        // Calling the wrapped _super function here
        // used to end in an infinite call loop
        this._super.apply(this, arguments);
        return 'Breakfast!';
      }
    });

    Taco.reopen({
      createBreakfast: function () {
        return this._super.apply(this, arguments);
      }
    });

    var taco = Taco.create();

    var result = undefined;
    _emberMetalRun_loop.default(function () {
      try {
        result = taco.createBreakfast();
      } catch (e) {
        result = 'Your breakfast was interrupted by an infinite stack error.';
      }
    });

    equal(result, 'Breakfast!');
  });
});
enifed('ember-metal/tests/mixin/reopen_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/mixin/reopen_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/mixin/reopen_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/mixin/required_test', ['exports', 'ember-metal/mixin', 'ember-metal/property_get'], function (exports, _emberMetalMixin, _emberMetalProperty_get) {
  'use strict';

  var PartialMixin = undefined,
      FinalMixin = undefined,
      obj = undefined;

  QUnit.module('Module.required', {
    setup: function () {
      expectDeprecation(function () {
        PartialMixin = _emberMetalMixin.Mixin.create({
          foo: _emberMetalMixin.required(),
          bar: 'BAR'
        });
      }, 'Ember.required is deprecated as its behavior is inconsistent and unreliable.');

      FinalMixin = _emberMetalMixin.Mixin.create({
        foo: 'FOO'
      });

      obj = {};
    },

    teardown: function () {
      PartialMixin = FinalMixin = obj = null;
    }
  });

  QUnit.test('applying a mixin to meet requirement', function () {
    FinalMixin.apply(obj);
    PartialMixin.apply(obj);
    equal(_emberMetalProperty_get.get(obj, 'foo'), 'FOO', 'should now be defined');
  });

  QUnit.test('combined mixins to meet requirement', function () {
    _emberMetalMixin.Mixin.create(PartialMixin, FinalMixin).apply(obj);
    equal(_emberMetalProperty_get.get(obj, 'foo'), 'FOO', 'should now be defined');
  });

  QUnit.test('merged mixin', function () {
    _emberMetalMixin.Mixin.create(PartialMixin, { foo: 'FOO' }).apply(obj);
    equal(_emberMetalProperty_get.get(obj, 'foo'), 'FOO', 'should now be defined');
  });

  QUnit.test('define property on source object', function () {
    obj.foo = 'FOO';
    PartialMixin.apply(obj);
    equal(_emberMetalProperty_get.get(obj, 'foo'), 'FOO', 'should now be defined');
  });

  QUnit.test('using apply', function () {
    _emberMetalMixin.mixin(obj, PartialMixin, { foo: 'FOO' });
    equal(_emberMetalProperty_get.get(obj, 'foo'), 'FOO', 'should now be defined');
  });
});
enifed('ember-metal/tests/mixin/required_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/mixin/required_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/mixin/required_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/mixin/without_test', ['exports', 'ember-metal/mixin'], function (exports, _emberMetalMixin) {
  'use strict';

  QUnit.test('without should create a new mixin excluding named properties', function () {
    var MixinA = _emberMetalMixin.Mixin.create({
      foo: 'FOO',
      bar: 'BAR'
    });

    var MixinB = MixinA.without('bar');

    var obj = {};
    MixinB.apply(obj);

    equal(obj.foo, 'FOO', 'should defined foo');
    equal(obj.bar, undefined, 'should not define bar');
  });
});
enifed('ember-metal/tests/mixin/without_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/mixin/without_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/mixin/without_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/observer_test', ['exports', 'ember-environment', 'internal-test-helpers', 'ember-metal/observer', 'ember-metal/property_events', 'ember-metal/properties', 'ember-metal/computed', 'ember-metal/mixin', 'ember-metal/run_loop'], function (exports, _emberEnvironment, _internalTestHelpers, _emberMetalObserver, _emberMetalProperty_events, _emberMetalProperties, _emberMetalComputed, _emberMetalMixin, _emberMetalRun_loop) {
  'use strict';

  function K() {}

  // ..........................................................
  // ADD OBSERVER
  //

  QUnit.module('addObserver');

  _internalTestHelpers.testBoth('observer should fire when property is modified', function (get, set) {
    var obj = {};
    var count = 0;

    _emberMetalObserver.addObserver(obj, 'foo', function () {
      equal(get(obj, 'foo'), 'bar', 'should invoke AFTER value changed');
      count++;
    });

    set(obj, 'foo', 'bar');
    equal(count, 1, 'should have invoked observer');
  });

  _internalTestHelpers.testBoth('observer should fire when dependent property is modified', function (get, set) {
    var obj = { bar: 'bar' };
    _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.computed(function () {
      return get(this, 'bar').toUpperCase();
    }).property('bar'));

    get(obj, 'foo');

    var count = 0;
    _emberMetalObserver.addObserver(obj, 'foo', function () {
      equal(get(obj, 'foo'), 'BAZ', 'should have invoked after prop change');
      count++;
    });

    set(obj, 'bar', 'baz');
    equal(count, 1, 'should have invoked observer');
  });

  _internalTestHelpers.testBoth('observer should continue to fire after dependent properties are accessed', function (get, set) {
    var observerCount = 0;
    var obj = {};

    _emberMetalProperties.defineProperty(obj, 'prop', _emberMetalComputed.computed(function () {
      return Math.random();
    }));
    _emberMetalProperties.defineProperty(obj, 'anotherProp', _emberMetalComputed.computed('prop', function () {
      return get(this, 'prop') + Math.random();
    }));

    _emberMetalObserver.addObserver(obj, 'prop', function () {
      observerCount++;
    });

    get(obj, 'anotherProp');

    for (var i = 0; i < 10; i++) {
      _emberMetalProperty_events.propertyWillChange(obj, 'prop');
      _emberMetalProperty_events.propertyDidChange(obj, 'prop');
    }

    equal(observerCount, 10, 'should continue to fire indefinitely');
  });

  if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.Function) {
    _internalTestHelpers.testBoth('observer added declaratively via brace expansion should fire when property changes', function (get, set) {
      var obj = {};
      var count = 0;

      _emberMetalMixin.mixin(obj, {
        observeFooAndBar: (function () {
          count++;
        }).observes('{foo,bar}')
      });

      set(obj, 'foo', 'foo');
      equal(count, 1, 'observer specified via brace expansion invoked on property change');

      set(obj, 'bar', 'bar');
      equal(count, 2, 'observer specified via brace expansion invoked on property change');

      set(obj, 'baz', 'baz');
      equal(count, 2, 'observer not invoked on unspecified property');
    });

    _internalTestHelpers.testBoth('observer specified declaratively via brace expansion should fire when dependent property changes', function (get, set) {
      var obj = { baz: 'Initial' };
      var count = 0;

      _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.computed(function () {
        return get(this, 'bar').toLowerCase();
      }).property('bar'));

      _emberMetalProperties.defineProperty(obj, 'bar', _emberMetalComputed.computed(function () {
        return get(this, 'baz').toUpperCase();
      }).property('baz'));

      _emberMetalMixin.mixin(obj, {
        fooAndBarWatcher: (function () {
          count++;
        }).observes('{foo,bar}')
      });

      get(obj, 'foo');
      set(obj, 'baz', 'Baz');
      // fire once for foo, once for bar
      equal(count, 2, 'observer specified via brace expansion invoked on dependent property change');

      set(obj, 'quux', 'Quux');
      equal(count, 2, 'observer not fired on unspecified property');
    });
  }

  _internalTestHelpers.testBoth('observers watching multiple properties via brace expansion should fire when the properties change', function (get, set) {
    var obj = {};
    var count = 0;

    _emberMetalMixin.mixin(obj, {
      observeFooAndBar: _emberMetalMixin.observer('{foo,bar}', function () {
        count++;
      })
    });

    set(obj, 'foo', 'foo');
    equal(count, 1, 'observer specified via brace expansion invoked on property change');

    set(obj, 'bar', 'bar');
    equal(count, 2, 'observer specified via brace expansion invoked on property change');

    set(obj, 'baz', 'baz');
    equal(count, 2, 'observer not invoked on unspecified property');
  });

  _internalTestHelpers.testBoth('observers watching multiple properties via brace expansion should fire when dependent properties change', function (get, set) {
    var obj = { baz: 'Initial' };
    var count = 0;

    _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.computed(function () {
      return get(this, 'bar').toLowerCase();
    }).property('bar'));

    _emberMetalProperties.defineProperty(obj, 'bar', _emberMetalComputed.computed(function () {
      return get(this, 'baz').toUpperCase();
    }).property('baz'));

    _emberMetalMixin.mixin(obj, {
      fooAndBarWatcher: _emberMetalMixin.observer('{foo,bar}', function () {
        count++;
      })
    });

    get(obj, 'foo');
    set(obj, 'baz', 'Baz');
    // fire once for foo, once for bar
    equal(count, 2, 'observer specified via brace expansion invoked on dependent property change');

    set(obj, 'quux', 'Quux');
    equal(count, 2, 'observer not fired on unspecified property');
  });

  _internalTestHelpers.testBoth('nested observers should fire in order', function (get, set) {
    var obj = { foo: 'foo', bar: 'bar' };
    var fooCount = 0;
    var barCount = 0;

    _emberMetalObserver.addObserver(obj, 'foo', function () {
      fooCount++;
    });
    _emberMetalObserver.addObserver(obj, 'bar', function () {
      set(obj, 'foo', 'BAZ');
      equal(fooCount, 1, 'fooCount should have fired already');
      barCount++;
    });

    set(obj, 'bar', 'BIFF');
    equal(barCount, 1, 'barCount should have fired');
    equal(fooCount, 1, 'foo should have fired');
  });

  _internalTestHelpers.testBoth('removing an chain observer on change should not fail', function (get, set) {
    var foo = { bar: 'bar' };
    var obj1 = { foo: foo };
    var obj2 = { foo: foo };
    var obj3 = { foo: foo };
    var obj4 = { foo: foo };
    var count1 = 0;
    var count2 = 0;
    var count3 = 0;
    var count4 = 0;

    function observer1() {
      count1++;
    }
    function observer2() {
      count2++;
    }
    function observer3() {
      count3++;
      _emberMetalObserver.removeObserver(obj1, 'foo.bar', observer1);
      _emberMetalObserver.removeObserver(obj2, 'foo.bar', observer2);
      _emberMetalObserver.removeObserver(obj4, 'foo.bar', observer4);
    }
    function observer4() {
      count4++;
    }

    _emberMetalObserver.addObserver(obj1, 'foo.bar', observer1);
    _emberMetalObserver.addObserver(obj2, 'foo.bar', observer2);
    _emberMetalObserver.addObserver(obj3, 'foo.bar', observer3);
    _emberMetalObserver.addObserver(obj4, 'foo.bar', observer4);

    set(foo, 'bar', 'baz');

    equal(count1, 1, 'observer1 fired');
    equal(count2, 1, 'observer2 fired');
    equal(count3, 1, 'observer3 fired');
    equal(count4, 0, 'observer4 did not fire');
  });

  _internalTestHelpers.testBoth('removing an chain before observer on change should not fail', function (get, set) {
    var foo = { bar: 'bar' };
    var obj1 = { foo: foo };
    var obj2 = { foo: foo };
    var obj3 = { foo: foo };
    var obj4 = { foo: foo };
    var count1 = 0;
    var count2 = 0;
    var count3 = 0;
    var count4 = 0;

    function observer1() {
      count1++;
    }
    function observer2() {
      count2++;
    }
    function observer3() {
      count3++;
      _emberMetalObserver._removeBeforeObserver(obj1, 'foo.bar', observer1);
      _emberMetalObserver._removeBeforeObserver(obj2, 'foo.bar', observer2);
      _emberMetalObserver._removeBeforeObserver(obj4, 'foo.bar', observer4);
    }
    function observer4() {
      count4++;
    }

    _emberMetalObserver._addBeforeObserver(obj1, 'foo.bar', observer1);
    _emberMetalObserver._addBeforeObserver(obj2, 'foo.bar', observer2);
    _emberMetalObserver._addBeforeObserver(obj3, 'foo.bar', observer3);
    _emberMetalObserver._addBeforeObserver(obj4, 'foo.bar', observer4);

    set(foo, 'bar', 'baz');

    equal(count1, 1, 'observer1 fired');
    equal(count2, 1, 'observer2 fired');
    equal(count3, 1, 'observer3 fired');
    equal(count4, 0, 'observer4 did not fire');
  });

  _internalTestHelpers.testBoth('suspending an observer should not fire during callback', function (get, set) {
    var obj = {};
    var target = undefined,
        otherTarget = undefined;

    target = {
      values: [],
      method: function () {
        this.values.push(get(obj, 'foo'));
      }
    };

    otherTarget = {
      values: [],
      method: function () {
        this.values.push(get(obj, 'foo'));
      }
    };

    _emberMetalObserver.addObserver(obj, 'foo', target, target.method);
    _emberMetalObserver.addObserver(obj, 'foo', otherTarget, otherTarget.method);

    function callback() {
      /*jshint validthis:true */
      equal(this, target);

      set(obj, 'foo', '2');

      return 'result';
    }

    set(obj, 'foo', '1');

    equal(_emberMetalObserver._suspendObserver(obj, 'foo', target, target.method, callback), 'result');

    set(obj, 'foo', '3');

    deepEqual(target.values, ['1', '3'], 'should invoke');
    deepEqual(otherTarget.values, ['1', '2', '3'], 'should invoke');
  });

  _internalTestHelpers.testBoth('suspending an observer should not defer change notifications during callback', function (get, set) {
    var obj = {};
    var target = undefined,
        otherTarget = undefined;

    target = {
      values: [],
      method: function () {
        this.values.push(get(obj, 'foo'));
      }
    };

    otherTarget = {
      values: [],
      method: function () {
        this.values.push(get(obj, 'foo'));
      }
    };

    _emberMetalObserver.addObserver(obj, 'foo', target, target.method);
    _emberMetalObserver.addObserver(obj, 'foo', otherTarget, otherTarget.method);

    function callback() {
      /*jshint validthis:true */
      equal(this, target);

      set(obj, 'foo', '2');

      return 'result';
    }

    set(obj, 'foo', '1');

    _emberMetalProperty_events.beginPropertyChanges();
    equal(_emberMetalObserver._suspendObserver(obj, 'foo', target, target.method, callback), 'result');
    _emberMetalProperty_events.endPropertyChanges();

    set(obj, 'foo', '3');

    deepEqual(target.values, ['1', '3'], 'should invoke');
    deepEqual(otherTarget.values, ['1', '2', '3'], 'should invoke');
  });

  _internalTestHelpers.testBoth('suspending observers should not fire during callback', function (get, set) {
    var obj = {};
    var target = undefined,
        otherTarget = undefined;

    target = {
      values: [],
      method: function () {
        this.values.push(get(obj, 'foo'));
      }
    };

    otherTarget = {
      values: [],
      method: function () {
        this.values.push(get(obj, 'foo'));
      }
    };

    _emberMetalObserver.addObserver(obj, 'foo', target, target.method);
    _emberMetalObserver.addObserver(obj, 'foo', otherTarget, otherTarget.method);

    function callback() {
      /*jshint validthis:true */
      equal(this, target);

      set(obj, 'foo', '2');

      return 'result';
    }

    set(obj, 'foo', '1');

    equal(_emberMetalObserver._suspendObservers(obj, ['foo'], target, target.method, callback), 'result');

    set(obj, 'foo', '3');

    deepEqual(target.values, ['1', '3'], 'should invoke');
    deepEqual(otherTarget.values, ['1', '2', '3'], 'should invoke');
  });

  _internalTestHelpers.testBoth('suspending observers should not defer change notifications during callback', function (get, set) {
    var obj = {};
    var target = undefined,
        otherTarget = undefined;

    target = {
      values: [],
      method: function () {
        this.values.push(get(obj, 'foo'));
      }
    };

    otherTarget = {
      values: [],
      method: function () {
        this.values.push(get(obj, 'foo'));
      }
    };

    _emberMetalObserver.addObserver(obj, 'foo', target, target.method);
    _emberMetalObserver.addObserver(obj, 'foo', otherTarget, otherTarget.method);

    function callback() {
      /*jshint validthis:true */
      equal(this, target);

      set(obj, 'foo', '2');

      return 'result';
    }

    set(obj, 'foo', '1');

    _emberMetalProperty_events.beginPropertyChanges();
    equal(_emberMetalObserver._suspendObservers(obj, ['foo'], target, target.method, callback), 'result');
    _emberMetalProperty_events.endPropertyChanges();

    set(obj, 'foo', '3');

    deepEqual(target.values, ['1', '3'], 'should invoke');
    deepEqual(otherTarget.values, ['1', '2', '3'], 'should invoke');
  });

  _internalTestHelpers.testBoth('deferring property change notifications', function (get, set) {
    var obj = { foo: 'foo' };
    var fooCount = 0;

    _emberMetalObserver.addObserver(obj, 'foo', function () {
      fooCount++;
    });

    _emberMetalProperty_events.beginPropertyChanges(obj);
    set(obj, 'foo', 'BIFF');
    set(obj, 'foo', 'BAZ');
    _emberMetalProperty_events.endPropertyChanges(obj);

    equal(fooCount, 1, 'foo should have fired once');
  });

  _internalTestHelpers.testBoth('deferring property change notifications safely despite exceptions', function (get, set) {
    var obj = { foo: 'foo' };
    var fooCount = 0;
    var exc = new Error('Something unexpected happened!');

    expect(2);
    _emberMetalObserver.addObserver(obj, 'foo', function () {
      fooCount++;
    });

    try {
      _emberMetalProperty_events.changeProperties(function () {
        set(obj, 'foo', 'BIFF');
        set(obj, 'foo', 'BAZ');
        throw exc;
      });
    } catch (err) {
      if (err !== exc) {
        throw err;
      }
    }

    equal(fooCount, 1, 'foo should have fired once');

    _emberMetalProperty_events.changeProperties(function () {
      set(obj, 'foo', 'BIFF2');
      set(obj, 'foo', 'BAZ2');
    });

    equal(fooCount, 2, 'foo should have fired again once');
  });

  _internalTestHelpers.testBoth('deferring property change notifications will not defer before observers', function (get, set) {
    var obj = { foo: 'foo' };
    var fooCount = 0;

    _emberMetalObserver._addBeforeObserver(obj, 'foo', function () {
      fooCount++;
    });

    _emberMetalProperty_events.beginPropertyChanges(obj);
    set(obj, 'foo', 'BIFF');
    equal(fooCount, 1, 'should fire before observer immediately');
    set(obj, 'foo', 'BAZ');
    _emberMetalProperty_events.endPropertyChanges(obj);

    equal(fooCount, 1, 'should not fire before observer twice');
  });

  _internalTestHelpers.testBoth('addObserver should propagate through prototype', function (get, set) {
    var obj = { foo: 'foo', count: 0 };
    var obj2 = undefined;

    _emberMetalObserver.addObserver(obj, 'foo', function () {
      this.count++;
    });
    obj2 = Object.create(obj);

    set(obj2, 'foo', 'bar');

    equal(obj2.count, 1, 'should have invoked observer on inherited');
    equal(obj.count, 0, 'should not have invoked observer on parent');

    obj2.count = 0;
    set(obj, 'foo', 'baz');
    equal(obj.count, 1, 'should have invoked observer on parent');
    equal(obj2.count, 0, 'should not have invoked observer on inherited');
  });

  _internalTestHelpers.testBoth('addObserver should respect targets with methods', function (get, set) {
    var observed = { foo: 'foo' };

    var target1 = {
      count: 0,

      didChange: function (obj, keyName) {
        var value = get(obj, keyName);
        equal(this, target1, 'should invoke with this');
        equal(obj, observed, 'param1 should be observed object');
        equal(keyName, 'foo', 'param2 should be keyName');
        equal(value, 'BAZ', 'param3 should new value');
        this.count++;
      }
    };

    var target2 = {
      count: 0,

      didChange: function (obj, keyName) {
        var value = get(obj, keyName);
        equal(this, target2, 'should invoke with this');
        equal(obj, observed, 'param1 should be observed object');
        equal(keyName, 'foo', 'param2 should be keyName');
        equal(value, 'BAZ', 'param3 should new value');
        this.count++;
      }
    };

    _emberMetalObserver.addObserver(observed, 'foo', target1, 'didChange');
    _emberMetalObserver.addObserver(observed, 'foo', target2, target2.didChange);

    set(observed, 'foo', 'BAZ');
    equal(target1.count, 1, 'target1 observer should have fired');
    equal(target2.count, 1, 'target2 observer should have fired');
  });

  _internalTestHelpers.testBoth('addObserver should allow multiple objects to observe a property', function (get, set) {
    var observed = { foo: 'foo' };

    var target1 = {
      count: 0,

      didChange: function (obj, keyName, value) {
        this.count++;
      }
    };

    var target2 = {
      count: 0,

      didChange: function (obj, keyName, value) {
        this.count++;
      }
    };

    _emberMetalObserver.addObserver(observed, 'foo', target1, 'didChange');
    _emberMetalObserver.addObserver(observed, 'foo', target2, 'didChange');

    set(observed, 'foo', 'BAZ');
    equal(target1.count, 1, 'target1 observer should have fired');
    equal(target2.count, 1, 'target2 observer should have fired');
  });

  // ..........................................................
  // REMOVE OBSERVER
  //

  QUnit.module('removeObserver');

  _internalTestHelpers.testBoth('removing observer should stop firing', function (get, set) {
    var obj = {};
    var count = 0;
    function F() {
      count++;
    }
    _emberMetalObserver.addObserver(obj, 'foo', F);

    set(obj, 'foo', 'bar');
    equal(count, 1, 'should have invoked observer');

    _emberMetalObserver.removeObserver(obj, 'foo', F);

    set(obj, 'foo', 'baz');
    equal(count, 1, 'removed observer shouldn\'t fire');
  });

  _internalTestHelpers.testBoth('local observers can be removed', function (get, set) {
    var barObserved = 0;

    var MyMixin = _emberMetalMixin.Mixin.create({
      foo1: _emberMetalMixin.observer('bar', function () {
        barObserved++;
      }),

      foo2: _emberMetalMixin.observer('bar', function () {
        barObserved++;
      })
    });

    var obj = {};
    MyMixin.apply(obj);

    set(obj, 'bar', 'HI!');
    equal(barObserved, 2, 'precond - observers should be fired');

    _emberMetalObserver.removeObserver(obj, 'bar', null, 'foo1');

    barObserved = 0;
    set(obj, 'bar', 'HI AGAIN!');

    equal(barObserved, 1, 'removed observers should not be called');
  });

  _internalTestHelpers.testBoth('removeObserver should respect targets with methods', function (get, set) {
    var observed = { foo: 'foo' };

    var target1 = {
      count: 0,

      didChange: function () {
        this.count++;
      }
    };

    var target2 = {
      count: 0,

      didChange: function () {
        this.count++;
      }
    };

    _emberMetalObserver.addObserver(observed, 'foo', target1, 'didChange');
    _emberMetalObserver.addObserver(observed, 'foo', target2, target2.didChange);

    set(observed, 'foo', 'BAZ');
    equal(target1.count, 1, 'target1 observer should have fired');
    equal(target2.count, 1, 'target2 observer should have fired');

    _emberMetalObserver.removeObserver(observed, 'foo', target1, 'didChange');
    _emberMetalObserver.removeObserver(observed, 'foo', target2, target2.didChange);

    target1.count = target2.count = 0;
    set(observed, 'foo', 'BAZ');
    equal(target1.count, 0, 'target1 observer should not fire again');
    equal(target2.count, 0, 'target2 observer should not fire again');
  });

  // ..........................................................
  // BEFORE OBSERVER
  //

  QUnit.module('_addBeforeObserver');

  _internalTestHelpers.testBoth('observer should fire before a property is modified', function (get, set) {
    var obj = { foo: 'foo' };
    var count = 0;

    _emberMetalObserver._addBeforeObserver(obj, 'foo', function () {
      equal(get(obj, 'foo'), 'foo', 'should invoke before value changed');
      count++;
    });

    set(obj, 'foo', 'bar');
    equal(count, 1, 'should have invoked observer');
  });

  _internalTestHelpers.testBoth('observer should fire before dependent property is modified', function (get, set) {
    var obj = { bar: 'bar' };
    _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.computed(function () {
      return get(this, 'bar').toUpperCase();
    }).property('bar'));

    get(obj, 'foo');

    var count = 0;
    _emberMetalObserver._addBeforeObserver(obj, 'foo', function () {
      equal(get(obj, 'foo'), 'BAR', 'should have invoked after prop change');
      count++;
    });

    set(obj, 'bar', 'baz');
    equal(count, 1, 'should have invoked observer');
  });

  _internalTestHelpers.testBoth('before observer watching multiple properties via brace expansion should fire when properties change', function (get, set) {
    var obj = {};
    var count = 0;

    _emberMetalMixin.mixin(obj, {
      fooAndBarWatcher: _emberMetalMixin._beforeObserver('{foo,bar}', function () {
        count++;
      })
    });

    set(obj, 'foo', 'foo');
    equal(count, 1, 'observer specified via brace expansion invoked on property change');

    set(obj, 'bar', 'bar');
    equal(count, 2, 'observer specified via brace expansion invoked on property change');

    set(obj, 'baz', 'baz');
    equal(count, 2, 'observer not invoked on unspecified property');
  });

  _internalTestHelpers.testBoth('before observer watching multiple properties via brace expansion should fire when dependent property changes', function (get, set) {
    var obj = { baz: 'Initial' };
    var count = 0;

    _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.computed(function () {
      return get(this, 'bar').toLowerCase();
    }).property('bar'));

    _emberMetalProperties.defineProperty(obj, 'bar', _emberMetalComputed.computed(function () {
      return get(this, 'baz').toUpperCase();
    }).property('baz'));

    _emberMetalMixin.mixin(obj, {
      fooAndBarWatcher: _emberMetalMixin._beforeObserver('{foo,bar}', function () {
        count++;
      })
    });

    get(obj, 'foo');
    set(obj, 'baz', 'Baz');
    // fire once for foo, once for bar
    equal(count, 2, 'observer specified via brace expansion invoked on dependent property change');

    set(obj, 'quux', 'Quux');
    equal(count, 2, 'observer not fired on unspecified property');
  });

  _internalTestHelpers.testBoth('_addBeforeObserver should propagate through prototype', function (get, set) {
    var obj = { foo: 'foo', count: 0 };
    var obj2 = undefined;

    _emberMetalObserver._addBeforeObserver(obj, 'foo', function () {
      this.count++;
    });
    obj2 = Object.create(obj);

    set(obj2, 'foo', 'bar');
    equal(obj2.count, 1, 'should have invoked observer on inherited');
    equal(obj.count, 0, 'should not have invoked observer on parent');

    obj2.count = 0;
    set(obj, 'foo', 'baz');
    equal(obj.count, 1, 'should have invoked observer on parent');
    equal(obj2.count, 0, 'should not have invoked observer on inherited');
  });

  _internalTestHelpers.testBoth('_addBeforeObserver should respect targets with methods', function (get, set) {
    var observed = { foo: 'foo' };

    var target1 = {
      count: 0,

      willChange: function (obj, keyName) {
        var value = get(obj, keyName);
        equal(this, target1, 'should invoke with this');
        equal(obj, observed, 'param1 should be observed object');
        equal(keyName, 'foo', 'param2 should be keyName');
        equal(value, 'foo', 'param3 should old value');
        this.count++;
      }
    };

    var target2 = {
      count: 0,

      willChange: function (obj, keyName) {
        var value = get(obj, keyName);
        equal(this, target2, 'should invoke with this');
        equal(obj, observed, 'param1 should be observed object');
        equal(keyName, 'foo', 'param2 should be keyName');
        equal(value, 'foo', 'param3 should old value');
        this.count++;
      }
    };

    _emberMetalObserver._addBeforeObserver(observed, 'foo', target1, 'willChange');
    _emberMetalObserver._addBeforeObserver(observed, 'foo', target2, target2.willChange);

    set(observed, 'foo', 'BAZ');
    equal(target1.count, 1, 'target1 observer should have fired');
    equal(target2.count, 1, 'target2 observer should have fired');
  });

  // ..........................................................
  // CHAINED OBSERVERS
  //

  var obj = undefined,
      count = undefined;

  QUnit.module('addObserver - dependentkey with chained properties', {
    setup: function () {
      obj = {
        foo: {
          bar: {
            baz: {
              biff: 'BIFF'
            }
          }
        },
        Capital: {
          foo: {
            bar: {
              baz: {
                biff: 'BIFF'
              }
            }
          }
        }
      };

      count = 0;
    },

    teardown: function () {
      obj = count = null;
    }
  });

  _internalTestHelpers.testBoth('depending on a chain with a computed property', function (get, set) {
    _emberMetalProperties.defineProperty(obj, 'computed', _emberMetalComputed.computed(function () {
      return { foo: 'bar' };
    }));

    var changed = 0;
    _emberMetalObserver.addObserver(obj, 'computed.foo', function () {
      changed++;
    });

    equal(_emberMetalComputed.cacheFor(obj, 'computed'), undefined, 'addObserver should not compute CP');

    set(obj, 'computed.foo', 'baz');

    equal(changed, 1, 'should fire observer');
  });

  _internalTestHelpers.testBoth('depending on a simple chain', function (get, set) {
    var val = undefined;
    _emberMetalObserver.addObserver(obj, 'foo.bar.baz.biff', function (target, key) {
      val = get(target, key);
      count++;
    });

    set(get(obj, 'foo.bar.baz'), 'biff', 'BUZZ');
    equal(val, 'BUZZ');
    equal(count, 1);

    set(get(obj, 'foo.bar'), 'baz', { biff: 'BLARG' });
    equal(val, 'BLARG');
    equal(count, 2);

    set(get(obj, 'foo'), 'bar', { baz: { biff: 'BOOM' } });
    equal(val, 'BOOM');
    equal(count, 3);

    set(obj, 'foo', { bar: { baz: { biff: 'BLARG' } } });
    equal(val, 'BLARG');
    equal(count, 4);

    set(get(obj, 'foo.bar.baz'), 'biff', 'BUZZ');
    equal(val, 'BUZZ');
    equal(count, 5);

    var foo = get(obj, 'foo');

    set(obj, 'foo', 'BOO');
    equal(val, undefined);
    equal(count, 6);

    set(foo.bar.baz, 'biff', 'BOOM');
    equal(count, 6, 'should be not have invoked observer');
  });

  _internalTestHelpers.testBoth('depending on a chain with a capitalized first key', function (get, set) {
    var val = undefined;

    _emberMetalObserver.addObserver(obj, 'Capital.foo.bar.baz.biff', function (target, key) {
      val = get(obj, key);
      count++;
    });

    set(get(obj, 'Capital.foo.bar.baz'), 'biff', 'BUZZ');
    equal(val, 'BUZZ');
    equal(count, 1);

    set(get(obj, 'Capital.foo.bar'), 'baz', { biff: 'BLARG' });
    equal(val, 'BLARG');
    equal(count, 2);

    set(get(obj, 'Capital.foo'), 'bar', { baz: { biff: 'BOOM' } });
    equal(val, 'BOOM');
    equal(count, 3);

    set(obj, 'Capital.foo', { bar: { baz: { biff: 'BLARG' } } });
    equal(val, 'BLARG');
    equal(count, 4);

    set(get(obj, 'Capital.foo.bar.baz'), 'biff', 'BUZZ');
    equal(val, 'BUZZ');
    equal(count, 5);

    var foo = get(obj, 'foo');

    set(obj, 'Capital.foo', 'BOO');
    equal(val, undefined);
    equal(count, 6);

    set(foo.bar.baz, 'biff', 'BOOM');
    equal(count, 6, 'should be not have invoked observer');
  });

  QUnit.module('_removeBeforeObserver');

  // ..........................................................
  // SETTING IDENTICAL VALUES
  //

  QUnit.module('props/observer_test - setting identical values');

  _internalTestHelpers.testBoth('setting simple prop should not trigger', function (get, set) {
    var obj = { foo: 'bar' };
    var count = 0;

    _emberMetalObserver.addObserver(obj, 'foo', function () {
      count++;
    });

    set(obj, 'foo', 'bar');
    equal(count, 0, 'should not trigger observer');

    set(obj, 'foo', 'baz');
    equal(count, 1, 'should trigger observer');

    set(obj, 'foo', 'baz');
    equal(count, 1, 'should not trigger observer again');
  });

  // The issue here is when a computed property is directly set with a value, then has a
  // dependent key change (which triggers a cache expiration and recomputation), observers will
  // not be fired if the CP setter is called with the last set value.
  _internalTestHelpers.testBoth('setting a cached computed property whose value has changed should trigger', function (get, set) {
    var obj = {};

    _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.computed({
      get: function () {
        return get(this, 'baz');
      },
      set: function (key, value) {
        return value;
      }
    }).property('baz'));

    var count = 0;

    _emberMetalObserver.addObserver(obj, 'foo', function () {
      count++;
    });

    set(obj, 'foo', 'bar');
    equal(count, 1);
    equal(get(obj, 'foo'), 'bar');

    set(obj, 'baz', 'qux');
    equal(count, 2);
    equal(get(obj, 'foo'), 'qux');

    get(obj, 'foo');
    set(obj, 'foo', 'bar');
    equal(count, 3);
    equal(get(obj, 'foo'), 'bar');
  });

  QUnit.module('Ember.immediateObserver (Deprecated)');

  _internalTestHelpers.testBoth('immediate observers should fire synchronously', function (get, set) {
    expectDeprecation(/Usage of `Ember.immediateObserver` is deprecated, use `Ember.observer` instead./);
    var obj = {};
    var observerCalled = 0;
    var mixin = undefined;

    // explicitly create a run loop so we do not inadvertently
    // trigger deferred behavior
    _emberMetalRun_loop.default(function () {
      mixin = _emberMetalMixin.Mixin.create({
        fooDidChange: _emberMetalMixin._immediateObserver('foo', function () {
          observerCalled++;
          equal(get(this, 'foo'), 'barbaz', 'newly set value is immediately available');
        })
      });

      mixin.apply(obj);

      _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.computed({
        get: function () {
          return 'yes hello this is foo';
        },
        set: function (key, value) {
          return value;
        }
      }));

      equal(get(obj, 'foo'), 'yes hello this is foo', 'precond - computed property returns a value');
      equal(observerCalled, 0, 'observer has not yet been called');

      set(obj, 'foo', 'barbaz');

      equal(observerCalled, 1, 'observer was called once');
    });
  });

  if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.Function) {
    _internalTestHelpers.testBoth('immediate observers added declaratively via brace expansion fire synchronously', function (get, set) {
      var obj = {};
      var observerCalled = 0;
      var mixin = undefined;

      // explicitly create a run loop so we do not inadvertently
      // trigger deferred behavior
      _emberMetalRun_loop.default(function () {
        expectDeprecation(function () {
          mixin = _emberMetalMixin.Mixin.create({
            fooDidChange: (function () {
              observerCalled++;
              equal(get(this, 'foo'), 'barbaz', 'newly set value is immediately available');
            }).observesImmediately('{foo,bar}')
          });
        }, /Function#observesImmediately is deprecated. Use Function#observes instead/);

        mixin.apply(obj);

        _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.computed({
          get: function (key) {
            return 'yes hello this is foo';
          },
          set: function (key, value) {
            return value;
          }
        }));

        equal(get(obj, 'foo'), 'yes hello this is foo', 'precond - computed property returns a value');
        equal(observerCalled, 0, 'observer has not yet been called');

        set(obj, 'foo', 'barbaz');

        equal(observerCalled, 1, 'observer was called once');
      });
    });
  }

  _internalTestHelpers.testBoth('immediate observers watching multiple properties via brace expansion fire synchronously', function (get, set) {
    expectDeprecation(/Usage of `Ember.immediateObserver` is deprecated, use `Ember.observer` instead./);
    var obj = {};
    var observerCalled = 0;
    var mixin = undefined;

    // explicitly create a run loop so we do not inadvertently
    // trigger deferred behavior
    _emberMetalRun_loop.default(function () {
      mixin = _emberMetalMixin.Mixin.create({
        fooDidChange: _emberMetalMixin._immediateObserver('{foo,bar}', function () {
          observerCalled++;
          equal(get(this, 'foo'), 'barbaz', 'newly set value is immediately available');
        })
      });

      mixin.apply(obj);

      _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.computed({
        get: function () {
          return 'yes hello this is foo';
        },
        set: function (key, value) {
          return value;
        }
      }));

      equal(get(obj, 'foo'), 'yes hello this is foo', 'precond - computed property returns a value');
      equal(observerCalled, 0, 'observer has not yet been called');

      set(obj, 'foo', 'barbaz');

      equal(observerCalled, 1, 'observer was called once');
    });
  });

  _internalTestHelpers.testBoth('immediate observers are for internal properties only', function (get, set) {
    expectDeprecation(/Usage of `Ember.immediateObserver` is deprecated, use `Ember.observer` instead./);
    expectAssertion(function () {
      _emberMetalMixin._immediateObserver('foo.bar', function () {
        return this;
      });
    }, 'Immediate observers must observe internal properties only, not properties on other objects.');
  });

  QUnit.module('changeProperties');

  _internalTestHelpers.testBoth('observers added/removed during changeProperties should do the right thing.', function (get, set) {
    var obj = {
      foo: 0
    };
    function Observer() {
      this.willChangeCount = 0;
      this.didChangeCount = 0;
    }
    Observer.prototype = {
      add: function () {
        _emberMetalObserver._addBeforeObserver(obj, 'foo', this, 'willChange');
        _emberMetalObserver.addObserver(obj, 'foo', this, 'didChange');
      },
      remove: function () {
        _emberMetalObserver._removeBeforeObserver(obj, 'foo', this, 'willChange');
        _emberMetalObserver.removeObserver(obj, 'foo', this, 'didChange');
      },
      willChange: function () {
        this.willChangeCount++;
      },
      didChange: function () {
        this.didChangeCount++;
      }
    };
    var addedBeforeFirstChangeObserver = new Observer();
    var addedAfterFirstChangeObserver = new Observer();
    var addedAfterLastChangeObserver = new Observer();
    var removedBeforeFirstChangeObserver = new Observer();
    var removedBeforeLastChangeObserver = new Observer();
    var removedAfterLastChangeObserver = new Observer();
    removedBeforeFirstChangeObserver.add();
    removedBeforeLastChangeObserver.add();
    removedAfterLastChangeObserver.add();
    _emberMetalProperty_events.changeProperties(function () {
      removedBeforeFirstChangeObserver.remove();
      addedBeforeFirstChangeObserver.add();

      set(obj, 'foo', 1);

      equal(addedBeforeFirstChangeObserver.willChangeCount, 1, '_addBeforeObserver called before the first change invoked immediately');
      equal(addedBeforeFirstChangeObserver.didChangeCount, 0, 'addObserver called before the first change is deferred');

      addedAfterFirstChangeObserver.add();
      removedBeforeLastChangeObserver.remove();

      set(obj, 'foo', 2);

      equal(addedAfterFirstChangeObserver.willChangeCount, 1, '_addBeforeObserver called after the first change invoked immediately');
      equal(addedAfterFirstChangeObserver.didChangeCount, 0, 'addObserver called after the first change is deferred');

      addedAfterLastChangeObserver.add();
      removedAfterLastChangeObserver.remove();
    });

    equal(removedBeforeFirstChangeObserver.willChangeCount, 0, '_removeBeforeObserver called before the first change sees none');
    equal(removedBeforeFirstChangeObserver.didChangeCount, 0, 'removeObserver called before the first change sees none');
    equal(addedBeforeFirstChangeObserver.willChangeCount, 1, '_addBeforeObserver called before the first change sees only 1');
    equal(addedBeforeFirstChangeObserver.didChangeCount, 1, 'addObserver called before the first change sees only 1');
    equal(addedAfterFirstChangeObserver.willChangeCount, 1, '_addBeforeObserver called after the first change sees 1');
    equal(addedAfterFirstChangeObserver.didChangeCount, 1, 'addObserver called after the first change sees 1');
    equal(addedAfterLastChangeObserver.willChangeCount, 0, '_addBeforeObserver called after the last change sees none');
    equal(addedAfterLastChangeObserver.didChangeCount, 0, 'addObserver called after the last change sees none');
    equal(removedBeforeLastChangeObserver.willChangeCount, 1, '_removeBeforeObserver called before the last change still sees 1');
    equal(removedBeforeLastChangeObserver.didChangeCount, 1, 'removeObserver called before the last change still sees 1');
    equal(removedAfterLastChangeObserver.willChangeCount, 1, '_removeBeforeObserver called after the last change still sees 1');
    equal(removedAfterLastChangeObserver.didChangeCount, 1, 'removeObserver called after the last change still sees 1');
  });

  QUnit.module('Keys behavior with observers');

  _internalTestHelpers.testBoth('should not leak properties on the prototype', function () {
    function Beer() {}
    Beer.prototype.type = 'ipa';

    var beer = new Beer();

    _emberMetalObserver.addObserver(beer, 'type', K);
    deepEqual(Object.keys(beer), []);
    _emberMetalObserver.removeObserver(beer, 'type', K);
  });

  _internalTestHelpers.testBoth('observing a non existent property', function (get, set) {
    function Beer() {}
    Beer.prototype.type = 'ipa';

    var beer = new Beer();

    _emberMetalObserver.addObserver(beer, 'brand', K);

    deepEqual(Object.keys(beer), []);

    set(beer, 'brand', 'Corona');
    deepEqual(Object.keys(beer), ['brand']);

    _emberMetalObserver.removeObserver(beer, 'brand', K);
  });

  _internalTestHelpers.testBoth('with observers switched on and off', function (get, set) {
    function Beer() {}
    Beer.prototype.type = 'ipa';

    var beer = new Beer();

    _emberMetalObserver.addObserver(beer, 'type', K);
    _emberMetalObserver.removeObserver(beer, 'type', K);

    deepEqual(Object.keys(beer), []);
  });

  _internalTestHelpers.testBoth('observers switched on and off with setter in between', function (get, set) {
    function Beer() {}
    Beer.prototype.type = 'ipa';

    var beer = new Beer();

    _emberMetalObserver.addObserver(beer, 'type', K);
    set(beer, 'type', 'ale');
    _emberMetalObserver.removeObserver(beer, 'type', K);

    deepEqual(Object.keys(beer), ['type']);
  });

  _internalTestHelpers.testBoth('observer switched on and off and then setter', function (get, set) {
    function Beer() {}
    Beer.prototype.type = 'ipa';

    var beer = new Beer();

    _emberMetalObserver.addObserver(beer, 'type', K);
    _emberMetalObserver.removeObserver(beer, 'type', K);
    set(beer, 'type', 'ale');

    deepEqual(Object.keys(beer), ['type']);
  });

  _internalTestHelpers.testBoth('observers switched on and off with setter in between (observed property is not shadowing)', function (get, set) {
    function Beer() {}

    var beer = new Beer();
    set(beer, 'type', 'ale');
    deepEqual(Object.keys(beer), ['type'], 'only set');

    var otherBeer = new Beer();
    _emberMetalObserver.addObserver(otherBeer, 'type', K);
    set(otherBeer, 'type', 'ale');
    deepEqual(Object.keys(otherBeer), ['type'], 'addObserver -> set');

    var yetAnotherBeer = new Beer();
    _emberMetalObserver.addObserver(yetAnotherBeer, 'type', K);
    set(yetAnotherBeer, 'type', 'ale');
    _emberMetalObserver.removeObserver(beer, 'type', K);
    deepEqual(Object.keys(yetAnotherBeer), ['type'], 'addObserver -> set -> removeObserver');

    var itsMyLastBeer = new Beer();
    set(itsMyLastBeer, 'type', 'ale');
    _emberMetalObserver.removeObserver(beer, 'type', K);
    deepEqual(Object.keys(itsMyLastBeer), ['type'], 'set -> removeObserver');
  });

  _internalTestHelpers.testBoth('observers switched on and off with setter in between (observed property is shadowing one on the prototype)', function (get, set) {
    function Beer() {}
    Beer.prototype.type = 'ipa';

    var beer = new Beer();
    set(beer, 'type', 'ale');
    deepEqual(Object.keys(beer), ['type'], 'after set');

    var otherBeer = new Beer();
    _emberMetalObserver.addObserver(otherBeer, 'type', K);
    set(otherBeer, 'type', 'ale');
    deepEqual(Object.keys(otherBeer), ['type'], 'addObserver -> set');

    var yetAnotherBeer = new Beer();
    _emberMetalObserver.addObserver(yetAnotherBeer, 'type', K);
    set(yetAnotherBeer, 'type', 'ale');
    _emberMetalObserver.removeObserver(beer, 'type', K);
    deepEqual(Object.keys(yetAnotherBeer), ['type'], 'addObserver -> set -> removeObserver');

    var itsMyLastBeer = new Beer();
    set(itsMyLastBeer, 'type', 'ale');
    _emberMetalObserver.removeObserver(beer, 'type', K);
    deepEqual(Object.keys(itsMyLastBeer), ['type'], 'set -> removeObserver');
  });
});
enifed('ember-metal/tests/observer_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/observer_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/observer_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/performance_test', ['exports', 'ember-metal/property_set', 'ember-metal/property_get', 'ember-metal/computed', 'ember-metal/properties', 'ember-metal/property_events', 'ember-metal/observer'], function (exports, _emberMetalProperty_set, _emberMetalProperty_get, _emberMetalComputed, _emberMetalProperties, _emberMetalProperty_events, _emberMetalObserver) {
  'use strict';

  /*
    This test file is designed to capture performance regressions related to
    deferred computation. Things like run loops, computed properties, and bindings
    should run the minimum amount of times to achieve best performance, so any
    bugs that cause them to get evaluated more than necessary should be put here.
  */

  QUnit.module('Computed Properties - Number of times evaluated');

  QUnit.test('computed properties that depend on multiple properties should run only once per run loop', function () {
    var obj = { a: 'a', b: 'b', c: 'c' };
    var cpCount = 0;
    var obsCount = 0;

    _emberMetalProperties.defineProperty(obj, 'abc', _emberMetalComputed.computed(function (key) {
      cpCount++;
      return 'computed ' + key;
    }).property('a', 'b', 'c'));

    _emberMetalProperty_get.get(obj, 'abc');

    cpCount = 0;

    _emberMetalObserver.addObserver(obj, 'abc', function () {
      obsCount++;
    });

    _emberMetalProperty_events.beginPropertyChanges();
    _emberMetalProperty_set.set(obj, 'a', 'aa');
    _emberMetalProperty_set.set(obj, 'b', 'bb');
    _emberMetalProperty_set.set(obj, 'c', 'cc');
    _emberMetalProperty_events.endPropertyChanges();

    _emberMetalProperty_get.get(obj, 'abc');

    equal(cpCount, 1, 'The computed property is only invoked once');
    equal(obsCount, 1, 'The observer is only invoked once');
  });

  QUnit.test('computed properties are not executed if they are the last segment of an observer chain pain', function () {
    var foo = { bar: { baz: {} } };

    var count = 0;

    _emberMetalProperties.defineProperty(foo.bar.baz, 'bam', _emberMetalComputed.computed(function () {
      count++;
    }));

    _emberMetalObserver.addObserver(foo, 'bar.baz.bam', function () {});

    _emberMetalProperty_events.propertyDidChange(_emberMetalProperty_get.get(foo, 'bar.baz'), 'bam');

    equal(count, 0, 'should not have recomputed property');
  });
});
enifed('ember-metal/tests/performance_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/performance_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/performance_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/properties_test', ['exports', 'ember-metal/computed', 'ember-metal/properties', 'ember-metal/deprecate_property'], function (exports, _emberMetalComputed, _emberMetalProperties, _emberMetalDeprecate_property) {
  'use strict';

  QUnit.module('Ember.defineProperty');

  QUnit.test('toString', function () {
    var obj = {};
    _emberMetalProperties.defineProperty(obj, 'toString', undefined, function () {
      return 'FOO';
    });
    equal(obj.toString(), 'FOO', 'should replace toString');
  });

  QUnit.test('for data properties, didDefineProperty hook should be called if implemented', function () {
    expect(2);

    var obj = {
      didDefineProperty: function (obj, keyName, value) {
        equal(keyName, 'foo', 'key name should be foo');
        equal(value, 'bar', 'value should be bar');
      }
    };

    _emberMetalProperties.defineProperty(obj, 'foo', undefined, 'bar');
  });

  QUnit.test('for computed properties, didDefineProperty hook should be called if implemented', function () {
    expect(2);

    var computedProperty = _emberMetalComputed.computed(function () {
      return this;
    });

    var obj = {
      didDefineProperty: function (obj, keyName, value) {
        equal(keyName, 'foo', 'key name should be foo');
        strictEqual(value, computedProperty, 'value should be passed as computed property');
      }
    };

    _emberMetalProperties.defineProperty(obj, 'foo', computedProperty);
  });

  QUnit.test('for descriptor properties, didDefineProperty hook should be called if implemented', function () {
    expect(2);

    var descriptor = {
      writable: true,
      configurable: false,
      enumerable: true,
      value: 42
    };

    var obj = {
      didDefineProperty: function (obj, keyName, value) {
        equal(keyName, 'answer', 'key name should be answer');
        strictEqual(value, descriptor, 'value should be passed as descriptor');
      }
    };

    _emberMetalProperties.defineProperty(obj, 'answer', descriptor);
  });

  QUnit.module('Ember.deprecateProperty');

  QUnit.test('enables access to deprecated property and returns the value of the new property', function () {
    expect(3);
    var obj = { foo: 'bar' };

    _emberMetalDeprecate_property.deprecateProperty(obj, 'baz', 'foo');

    expectDeprecation();
    equal(obj.baz, obj.foo, 'baz and foo are equal');

    obj.foo = 'blammo';
    equal(obj.baz, obj.foo, 'baz and foo are equal');
  });

  QUnit.test('deprecatedKey is not enumerable', function () {
    expect(2);
    var obj = { foo: 'bar', blammo: 'whammy' };

    _emberMetalDeprecate_property.deprecateProperty(obj, 'baz', 'foo');

    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        notEqual(prop, 'baz');
      }
    }
  });

  QUnit.test('enables setter to deprecated property and updates the value of the new property', function () {
    expect(3);
    var obj = { foo: 'bar' };

    _emberMetalDeprecate_property.deprecateProperty(obj, 'baz', 'foo');

    expectDeprecation();
    obj.baz = 'bloop';
    equal(obj.foo, 'bloop', 'updating baz updates foo');
    equal(obj.baz, obj.foo, 'baz and foo are equal');
  });
});
enifed('ember-metal/tests/properties_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/properties_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/properties_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/property_did_change_hook', ['exports', 'internal-test-helpers', 'ember-metal/property_events', 'ember-metal/watching', 'ember-metal/properties', 'ember-metal/alias', 'ember-metal/computed'], function (exports, _internalTestHelpers, _emberMetalProperty_events, _emberMetalWatching, _emberMetalProperties, _emberMetalAlias, _emberMetalComputed) {
  'use strict';

  QUnit.module('PROPERTY_DID_CHANGE');

  _internalTestHelpers.testBoth('alias and cp', function (get, set) {
    var _obj;

    var counts = {};
    var obj = (_obj = {
      child: {}
    }, _obj[_emberMetalProperty_events.PROPERTY_DID_CHANGE] = function (keyName) {
      counts[keyName] = (counts[keyName] || 0) + 1;
    }, _obj);

    _emberMetalProperties.defineProperty(obj, 'cost', _emberMetalAlias.default('child.cost'));
    _emberMetalProperties.defineProperty(obj, 'tax', _emberMetalAlias.default('child.tax'));

    _emberMetalProperties.defineProperty(obj, 'total', _emberMetalComputed.computed('cost', 'tax', {
      get: function () {
        return get(this, 'cost') + get(this, 'tax');
      }
    }));

    ok(!_emberMetalWatching.isWatching(obj, 'child.cost'), 'precond alias target `child.cost` is not watched');
    equal(get(obj, 'cost'), undefined);
    // this is how PROPERTY_DID_CHANGE will get notified
    ok(_emberMetalWatching.isWatching(obj, 'child.cost'), 'alias target `child.cost` is watched after consumption');

    ok(!_emberMetalWatching.isWatching(obj, 'child.tax'), 'precond alias target `child.tax` is not watched');
    equal(get(obj, 'tax'), undefined);
    // this is how PROPERTY_DID_CHANGE will get notified
    ok(_emberMetalWatching.isWatching(obj, 'child.tax'), 'alias target `child.cost` is watched after consumption');

    // increments the watching count on the alias itself to 1
    ok(isNaN(get(obj, 'total')), 'total is initialized');

    // decrements the watching count on the alias itself to 0
    set(obj, 'child', {
      cost: 399.00,
      tax: 32.93
    });

    // this should have called PROPERTY_DID_CHANGE for all of them
    equal(counts['cost'], 1, 'PROPERTY_DID_CHANGE called with cost');
    equal(counts['tax'], 1, 'PROPERTY_DID_CHANGE called with tax');
    equal(counts['total'], 1, 'PROPERTY_DID_CHANGE called with total');

    // we should still have a dependency installed
    ok(_emberMetalWatching.isWatching(obj, 'child.cost'), 'watching child.cost');
    ok(_emberMetalWatching.isWatching(obj, 'child.tax'), 'watching child.tax');

    set(obj, 'child', {
      cost: 100.00,
      tax: 10.00
    });

    equal(counts['cost'], 2, 'PROPERTY_DID_CHANGE called with cost');
    equal(counts['tax'], 2, 'PROPERTY_DID_CHANGE called with tax');
    equal(counts['total'], 1, 'PROPERTY_DID_CHANGE called with total');
  });
});
enifed('ember-metal/tests/property_did_change_hook.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/property_did_change_hook.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/property_did_change_hook.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/run_loop/add_queue_test', ['exports', 'ember-metal/run_loop'], function (exports, _emberMetalRun_loop) {
  'use strict';

  var originalQueues = _emberMetalRun_loop.default.queues;
  var queues = undefined;

  QUnit.module('system/run_loop/add_queue_test', {
    setup: function () {
      _emberMetalRun_loop.default.queues = queues = ['blork', 'bleep'];
    },
    teardown: function () {
      _emberMetalRun_loop.default.queues = originalQueues;
    }
  });

  QUnit.test('adds a queue after a specified one', function () {
    _emberMetalRun_loop.default._addQueue('testeroo', 'blork');

    equal(queues.indexOf('testeroo'), 1, 'new queue was added after specified queue');
  });

  QUnit.test('does not add the queue if it already exists', function () {
    _emberMetalRun_loop.default._addQueue('testeroo', 'blork');
    _emberMetalRun_loop.default._addQueue('testeroo', 'blork');

    equal(queues.length, 3, 'queue was not added twice');
  });
});
enifed('ember-metal/tests/run_loop/add_queue_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/run_loop/add_queue_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/run_loop/add_queue_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/run_loop/debounce_test', ['exports', 'ember-metal/run_loop'], function (exports, _emberMetalRun_loop) {
  'use strict';

  var originalDebounce = _emberMetalRun_loop.default.backburner.debounce;
  var wasCalled = false;

  QUnit.module('Ember.run.debounce', {
    setup: function () {
      _emberMetalRun_loop.default.backburner.debounce = function () {
        wasCalled = true;
      };
    },
    teardown: function () {
      _emberMetalRun_loop.default.backburner.debounce = originalDebounce;
    }
  });

  QUnit.test('Ember.run.debounce uses Backburner.debounce', function () {
    _emberMetalRun_loop.default.debounce(function () {});
    ok(wasCalled, 'Ember.run.debounce used');
  });
});
enifed('ember-metal/tests/run_loop/debounce_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/run_loop/debounce_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/run_loop/debounce_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/run_loop/later_test', ['exports', 'ember-metal/is_none', 'ember-metal/run_loop'], function (exports, _emberMetalIs_none, _emberMetalRun_loop) {
  'use strict';

  var originalSetTimeout = window.setTimeout;
  var originalDateValueOf = Date.prototype.valueOf;
  var originalPlatform = _emberMetalRun_loop.default.backburner._platform;

  function wait(callback, maxWaitCount) {
    maxWaitCount = _emberMetalIs_none.default(maxWaitCount) ? 100 : maxWaitCount;

    originalSetTimeout(function () {
      if (maxWaitCount > 0 && (_emberMetalRun_loop.default.hasScheduledTimers() || _emberMetalRun_loop.default.currentRunLoop)) {
        wait(callback, maxWaitCount - 1);

        return;
      }

      callback();
    }, 10);
  }

  // Synchronous "sleep". This simulates work being done
  // after run.later was called but before the run loop
  // has flushed. In previous versions, this would have
  // caused the run.later callback to have run from
  // within the run loop flush, since by the time the
  // run loop has to flush, it would have considered
  // the timer already expired.
  function pauseUntil(time) {
    // jscs:disable
    while (+new Date() < time) {} /* do nothing - sleeping */
    // jscs:enable
  }

  QUnit.module('run.later', {
    teardown: function () {
      _emberMetalRun_loop.default.backburner._platform = originalPlatform;
      window.setTimeout = originalSetTimeout;
      Date.prototype.valueOf = originalDateValueOf;
    }
  });

  asyncTest('should invoke after specified period of time - function only', function () {
    var invoked = false;

    _emberMetalRun_loop.default(function () {
      _emberMetalRun_loop.default.later(function () {
        return invoked = true;
      }, 100);
    });

    wait(function () {
      QUnit.start();
      equal(invoked, true, 'should have invoked later item');
    });
  });

  asyncTest('should invoke after specified period of time - target/method', function () {
    var obj = { invoked: false };

    _emberMetalRun_loop.default(function () {
      _emberMetalRun_loop.default.later(obj, function () {
        this.invoked = true;
      }, 100);
    });

    wait(function () {
      QUnit.start();
      equal(obj.invoked, true, 'should have invoked later item');
    });
  });

  asyncTest('should invoke after specified period of time - target/method/args', function () {
    var obj = { invoked: 0 };

    _emberMetalRun_loop.default(function () {
      _emberMetalRun_loop.default.later(obj, function (amt) {
        this.invoked += amt;
      }, 10, 100);
    });

    wait(function () {
      QUnit.start();
      equal(obj.invoked, 10, 'should have invoked later item');
    });
  });

  asyncTest('should always invoke within a separate runloop', function () {
    var obj = { invoked: 0 };
    var firstRunLoop = undefined,
        secondRunLoop = undefined;

    _emberMetalRun_loop.default(function () {
      firstRunLoop = _emberMetalRun_loop.default.currentRunLoop;

      _emberMetalRun_loop.default.later(obj, function (amt) {
        this.invoked += amt;
        secondRunLoop = _emberMetalRun_loop.default.currentRunLoop;
      }, 10, 1);

      pauseUntil(+new Date() + 100);
    });

    ok(firstRunLoop, 'first run loop captured');
    ok(!_emberMetalRun_loop.default.currentRunLoop, 'shouldn\'t be in a run loop after flush');
    equal(obj.invoked, 0, 'shouldn\'t have invoked later item yet');

    wait(function () {
      QUnit.start();
      equal(obj.invoked, 10, 'should have invoked later item');
      ok(secondRunLoop, 'second run loop took place');
      ok(secondRunLoop !== firstRunLoop, 'two different run loops took place');
    });
  });

  // Our current implementation doesn't allow us to correctly enforce this ordering.
  // We should probably implement a queue to provide this guarantee.
  // See https://github.com/emberjs/ember.js/issues/3526 for more information.

  // asyncTest('callback order', function() {
  //   let array = [];
  //   function fn(val) { array.push(val); }

  //   run(function() {
  //     run.later(this, fn, 4, 5);
  //     run.later(this, fn, 1, 1);
  //     run.later(this, fn, 5, 10);
  //     run.later(this, fn, 2, 3);
  //     run.later(this, fn, 3, 3);
  //   });

  //   deepEqual(array, []);

  //   wait(function() {
  //     QUnit.start();
  //     deepEqual(array, [1,2,3,4,5], 'callbacks were called in expected order');
  //   });
  // });

  // Out current implementation doesn't allow us to properly enforce what is tested here.
  // We should probably fix it, but it's not technically a bug right now.
  // See https://github.com/emberjs/ember.js/issues/3522 for more information.

  // asyncTest('callbacks coalesce into same run loop if expiring at the same time', function() {
  //   let array = [];
  //   function fn(val) { array.push(run.currentRunLoop); }

  //   run(function() {

  //     // Force +new Date to return the same result while scheduling
  //     // run.later timers. Otherwise: non-determinism!
  //     let now = +new Date();
  //     Date.prototype.valueOf = function() { return now; };

  //     run.later(this, fn, 10);
  //     run.later(this, fn, 200);
  //     run.later(this, fn, 200);

  //     Date.prototype.valueOf = originalDateValueOf;
  //   });

  //   deepEqual(array, []);

  //   wait(function() {
  //     QUnit.start();
  //     equal(array.length, 3, 'all callbacks called');
  //     ok(array[0] !== array[1], 'first two callbacks have different run loops');
  //     ok(array[0], 'first runloop present');
  //     ok(array[1], 'second runloop present');
  //     equal(array[1], array[2], 'last two callbacks got the same run loop');
  //   });
  // });

  asyncTest('inception calls to run.later should run callbacks in separate run loops', function () {
    var runLoop = undefined,
        finished = undefined;

    _emberMetalRun_loop.default(function () {
      runLoop = _emberMetalRun_loop.default.currentRunLoop;
      ok(runLoop);

      _emberMetalRun_loop.default.later(function () {
        ok(_emberMetalRun_loop.default.currentRunLoop && _emberMetalRun_loop.default.currentRunLoop !== runLoop, 'first later callback has own run loop');
        runLoop = _emberMetalRun_loop.default.currentRunLoop;

        _emberMetalRun_loop.default.later(function () {
          ok(_emberMetalRun_loop.default.currentRunLoop && _emberMetalRun_loop.default.currentRunLoop !== runLoop, 'second later callback has own run loop');
          finished = true;
        }, 40);
      }, 40);
    });

    wait(function () {
      QUnit.start();
      ok(finished, 'all .later callbacks run');
    });
  });

  asyncTest('setTimeout should never run with a negative wait', function () {
    // Rationale: The old run loop code was susceptible to an occasional
    // bug where invokeLaterTimers would be scheduled with a setTimeout
    // with a negative wait. Modern browsers normalize this to 0, but
    // older browsers (IE <= 8) break with a negative wait, which
    // happens when an expired timer callback takes a while to run,
    // which is what we simulate here.
    var newSetTimeoutUsed = undefined;
    _emberMetalRun_loop.default.backburner._platform = {
      setTimeout: function () {
        var wait = arguments[arguments.length - 1];
        newSetTimeoutUsed = true;
        ok(!isNaN(wait) && wait >= 0, 'wait is a non-negative number');

        return originalPlatform.setTimeout.apply(originalPlatform, arguments);
      }
    };

    var count = 0;
    _emberMetalRun_loop.default(function () {
      _emberMetalRun_loop.default.later(function () {
        count++;

        // This will get run first. Waste some time.
        // This is intended to break invokeLaterTimers code by taking a
        // long enough time that other timers should technically expire. It's
        // fine that they're not called in this run loop; just need to
        // make sure that invokeLaterTimers doesn't end up scheduling
        // a negative setTimeout.
        pauseUntil(+new Date() + 60);
      }, 1);

      _emberMetalRun_loop.default.later(function () {
        equal(count, 1, 'callbacks called in order');
      }, 50);
    });

    wait(function () {
      QUnit.start();
      ok(newSetTimeoutUsed, 'stub setTimeout was used');
    });
  });
});
enifed('ember-metal/tests/run_loop/later_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/run_loop/later_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/run_loop/later_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/run_loop/next_test', ['exports', 'ember-metal/run_loop'], function (exports, _emberMetalRun_loop) {
  'use strict';

  QUnit.module('run.next');

  asyncTest('should invoke immediately on next timeout', function () {
    var invoked = false;

    _emberMetalRun_loop.default(function () {
      return _emberMetalRun_loop.default.next(function () {
        return invoked = true;
      });
    });

    equal(invoked, false, 'should not have invoked yet');

    setTimeout(function () {
      QUnit.start();
      equal(invoked, true, 'should have invoked later item');
    }, 20);
  });

  asyncTest('callback should be called from within separate loop', function () {
    var firstRunLoop = undefined,
        secondRunLoop = undefined;
    _emberMetalRun_loop.default(function () {
      firstRunLoop = _emberMetalRun_loop.default.currentRunLoop;
      _emberMetalRun_loop.default.next(function () {
        return secondRunLoop = _emberMetalRun_loop.default.currentRunLoop;
      });
    });

    setTimeout(function () {
      QUnit.start();
      ok(secondRunLoop, 'callback was called from within run loop');
      ok(firstRunLoop && secondRunLoop !== firstRunLoop, 'two separate run loops were invoked');
    }, 20);
  });

  asyncTest('multiple calls to run.next share coalesce callbacks into same run loop', function () {
    var secondRunLoop = undefined,
        thirdRunLoop = undefined;
    _emberMetalRun_loop.default(function () {
      _emberMetalRun_loop.default.next(function () {
        return secondRunLoop = _emberMetalRun_loop.default.currentRunLoop;
      });
      _emberMetalRun_loop.default.next(function () {
        return thirdRunLoop = _emberMetalRun_loop.default.currentRunLoop;
      });
    });

    setTimeout(function () {
      QUnit.start();
      ok(secondRunLoop && secondRunLoop === thirdRunLoop, 'callbacks coalesced into same run loop');
    }, 20);
  });
});
enifed('ember-metal/tests/run_loop/next_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/run_loop/next_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/run_loop/next_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/run_loop/once_test', ['exports', 'ember-metal/run_loop'], function (exports, _emberMetalRun_loop) {
  'use strict';

  QUnit.module('system/run_loop/once_test');

  QUnit.test('calling invokeOnce more than once invokes only once', function () {
    var count = 0;
    _emberMetalRun_loop.default(function () {
      function F() {
        count++;
      }
      _emberMetalRun_loop.default.once(F);
      _emberMetalRun_loop.default.once(F);
      _emberMetalRun_loop.default.once(F);
    });

    equal(count, 1, 'should have invoked once');
  });

  QUnit.test('should differentiate based on target', function () {
    var A = { count: 0 };
    var B = { count: 0 };
    _emberMetalRun_loop.default(function () {
      function F() {
        this.count++;
      }
      _emberMetalRun_loop.default.once(A, F);
      _emberMetalRun_loop.default.once(B, F);
      _emberMetalRun_loop.default.once(A, F);
      _emberMetalRun_loop.default.once(B, F);
    });

    equal(A.count, 1, 'should have invoked once on A');
    equal(B.count, 1, 'should have invoked once on B');
  });

  QUnit.test('should ignore other arguments - replacing previous ones', function () {
    var A = { count: 0 };
    var B = { count: 0 };

    _emberMetalRun_loop.default(function () {
      function F(amt) {
        this.count += amt;
      }
      _emberMetalRun_loop.default.once(A, F, 10);
      _emberMetalRun_loop.default.once(B, F, 20);
      _emberMetalRun_loop.default.once(A, F, 30);
      _emberMetalRun_loop.default.once(B, F, 40);
    });

    equal(A.count, 30, 'should have invoked once on A');
    equal(B.count, 40, 'should have invoked once on B');
  });

  QUnit.test('should be inside of a runloop when running', function () {
    _emberMetalRun_loop.default(function () {
      _emberMetalRun_loop.default.once(function () {
        return ok(!!_emberMetalRun_loop.default.currentRunLoop, 'should have a runloop');
      });
    });
  });
});
enifed('ember-metal/tests/run_loop/once_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/run_loop/once_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/run_loop/once_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/run_loop/onerror_test', ['exports', 'ember-metal/run_loop', 'ember-metal/error_handler'], function (exports, _emberMetalRun_loop, _emberMetalError_handler) {
  'use strict';

  QUnit.module('system/run_loop/onerror_test');

  QUnit.test('With Ember.onerror undefined, errors in Ember.run are thrown', function () {
    var thrown = new Error('Boom!');
    var original = _emberMetalError_handler.getOnerror();

    var caught = undefined;
    _emberMetalError_handler.setOnerror(undefined);
    try {
      _emberMetalRun_loop.default(function () {
        throw thrown;
      });
    } catch (error) {
      caught = error;
    } finally {
      _emberMetalError_handler.setOnerror(original);
    }

    deepEqual(caught, thrown);
  });

  QUnit.test('With Ember.onerror set, errors in Ember.run are caught', function () {
    var thrown = new Error('Boom!');
    var original = _emberMetalError_handler.getOnerror();

    var caught = undefined;
    _emberMetalError_handler.setOnerror(function (error) {
      caught = error;
    });
    try {
      _emberMetalRun_loop.default(function () {
        throw thrown;
      });
    } finally {
      _emberMetalError_handler.setOnerror(original);
    }

    deepEqual(caught, thrown);
  });
});
enifed('ember-metal/tests/run_loop/onerror_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/run_loop/onerror_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/run_loop/onerror_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/run_loop/run_bind_test', ['exports', 'ember-metal/run_loop'], function (exports, _emberMetalRun_loop) {
  'use strict';

  QUnit.module('system/run_loop/run_bind_test');

  QUnit.test('Ember.run.bind builds a run-loop wrapped callback handler', function () {
    expect(3);

    var obj = {
      value: 0,
      increment: function (increment) {
        ok(_emberMetalRun_loop.default.currentRunLoop, 'expected a run-loop');
        return this.value += increment;
      }
    };

    var proxiedFunction = _emberMetalRun_loop.default.bind(obj, obj.increment, 1);
    equal(proxiedFunction(), 1);
    equal(obj.value, 1);
  });

  QUnit.test('Ember.run.bind keeps the async callback arguments', function () {
    expect(4);

    function asyncCallback(increment, increment2, increment3) {
      ok(_emberMetalRun_loop.default.currentRunLoop, 'expected a run-loop');
      equal(increment, 1);
      equal(increment2, 2);
      equal(increment3, 3);
    }

    function asyncFunction(fn) {
      fn(2, 3);
    }

    asyncFunction(_emberMetalRun_loop.default.bind(asyncCallback, asyncCallback, 1));
  });
});
enifed('ember-metal/tests/run_loop/run_bind_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/run_loop/run_bind_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/run_loop/run_bind_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/run_loop/run_test', ['exports', 'ember-metal/run_loop'], function (exports, _emberMetalRun_loop) {
  'use strict';

  QUnit.module('system/run_loop/run_test');

  QUnit.test('Ember.run invokes passed function, returning value', function () {
    var obj = {
      foo: function () {
        return [this.bar, 'FOO'];
      },
      bar: 'BAR',
      checkArgs: function (arg1, arg2) {
        return [arg1, this.bar, arg2];
      }
    };

    equal(_emberMetalRun_loop.default(function () {
      return 'FOO';
    }), 'FOO', 'pass function only');
    deepEqual(_emberMetalRun_loop.default(obj, obj.foo), ['BAR', 'FOO'], 'pass obj and obj.method');
    deepEqual(_emberMetalRun_loop.default(obj, 'foo'), ['BAR', 'FOO'], 'pass obj and "method"');
    deepEqual(_emberMetalRun_loop.default(obj, obj.checkArgs, 'hello', 'world'), ['hello', 'BAR', 'world'], 'pass obj, obj.method, and extra arguments');
  });
});
enifed('ember-metal/tests/run_loop/run_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/run_loop/run_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/run_loop/run_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/run_loop/schedule_test', ['exports', 'ember-metal/run_loop'], function (exports, _emberMetalRun_loop) {
  'use strict';

  QUnit.module('system/run_loop/schedule_test');

  QUnit.test('scheduling item in queue should defer until finished', function () {
    var cnt = 0;

    _emberMetalRun_loop.default(function () {
      _emberMetalRun_loop.default.schedule('actions', function () {
        return cnt++;
      });
      _emberMetalRun_loop.default.schedule('actions', function () {
        return cnt++;
      });
      equal(cnt, 0, 'should not run action yet');
    });

    equal(cnt, 2, 'should flush actions now');
  });

  QUnit.test('a scheduled item can be canceled', function (assert) {
    var hasRan = false;

    _emberMetalRun_loop.default(function () {
      var cancelId = _emberMetalRun_loop.default.schedule('actions', function () {
        return hasRan = true;
      });
      _emberMetalRun_loop.default.cancel(cancelId);
    });

    assert.notOk(hasRan, 'should not have ran callback run');
  });

  QUnit.test('nested runs should queue each phase independently', function () {
    var cnt = 0;

    _emberMetalRun_loop.default(function () {
      _emberMetalRun_loop.default.schedule('actions', function () {
        return cnt++;
      });
      equal(cnt, 0, 'should not run action yet');

      _emberMetalRun_loop.default(function () {
        _emberMetalRun_loop.default.schedule('actions', function () {
          return cnt++;
        });
      });
      equal(cnt, 1, 'should not run action yet');
    });

    equal(cnt, 2, 'should flush actions now');
  });

  QUnit.test('prior queues should be flushed before moving on to next queue', function () {
    var order = [];

    _emberMetalRun_loop.default(function () {
      var runLoop = _emberMetalRun_loop.default.currentRunLoop;
      ok(runLoop, 'run loop present');

      _emberMetalRun_loop.default.schedule('sync', function () {
        order.push('sync');
        equal(runLoop, _emberMetalRun_loop.default.currentRunLoop, 'same run loop used');
      });

      _emberMetalRun_loop.default.schedule('actions', function () {
        order.push('actions');
        equal(runLoop, _emberMetalRun_loop.default.currentRunLoop, 'same run loop used');

        _emberMetalRun_loop.default.schedule('actions', function () {
          order.push('actions');
          equal(runLoop, _emberMetalRun_loop.default.currentRunLoop, 'same run loop used');
        });

        _emberMetalRun_loop.default.schedule('sync', function () {
          order.push('sync');
          equal(runLoop, _emberMetalRun_loop.default.currentRunLoop, 'same run loop used');
        });
      });

      _emberMetalRun_loop.default.schedule('destroy', function () {
        order.push('destroy');
        equal(runLoop, _emberMetalRun_loop.default.currentRunLoop, 'same run loop used');
      });
    });

    deepEqual(order, ['sync', 'actions', 'sync', 'actions', 'destroy']);
  });

  QUnit.test('makes sure it does not trigger an autorun during testing', function () {
    expectAssertion(function () {
      return _emberMetalRun_loop.default.schedule('actions', function () {});
    }, /wrap any code with asynchronous side-effects in a run/);

    // make sure not just the first violation is asserted.
    expectAssertion(function () {
      return _emberMetalRun_loop.default.schedule('actions', function () {});
    }, /wrap any code with asynchronous side-effects in a run/);
  });
});
enifed('ember-metal/tests/run_loop/schedule_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/run_loop/schedule_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/run_loop/schedule_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/run_loop/sync_test', ['exports', 'ember-metal/run_loop'], function (exports, _emberMetalRun_loop) {
  'use strict';

  QUnit.module('system/run_loop/sync_test');

  QUnit.test('sync() will immediately flush the sync queue only', function () {
    var cnt = 0;

    _emberMetalRun_loop.default(function () {
      function cntup() {
        cnt++;
      }

      function syncfunc() {
        if (++cnt < 5) {
          _emberMetalRun_loop.default.schedule('sync', syncfunc);
        }
        _emberMetalRun_loop.default.schedule('actions', cntup);
      }

      syncfunc();

      equal(cnt, 1, 'should not run action yet');
      _emberMetalRun_loop.default.sync();

      equal(cnt, 5, 'should have run sync queue continuously');
    });

    equal(cnt, 10, 'should flush actions now too');
  });

  QUnit.test('calling sync() outside a run loop does not cause an error', function () {
    expect(0);

    _emberMetalRun_loop.default.sync();
  });
});
enifed('ember-metal/tests/run_loop/sync_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/run_loop/sync_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/run_loop/sync_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/run_loop/unwind_test', ['exports', 'ember-metal/run_loop', 'ember-metal/error'], function (exports, _emberMetalRun_loop, _emberMetalError) {
  'use strict';

  QUnit.module('system/run_loop/unwind_test');

  QUnit.test('RunLoop unwinds despite unhandled exception', function () {
    var initialRunLoop = _emberMetalRun_loop.default.currentRunLoop;

    throws(function () {
      _emberMetalRun_loop.default(function () {
        _emberMetalRun_loop.default.schedule('actions', function () {
          throw new _emberMetalError.default('boom!');
        });
      });
    }, Error, 'boom!');

    // The real danger at this point is that calls to autorun will stick
    // tasks into the already-dead runloop, which will never get
    // flushed. I can't easily demonstrate this in a unit test because
    // autorun explicitly doesn't work in test mode. - ef4
    equal(_emberMetalRun_loop.default.currentRunLoop, initialRunLoop, 'Previous run loop should be cleaned up despite exception');

    // Prevent a failure in this test from breaking subsequent tests.
    _emberMetalRun_loop.default.currentRunLoop = initialRunLoop;
  });

  QUnit.test('run unwinds despite unhandled exception', function () {
    var initialRunLoop = _emberMetalRun_loop.default.currentRunLoop;

    throws(function () {
      _emberMetalRun_loop.default(function () {
        throw new _emberMetalError.default('boom!');
      });
    }, _emberMetalError.default, 'boom!');

    equal(_emberMetalRun_loop.default.currentRunLoop, initialRunLoop, 'Previous run loop should be cleaned up despite exception');

    // Prevent a failure in this test from breaking subsequent tests.
    _emberMetalRun_loop.default.currentRunLoop = initialRunLoop;
  });
});
enifed('ember-metal/tests/run_loop/unwind_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/run_loop/unwind_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/run_loop/unwind_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/set_properties_test', ['exports', 'ember-metal/set_properties'], function (exports, _emberMetalSet_properties) {
  'use strict';

  QUnit.module('Ember.setProperties');

  QUnit.test('supports setting multiple attributes at once', function () {
    deepEqual(_emberMetalSet_properties.default(null, null), null, 'noop for null properties and null object');
    deepEqual(_emberMetalSet_properties.default(undefined, undefined), undefined, 'noop for undefined properties and undefined object');

    deepEqual(_emberMetalSet_properties.default({}), undefined, 'noop for no properties');
    deepEqual(_emberMetalSet_properties.default({}, undefined), undefined, 'noop for undefined');
    deepEqual(_emberMetalSet_properties.default({}, null), null, 'noop for null');
    deepEqual(_emberMetalSet_properties.default({}, NaN), NaN, 'noop for NaN');
    deepEqual(_emberMetalSet_properties.default({}, {}), {}, 'meh');

    deepEqual(_emberMetalSet_properties.default({}, { foo: 1 }), { foo: 1 }, 'Set a single property');

    deepEqual(_emberMetalSet_properties.default({}, { foo: 1, bar: 1 }), { foo: 1, bar: 1 }, 'Set multiple properties');

    deepEqual(_emberMetalSet_properties.default({ foo: 2, baz: 2 }, { foo: 1 }), { foo: 1 }, 'Set one of multiple properties');

    deepEqual(_emberMetalSet_properties.default({ foo: 2, baz: 2 }, { bar: 2 }), {
      bar: 2
    }, 'Set an additional, previously unset property');
  });
});
enifed('ember-metal/tests/set_properties_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/set_properties_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/set_properties_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/watching/is_watching_test', ['exports', 'ember-metal/computed', 'ember-metal/property_get', 'ember-metal/properties', 'ember-metal/mixin', 'ember-metal/observer', 'ember-metal/watching'], function (exports, _emberMetalComputed, _emberMetalProperty_get, _emberMetalProperties, _emberMetalMixin, _emberMetalObserver, _emberMetalWatching) {
  'use strict';

  QUnit.module('isWatching');

  function testObserver(setup, teardown) {
    var key = arguments.length <= 2 || arguments[2] === undefined ? 'key' : arguments[2];

    var obj = {};
    function fn() {}

    equal(_emberMetalWatching.isWatching(obj, key), false, 'precond - isWatching is false by default');
    setup(obj, key, fn);
    equal(_emberMetalWatching.isWatching(obj, key), true, 'isWatching is true when observers are added');
    teardown(obj, key, fn);
    equal(_emberMetalWatching.isWatching(obj, key), false, 'isWatching is false after observers are removed');
  }

  QUnit.test('isWatching is true for regular local observers', function () {
    testObserver(function (obj, key, fn) {
      _emberMetalMixin.Mixin.create({
        didChange: _emberMetalMixin.observer(key, fn)
      }).apply(obj);
    }, function (obj, key, fn) {
      return _emberMetalObserver.removeObserver(obj, key, obj, fn);
    });
  });

  QUnit.test('isWatching is true for nonlocal observers', function () {
    testObserver(function (obj, key, fn) {
      _emberMetalObserver.addObserver(obj, key, obj, fn);
    }, function (obj, key, fn) {
      return _emberMetalObserver.removeObserver(obj, key, obj, fn);
    });
  });

  QUnit.test('isWatching is true for chained observers', function () {
    testObserver(function (obj, key, fn) {
      _emberMetalObserver.addObserver(obj, key + '.bar', obj, fn);
    }, function (obj, key, fn) {
      _emberMetalObserver.removeObserver(obj, key + '.bar', obj, fn);
    });
  });

  QUnit.test('isWatching is true for computed properties', function () {
    testObserver(function (obj, key, fn) {
      _emberMetalProperties.defineProperty(obj, 'computed', _emberMetalComputed.computed(fn).property(key));
      _emberMetalProperty_get.get(obj, 'computed');
    }, function (obj, key, fn) {
      return _emberMetalProperties.defineProperty(obj, 'computed', null);
    });
  });

  QUnit.test('isWatching is true for chained computed properties', function () {
    testObserver(function (obj, key, fn) {
      _emberMetalProperties.defineProperty(obj, 'computed', _emberMetalComputed.computed(fn).property(key + '.bar'));
      _emberMetalProperty_get.get(obj, 'computed');
    }, function (obj, key, fn) {
      return _emberMetalProperties.defineProperty(obj, 'computed', null);
    });
  });

  // can't watch length on Array - it is special...
  // But you should be able to watch a length property of an object
  QUnit.test('isWatching is true for \'length\' property on object', function () {
    testObserver(function (obj, key, fn) {
      _emberMetalProperties.defineProperty(obj, 'length', null, '26.2 miles');
      _emberMetalObserver.addObserver(obj, 'length', obj, fn);
    }, function (obj, key, fn) {
      return _emberMetalObserver.removeObserver(obj, 'length', obj, fn);
    }, 'length');
  });
});
enifed('ember-metal/tests/watching/is_watching_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/watching/is_watching_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/watching/is_watching_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/watching/unwatch_test', ['exports', 'internal-test-helpers', 'ember-metal/watching', 'ember-metal/properties', 'ember-metal/events', 'ember-metal/computed', 'ember-metal/property_set'], function (exports, _internalTestHelpers, _emberMetalWatching, _emberMetalProperties, _emberMetalEvents, _emberMetalComputed, _emberMetalProperty_set) {
  'use strict';

  var willCount = undefined,
      didCount = undefined;

  QUnit.module('unwatch', {
    setup: function () {
      willCount = didCount = 0;
    }
  });

  function addListeners(obj, keyPath) {
    _emberMetalEvents.addListener(obj, keyPath + ':before', function () {
      return willCount++;
    });
    _emberMetalEvents.addListener(obj, keyPath + ':change', function () {
      return didCount++;
    });
  }

  _internalTestHelpers.testBoth('unwatching a computed property - regular get/set', function (get, set) {
    var obj = {};

    _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.computed({
      get: function () {
        return this.__foo;
      },
      set: function (keyName, value) {
        this.__foo = value;
        return this.__foo;
      }
    }));
    addListeners(obj, 'foo');

    _emberMetalWatching.watch(obj, 'foo');
    set(obj, 'foo', 'bar');
    equal(willCount, 1, 'should have invoked willCount');
    equal(didCount, 1, 'should have invoked didCount');

    _emberMetalWatching.unwatch(obj, 'foo');
    willCount = didCount = 0;
    set(obj, 'foo', 'BAZ');
    equal(willCount, 0, 'should NOT have invoked willCount');
    equal(didCount, 0, 'should NOT have invoked didCount');
  });

  _internalTestHelpers.testBoth('unwatching a regular property - regular get/set', function (get, set) {
    var obj = { foo: 'BIFF' };
    addListeners(obj, 'foo');

    _emberMetalWatching.watch(obj, 'foo');
    set(obj, 'foo', 'bar');
    equal(willCount, 1, 'should have invoked willCount');
    equal(didCount, 1, 'should have invoked didCount');

    _emberMetalWatching.unwatch(obj, 'foo');
    willCount = didCount = 0;
    set(obj, 'foo', 'BAZ');
    equal(willCount, 0, 'should NOT have invoked willCount');
    equal(didCount, 0, 'should NOT have invoked didCount');
  });

  QUnit.test('unwatching should be nested', function () {
    var obj = { foo: 'BIFF' };
    addListeners(obj, 'foo');

    _emberMetalWatching.watch(obj, 'foo');
    _emberMetalWatching.watch(obj, 'foo');
    _emberMetalProperty_set.set(obj, 'foo', 'bar');
    equal(willCount, 1, 'should have invoked willCount');
    equal(didCount, 1, 'should have invoked didCount');

    _emberMetalWatching.unwatch(obj, 'foo');
    willCount = didCount = 0;
    _emberMetalProperty_set.set(obj, 'foo', 'BAZ');
    equal(willCount, 1, 'should NOT have invoked willCount');
    equal(didCount, 1, 'should NOT have invoked didCount');

    _emberMetalWatching.unwatch(obj, 'foo');
    willCount = didCount = 0;
    _emberMetalProperty_set.set(obj, 'foo', 'BAZ');
    equal(willCount, 0, 'should NOT have invoked willCount');
    equal(didCount, 0, 'should NOT have invoked didCount');
  });

  _internalTestHelpers.testBoth('unwatching "length" property on an object', function (get, set) {
    var obj = { foo: 'RUN' };
    addListeners(obj, 'length');

    // Can watch length when it is undefined
    _emberMetalWatching.watch(obj, 'length');
    set(obj, 'length', '10k');
    equal(willCount, 1, 'should have invoked willCount');
    equal(didCount, 1, 'should have invoked didCount');

    // Should stop watching despite length now being defined (making object 'array-like')
    _emberMetalWatching.unwatch(obj, 'length');
    willCount = didCount = 0;
    set(obj, 'length', '5k');
    equal(willCount, 0, 'should NOT have invoked willCount');
    equal(didCount, 0, 'should NOT have invoked didCount');
  });

  _internalTestHelpers.testBoth('unwatching should not destroy non MANDATORY_SETTER descriptor', function (get, set) {
    var obj = { get foo() {
        return 'RUN';
      } };

    equal(obj.foo, 'RUN', 'obj.foo');
    _emberMetalWatching.watch(obj, 'foo');
    equal(obj.foo, 'RUN', 'obj.foo after watch');
    _emberMetalWatching.unwatch(obj, 'foo');
    equal(obj.foo, 'RUN', 'obj.foo after unwatch');
  });
});
enifed('ember-metal/tests/watching/unwatch_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/watching/unwatch_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/watching/unwatch_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/watching/watch_test', ['exports', 'ember-environment', 'ember-metal/meta', 'ember-metal/property_set', 'ember-metal/property_get', 'ember-metal/computed', 'ember-metal/properties', 'internal-test-helpers', 'ember-metal/events', 'ember-metal/watching'], function (exports, _emberEnvironment, _emberMetalMeta, _emberMetalProperty_set, _emberMetalProperty_get, _emberMetalComputed, _emberMetalProperties, _internalTestHelpers, _emberMetalEvents, _emberMetalWatching) {
  'use strict';

  var willCount = undefined,
      didCount = undefined,
      willKeys = undefined,
      didKeys = undefined,
      originalLookup = undefined;

  QUnit.module('watch', {
    setup: function () {
      willCount = didCount = 0;
      willKeys = [];
      didKeys = [];

      originalLookup = _emberEnvironment.context.lookup;
      _emberEnvironment.context.lookup = {};
    },

    teardown: function () {
      _emberEnvironment.context.lookup = originalLookup;
    }
  });

  function addListeners(obj, keyPath) {
    _emberMetalEvents.addListener(obj, keyPath + ':before', function () {
      willCount++;
      willKeys.push(keyPath);
    });
    _emberMetalEvents.addListener(obj, keyPath + ':change', function () {
      didCount++;
      didKeys.push(keyPath);
    });
  }

  _internalTestHelpers.testBoth('watching a computed property', function (get, set) {
    var obj = {};
    _emberMetalProperties.defineProperty(obj, 'foo', _emberMetalComputed.computed({
      get: function () {
        return this.__foo;
      },
      set: function (keyName, value) {
        if (value !== undefined) {
          this.__foo = value;
        }
        return this.__foo;
      }
    }));
    addListeners(obj, 'foo');

    _emberMetalWatching.watch(obj, 'foo');
    set(obj, 'foo', 'bar');
    equal(willCount, 1, 'should have invoked willCount');
    equal(didCount, 1, 'should have invoked didCount');
  });

  _internalTestHelpers.testBoth('watching a regular defined property', function (get, set) {
    var obj = { foo: 'baz' };
    addListeners(obj, 'foo');

    _emberMetalWatching.watch(obj, 'foo');
    equal(get(obj, 'foo'), 'baz', 'should have original prop');

    set(obj, 'foo', 'bar');
    equal(willCount, 1, 'should have invoked willCount');
    equal(didCount, 1, 'should have invoked didCount');

    equal(get(obj, 'foo'), 'bar', 'should get new value');
    equal(obj.foo, 'bar', 'property should be accessible on obj');
  });

  _internalTestHelpers.testBoth('watching a regular undefined property', function (get, set) {
    var obj = {};
    addListeners(obj, 'foo');

    _emberMetalWatching.watch(obj, 'foo');

    equal('foo' in obj, false, 'precond undefined');

    set(obj, 'foo', 'bar');

    equal(willCount, 1, 'should have invoked willCount');
    equal(didCount, 1, 'should have invoked didCount');

    equal(get(obj, 'foo'), 'bar', 'should get new value');
    equal(obj.foo, 'bar', 'property should be accessible on obj');
  });

  _internalTestHelpers.testBoth('watches should inherit', function (get, set) {
    var obj = { foo: 'baz' };
    var objB = Object.create(obj);

    addListeners(obj, 'foo');
    _emberMetalWatching.watch(obj, 'foo');
    equal(get(obj, 'foo'), 'baz', 'should have original prop');

    set(obj, 'foo', 'bar');
    set(objB, 'foo', 'baz');
    equal(willCount, 2, 'should have invoked willCount once only');
    equal(didCount, 2, 'should have invoked didCount once only');
  });

  QUnit.test('watching an object THEN defining it should work also', function () {
    var obj = {};
    addListeners(obj, 'foo');

    _emberMetalWatching.watch(obj, 'foo');

    _emberMetalProperties.defineProperty(obj, 'foo');
    _emberMetalProperty_set.set(obj, 'foo', 'bar');

    equal(_emberMetalProperty_get.default(obj, 'foo'), 'bar', 'should have set');
    equal(willCount, 1, 'should have invoked willChange once');
    equal(didCount, 1, 'should have invoked didChange once');
  });

  QUnit.test('watching a chain then defining the property', function () {
    var obj = {};
    var foo = { bar: 'bar' };
    addListeners(obj, 'foo.bar');
    addListeners(foo, 'bar');

    _emberMetalWatching.watch(obj, 'foo.bar');

    _emberMetalProperties.defineProperty(obj, 'foo', undefined, foo);
    _emberMetalProperty_set.set(foo, 'bar', 'baz');

    deepEqual(willKeys, ['foo.bar', 'bar'], 'should have invoked willChange with bar, foo.bar');
    deepEqual(didKeys, ['foo.bar', 'bar'], 'should have invoked didChange with bar, foo.bar');
    equal(willCount, 2, 'should have invoked willChange twice');
    equal(didCount, 2, 'should have invoked didChange twice');
  });

  QUnit.test('watching a chain then defining the nested property', function () {
    var bar = {};
    var obj = { foo: bar };
    var baz = { baz: 'baz' };
    addListeners(obj, 'foo.bar.baz');
    addListeners(baz, 'baz');

    _emberMetalWatching.watch(obj, 'foo.bar.baz');

    _emberMetalProperties.defineProperty(bar, 'bar', undefined, baz);
    _emberMetalProperty_set.set(baz, 'baz', 'BOO');

    deepEqual(willKeys, ['foo.bar.baz', 'baz'], 'should have invoked willChange with bar, foo.bar');
    deepEqual(didKeys, ['foo.bar.baz', 'baz'], 'should have invoked didChange with bar, foo.bar');
    equal(willCount, 2, 'should have invoked willChange twice');
    equal(didCount, 2, 'should have invoked didChange twice');
  });

  _internalTestHelpers.testBoth('watching an object value then unwatching should restore old value', function (get, set) {
    var obj = { foo: { bar: { baz: { biff: 'BIFF' } } } };
    addListeners(obj, 'foo.bar.baz.biff');

    _emberMetalWatching.watch(obj, 'foo.bar.baz.biff');

    var foo = get(obj, 'foo');
    equal(get(get(get(foo, 'bar'), 'baz'), 'biff'), 'BIFF', 'biff should exist');

    _emberMetalWatching.unwatch(obj, 'foo.bar.baz.biff');
    equal(get(get(get(foo, 'bar'), 'baz'), 'biff'), 'BIFF', 'biff should exist');
  });

  QUnit.test('when watching another object, destroy should remove chain watchers from the other object', function () {
    var objA = {};
    var objB = { foo: 'bar' };
    objA.b = objB;
    addListeners(objA, 'b.foo');

    _emberMetalWatching.watch(objA, 'b.foo');

    var meta_objB = _emberMetalMeta.meta(objB);
    var chainNode = _emberMetalMeta.meta(objA).readableChains()._chains.b._chains.foo;

    equal(meta_objB.peekWatching('foo'), 1, 'should be watching foo');
    equal(meta_objB.readableChainWatchers().has('foo', chainNode), true, 'should have chain watcher');

    _emberMetalWatching.destroy(objA);

    equal(meta_objB.peekWatching('foo'), 0, 'should not be watching foo');
    equal(meta_objB.readableChainWatchers().has('foo', chainNode), false, 'should not have chain watcher');
  });

  // TESTS for length property

  _internalTestHelpers.testBoth('watching "length" property on an object', function (get, set) {
    var obj = { length: '26.2 miles' };
    addListeners(obj, 'length');

    _emberMetalWatching.watch(obj, 'length');
    equal(get(obj, 'length'), '26.2 miles', 'should have original prop');

    set(obj, 'length', '10k');
    equal(willCount, 1, 'should have invoked willCount');
    equal(didCount, 1, 'should have invoked didCount');

    equal(get(obj, 'length'), '10k', 'should get new value');
    equal(obj.length, '10k', 'property should be accessible on obj');
  });

  _internalTestHelpers.testBoth('watching "length" property on an array', function (get, set) {
    var arr = [];
    addListeners(arr, 'length');

    _emberMetalWatching.watch(arr, 'length');
    equal(get(arr, 'length'), 0, 'should have original prop');

    set(arr, 'length', '10');
    equal(willCount, 1, 'should NOT have invoked willCount');
    equal(didCount, 1, 'should NOT have invoked didCount');

    equal(get(arr, 'length'), 10, 'should get new value');
    equal(arr.length, 10, 'property should be accessible on arr');
  });

  _internalTestHelpers.testBoth('watch + ES5 getter', function (get) {
    var parent = { b: 1 };
    var child = {
      get b() {
        return parent.b;
      }
    };

    equal(parent.b, 1, 'parent.b should be 1');
    equal(child.b, 1, 'child.b should be 1');
    equal(get(child, 'b'), 1, 'Ember.get(child, "b") should be 1');

    _emberMetalWatching.watch(child, 'b');

    equal(parent.b, 1, 'parent.b should be 1 (after watch)');
    equal(child.b, 1, 'child.b should be 1  (after watch)');

    equal(get(child, 'b'), 1, 'Ember.get(child, "b") should be 1 (after watch)');
  });

  _internalTestHelpers.testBoth('watch + Ember.set + no-descriptor', function (get, set) {
    var child = {};

    equal(child.b, undefined, 'child.b ');
    equal(get(child, 'b'), undefined, 'Ember.get(child, "b")');

    _emberMetalWatching.watch(child, 'b');
    set(child, 'b', 1);

    equal(child.b, 1, 'child.b (after watch)');
    equal(get(child, 'b'), 1, 'Ember.get(child, "b") (after watch)');
  });
});
enifed('ember-metal/tests/watching/watch_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/watching/watch_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/watching/watch_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/tests/weak_map_test', ['exports', 'ember-metal/weak_map'], function (exports, _emberMetalWeak_map) {
  'use strict';

  QUnit.module('Ember.WeakMap');

  QUnit.test('has weakMap like qualities', function (assert) {
    var map = new _emberMetalWeak_map.default();
    var map2 = new _emberMetalWeak_map.default();

    var a = {};
    var b = {};
    var c = {};

    assert.strictEqual(map.get(a), undefined);
    assert.strictEqual(map.get(b), undefined);
    assert.strictEqual(map.get(c), undefined);

    assert.strictEqual(map2.get(a), undefined);
    assert.strictEqual(map2.get(b), undefined);
    assert.strictEqual(map2.get(c), undefined);

    assert.strictEqual(map.set(a, 1), map, 'map.set should return itself');
    assert.strictEqual(map.get(a), 1);
    assert.strictEqual(map.set(b, undefined), map);
    assert.strictEqual(map.set(a, 2), map);
    assert.strictEqual(map.get(a), 2);
    assert.strictEqual(map.set(b, undefined), map);

    assert.strictEqual(map2.get(a), undefined);
    assert.strictEqual(map2.get(b), undefined);
    assert.strictEqual(map2.get(c), undefined);

    assert.strictEqual(map.set(c, 1), map);
    assert.strictEqual(map.get(c), 1);
    assert.strictEqual(map.get(a), 2);
    assert.strictEqual(map.get(b), undefined);

    assert.strictEqual(map2.set(a, 3), map2);
    assert.strictEqual(map2.set(b, 4), map2);
    assert.strictEqual(map2.set(c, 5), map2);

    assert.strictEqual(map2.get(a), 3);
    assert.strictEqual(map2.get(b), 4);
    assert.strictEqual(map2.get(c), 5);

    assert.strictEqual(map.get(c), 1);
    assert.strictEqual(map.get(a), 2);
    assert.strictEqual(map.get(b), undefined);
  });

  QUnit.test('WeakMap constructor requres new', function (assert) {
    var expectedError = new TypeError('Constructor WeakMap requires \'new\'');

    assert.throws(function () {
      // jshint newcap: false
      _emberMetalWeak_map.default();
    }, expectedError);
  });

  QUnit.test('constructing a WeakMap with an invalid iterator throws an error', function (assert) {
    var expectedError = new TypeError('The weak map constructor polyfill only supports an array argument');

    assert.throws(function () {
      new _emberMetalWeak_map.default({ a: 1 });
    }, expectedError);
  });

  QUnit.test('constructing a WeakMap with a valid iterator inserts the entries', function (assert) {
    var a = {};
    var b = {};
    var c = {};

    var map = new _emberMetalWeak_map.default([[a, 1], [b, 2], [c, 3]]);

    assert.strictEqual(map.get(a), 1);
    assert.strictEqual(map.get(b), 2);
    assert.strictEqual(map.get(c), 3);
  });

  QUnit.test('that error is thrown when using a primitive key', function (assert) {
    var expectedError = new TypeError('Invalid value used as weak map key');
    var map = new _emberMetalWeak_map.default();

    assert.throws(function () {
      return map.set('a', 1);
    }, expectedError);
    assert.throws(function () {
      return map.set(1, 1);
    }, expectedError);
    assert.throws(function () {
      return map.set(true, 1);
    }, expectedError);
    assert.throws(function () {
      return map.set(null, 1);
    }, expectedError);
    assert.throws(function () {
      return map.set(undefined, 1);
    }, expectedError);
  });

  QUnit.test('that .has and .delete work as expected', function (assert) {
    var map = new _emberMetalWeak_map.default();
    var a = {};
    var b = {};
    var foo = { id: 1, name: 'My file', progress: 0 };

    assert.strictEqual(map.set(a, foo), map);
    assert.strictEqual(map.get(a), foo);
    assert.strictEqual(map.has(a), true);
    assert.strictEqual(map.has(b), false);
    assert.strictEqual(map.delete(a), true);
    assert.strictEqual(map.has(a), false);
    assert.strictEqual(map.delete(a), false);
    assert.strictEqual(map.set(a, undefined), map);
    assert.strictEqual(map.has(a), true);
    assert.strictEqual(map.delete(a), true);
    assert.strictEqual(map.delete(a), false);
    assert.strictEqual(map.has(a), false);
  });

  QUnit.test('that .toString works as expected', function (assert) {
    var map = new _emberMetalWeak_map.default();

    assert.strictEqual(map.toString(), '[object WeakMap]');
  });
});
enifed('ember-metal/tests/weak_map_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/tests/weak_map_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/tests/weak_map_test.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/transaction.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/transaction.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/transaction.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/watch_key.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/watch_key.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/watch_key.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/watch_path.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/watch_path.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/watch_path.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/watching.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/watching.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/watching.js should pass ESLint\n\n');
  });
});
enifed('ember-metal/weak_map.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-metal/weak_map.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-metal/weak_map.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/ext/controller.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/ext/controller.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/ext/controller.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/ext/run_loop.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/ext/run_loop.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/ext/run_loop.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/index.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/index.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/index.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/location/api.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/location/api.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/location/api.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/location/auto_location.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/location/auto_location.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/location/auto_location.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/location/hash_location.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/location/hash_location.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/location/hash_location.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/location/history_location.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/location/history_location.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/location/history_location.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/location/none_location.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/location/none_location.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/location/none_location.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/location/util.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/location/util.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/location/util.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/services/router.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/services/router.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/services/router.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/services/routing.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/services/routing.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/services/routing.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/system/cache.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/system/cache.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/system/cache.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/system/controller_for.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/system/controller_for.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/system/controller_for.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/system/dsl.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/system/dsl.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/system/dsl.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/system/generate_controller.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/system/generate_controller.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/system/generate_controller.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/system/query_params.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/system/query_params.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/system/query_params.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/system/route.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/system/route.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/system/route.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/system/router.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/system/router.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/system/router.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/system/router_state.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/system/router_state.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/system/router_state.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/tests/ext/controller_test', ['exports', 'ember-utils', 'internal-test-helpers', 'ember-runtime'], function (exports, _emberUtils, _internalTestHelpers, _emberRuntime) {
  'use strict';

  QUnit.module('ember-routing/ext/controller');

  QUnit.test('transitionToRoute considers an engine\'s mountPoint', function () {
    expect(4);

    var router = {
      transitionTo: function (route) {
        return route;
      }
    };

    var engineInstance = _internalTestHelpers.buildOwner({
      ownerOptions: {
        routable: true,
        mountPoint: 'foo.bar'
      }
    });

    var controller = _emberRuntime.Controller.create({ target: router });
    _emberUtils.setOwner(controller, engineInstance);

    strictEqual(controller.transitionToRoute('application'), 'foo.bar.application', 'properly prefixes application route');
    strictEqual(controller.transitionToRoute('posts'), 'foo.bar.posts', 'properly prefixes child routes');
    throws(function () {
      return controller.transitionToRoute('/posts');
    }, 'throws when trying to use a url');

    var queryParams = {};
    strictEqual(controller.transitionToRoute(queryParams), queryParams, 'passes query param only transitions through');
  });
});
enifed('ember-routing/tests/ext/controller_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/tests/ext/controller_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/tests/ext/controller_test.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/tests/location/auto_location_test', ['exports', 'ember-utils', 'ember-environment', 'ember-metal', 'ember-routing/location/auto_location', 'ember-routing/location/history_location', 'ember-routing/location/hash_location', 'ember-routing/location/none_location', 'internal-test-helpers'], function (exports, _emberUtils, _emberEnvironment, _emberMetal, _emberRoutingLocationAuto_location, _emberRoutingLocationHistory_location, _emberRoutingLocationHash_location, _emberRoutingLocationNone_location, _internalTestHelpers) {
  'use strict';

  function mockBrowserLocation(overrides) {
    return _emberUtils.assign({
      href: 'http://test.com/',
      pathname: '/',
      hash: '',
      search: '',
      replace: function () {
        ok(false, 'location.replace should not be called during testing');
      }
    }, overrides);
  }

  function mockBrowserHistory(overrides) {
    return _emberUtils.assign({
      pushState: function () {
        ok(false, 'history.pushState should not be called during testing');
      },
      replaceState: function () {
        ok(false, 'history.replaceState should not be called during testing');
      }
    }, overrides);
  }

  function createLocation(location, history) {
    var _AutoLocation$create;

    var owner = _internalTestHelpers.buildOwner();

    owner.register('location:history', _emberRoutingLocationHistory_location.default);
    owner.register('location:hash', _emberRoutingLocationHash_location.default);
    owner.register('location:none', _emberRoutingLocationNone_location.default);

    var autolocation = _emberRoutingLocationAuto_location.default.create((_AutoLocation$create = {}, _AutoLocation$create[_emberUtils.OWNER] = owner, _AutoLocation$create.location = location, _AutoLocation$create.history = history, _AutoLocation$create.global = {}, _AutoLocation$create));

    return autolocation;
  }

  var location = undefined;

  QUnit.module('Ember.AutoLocation', {
    teardown: function () {
      if (location) {
        _emberMetal.run(location, 'destroy');
      }
    }
  });

  QUnit.test('AutoLocation should have the `global`', function (assert) {
    var location = _emberRoutingLocationAuto_location.default.create();

    assert.ok(location.global, 'has a global defined');
    assert.strictEqual(location.global, _emberEnvironment.environment.window, 'has the environments window global');
  });

  QUnit.test('AutoLocation should return concrete implementation\'s value for `getURL`', function () {
    expect(1);

    var browserLocation = mockBrowserLocation();
    var browserHistory = mockBrowserHistory();

    location = createLocation(browserLocation, browserHistory);
    location.detect();

    var concreteImplementation = _emberMetal.get(location, 'concreteImplementation');

    concreteImplementation.getURL = function () {
      return '/lincoln/park';
    };

    equal(location.getURL(), '/lincoln/park');
  });

  QUnit.test('AutoLocation should use a HistoryLocation instance when pushStates is supported', function () {
    expect(1);

    var browserLocation = mockBrowserLocation();
    var browserHistory = mockBrowserHistory();

    location = createLocation(browserLocation, browserHistory);
    location.detect();

    ok(_emberMetal.get(location, 'concreteImplementation') instanceof _emberRoutingLocationHistory_location.default);
  });

  QUnit.test('AutoLocation should use a HashLocation instance when pushStates are not supported, but hashchange events are and the URL is already in the HashLocation format', function () {
    expect(1);

    var browserLocation = mockBrowserLocation({
      hash: '#/testd'
    });

    location = createLocation(browserLocation);
    location.global = {
      onhashchange: function () {}
    };

    location.detect();
    ok(_emberMetal.get(location, 'concreteImplementation') instanceof _emberRoutingLocationHash_location.default);
  });

  QUnit.test('AutoLocation should use a NoneLocation instance when neither history nor hashchange are supported.', function () {
    expect(1);

    location = createLocation(mockBrowserLocation());
    location.detect();

    ok(_emberMetal.get(location, 'concreteImplementation') instanceof _emberRoutingLocationNone_location.default);
  });

  QUnit.test('AutoLocation should use an index path (i.e. \'/\') without any location.hash as OK for HashLocation', function () {
    expect(1);

    var browserLocation = mockBrowserLocation({
      href: 'http://test.com/',
      pathname: '/',
      hash: '',
      search: '',
      replace: function (path) {
        ok(false, 'location.replace should not be called');
      }
    });

    location = createLocation(browserLocation);
    location.global = {
      onhashchange: function () {}
    };

    location.detect();

    ok(_emberMetal.get(location, 'concreteImplementation') instanceof _emberRoutingLocationHash_location.default, 'uses a HashLocation');
  });

  QUnit.test('AutoLocation should transform the URL for hashchange-only browsers viewing a HistoryLocation-formatted path', function () {
    expect(3);

    var browserLocation = mockBrowserLocation({
      hash: '',
      hostname: 'test.com',
      href: 'http://test.com/test',
      pathname: '/test',
      protocol: 'http:',
      port: '',
      search: '',

      replace: function (path) {
        equal(path, 'http://test.com/#/test', 'location.replace should be called with normalized HashLocation path');
      }
    });

    var location = createLocation(browserLocation);
    location.global = {
      onhashchange: function () {}
    };

    location.detect();

    ok(_emberMetal.get(location, 'concreteImplementation') instanceof _emberRoutingLocationNone_location.default, 'NoneLocation should be used while we attempt to location.replace()');
    equal(_emberMetal.get(location, 'cancelRouterSetup'), true, 'cancelRouterSetup should be set so the router knows.');
  });

  QUnit.test('AutoLocation should replace the URL for pushState-supported browsers viewing a HashLocation-formatted url', function () {
    expect(2);

    var browserLocation = mockBrowserLocation({
      hash: '#/test',
      hostname: 'test.com',
      href: 'http://test.com/#/test',
      pathname: '/',
      protocol: 'http:',
      port: '',
      search: ''
    });

    var browserHistory = mockBrowserHistory({
      replaceState: function (state, title, path) {
        equal(path, '/test', 'history.replaceState should be called with normalized HistoryLocation url');
      }
    });

    var location = createLocation(browserLocation, browserHistory);
    location.detect();

    ok(_emberMetal.get(location, 'concreteImplementation'), _emberRoutingLocationHistory_location.default);
  });

  QUnit.test('AutoLocation requires any rootURL given to end in a trailing forward slash', function () {
    expect(3);
    var browserLocation = mockBrowserLocation();
    var expectedMsg = /rootURL must end with a trailing forward slash e.g. "\/app\/"/;

    location = createLocation(browserLocation);
    location.rootURL = 'app';

    expectAssertion(function () {
      location.detect();
    }, expectedMsg);

    location.rootURL = '/app';
    expectAssertion(function () {
      location.detect();
    }, expectedMsg);

    // Note the trailing whitespace
    location.rootURL = '/app/ ';
    expectAssertion(function () {
      location.detect();
    }, expectedMsg);
  });

  QUnit.test('AutoLocation provides its rootURL to the concreteImplementation', function () {
    expect(1);
    var browserLocation = mockBrowserLocation({
      pathname: '/some/subdir/derp'
    });
    var browserHistory = mockBrowserHistory();

    location = createLocation(browserLocation, browserHistory);
    location.rootURL = '/some/subdir/';

    location.detect();

    var concreteLocation = _emberMetal.get(location, 'concreteImplementation');
    equal(location.rootURL, concreteLocation.rootURL);
  });

  QUnit.test('getHistoryPath() should return a normalized, HistoryLocation-supported path', function () {
    expect(3);

    var browserLocation = mockBrowserLocation({
      href: 'http://test.com/app/about?foo=bar#foo',
      pathname: '/app/about',
      search: '?foo=bar',
      hash: '#foo'
    });

    equal(_emberRoutingLocationAuto_location.getHistoryPath('/app/', browserLocation), '/app/about?foo=bar#foo', 'URLs already in HistoryLocation form should come out the same');

    browserLocation = mockBrowserLocation({
      href: 'http://test.com/app/#/about?foo=bar#foo',
      pathname: '/app/',
      search: '',
      hash: '#/about?foo=bar#foo'
    });
    equal(_emberRoutingLocationAuto_location.getHistoryPath('/app/', browserLocation), '/app/about?foo=bar#foo', 'HashLocation formed URLs should be normalized');

    browserLocation = mockBrowserLocation({
      href: 'http://test.com/app/#about?foo=bar#foo',
      pathname: '/app/',
      search: '',
      hash: '#about?foo=bar#foo'
    });
    equal(_emberRoutingLocationAuto_location.getHistoryPath('/app', browserLocation), '/app/#about?foo=bar#foo', 'URLs with a hash not following #/ convention shouldn\'t be normalized as a route');
  });

  QUnit.test('getHashPath() should return a normalized, HashLocation-supported path', function () {
    expect(3);

    var browserLocation = mockBrowserLocation({
      href: 'http://test.com/app/#/about?foo=bar#foo',
      pathname: '/app/',
      search: '',
      hash: '#/about?foo=bar#foo'
    });
    equal(_emberRoutingLocationAuto_location.getHashPath('/app/', browserLocation), '/app/#/about?foo=bar#foo', 'URLs already in HistoryLocation form should come out the same');

    browserLocation = mockBrowserLocation({
      href: 'http://test.com/app/about?foo=bar#foo',
      pathname: '/app/about',
      search: '?foo=bar',
      hash: '#foo'
    });
    equal(_emberRoutingLocationAuto_location.getHashPath('/app/', browserLocation), '/app/#/about?foo=bar#foo', 'HistoryLocation formed URLs should be normalized');

    browserLocation = mockBrowserLocation({
      href: 'http://test.com/app/#about?foo=bar#foo',
      pathname: '/app/',
      search: '',
      hash: '#about?foo=bar#foo'
    });

    equal(_emberRoutingLocationAuto_location.getHashPath('/app/', browserLocation), '/app/#/#about?foo=bar#foo', 'URLs with a hash not following #/ convention shouldn\'t be normalized as a route');
  });
});
enifed('ember-routing/tests/location/auto_location_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/tests/location/auto_location_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/tests/location/auto_location_test.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/tests/location/hash_location_test', ['exports', 'ember-metal', 'ember-routing/location/hash_location'], function (exports, _emberMetal, _emberRoutingLocationHash_location) {
  'use strict';

  var HashTestLocation = undefined,
      location = undefined;

  function createLocation(options) {
    if (!options) {
      options = {};
    }
    location = HashTestLocation.create(options);
  }

  function mockBrowserLocation(path) {
    // This is a neat trick to auto-magically extract the hostname from any
    // url by letting the browser do the work ;)
    var tmp = document.createElement('a');
    tmp.href = path;

    var protocol = !tmp.protocol || tmp.protocol === ':' ? 'http' : tmp.protocol;
    var pathname = tmp.pathname.match(/^\//) ? tmp.pathname : '/' + tmp.pathname;

    return {
      hash: tmp.hash,
      host: tmp.host || 'localhost',
      hostname: tmp.hostname || 'localhost',
      href: tmp.href,
      pathname: pathname,
      port: tmp.port || '',
      protocol: protocol,
      search: tmp.search
    };
  }

  function triggerHashchange() {
    var event = document.createEvent('HTMLEvents');
    event.initEvent('hashchange', true, false);
    window.dispatchEvent(event);
  }

  QUnit.module('Ember.HashLocation', {
    setup: function () {
      HashTestLocation = _emberRoutingLocationHash_location.default.extend({
        _location: {
          href: 'http://test.com/',
          pathname: '/',
          hash: '',
          search: '',
          replace: function () {
            ok(false, 'location.replace should not be called during testing');
          }
        }
      });
    },

    teardown: function () {
      _emberMetal.run(function () {
        if (location) {
          location.destroy();
        }
      });
    }
  });

  QUnit.test('HashLocation.getURL() returns the current url', function () {
    expect(1);

    createLocation({
      _location: mockBrowserLocation('/#/foo/bar')
    });

    equal(location.getURL(), '/foo/bar');
  });

  QUnit.test('HashLocation.getURL() includes extra hashes', function () {
    expect(1);

    createLocation({
      _location: mockBrowserLocation('/#/foo#bar#car')
    });

    equal(location.getURL(), '/foo#bar#car');
  });

  QUnit.test('HashLocation.getURL() assumes location.hash without #/ prefix is not a route path', function () {
    expect(1);

    createLocation({
      _location: mockBrowserLocation('/#foo#bar')
    });

    equal(location.getURL(), '/#foo#bar');
  });

  QUnit.test('HashLocation.getURL() returns a normal forward slash when there is no location.hash', function () {
    expect(1);

    createLocation({
      _location: mockBrowserLocation('/')
    });

    equal(location.getURL(), '/');
  });

  QUnit.test('HashLocation.setURL() correctly sets the url', function () {
    expect(2);

    createLocation();

    location.setURL('/bar');

    equal(_emberMetal.get(location, 'location.hash'), '/bar');
    equal(_emberMetal.get(location, 'lastSetURL'), '/bar');
  });

  QUnit.test('HashLocation.replaceURL() correctly replaces to the path with a page reload', function () {
    expect(2);

    createLocation({
      _location: {
        replace: function (path) {
          equal(path, '#/foo');
        }
      }
    });

    location.replaceURL('/foo');

    equal(_emberMetal.get(location, 'lastSetURL'), '/foo');
  });

  QUnit.test('HashLocation.onUpdateURL callback executes as expected', function () {
    expect(1);

    createLocation({
      _location: mockBrowserLocation('/#/foo/bar')
    });

    var callback = function (param) {
      equal(param, '/foo/bar', 'path is passed as param');
    };

    location.onUpdateURL(callback);

    triggerHashchange();
  });

  QUnit.test('HashLocation.onUpdateURL doesn\'t execute callback if lastSetURL === path', function () {
    expect(0);

    createLocation({
      _location: {
        href: '/#/foo/bar'
      },
      lastSetURL: '/foo/bar'
    });

    var callback = function (param) {
      ok(false, 'callback should not be called');
    };

    location.onUpdateURL(callback);

    triggerHashchange();
  });

  QUnit.test('HashLocation.formatURL() prepends a # to the provided string', function () {
    expect(1);

    createLocation();

    equal(location.formatURL('/foo#bar'), '#/foo#bar');
  });

  QUnit.test('HashLocation.willDestroy() cleans up hashchange event listener', function () {
    expect(1);

    createLocation();

    var callback = function (param) {
      ok(true, 'should invoke callback once');
    };

    location.onUpdateURL(callback);

    triggerHashchange();

    _emberMetal.run(location, 'destroy');
    location = null;

    triggerHashchange();
  });
});
enifed('ember-routing/tests/location/hash_location_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/tests/location/hash_location_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/tests/location/hash_location_test.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/tests/location/history_location_test', ['exports', 'ember-metal', 'ember-routing/location/history_location'], function (exports, _emberMetal, _emberRoutingLocationHistory_location) {
  'use strict';

  var FakeHistory = undefined,
      HistoryTestLocation = undefined,
      location = undefined;

  function createLocation(options) {
    if (!options) {
      options = {};
    }
    location = HistoryTestLocation.create(options);
  }

  function mockBrowserLocation(path) {
    // This is a neat trick to auto-magically extract the hostname from any
    // url by letting the browser do the work ;)
    var tmp = document.createElement('a');
    tmp.href = path;

    var protocol = !tmp.protocol || tmp.protocol === ':' ? 'http' : tmp.protocol;
    var pathname = tmp.pathname.match(/^\//) ? tmp.pathname : '/' + tmp.pathname;

    return {
      hash: tmp.hash,
      host: tmp.host || 'localhost',
      hostname: tmp.hostname || 'localhost',
      href: tmp.href,
      pathname: pathname,
      port: tmp.port || '',
      protocol: protocol,
      search: tmp.search
    };
  }

  QUnit.module('Ember.HistoryLocation', {
    setup: function () {
      FakeHistory = {
        state: null,
        _states: [],
        replaceState: function (state, title, url) {
          this.state = state;
          this._states[0] = state;
        },
        pushState: function (state, title, url) {
          this.state = state;
          this._states.unshift(state);
        }
      };

      HistoryTestLocation = _emberRoutingLocationHistory_location.default.extend({
        history: FakeHistory
      });
    },

    teardown: function () {
      _emberMetal.run(function () {
        if (location) {
          location.destroy();
        }
      });
    }
  });

  QUnit.test('HistoryLocation initState does not get fired on init', function () {
    expect(1);

    HistoryTestLocation.reopen({
      init: function () {
        ok(true, 'init was called');
        this._super.apply(this, arguments);
      },
      initState: function () {
        ok(false, 'initState() should not be called automatically');
      }
    });

    createLocation();
  });

  QUnit.test('webkit doesn\'t fire popstate on page load', function () {
    expect(1);

    HistoryTestLocation.reopen({
      initState: function () {
        this._super.apply(this, arguments);
        // these two should be equal to be able
        // to successfully detect webkit initial popstate
        equal(this._previousURL, this.getURL());
      }
    });

    createLocation();
    location.initState();
  });

  QUnit.test('base URL is removed when retrieving the current pathname', function () {
    expect(1);

    HistoryTestLocation.reopen({
      init: function () {
        this._super.apply(this, arguments);

        _emberMetal.set(this, 'location', mockBrowserLocation('/base/foo/bar'));
        _emberMetal.set(this, 'baseURL', '/base/');
      },

      initState: function () {
        this._super.apply(this, arguments);

        equal(this.getURL(), '/foo/bar');
      }
    });

    createLocation();
    location.initState();
  });

  if (_emberMetal.isFeatureEnabled('ember-unique-location-history-state')) {
    QUnit.test('base URL is preserved when moving around', function () {
      expect(2);

      HistoryTestLocation.reopen({
        init: function () {
          this._super.apply(this, arguments);

          _emberMetal.set(this, 'location', mockBrowserLocation('/base/foo/bar'));
          _emberMetal.set(this, 'baseURL', '/base/');
        }
      });

      createLocation();
      location.initState();
      location.setURL('/one/two');

      equal(location._historyState.path, '/base/one/two');
      ok(location._historyState.uuid);
    });

    QUnit.test('setURL continues to set even with a null state (iframes may set this)', function () {
      expect(2);

      createLocation();
      location.initState();

      FakeHistory.pushState(null);
      location.setURL('/three/four');

      equal(location._historyState.path, '/three/four');
      ok(location._historyState.uuid);
    });

    QUnit.test('replaceURL continues to set even with a null state (iframes may set this)', function () {
      expect(2);

      createLocation();
      location.initState();

      FakeHistory.pushState(null);
      location.replaceURL('/three/four');

      equal(location._historyState.path, '/three/four');
      ok(location._historyState.uuid);
    });
  } else {
    QUnit.test('base URL is preserved when moving around', function () {
      expect(1);

      HistoryTestLocation.reopen({
        init: function () {
          this._super.apply(this, arguments);

          _emberMetal.set(this, 'location', mockBrowserLocation('/base/foo/bar'));
          _emberMetal.set(this, 'baseURL', '/base/');
        }
      });

      createLocation();
      location.initState();
      location.setURL('/one/two');

      equal(location._historyState.path, '/base/one/two');
    });

    QUnit.test('setURL continues to set even with a null state (iframes may set this)', function () {
      expect(1);

      createLocation();
      location.initState();

      FakeHistory.pushState(null);
      location.setURL('/three/four');

      equal(location._historyState.path, '/three/four');
    });

    QUnit.test('replaceURL continues to set even with a null state (iframes may set this)', function () {
      expect(1);

      createLocation();
      location.initState();

      FakeHistory.pushState(null);
      location.replaceURL('/three/four');

      equal(location._historyState.path, '/three/four');
    });
  }

  QUnit.test('HistoryLocation.getURL() returns the current url, excluding both rootURL and baseURL', function () {
    expect(1);

    HistoryTestLocation.reopen({
      init: function () {
        this._super.apply(this, arguments);

        _emberMetal.set(this, 'location', mockBrowserLocation('/base/foo/bar'));
        _emberMetal.set(this, 'rootURL', '/app/');
        _emberMetal.set(this, 'baseURL', '/base/');
      }
    });

    createLocation();

    equal(location.getURL(), '/foo/bar');
  });

  QUnit.test('HistoryLocation.getURL() returns the current url, does not remove rootURL if its not at start of url', function () {
    expect(1);

    HistoryTestLocation.reopen({
      init: function () {
        this._super.apply(this, arguments);

        _emberMetal.set(this, 'location', mockBrowserLocation('/foo/bar/baz'));
        _emberMetal.set(this, 'rootURL', '/bar/');
      }
    });

    createLocation();

    equal(location.getURL(), '/foo/bar/baz');
  });

  QUnit.test('HistoryLocation.getURL() will not remove the rootURL when only a partial match', function () {
    expect(1);

    HistoryTestLocation.reopen({
      init: function () {
        this._super.apply(this, arguments);
        _emberMetal.set(this, 'location', mockBrowserLocation('/bars/baz'));
        _emberMetal.set(this, 'rootURL', '/bar/');
      }
    });

    createLocation();

    equal(location.getURL(), '/bars/baz');
  });

  QUnit.test('HistoryLocation.getURL() returns the current url, does not remove baseURL if its not at start of url', function () {
    expect(1);

    HistoryTestLocation.reopen({
      init: function () {
        this._super.apply(this, arguments);

        _emberMetal.set(this, 'location', mockBrowserLocation('/foo/bar/baz'));
        _emberMetal.set(this, 'baseURL', '/bar/');
      }
    });

    createLocation();

    equal(location.getURL(), '/foo/bar/baz');
  });

  QUnit.test('HistoryLocation.getURL() will not remove the baseURL when only a partial match', function () {
    expect(1);

    HistoryTestLocation.reopen({
      init: function () {
        this._super.apply(this, arguments);
        _emberMetal.set(this, 'location', mockBrowserLocation('/bars/baz'));
        _emberMetal.set(this, 'baseURL', '/bar/');
      }
    });

    createLocation();

    equal(location.getURL(), '/bars/baz');
  });

  QUnit.test('HistoryLocation.getURL() includes location.search', function () {
    expect(1);

    HistoryTestLocation.reopen({
      init: function () {
        this._super.apply(this, arguments);
        _emberMetal.set(this, 'location', mockBrowserLocation('/foo/bar?time=morphin'));
      }
    });

    createLocation();

    equal(location.getURL(), '/foo/bar?time=morphin');
  });

  QUnit.test('HistoryLocation.getURL() includes location.hash', function () {
    expect(1);

    HistoryTestLocation.reopen({
      init: function () {
        this._super.apply(this, arguments);
        _emberMetal.set(this, 'location', mockBrowserLocation('/foo/bar#pink-power-ranger'));
      }
    });

    createLocation();

    equal(location.getURL(), '/foo/bar#pink-power-ranger');
  });

  QUnit.test('HistoryLocation.getURL() includes location.hash and location.search', function () {
    expect(1);

    HistoryTestLocation.reopen({
      init: function () {
        this._super.apply(this, arguments);
        _emberMetal.set(this, 'location', mockBrowserLocation('/foo/bar?time=morphin#pink-power-ranger'));
      }
    });

    createLocation();

    equal(location.getURL(), '/foo/bar?time=morphin#pink-power-ranger');
  });
});
enifed('ember-routing/tests/location/history_location_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/tests/location/history_location_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/tests/location/history_location_test.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/tests/location/none_location_test', ['exports', 'ember-metal', 'ember-routing/location/none_location'], function (exports, _emberMetal, _emberRoutingLocationNone_location) {
  'use strict';

  var NoneTestLocation = undefined,
      location = undefined;

  function createLocation(options) {
    if (!options) {
      options = {};
    }
    location = NoneTestLocation.create(options);
  }

  QUnit.module('Ember.NoneLocation', {
    setup: function () {
      NoneTestLocation = _emberRoutingLocationNone_location.default.extend({});
    },

    teardown: function () {
      _emberMetal.run(function () {
        if (location) {
          location.destroy();
        }
      });
    }
  });

  QUnit.test('NoneLocation.formatURL() returns the current url always appending rootURL', function () {
    expect(1);

    NoneTestLocation.reopen({
      init: function () {
        this._super.apply(this, arguments);
        _emberMetal.set(this, 'rootURL', '/en/');
      }
    });

    createLocation();

    equal(location.formatURL('/foo/bar'), '/en/foo/bar');
  });

  QUnit.test('NoneLocation.getURL() returns the current path minus rootURL', function () {
    expect(1);

    NoneTestLocation.reopen({
      init: function () {
        this._super.apply(this, arguments);
        _emberMetal.set(this, 'rootURL', '/foo/');
        _emberMetal.set(this, 'path', '/foo/bar');
      }
    });

    createLocation();

    equal(location.getURL(), '/bar');
  });

  QUnit.test('NoneLocation.getURL() will remove the rootURL only from the beginning of a url', function () {
    expect(1);

    NoneTestLocation.reopen({
      init: function () {
        this._super.apply(this, arguments);
        _emberMetal.set(this, 'rootURL', '/bar/');
        _emberMetal.set(this, 'path', '/foo/bar/baz');
      }
    });

    createLocation();

    equal(location.getURL(), '/foo/bar/baz');
  });

  QUnit.test('NoneLocation.getURL() will not remove the rootURL when only a partial match', function () {
    expect(1);

    NoneTestLocation.reopen({
      init: function () {
        this._super.apply(this, arguments);
        _emberMetal.set(this, 'rootURL', '/bar/');
        _emberMetal.set(this, 'path', '/bars/baz');
      }
    });

    createLocation();

    equal(location.getURL(), '/bars/baz');
  });
});
enifed('ember-routing/tests/location/none_location_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/tests/location/none_location_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/tests/location/none_location_test.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/tests/location/util_test', ['exports', 'ember-utils', 'ember-routing/location/util'], function (exports, _emberUtils, _emberRoutingLocationUtil) {
  'use strict';

  function mockBrowserLocation(overrides) {
    return _emberUtils.assign({
      href: 'http://test.com/',
      pathname: '/',
      hash: '',
      search: '',
      replace: function () {
        ok(false, 'location.replace should not be called during testing');
      }
    }, overrides);
  }

  QUnit.module('Location Utilities');

  QUnit.test('replacePath cannot be used to redirect to a different origin', function () {
    expect(1);

    var expectedURL = undefined;

    var location = {
      protocol: 'http:',
      hostname: 'emberjs.com',
      port: '1337',

      replace: function (url) {
        equal(url, expectedURL);
      }
    };

    expectedURL = 'http://emberjs.com:1337//google.com';
    _emberRoutingLocationUtil.replacePath(location, '//google.com');
  });

  QUnit.test('getPath() should normalize location.pathname, making sure it always returns a leading slash', function () {
    expect(2);

    var location = mockBrowserLocation({ pathname: 'test' });
    equal(_emberRoutingLocationUtil.getPath(location), '/test', 'When there is no leading slash, one is added.');

    location = mockBrowserLocation({ pathname: '/test' });
    equal(_emberRoutingLocationUtil.getPath(location), '/test', 'When a leading slash is already there, it isn\'t added again');
  });

  QUnit.test('getQuery() should return location.search as-is', function () {
    expect(1);

    var location = mockBrowserLocation({ search: '?foo=bar' });
    equal(_emberRoutingLocationUtil.getQuery(location), '?foo=bar');
  });

  QUnit.test('getFullPath() should return full pathname including query and hash', function () {
    expect(1);

    var location = mockBrowserLocation({
      href: 'http://test.com/about?foo=bar#foo',
      pathname: '/about',
      search: '?foo=bar',
      hash: '#foo'
    });

    equal(_emberRoutingLocationUtil.getFullPath(location), '/about?foo=bar#foo');
  });

  QUnit.test('Feature-Detecting onhashchange', function () {
    equal(_emberRoutingLocationUtil.supportsHashChange(undefined, { onhashchange: function () {} }), true, 'When not in IE, use onhashchange existence as evidence of the feature');
    equal(_emberRoutingLocationUtil.supportsHashChange(undefined, {}), false, 'When not in IE, use onhashchange absence as evidence of the feature absence');
    equal(_emberRoutingLocationUtil.supportsHashChange(7, { onhashchange: function () {} }), false, 'When in IE7 compatibility mode, never report existence of the feature');
    equal(_emberRoutingLocationUtil.supportsHashChange(8, { onhashchange: function () {} }), true, 'When in IE8+, use onhashchange existence as evidence of the feature');
  });

  // jscs:disable
  QUnit.test("Feature-detecting the history API", function () {
    equal(_emberRoutingLocationUtil.supportsHistory("", { pushState: true }), true, "returns true if not Android Gingerbread and history.pushState exists");
    equal(_emberRoutingLocationUtil.supportsHistory("", {}), false, "returns false if history.pushState doesn't exist");
    equal(_emberRoutingLocationUtil.supportsHistory("", undefined), false, "returns false if history doesn't exist");

    equal(_emberRoutingLocationUtil.supportsHistory("Mozilla/5.0 (Linux; U; Android 2.3.5; en-us; HTC Vision Build/GRI40) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1", { pushState: true }), false, "returns false if Android 2.x stock browser (not Chrome) claiming to support pushState");

    equal(_emberRoutingLocationUtil.supportsHistory("Mozilla/5.0 (Linux; U; Android 4.0.3; nl-nl; GT-N7000 Build/IML74K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30", { pushState: true }), false, "returns false for Android 4.0.x stock browser (not Chrome) claiming to support pushState");

    equal(_emberRoutingLocationUtil.supportsHistory("Mozilla/5.0 (Linux; U; Android 20.3.5; en-us; HTC Vision Build/GRI40) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1", { pushState: true }), true, "returns true if Android version begins with 2, but is greater than 2");

    equal(_emberRoutingLocationUtil.supportsHistory("Mozilla/5.0 (Linux; Android 4.0.4; Galaxy Nexus Build/IMM76B) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.133 Mobile Safari/535.19", { pushState: true }), true, "returns true for Chrome (not stock browser) on Android 4.0.x");

    // Windows Phone UA and History API: https://github.com/Modernizr/Modernizr/issues/1471
    equal(_emberRoutingLocationUtil.supportsHistory("Mozilla/5.0 (Mobile; Windows Phone 8.1; Android 4.0; ARM; Trident/7.0; Touch; rv:11.0; IEMobile/11.0; Microsoft; Virtual) like iPhone OS 7_0_3 Mac OS X AppleWebKit/537 (KHTML, like Gecko) Mobile Safari/537", { pushState: true }), true, "returns true for Windows Phone 8.1 with misleading user agent string");
  });
  // jscs:enable
});
enifed('ember-routing/tests/location/util_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/tests/location/util_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/tests/location/util_test.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/tests/system/cache_test', ['exports', 'ember-routing/system/cache'], function (exports, _emberRoutingSystemCache) {
  'use strict';

  QUnit.module('BucketCache', {
    setup: function () {
      this.cache = _emberRoutingSystemCache.default.create();
    }
  });

  QUnit.test('has - returns false when bucket is not in cache', function (assert) {
    assert.strictEqual(this.cache.has('foo'), false);
    assert.strictEqual(this.cache.has('constructor'), false);
  });

  QUnit.test('has - returns true when bucket is in cache', function (assert) {
    var token = {};

    this.cache.stash('foo', 'bar', token);
    this.cache.stash('constructor', 'bar', token);

    assert.strictEqual(this.cache.has('foo'), true);
    assert.strictEqual(this.cache.has('constructor'), true);
  });

  QUnit.test('lookup - returns stashed value if key does exist in bucket', function (assert) {
    var token = {};
    var defaultValue = {};

    this.cache.stash('foo', 'bar', token);

    assert.strictEqual(this.cache.lookup('foo', 'bar', defaultValue), token);
  });

  QUnit.test('lookup - returns default value if key does not exist in bucket', function (assert) {
    var token = {};
    var defaultValue = {};

    this.cache.stash('foo', 'bar', token);

    assert.strictEqual(this.cache.lookup('foo', 'boo', defaultValue), defaultValue);
    assert.strictEqual(this.cache.lookup('foo', 'constructor', defaultValue), defaultValue);
  });

  QUnit.test('lookup - returns default value if bucket does not exist', function (assert) {
    var defaultValue = {};

    assert.strictEqual(this.cache.lookup('boo', 'bar', defaultValue), defaultValue);
    assert.strictEqual(this.cache.lookup('constructor', 'bar', defaultValue), defaultValue);
  });
});
enifed('ember-routing/tests/system/cache_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/tests/system/cache_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/tests/system/cache_test.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/tests/system/controller_for_test', ['exports', 'ember-metal', 'ember-runtime', 'ember-routing/system/controller_for', 'ember-routing/system/generate_controller', 'internal-test-helpers'], function (exports, _emberMetal, _emberRuntime, _emberRoutingSystemController_for, _emberRoutingSystemGenerate_controller, _internalTestHelpers) {
  'use strict';

  function buildInstance(namespace) {
    var owner = _internalTestHelpers.buildOwner();

    owner.__registry__.resolver = resolverFor(namespace);
    owner.registerOptionsForType('view', { singleton: false });

    owner.register('application:main', namespace, { instantiate: false });

    owner.register('controller:basic', _emberRuntime.Controller, { instantiate: false });

    return owner;
  }

  function resolverFor(namespace) {
    return {
      resolve: function (fullName) {
        var nameParts = fullName.split(':');
        var type = nameParts[0];
        var name = nameParts[1];

        if (name === 'basic') {
          name = '';
        }
        var className = _emberRuntime.String.classify(name) + _emberRuntime.String.classify(type);
        var factory = _emberMetal.get(namespace, className);

        if (factory) {
          return factory;
        }
      }
    };
  }

  var appInstance = undefined,
      appController = undefined,
      namespace = undefined;

  QUnit.module('Ember.controllerFor', {
    setup: function () {
      namespace = _emberRuntime.Namespace.create();
      appInstance = buildInstance(namespace);
      appInstance.register('controller:app', _emberRuntime.Controller.extend());
      appController = appInstance.lookup('controller:app');
    },
    teardown: function () {
      _emberMetal.run(function () {
        appInstance.destroy();
        namespace.destroy();
      });
    }
  });

  QUnit.test('controllerFor should lookup for registered controllers', function () {
    var controller = _emberRoutingSystemController_for.default(appInstance, 'app');

    equal(appController, controller, 'should find app controller');
  });

  QUnit.module('Ember.generateController', {
    setup: function () {
      namespace = _emberRuntime.Namespace.create();
      appInstance = buildInstance(namespace);
    },
    teardown: function () {
      _emberMetal.run(function () {
        appInstance.destroy();
        namespace.destroy();
      });
    }
  });

  QUnit.test('generateController should return Ember.Controller', function () {
    var controller = _emberRoutingSystemGenerate_controller.default(appInstance, 'home');

    ok(controller instanceof _emberRuntime.Controller, 'should return controller');
  });

  QUnit.test('generateController should return App.Controller if provided', function () {
    var controller = undefined;
    namespace.Controller = _emberRuntime.Controller.extend();

    controller = _emberRoutingSystemGenerate_controller.default(appInstance, 'home');

    ok(controller instanceof namespace.Controller, 'should return controller');
  });

  QUnit.test('generateController should return controller:basic if provided', function () {
    var controller = undefined;

    var BasicController = _emberRuntime.Controller.extend();
    appInstance.register('controller:basic', BasicController);

    controller = _emberRoutingSystemGenerate_controller.default(appInstance, 'home');

    if (_emberMetal.isFeatureEnabled('ember-no-double-extend')) {
      ok(controller instanceof BasicController, 'should return base class of controller');
    } else {
      var doubleExtendedFactory = undefined;
      ignoreDeprecation(function () {
        doubleExtendedFactory = appInstance._lookupFactory('controller:basic');
      });
      ok(controller instanceof doubleExtendedFactory, 'should return double-extended controller');
    }
  });
});
// A
enifed('ember-routing/tests/system/controller_for_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/tests/system/controller_for_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/tests/system/controller_for_test.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/tests/system/dsl_test', ['exports', 'ember-utils', 'ember-routing/system/router', 'internal-test-helpers'], function (exports, _emberUtils, _emberRoutingSystemRouter, _internalTestHelpers) {
  'use strict';

  var Router = undefined;

  function setup() {
    Router = _emberRoutingSystemRouter.default.extend();
  }

  function teardown() {
    Router = null;
  }

  QUnit.module('Ember Router DSL', {
    setup: setup,
    teardown: teardown
  });

  QUnit.test('should fail when using a reserved route name', function () {
    expectDeprecation('this.resource() is deprecated. Use this.route(\'name\', { resetNamespace: true }, function () {}) instead.');
    var reservedNames = ['array', 'basic', 'object', 'application'];

    expect(reservedNames.length * 2 + 1);

    reservedNames.forEach(function (reservedName) {
      expectAssertion(function () {
        Router = _emberRoutingSystemRouter.default.extend();

        Router.map(function () {
          this.route(reservedName);
        });

        var router = Router.create();
        router._initRouterJs();
      }, '\'' + reservedName + '\' cannot be used as a route name.');

      expectAssertion(function () {
        Router = _emberRoutingSystemRouter.default.extend();

        Router.map(function () {
          this.resource(reservedName);
        });

        var router = Router.create();
        router._initRouterJs();
      }, '\'' + reservedName + '\' cannot be used as a route name.');
    });
  });

  QUnit.test('should reset namespace if nested with resource', function () {
    expectDeprecation('this.resource() is deprecated. Use this.route(\'name\', { resetNamespace: true }, function () {}) instead.');

    Router = Router.map(function () {
      this.resource('bleep', function () {
        this.resource('bloop', function () {
          this.resource('blork');
        });
      });
    });

    var router = Router.create();
    router._initRouterJs();

    ok(router.router.recognizer.names['bleep'], 'nested resources do not contain parent name');
    ok(router.router.recognizer.names['bloop'], 'nested resources do not contain parent name');
    ok(router.router.recognizer.names['blork'], 'nested resources do not contain parent name');
  });

  QUnit.test('should retain resource namespace if nested with routes', function () {
    Router = Router.map(function () {
      this.route('bleep', function () {
        this.route('bloop', function () {
          this.route('blork');
        });
      });
    });

    var router = Router.create();
    router._initRouterJs();

    ok(router.router.recognizer.names['bleep'], 'parent name was used as base of nested routes');
    ok(router.router.recognizer.names['bleep.bloop'], 'parent name was used as base of nested routes');
    ok(router.router.recognizer.names['bleep.bloop.blork'], 'parent name was used as base of nested routes');
  });

  QUnit.test('should add loading and error routes if _isRouterMapResult is true', function () {
    Router.map(function () {
      this.route('blork');
    });

    var router = Router.create({
      _hasModuleBasedResolver: function () {
        return true;
      }
    });

    router._initRouterJs();

    ok(router.router.recognizer.names['blork'], 'main route was created');
    ok(router.router.recognizer.names['blork_loading'], 'loading route was added');
    ok(router.router.recognizer.names['blork_error'], 'error route was added');
  });

  QUnit.test('should not add loading and error routes if _isRouterMapResult is false', function () {
    Router.map(function () {
      this.route('blork');
    });

    var router = Router.create();
    router._initRouterJs(false);

    ok(router.router.recognizer.names['blork'], 'main route was created');
    ok(!router.router.recognizer.names['blork_loading'], 'loading route was not added');
    ok(!router.router.recognizer.names['blork_error'], 'error route was not added');
  });

  QUnit.test('should reset namespace of loading and error routes for routes with resetNamespace', function () {
    Router.map(function () {
      this.route('blork', function () {
        this.route('blorp');
        this.route('bleep', { resetNamespace: true });
      });
    });

    var router = Router.create({
      _hasModuleBasedResolver: function () {
        return true;
      }
    });

    router._initRouterJs();

    ok(router.router.recognizer.names['blork.blorp'], 'nested route was created');
    ok(router.router.recognizer.names['blork.blorp_loading'], 'nested loading route was added');
    ok(router.router.recognizer.names['blork.blorp_error'], 'nested error route was added');

    ok(router.router.recognizer.names['bleep'], 'reset route was created');
    ok(router.router.recognizer.names['bleep_loading'], 'reset loading route was added');
    ok(router.router.recognizer.names['bleep_error'], 'reset error route was added');

    ok(!router.router.recognizer.names['blork.bleep'], 'nested reset route was not created');
    ok(!router.router.recognizer.names['blork.bleep_loading'], 'nested reset loading route was not added');
    ok(!router.router.recognizer.names['blork.bleep_error'], 'nested reset error route was not added');
  });

  QUnit.test('should throw an error when defining a route serializer outside an engine', function () {
    Router.map(function () {
      var _this = this;

      throws(function () {
        _this.route('posts', { serialize: function () {} });
      }, /Defining a route serializer on route 'posts' outside an Engine is not allowed/);
    });

    Router.create()._initRouterJs();
  });

  QUnit.module('Ember Router DSL with engines', {
    setup: setup,
    teardown: teardown
  });

  QUnit.test('should allow mounting of engines', function (assert) {
    assert.expect(3);

    Router = Router.map(function () {
      this.route('bleep', function () {
        this.route('bloop', function () {
          this.mount('chat');
        });
      });
    });

    var engineInstance = _internalTestHelpers.buildOwner({
      ownerOptions: { routable: true }
    });

    var router = Router.create();
    _emberUtils.setOwner(router, engineInstance);
    router._initRouterJs();

    assert.ok(router.router.recognizer.names['bleep'], 'parent name was used as base of nested routes');
    assert.ok(router.router.recognizer.names['bleep.bloop'], 'parent name was used as base of nested routes');
    assert.ok(router.router.recognizer.names['bleep.bloop.chat'], 'parent name was used as base of mounted engine');
  });

  QUnit.test('should allow mounting of engines at a custom path', function (assert) {
    assert.expect(1);

    Router = Router.map(function () {
      this.route('bleep', function () {
        this.route('bloop', function () {
          this.mount('chat', { path: 'custom-chat' });
        });
      });
    });

    var engineInstance = _internalTestHelpers.buildOwner({
      ownerOptions: { routable: true }
    });

    var router = Router.create();
    _emberUtils.setOwner(router, engineInstance);
    router._initRouterJs();

    assert.deepEqual(router.router.recognizer.names['bleep.bloop.chat'].segments.slice(1, 4).map(function (s) {
      return s.value;
    }), ['bleep', 'bloop', 'custom-chat'], 'segments are properly associated with mounted engine');
  });

  QUnit.test('should allow aliasing of engine names with `as`', function (assert) {
    assert.expect(1);

    Router = Router.map(function () {
      this.route('bleep', function () {
        this.route('bloop', function () {
          this.mount('chat', { as: 'blork' });
        });
      });
    });

    var engineInstance = _internalTestHelpers.buildOwner({
      ownerOptions: { routable: true }
    });

    var router = Router.create();
    _emberUtils.setOwner(router, engineInstance);
    router._initRouterJs();

    assert.deepEqual(router.router.recognizer.names['bleep.bloop.blork'].segments.slice(1, 4).map(function (s) {
      return s.value;
    }), ['bleep', 'bloop', 'blork'], 'segments are properly associated with mounted engine with aliased name');
  });

  QUnit.test('should add loading and error routes to a mount if _isRouterMapResult is true', function () {
    Router.map(function () {
      this.mount('chat');
    });

    var engineInstance = _internalTestHelpers.buildOwner({
      ownerOptions: { routable: true }
    });

    var router = Router.create({
      _hasModuleBasedResolver: function () {
        return true;
      }
    });
    _emberUtils.setOwner(router, engineInstance);
    router._initRouterJs();

    ok(router.router.recognizer.names['chat'], 'main route was created');
    ok(router.router.recognizer.names['chat_loading'], 'loading route was added');
    ok(router.router.recognizer.names['chat_error'], 'error route was added');
  });

  QUnit.test('should add loading and error routes to a mount alias if _isRouterMapResult is true', function () {
    Router.map(function () {
      this.mount('chat', { as: 'shoutbox' });
    });

    var engineInstance = _internalTestHelpers.buildOwner({
      ownerOptions: { routable: true }
    });

    var router = Router.create({
      _hasModuleBasedResolver: function () {
        return true;
      }
    });
    _emberUtils.setOwner(router, engineInstance);
    router._initRouterJs();

    ok(router.router.recognizer.names['shoutbox'], 'main route was created');
    ok(router.router.recognizer.names['shoutbox_loading'], 'loading route was added');
    ok(router.router.recognizer.names['shoutbox_error'], 'error route was added');
  });

  QUnit.test('should not add loading and error routes to a mount if _isRouterMapResult is false', function () {
    Router.map(function () {
      this.mount('chat');
    });

    var engineInstance = _internalTestHelpers.buildOwner({
      ownerOptions: { routable: true }
    });

    var router = Router.create();
    _emberUtils.setOwner(router, engineInstance);
    router._initRouterJs(false);

    ok(router.router.recognizer.names['chat'], 'main route was created');
    ok(!router.router.recognizer.names['chat_loading'], 'loading route was not added');
    ok(!router.router.recognizer.names['chat_error'], 'error route was not added');
  });

  QUnit.test('should reset namespace of loading and error routes for mounts with resetNamespace', function () {
    Router.map(function () {
      this.route('news', function () {
        this.mount('chat');
        this.mount('blog', { resetNamespace: true });
      });
    });

    var engineInstance = _internalTestHelpers.buildOwner({
      ownerOptions: { routable: true }
    });

    var router = Router.create({
      _hasModuleBasedResolver: function () {
        return true;
      }
    });
    _emberUtils.setOwner(router, engineInstance);
    router._initRouterJs();

    ok(router.router.recognizer.names['news.chat'], 'nested route was created');
    ok(router.router.recognizer.names['news.chat_loading'], 'nested loading route was added');
    ok(router.router.recognizer.names['news.chat_error'], 'nested error route was added');

    ok(router.router.recognizer.names['blog'], 'reset route was created');
    ok(router.router.recognizer.names['blog_loading'], 'reset loading route was added');
    ok(router.router.recognizer.names['blog_error'], 'reset error route was added');

    ok(!router.router.recognizer.names['news.blog'], 'nested reset route was not created');
    ok(!router.router.recognizer.names['news.blog_loading'], 'nested reset loading route was not added');
    ok(!router.router.recognizer.names['news.blog_error'], 'nested reset error route was not added');
  });
});
enifed('ember-routing/tests/system/dsl_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/tests/system/dsl_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/tests/system/dsl_test.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/tests/system/route_test', ['exports', 'ember-utils', 'internal-test-helpers', 'ember-runtime', 'ember-routing/system/route', 'container'], function (exports, _emberUtils, _internalTestHelpers, _emberRuntime, _emberRoutingSystemRoute, _container) {
  'use strict';

  var route = undefined,
      routeOne = undefined,
      routeTwo = undefined,
      lookupHash = undefined;

  function setup() {
    route = _emberRoutingSystemRoute.default.create();
  }

  function teardown() {
    _internalTestHelpers.runDestroy(route);
  }

  QUnit.module('Ember.Route', {
    setup: setup,
    teardown: teardown
  });

  QUnit.test('default store utilizes the container to acquire the model factory', function () {
    var _ownerOptions;

    expect(4);

    var Post = _emberRuntime.Object.extend();
    var post = {};

    Post.reopenClass({
      find: function (id) {
        return post;
      }
    });

    var ownerOptions = {
      ownerOptions: (_ownerOptions = {
        hasRegistration: function () {
          return true;
        }
      }, _ownerOptions[_container.FACTORY_FOR] = function (fullName) {
        equal(fullName, 'model:post', 'correct factory was looked up');

        return {
          class: Post,
          create: function () {
            return Post.create();
          }
        };
      }, _ownerOptions)
    };

    _emberUtils.setOwner(route, _internalTestHelpers.buildOwner(ownerOptions));

    route.set('_qp', null);

    equal(route.model({ post_id: 1 }), post);
    equal(route.findModel('post', 1), post, '#findModel returns the correct post');
  });

  QUnit.test('\'store\' can be injected by data persistence frameworks', function () {
    expect(8);
    _internalTestHelpers.runDestroy(route);

    var owner = _internalTestHelpers.buildOwner();

    var post = {
      id: 1
    };

    var Store = _emberRuntime.Object.extend({
      find: function (type, value) {
        ok(true, 'injected model was called');
        equal(type, 'post', 'correct type was called');
        equal(value, 1, 'correct value was called');
        return post;
      }
    });

    owner.register('route:index', _emberRoutingSystemRoute.default);
    owner.register('store:main', Store);

    owner.inject('route', 'store', 'store:main');

    route = owner.lookup('route:index');

    equal(route.model({ post_id: 1 }), post, '#model returns the correct post');
    equal(route.findModel('post', 1), post, '#findModel returns the correct post');
  });

  QUnit.test('assert if \'store.find\' method is not found', function () {
    expect(1);
    _internalTestHelpers.runDestroy(route);

    var owner = _internalTestHelpers.buildOwner();
    var Post = _emberRuntime.Object.extend();

    owner.register('route:index', _emberRoutingSystemRoute.default);
    owner.register('model:post', Post);

    route = owner.lookup('route:index');

    expectAssertion(function () {
      route.findModel('post', 1);
    }, 'Post has no method `find`.');
  });

  QUnit.test('asserts if model class is not found', function () {
    expect(1);
    _internalTestHelpers.runDestroy(route);

    var owner = _internalTestHelpers.buildOwner();
    owner.register('route:index', _emberRoutingSystemRoute.default);

    route = owner.lookup('route:index');

    expectAssertion(function () {
      route.model({ post_id: 1 });
    }, /You used the dynamic segment post_id in your route undefined, but <Ember.Object:ember\d+>.Post did not exist and you did not override your route\'s `model` hook./);
  });

  QUnit.test('\'store\' does not need to be injected', function () {
    expect(1);

    _internalTestHelpers.runDestroy(route);

    var owner = _internalTestHelpers.buildOwner();

    owner.register('route:index', _emberRoutingSystemRoute.default);

    route = owner.lookup('route:index');

    ignoreAssertion(function () {
      route.model({ post_id: 1 });
    });

    ok(true, 'no error was raised');
  });

  QUnit.test('modelFor doesn\'t require the router', function () {
    expect(1);

    var owner = _internalTestHelpers.buildOwner();
    _emberUtils.setOwner(route, owner);

    var foo = { name: 'foo' };

    var FooRoute = _emberRoutingSystemRoute.default.extend({
      currentModel: foo
    });

    owner.register('route:foo', FooRoute);

    strictEqual(route.modelFor('foo'), foo);
  });

  QUnit.test('.send just calls an action if the router is absent', function () {
    expect(7);
    var route = _emberRoutingSystemRoute.default.extend({
      actions: {
        returnsTrue: function (foo, bar) {
          equal(foo, 1);
          equal(bar, 2);
          equal(this, route);
          return true;
        },

        returnsFalse: function () {
          ok(true, 'returnsFalse was called');
          return false;
        }
      }
    }).create();

    equal(true, route.send('returnsTrue', 1, 2));
    equal(false, route.send('returnsFalse'));
    equal(undefined, route.send('nonexistent', 1, 2, 3));
  });

  QUnit.test('.send just calls an action if the routers internal router property is absent', function () {
    expect(7);
    var route = _emberRoutingSystemRoute.default.extend({
      router: {},
      actions: {
        returnsTrue: function (foo, bar) {
          equal(foo, 1);
          equal(bar, 2);
          equal(this, route);
          return true;
        },

        returnsFalse: function () {
          ok(true, 'returnsFalse was called');
          return false;
        }
      }
    }).create();

    equal(true, route.send('returnsTrue', 1, 2));
    equal(false, route.send('returnsFalse'));
    equal(undefined, route.send('nonexistent', 1, 2, 3));
  });

  QUnit.test('can access `actions` hash via `_actions` [DEPRECATED]', function () {
    expect(2);

    var route = _emberRoutingSystemRoute.default.extend({
      actions: {
        foo: function () {
          ok(true, 'called foo action');
        }
      }
    }).create();

    expectDeprecation(function () {
      route._actions.foo();
    }, 'Usage of `_actions` is deprecated, use `actions` instead.');
  });

  QUnit.test('actions in both `_actions` and `actions` results in an assertion', function () {
    expectAssertion(function () {
      _emberRoutingSystemRoute.default.extend({
        _actions: {},
        actions: {}
      }).create();
    }, 'Specifying `_actions` and `actions` in the same mixin is not supported.');
  });

  QUnit.test('actions added via `_actions` can be used [DEPRECATED]', function () {
    expect(3);

    var route = undefined;
    expectDeprecation(function () {
      route = _emberRoutingSystemRoute.default.extend({
        _actions: {
          bar: function () {
            ok(true, 'called bar action');
          }
        }
      }, {
        actions: {
          foo: function () {
            ok(true, 'called foo action');
          }
        }
      }).create();
    }, 'Specifying actions in `_actions` is deprecated, please use `actions` instead.');

    route.send('foo');
    route.send('bar');
  });

  QUnit.module('Ember.Route serialize', {
    setup: setup,
    teardown: teardown
  });

  QUnit.test('returns the models properties if params does not include *_id', function () {
    var model = { id: 2, firstName: 'Ned', lastName: 'Ryerson' };

    deepEqual(route.serialize(model, ['firstName', 'lastName']), { firstName: 'Ned', lastName: 'Ryerson' }, 'serialized correctly');
  });

  QUnit.test('returns model.id if params include *_id', function () {
    var model = { id: 2 };

    deepEqual(route.serialize(model, ['post_id']), { post_id: 2 }, 'serialized correctly');
  });

  QUnit.test('returns checks for existence of model.post_id before trying model.id', function () {
    var model = { post_id: 3 };

    deepEqual(route.serialize(model, ['post_id']), { post_id: 3 }, 'serialized correctly');
  });

  QUnit.test('returns undefined if model is not set', function () {
    equal(route.serialize(undefined, ['post_id']), undefined, 'serialized correctly');
  });

  QUnit.module('Ember.Route interaction', {
    setup: function () {
      var owner = {
        lookup: function (fullName) {
          return lookupHash[fullName];
        }
      };

      routeOne = _emberRoutingSystemRoute.default.create({ routeName: 'one' });
      routeTwo = _emberRoutingSystemRoute.default.create({ routeName: 'two' });

      _emberUtils.setOwner(routeOne, owner);
      _emberUtils.setOwner(routeTwo, owner);

      lookupHash = {
        'route:one': routeOne,
        'route:two': routeTwo
      };
    },

    teardown: function () {
      _internalTestHelpers.runDestroy(routeOne);
      _internalTestHelpers.runDestroy(routeTwo);
    }
  });

  QUnit.test('controllerFor uses route\'s controllerName if specified', function () {
    var testController = {};
    lookupHash['controller:test'] = testController;

    routeOne.controllerName = 'test';

    equal(routeTwo.controllerFor('one'), testController);
  });

  QUnit.module('Route injected properties');

  QUnit.test('services can be injected into routes', function () {
    var owner = _internalTestHelpers.buildOwner();

    owner.register('route:application', _emberRoutingSystemRoute.default.extend({
      authService: _emberRuntime.inject.service('auth')
    }));

    owner.register('service:auth', _emberRuntime.Service.extend());

    var appRoute = owner.lookup('route:application');
    var authService = owner.lookup('service:auth');

    equal(authService, appRoute.get('authService'), 'service.auth is injected');
  });

  QUnit.module('Ember.Route with engines');

  QUnit.test('paramsFor considers an engine\'s mountPoint', function (assert) {
    expect(2);

    var router = {
      _deserializeQueryParams: function () {},
      router: {
        state: {
          handlerInfos: [{ name: 'posts' }],
          params: {
            'foo.bar': { a: 'b' },
            'foo.bar.posts': { c: 'd' }
          }
        }
      }
    };

    var engineInstance = _internalTestHelpers.buildOwner({
      ownerOptions: {
        routable: true,

        mountPoint: 'foo.bar',

        lookup: function (name) {
          if (name === 'route:posts') {
            return postsRoute;
          } else if (name === 'route:application') {
            return applicationRoute;
          }
        }
      }
    });

    var applicationRoute = _emberRoutingSystemRoute.default.create({ router: router, routeName: 'application', fullRouteName: 'foo.bar' });
    var postsRoute = _emberRoutingSystemRoute.default.create({ router: router, routeName: 'posts', fullRouteName: 'foo.bar.posts' });
    var route = _emberRoutingSystemRoute.default.create({ router: router });

    _emberUtils.setOwner(applicationRoute, engineInstance);
    _emberUtils.setOwner(postsRoute, engineInstance);
    _emberUtils.setOwner(route, engineInstance);

    assert.deepEqual(route.paramsFor('application'), { a: 'b' }, 'params match for root `application` route in engine');
    assert.deepEqual(route.paramsFor('posts'), { c: 'd' }, 'params match for `posts` route in engine');
  });

  QUnit.test('modelFor considers an engine\'s mountPoint', function () {
    expect(2);

    var applicationModel = { id: '1' };
    var postsModel = { id: '2' };

    var router = {
      router: {
        activeTransition: {
          resolvedModels: {
            'foo.bar': applicationModel,
            'foo.bar.posts': postsModel
          }
        }
      }
    };

    var engineInstance = _internalTestHelpers.buildOwner({
      ownerOptions: {
        routable: true,

        mountPoint: 'foo.bar',

        lookup: function (name) {
          if (name === 'route:posts') {
            return postsRoute;
          } else if (name === 'route:application') {
            return applicationRoute;
          }
        }
      }
    });

    var applicationRoute = _emberRoutingSystemRoute.default.create({ router: router, routeName: 'application' });
    var postsRoute = _emberRoutingSystemRoute.default.create({ router: router, routeName: 'posts' });
    var route = _emberRoutingSystemRoute.default.create({ router: router });

    _emberUtils.setOwner(applicationRoute, engineInstance);
    _emberUtils.setOwner(postsRoute, engineInstance);
    _emberUtils.setOwner(route, engineInstance);

    strictEqual(route.modelFor('application'), applicationModel);
    strictEqual(route.modelFor('posts'), postsModel);
  });

  QUnit.test('transitionTo considers an engine\'s mountPoint', function () {
    expect(4);

    var router = {
      transitionTo: function (route) {
        return route;
      }
    };

    var engineInstance = _internalTestHelpers.buildOwner({
      ownerOptions: {
        routable: true,
        mountPoint: 'foo.bar'
      }
    });

    var route = _emberRoutingSystemRoute.default.create({ router: router });
    _emberUtils.setOwner(route, engineInstance);

    strictEqual(route.transitionTo('application'), 'foo.bar.application', 'properly prefixes application route');
    strictEqual(route.transitionTo('posts'), 'foo.bar.posts', 'properly prefixes child routes');
    throws(function () {
      return route.transitionTo('/posts');
    }, 'throws when trying to use a url');

    var queryParams = {};
    strictEqual(route.transitionTo(queryParams), queryParams, 'passes query param only transitions through');
  });

  QUnit.test('intermediateTransitionTo considers an engine\'s mountPoint', function () {
    expect(4);

    var lastRoute = undefined;
    var router = {
      intermediateTransitionTo: function (route) {
        lastRoute = route;
      }
    };

    var engineInstance = _internalTestHelpers.buildOwner({
      ownerOptions: {
        routable: true,
        mountPoint: 'foo.bar'
      }
    });

    var route = _emberRoutingSystemRoute.default.create({ router: router });
    _emberUtils.setOwner(route, engineInstance);

    route.intermediateTransitionTo('application');
    strictEqual(lastRoute, 'foo.bar.application', 'properly prefixes application route');

    route.intermediateTransitionTo('posts');
    strictEqual(lastRoute, 'foo.bar.posts', 'properly prefixes child routes');

    throws(function () {
      return route.intermediateTransitionTo('/posts');
    }, 'throws when trying to use a url');

    var queryParams = {};
    route.intermediateTransitionTo(queryParams);
    strictEqual(lastRoute, queryParams, 'passes query param only transitions through');
  });

  QUnit.test('replaceWith considers an engine\'s mountPoint', function () {
    expect(4);

    var router = {
      replaceWith: function (route) {
        return route;
      }
    };

    var engineInstance = _internalTestHelpers.buildOwner({
      ownerOptions: {
        routable: true,
        mountPoint: 'foo.bar'
      }
    });

    var route = _emberRoutingSystemRoute.default.create({ router: router });
    _emberUtils.setOwner(route, engineInstance);

    strictEqual(route.replaceWith('application'), 'foo.bar.application', 'properly prefixes application route');
    strictEqual(route.replaceWith('posts'), 'foo.bar.posts', 'properly prefixes child routes');
    throws(function () {
      return route.replaceWith('/posts');
    }, 'throws when trying to use a url');

    var queryParams = {};
    strictEqual(route.replaceWith(queryParams), queryParams, 'passes query param only transitions through');
  });
});
enifed('ember-routing/tests/system/route_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/tests/system/route_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/tests/system/route_test.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/tests/system/router_test', ['exports', 'ember-utils', 'ember-routing/location/hash_location', 'ember-routing/location/history_location', 'ember-routing/location/auto_location', 'ember-routing/location/none_location', 'ember-routing/system/router', 'internal-test-helpers'], function (exports, _emberUtils, _emberRoutingLocationHash_location, _emberRoutingLocationHistory_location, _emberRoutingLocationAuto_location, _emberRoutingLocationNone_location, _emberRoutingSystemRouter, _internalTestHelpers) {
  'use strict';

  var owner = undefined;

  function createRouter(settings) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    var CustomRouter = _emberRoutingSystemRouter.default.extend();
    var router = CustomRouter.create(settings);

    if (!options.skipOwner) {
      _emberUtils.setOwner(router, owner);
    }

    if (!options.disableSetup) {
      router.setupRouter();
    }

    return router;
  }

  QUnit.module('Ember Router', {
    setup: function () {
      owner = _internalTestHelpers.buildOwner();

      //register the HashLocation (the default)
      owner.register('location:hash', _emberRoutingLocationHash_location.default);
      owner.register('location:history', _emberRoutingLocationHistory_location.default);
      owner.register('location:auto', _emberRoutingLocationAuto_location.default);
      owner.register('location:none', _emberRoutingLocationNone_location.default);
    },
    teardown: function () {
      _internalTestHelpers.runDestroy(owner);
      owner = null;
    }
  });

  QUnit.test('can create a router without an owner', function () {
    createRouter(null, { disableSetup: true, skipOwner: true });

    ok(true, 'no errors were thrown when creating without a container');
  });

  QUnit.test('should not create a router.js instance upon init', function () {
    var router = createRouter(null, { disableSetup: true });

    ok(!router.router);
  });

  QUnit.test('should not reify location until setupRouter is called', function () {
    var router = createRouter(null, { disableSetup: true });
    equal(typeof router.location, 'string', 'location is specified as a string');

    router.setupRouter();

    equal(typeof router.location, 'object', 'location is reified into an object');
  });

  QUnit.test('should destroy its location upon destroying the routers owner.', function () {
    var router = createRouter();
    var location = router.get('location');

    _internalTestHelpers.runDestroy(owner);

    ok(location.isDestroyed, 'location should be destroyed');
  });

  QUnit.test('should instantiate its location with its `rootURL`', function () {
    var router = createRouter({
      rootURL: '/rootdir/'
    });
    var location = router.get('location');

    equal(location.get('rootURL'), '/rootdir/');
  });

  QUnit.test('replacePath should be called with the right path', function () {
    expect(1);

    var location = owner.lookup('location:auto');

    var browserLocation = {
      href: 'http://test.com/rootdir/welcome',
      origin: 'http://test.com',
      pathname: '/rootdir/welcome',
      hash: '',
      search: '',
      replace: function (url) {
        equal(url, 'http://test.com/rootdir/#/welcome');
      }
    };

    location.location = browserLocation;
    location.global = { onhashchange: function () {} };
    location.history = null;

    createRouter({
      location: 'auto',
      rootURL: '/rootdir/'
    });
  });

  QUnit.test('Ember.Router._routePath should consume identical prefixes', function () {
    createRouter();

    expect(8);

    function routePath(s1, s2, s3) {
      var handlerInfos = Array.prototype.slice.call(arguments).map(function (s) {
        return { name: s };
      });
      handlerInfos.unshift({ name: 'ignored' });

      return _emberRoutingSystemRouter.default._routePath(handlerInfos);
    }

    equal(routePath('foo'), 'foo');
    equal(routePath('foo', 'bar', 'baz'), 'foo.bar.baz');
    equal(routePath('foo', 'foo.bar'), 'foo.bar');
    equal(routePath('foo', 'foo.bar', 'foo.bar.baz'), 'foo.bar.baz');
    equal(routePath('foo', 'foo.bar', 'foo.bar.baz.wow'), 'foo.bar.baz.wow');
    equal(routePath('foo', 'foo.bar.baz.wow'), 'foo.bar.baz.wow');
    equal(routePath('foo.bar', 'bar.baz.wow'), 'foo.bar.baz.wow');

    // This makes no sense, not trying to handle it, just
    // making sure it doesn't go boom.
    equal(routePath('foo.bar.baz', 'foo'), 'foo.bar.baz.foo');
  });

  QUnit.test('Router should cancel routing setup when the Location class says so via cancelRouterSetup', function () {
    expect(0);

    var router = undefined;
    var FakeLocation = {
      cancelRouterSetup: true,
      create: function () {
        return this;
      }
    };

    owner.register('location:fake', FakeLocation);

    router = createRouter({
      location: 'fake',

      _setupRouter: function () {
        ok(false, '_setupRouter should not be called');
      }
    });

    router.startRouting();
  });

  QUnit.test('AutoLocation should replace the url when it\'s not in the preferred format', function () {
    expect(1);

    var location = owner.lookup('location:auto');

    location.location = {
      href: 'http://test.com/rootdir/welcome',
      origin: 'http://test.com',
      pathname: '/rootdir/welcome',
      hash: '',
      search: '',
      replace: function (url) {
        equal(url, 'http://test.com/rootdir/#/welcome');
      }
    };
    location.history = null;
    location.global = {
      onhashchange: function () {}
    };

    createRouter({
      location: 'auto',
      rootURL: '/rootdir/'
    });
  });

  QUnit.test('Router#handleURL should remove any #hashes before doing URL transition', function () {
    expect(2);

    var router = createRouter({
      _doURLTransition: function (routerJsMethod, url) {
        equal(routerJsMethod, 'handleURL');
        equal(url, '/foo/bar?time=morphin');
      }
    });

    router.handleURL('/foo/bar?time=morphin#pink-power-ranger');
  });

  QUnit.test('Router#triggerEvent allows actions to bubble when returning true', function (assert) {
    assert.expect(2);

    var handlerInfos = [{
      name: 'application',
      handler: {
        actions: {
          loading: function () {
            assert.ok(false, 'loading not handled by application route');
          }
        }
      }
    }, {
      name: 'about',
      handler: {
        actions: {
          loading: function () {
            assert.ok(true, 'loading handled by about route');
            return false;
          }
        }
      }
    }, {
      name: 'about.me',
      handler: {
        actions: {
          loading: function () {
            assert.ok(true, 'loading handled by about.me route');
            return true;
          }
        }
      }
    }];

    _emberRoutingSystemRouter.triggerEvent(handlerInfos, false, ['loading']);
  });

  QUnit.test('Router#triggerEvent ignores handlers that have not loaded yet', function (assert) {
    assert.expect(1);

    var handlerInfos = [{
      name: 'about',
      handler: {
        actions: {
          loading: function () {
            assert.ok(true, 'loading handled by about route');
          }
        }
      }
    }, {
      name: 'about.me',
      handler: undefined
    }];

    _emberRoutingSystemRouter.triggerEvent(handlerInfos, false, ['loading']);
  });
});
enifed('ember-routing/tests/system/router_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/tests/system/router_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/tests/system/router_test.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/tests/utils_test', ['exports', 'ember-routing/utils'], function (exports, _emberRoutingUtils) {
  'use strict';

  QUnit.module('Routing query parameter utils - normalizeControllerQueryParams');

  QUnit.test('converts array style into verbose object style', function (assert) {
    var paramName = 'foo';
    var params = [paramName];
    var normalized = _emberRoutingUtils.normalizeControllerQueryParams(params);

    ok(normalized[paramName], 'turns the query param name into key');
    equal(normalized[paramName].as, null, 'includes a blank alias in \'as\' key');
    equal(normalized[paramName].scope, 'model', 'defaults scope to model');
  });

  QUnit.test('converts object style [{foo: \'an_alias\'}]', function (assert) {
    var paramName = 'foo';
    var params = [{ 'foo': 'an_alias' }];
    var normalized = _emberRoutingUtils.normalizeControllerQueryParams(params);

    ok(normalized[paramName], 'retains the query param name as key');
    equal(normalized[paramName].as, 'an_alias', 'includes the provided alias in \'as\' key');
    equal(normalized[paramName].scope, 'model', 'defaults scope to model');
  });

  QUnit.test('retains maximally verbose object style [{foo: {as: \'foo\'}}]', function (assert) {
    var paramName = 'foo';
    var params = [{ 'foo': { as: 'an_alias' } }];
    var normalized = _emberRoutingUtils.normalizeControllerQueryParams(params);

    ok(normalized[paramName], 'retains the query param name as key');
    equal(normalized[paramName].as, 'an_alias', 'includes the provided alias in \'as\' key');
    equal(normalized[paramName].scope, 'model', 'defaults scope to model');
  });
});
enifed('ember-routing/tests/utils_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/tests/utils_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/tests/utils_test.js should pass ESLint\n\n');
  });
});
enifed('ember-routing/utils.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-routing/utils.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-routing/utils.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/compare.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/compare.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/compare.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/computed/computed_macros.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/computed/computed_macros.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/computed/computed_macros.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/computed/reduce_computed_macros.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/computed/reduce_computed_macros.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/computed/reduce_computed_macros.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/controllers/controller.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/controllers/controller.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/controllers/controller.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/copy.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/copy.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/copy.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/ext/function.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/ext/function.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/ext/function.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/ext/rsvp.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/ext/rsvp.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/ext/rsvp.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/ext/string.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/ext/string.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/ext/string.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/index.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/index.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/index.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/inject.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/inject.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/inject.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/is-equal.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/is-equal.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/is-equal.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/mixins/-proxy.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/mixins/-proxy.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/mixins/-proxy.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/mixins/action_handler.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/mixins/action_handler.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/mixins/action_handler.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/mixins/array.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/mixins/array.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/mixins/array.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/mixins/comparable.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/mixins/comparable.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/mixins/comparable.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/mixins/container_proxy.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/mixins/container_proxy.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/mixins/container_proxy.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/mixins/controller.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/mixins/controller.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/mixins/controller.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/mixins/controller_content_model_alias_deprecation.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/mixins/controller_content_model_alias_deprecation.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/mixins/controller_content_model_alias_deprecation.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/mixins/copyable.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/mixins/copyable.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/mixins/copyable.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/mixins/enumerable.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/mixins/enumerable.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/mixins/enumerable.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/mixins/evented.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/mixins/evented.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/mixins/evented.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/mixins/freezable.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/mixins/freezable.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/mixins/freezable.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/mixins/mutable_array.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/mixins/mutable_array.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/mixins/mutable_array.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/mixins/mutable_enumerable.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/mixins/mutable_enumerable.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/mixins/mutable_enumerable.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/mixins/observable.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/mixins/observable.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/mixins/observable.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/mixins/promise_proxy.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/mixins/promise_proxy.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/mixins/promise_proxy.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/mixins/registry_proxy.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/mixins/registry_proxy.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/mixins/registry_proxy.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/mixins/target_action_support.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/mixins/target_action_support.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/mixins/target_action_support.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/string_registry.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/string_registry.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/string_registry.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/system/application.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/system/application.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/system/application.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/system/array_proxy.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/system/array_proxy.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/system/array_proxy.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/system/core_object.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/system/core_object.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/system/core_object.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/system/each_proxy.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/system/each_proxy.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/system/each_proxy.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/system/lazy_load.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/system/lazy_load.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/system/lazy_load.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/system/namespace.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/system/namespace.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/system/namespace.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/system/native_array.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/system/native_array.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/system/native_array.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/system/object.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/system/object.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/system/object.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/system/object_proxy.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/system/object_proxy.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/system/object_proxy.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/system/service.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/system/service.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/system/service.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/system/string.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/system/string.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/system/string.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/computed/computed_macros_test', ['exports', 'ember-metal', 'ember-runtime/computed/computed_macros', 'internal-test-helpers', 'ember-runtime/system/object', 'ember-runtime/system/native_array'], function (exports, _emberMetal, _emberRuntimeComputedComputed_macros, _internalTestHelpers, _emberRuntimeSystemObject, _emberRuntimeSystemNative_array) {
  'use strict';

  QUnit.module('CP macros');

  _internalTestHelpers.testBoth('Ember.computed.empty', function (get, set) {
    var obj = _emberRuntimeSystemObject.default.extend({
      bestLannister: null,
      lannisters: null,

      bestLannisterUnspecified: _emberRuntimeComputedComputed_macros.empty('bestLannister'),
      noLannistersKnown: _emberRuntimeComputedComputed_macros.empty('lannisters')
    }).create({
      lannisters: _emberRuntimeSystemNative_array.A()
    });

    equal(get(obj, 'bestLannisterUnspecified'), true, 'bestLannister initially empty');
    equal(get(obj, 'noLannistersKnown'), true, 'lannisters initially empty');

    get(obj, 'lannisters').pushObject('Tyrion');
    set(obj, 'bestLannister', 'Tyrion');

    equal(get(obj, 'bestLannisterUnspecified'), false, 'empty respects strings');
    equal(get(obj, 'noLannistersKnown'), false, 'empty respects array mutations');
  });

  _internalTestHelpers.testBoth('Ember.computed.notEmpty', function (get, set) {
    var obj = _emberRuntimeSystemObject.default.extend({
      bestLannister: null,
      lannisters: null,

      bestLannisterSpecified: _emberRuntimeComputedComputed_macros.notEmpty('bestLannister'),
      LannistersKnown: _emberRuntimeComputedComputed_macros.notEmpty('lannisters')
    }).create({
      lannisters: _emberRuntimeSystemNative_array.A()
    });

    equal(get(obj, 'bestLannisterSpecified'), false, 'bestLannister initially empty');
    equal(get(obj, 'LannistersKnown'), false, 'lannisters initially empty');

    get(obj, 'lannisters').pushObject('Tyrion');
    set(obj, 'bestLannister', 'Tyrion');

    equal(get(obj, 'bestLannisterSpecified'), true, 'empty respects strings');
    equal(get(obj, 'LannistersKnown'), true, 'empty respects array mutations');
  });

  _internalTestHelpers.testBoth('computed.not', function (get, set) {
    var obj = { foo: true };
    _emberMetal.defineProperty(obj, 'notFoo', _emberRuntimeComputedComputed_macros.not('foo'));
    equal(get(obj, 'notFoo'), false);

    obj = { foo: { bar: true } };
    _emberMetal.defineProperty(obj, 'notFoo', _emberRuntimeComputedComputed_macros.not('foo.bar'));
    equal(get(obj, 'notFoo'), false);
  });

  _internalTestHelpers.testBoth('computed.empty', function (get, set) {
    var obj = { foo: [], bar: undefined, baz: null, quz: '' };
    _emberMetal.defineProperty(obj, 'fooEmpty', _emberRuntimeComputedComputed_macros.empty('foo'));
    _emberMetal.defineProperty(obj, 'barEmpty', _emberRuntimeComputedComputed_macros.empty('bar'));
    _emberMetal.defineProperty(obj, 'bazEmpty', _emberRuntimeComputedComputed_macros.empty('baz'));
    _emberMetal.defineProperty(obj, 'quzEmpty', _emberRuntimeComputedComputed_macros.empty('quz'));

    equal(get(obj, 'fooEmpty'), true);
    set(obj, 'foo', [1]);
    equal(get(obj, 'fooEmpty'), false);
    equal(get(obj, 'barEmpty'), true);
    equal(get(obj, 'bazEmpty'), true);
    equal(get(obj, 'quzEmpty'), true);
    set(obj, 'quz', 'asdf');
    equal(get(obj, 'quzEmpty'), false);
  });

  _internalTestHelpers.testBoth('computed.bool', function (get, set) {
    var obj = { foo: function () {}, bar: 'asdf', baz: null, quz: false };
    _emberMetal.defineProperty(obj, 'fooBool', _emberRuntimeComputedComputed_macros.bool('foo'));
    _emberMetal.defineProperty(obj, 'barBool', _emberRuntimeComputedComputed_macros.bool('bar'));
    _emberMetal.defineProperty(obj, 'bazBool', _emberRuntimeComputedComputed_macros.bool('baz'));
    _emberMetal.defineProperty(obj, 'quzBool', _emberRuntimeComputedComputed_macros.bool('quz'));
    equal(get(obj, 'fooBool'), true);
    equal(get(obj, 'barBool'), true);
    equal(get(obj, 'bazBool'), false);
    equal(get(obj, 'quzBool'), false);
  });

  _internalTestHelpers.testBoth('computed.alias', function (get, set) {
    var obj = { bar: 'asdf', baz: null, quz: false };
    _emberMetal.defineProperty(obj, 'bay', _emberMetal.computed(function (key) {
      return 'apple';
    }));

    _emberMetal.defineProperty(obj, 'barAlias', _emberMetal.alias('bar'));
    _emberMetal.defineProperty(obj, 'bazAlias', _emberMetal.alias('baz'));
    _emberMetal.defineProperty(obj, 'quzAlias', _emberMetal.alias('quz'));
    _emberMetal.defineProperty(obj, 'bayAlias', _emberMetal.alias('bay'));

    equal(get(obj, 'barAlias'), 'asdf');
    equal(get(obj, 'bazAlias'), null);
    equal(get(obj, 'quzAlias'), false);
    equal(get(obj, 'bayAlias'), 'apple');

    set(obj, 'barAlias', 'newBar');
    set(obj, 'bazAlias', 'newBaz');
    set(obj, 'quzAlias', null);

    equal(get(obj, 'barAlias'), 'newBar');
    equal(get(obj, 'bazAlias'), 'newBaz');
    equal(get(obj, 'quzAlias'), null);

    equal(get(obj, 'bar'), 'newBar');
    equal(get(obj, 'baz'), 'newBaz');
    equal(get(obj, 'quz'), null);
  });

  _internalTestHelpers.testBoth('computed.alias set', function (get, set) {
    var obj = {};
    var constantValue = 'always `a`';

    _emberMetal.defineProperty(obj, 'original', _emberMetal.computed({
      get: function (key) {
        return constantValue;
      },
      set: function (key, value) {
        return constantValue;
      }
    }));
    _emberMetal.defineProperty(obj, 'aliased', _emberMetal.alias('original'));

    equal(get(obj, 'original'), constantValue);
    equal(get(obj, 'aliased'), constantValue);

    set(obj, 'aliased', 'should not set to this value');

    equal(get(obj, 'original'), constantValue);
    equal(get(obj, 'aliased'), constantValue);
  });

  _internalTestHelpers.testBoth('computed.match', function (get, set) {
    var obj = { name: 'Paul' };
    _emberMetal.defineProperty(obj, 'isPaul', _emberRuntimeComputedComputed_macros.match('name', /Paul/));

    equal(get(obj, 'isPaul'), true, 'is Paul');

    set(obj, 'name', 'Pierre');

    equal(get(obj, 'isPaul'), false, 'is not Paul anymore');
  });

  _internalTestHelpers.testBoth('computed.notEmpty', function (get, set) {
    var obj = { items: [1] };
    _emberMetal.defineProperty(obj, 'hasItems', _emberRuntimeComputedComputed_macros.notEmpty('items'));

    equal(get(obj, 'hasItems'), true, 'is not empty');

    set(obj, 'items', []);

    equal(get(obj, 'hasItems'), false, 'is empty');
  });

  _internalTestHelpers.testBoth('computed.equal', function (get, set) {
    var obj = { name: 'Paul' };
    _emberMetal.defineProperty(obj, 'isPaul', _emberRuntimeComputedComputed_macros.equal('name', 'Paul'));

    equal(get(obj, 'isPaul'), true, 'is Paul');

    set(obj, 'name', 'Pierre');

    equal(get(obj, 'isPaul'), false, 'is not Paul anymore');
  });

  _internalTestHelpers.testBoth('computed.gt', function (get, set) {
    var obj = { number: 2 };
    _emberMetal.defineProperty(obj, 'isGreaterThenOne', _emberRuntimeComputedComputed_macros.gt('number', 1));

    equal(get(obj, 'isGreaterThenOne'), true, 'is gt');

    set(obj, 'number', 1);

    equal(get(obj, 'isGreaterThenOne'), false, 'is not gt');

    set(obj, 'number', 0);

    equal(get(obj, 'isGreaterThenOne'), false, 'is not gt');
  });

  _internalTestHelpers.testBoth('computed.gte', function (get, set) {
    var obj = { number: 2 };
    _emberMetal.defineProperty(obj, 'isGreaterOrEqualThenOne', _emberRuntimeComputedComputed_macros.gte('number', 1));

    equal(get(obj, 'isGreaterOrEqualThenOne'), true, 'is gte');

    set(obj, 'number', 1);

    equal(get(obj, 'isGreaterOrEqualThenOne'), true, 'is gte');

    set(obj, 'number', 0);

    equal(get(obj, 'isGreaterOrEqualThenOne'), false, 'is not gte');
  });

  _internalTestHelpers.testBoth('computed.lt', function (get, set) {
    var obj = { number: 0 };
    _emberMetal.defineProperty(obj, 'isLesserThenOne', _emberRuntimeComputedComputed_macros.lt('number', 1));

    equal(get(obj, 'isLesserThenOne'), true, 'is lt');

    set(obj, 'number', 1);

    equal(get(obj, 'isLesserThenOne'), false, 'is not lt');

    set(obj, 'number', 2);

    equal(get(obj, 'isLesserThenOne'), false, 'is not lt');
  });

  _internalTestHelpers.testBoth('computed.lte', function (get, set) {
    var obj = { number: 0 };
    _emberMetal.defineProperty(obj, 'isLesserOrEqualThenOne', _emberRuntimeComputedComputed_macros.lte('number', 1));

    equal(get(obj, 'isLesserOrEqualThenOne'), true, 'is lte');

    set(obj, 'number', 1);

    equal(get(obj, 'isLesserOrEqualThenOne'), true, 'is lte');

    set(obj, 'number', 2);

    equal(get(obj, 'isLesserOrEqualThenOne'), false, 'is not lte');
  });

  _internalTestHelpers.testBoth('computed.and two properties', function (get, set) {
    var obj = { one: true, two: true };
    _emberMetal.defineProperty(obj, 'oneAndTwo', _emberRuntimeComputedComputed_macros.and('one', 'two'));

    equal(get(obj, 'oneAndTwo'), true, 'one and two');

    set(obj, 'one', false);

    equal(get(obj, 'oneAndTwo'), false, 'one and not two');

    set(obj, 'one', null);
    set(obj, 'two', 'Yes');

    equal(get(obj, 'oneAndTwo'), null, 'returns falsy value as in &&');

    set(obj, 'one', true);
    set(obj, 'two', 2);

    equal(get(obj, 'oneAndTwo'), 2, 'returns truthy value as in &&');
  });

  _internalTestHelpers.testBoth('computed.and three properties', function (get, set) {
    var obj = { one: true, two: true, three: true };
    _emberMetal.defineProperty(obj, 'oneTwoThree', _emberRuntimeComputedComputed_macros.and('one', 'two', 'three'));

    equal(get(obj, 'oneTwoThree'), true, 'one and two and three');

    set(obj, 'one', false);

    equal(get(obj, 'oneTwoThree'), false, 'one and not two and not three');

    set(obj, 'one', true);
    set(obj, 'two', 2);
    set(obj, 'three', 3);

    equal(get(obj, 'oneTwoThree'), 3, 'returns truthy value as in &&');
  });

  _internalTestHelpers.testBoth('computed.and expand properties', function (get, set) {
    var obj = { one: true, two: true, three: true };
    _emberMetal.defineProperty(obj, 'oneTwoThree', _emberRuntimeComputedComputed_macros.and('{one,two,three}'));

    equal(get(obj, 'oneTwoThree'), true, 'one and two and three');

    set(obj, 'one', false);

    equal(get(obj, 'oneTwoThree'), false, 'one and not two and not three');

    set(obj, 'one', true);
    set(obj, 'two', 2);
    set(obj, 'three', 3);

    equal(get(obj, 'oneTwoThree'), 3, 'returns truthy value as in &&');
  });

  _internalTestHelpers.testBoth('computed.or two properties', function (get, set) {
    var obj = { one: true, two: true };
    _emberMetal.defineProperty(obj, 'oneOrTwo', _emberRuntimeComputedComputed_macros.or('one', 'two'));

    equal(get(obj, 'oneOrTwo'), true, 'one or two');

    set(obj, 'one', false);

    equal(get(obj, 'oneOrTwo'), true, 'one or two');

    set(obj, 'two', false);

    equal(get(obj, 'oneOrTwo'), false, 'nor one nor two');

    set(obj, 'two', null);

    equal(get(obj, 'oneOrTwo'), null, 'returns last falsy value as in ||');

    set(obj, 'two', true);

    equal(get(obj, 'oneOrTwo'), true, 'one or two');

    set(obj, 'one', 1);

    equal(get(obj, 'oneOrTwo'), 1, 'returns truthy value as in ||');
  });

  _internalTestHelpers.testBoth('computed.or three properties', function (get, set) {
    var obj = { one: true, two: true, three: true };
    _emberMetal.defineProperty(obj, 'oneTwoThree', _emberRuntimeComputedComputed_macros.or('one', 'two', 'three'));

    equal(get(obj, 'oneTwoThree'), true, 'one or two or three');

    set(obj, 'one', false);

    equal(get(obj, 'oneTwoThree'), true, 'one or two or three');

    set(obj, 'two', false);

    equal(get(obj, 'oneTwoThree'), true, 'one or two or three');

    set(obj, 'three', false);

    equal(get(obj, 'oneTwoThree'), false, 'one or two or three');

    set(obj, 'three', null);

    equal(get(obj, 'oneTwoThree'), null, 'returns last falsy value as in ||');

    set(obj, 'two', true);

    equal(get(obj, 'oneTwoThree'), true, 'one or two or three');

    set(obj, 'one', 1);

    equal(get(obj, 'oneTwoThree'), 1, 'returns truthy value as in ||');
  });

  _internalTestHelpers.testBoth('computed.or expand properties', function (get, set) {
    var obj = { one: true, two: true, three: true };
    _emberMetal.defineProperty(obj, 'oneTwoThree', _emberRuntimeComputedComputed_macros.or('{one,two,three}'));

    equal(get(obj, 'oneTwoThree'), true, 'one or two or three');

    set(obj, 'one', false);

    equal(get(obj, 'oneTwoThree'), true, 'one or two or three');

    set(obj, 'two', false);

    equal(get(obj, 'oneTwoThree'), true, 'one or two or three');

    set(obj, 'three', false);

    equal(get(obj, 'oneTwoThree'), false, 'one or two or three');

    set(obj, 'three', null);

    equal(get(obj, 'oneTwoThree'), null, 'returns last falsy value as in ||');

    set(obj, 'two', true);

    equal(get(obj, 'oneTwoThree'), true, 'one or two or three');

    set(obj, 'one', 1);

    equal(get(obj, 'oneTwoThree'), 1, 'returns truthy value as in ||');
  });

  _internalTestHelpers.testBoth('computed.or and computed.and warn about dependent keys with spaces', function (get, set) {
    var obj = { one: true, two: true };
    expectAssertion(function () {
      _emberMetal.defineProperty(obj, 'oneOrTwo', _emberRuntimeComputedComputed_macros.or('one', 'two three'));
    }, /Dependent keys passed to Ember\.computed\.or\(\) can't have spaces\./);

    expectAssertion(function () {
      _emberMetal.defineProperty(obj, 'oneAndTwo', _emberRuntimeComputedComputed_macros.and('one', 'two three'));
    }, /Dependent keys passed to Ember\.computed\.and\(\) can't have spaces\./);
  });

  _internalTestHelpers.testBoth('computed.oneWay', function (get, set) {
    var obj = {
      firstName: 'Teddy',
      lastName: 'Zeenny'
    };

    _emberMetal.defineProperty(obj, 'nickName', _emberRuntimeComputedComputed_macros.oneWay('firstName'));

    equal(get(obj, 'firstName'), 'Teddy');
    equal(get(obj, 'lastName'), 'Zeenny');
    equal(get(obj, 'nickName'), 'Teddy');

    set(obj, 'nickName', 'TeddyBear');

    equal(get(obj, 'firstName'), 'Teddy');
    equal(get(obj, 'lastName'), 'Zeenny');

    equal(get(obj, 'nickName'), 'TeddyBear');

    set(obj, 'firstName', 'TEDDDDDDDDYYY');

    equal(get(obj, 'nickName'), 'TeddyBear');
  });

  _internalTestHelpers.testBoth('computed.readOnly', function (get, set) {
    var obj = {
      firstName: 'Teddy',
      lastName: 'Zeenny'
    };

    _emberMetal.defineProperty(obj, 'nickName', _emberRuntimeComputedComputed_macros.readOnly('firstName'));

    equal(get(obj, 'firstName'), 'Teddy');
    equal(get(obj, 'lastName'), 'Zeenny');
    equal(get(obj, 'nickName'), 'Teddy');

    throws(function () {
      set(obj, 'nickName', 'TeddyBear');
    }, / /);

    equal(get(obj, 'firstName'), 'Teddy');
    equal(get(obj, 'lastName'), 'Zeenny');

    equal(get(obj, 'nickName'), 'Teddy');

    set(obj, 'firstName', 'TEDDDDDDDDYYY');

    equal(get(obj, 'nickName'), 'TEDDDDDDDDYYY');
  });

  _internalTestHelpers.testBoth('computed.deprecatingAlias', function (get, set) {
    var obj = { bar: 'asdf', baz: null, quz: false };
    _emberMetal.defineProperty(obj, 'bay', _emberMetal.computed(function (key) {
      return 'apple';
    }));

    _emberMetal.defineProperty(obj, 'barAlias', _emberRuntimeComputedComputed_macros.deprecatingAlias('bar'));
    _emberMetal.defineProperty(obj, 'bazAlias', _emberRuntimeComputedComputed_macros.deprecatingAlias('baz'));
    _emberMetal.defineProperty(obj, 'quzAlias', _emberRuntimeComputedComputed_macros.deprecatingAlias('quz'));
    _emberMetal.defineProperty(obj, 'bayAlias', _emberRuntimeComputedComputed_macros.deprecatingAlias('bay'));

    expectDeprecation(function () {
      equal(get(obj, 'barAlias'), 'asdf');
    }, 'Usage of `barAlias` is deprecated, use `bar` instead.');

    expectDeprecation(function () {
      equal(get(obj, 'bazAlias'), null);
    }, 'Usage of `bazAlias` is deprecated, use `baz` instead.');

    expectDeprecation(function () {
      equal(get(obj, 'quzAlias'), false);
    }, 'Usage of `quzAlias` is deprecated, use `quz` instead.');

    expectDeprecation(function () {
      equal(get(obj, 'bayAlias'), 'apple');
    }, 'Usage of `bayAlias` is deprecated, use `bay` instead.');

    expectDeprecation(function () {
      set(obj, 'barAlias', 'newBar');
    }, 'Usage of `barAlias` is deprecated, use `bar` instead.');

    expectDeprecation(function () {
      set(obj, 'bazAlias', 'newBaz');
    }, 'Usage of `bazAlias` is deprecated, use `baz` instead.');

    expectDeprecation(function () {
      set(obj, 'quzAlias', null);
    }, 'Usage of `quzAlias` is deprecated, use `quz` instead.');

    equal(get(obj, 'barAlias'), 'newBar');
    equal(get(obj, 'bazAlias'), 'newBaz');
    equal(get(obj, 'quzAlias'), null);

    equal(get(obj, 'bar'), 'newBar');
    equal(get(obj, 'baz'), 'newBaz');
    equal(get(obj, 'quz'), null);
  });
});
enifed('ember-runtime/tests/computed/computed_macros_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/computed/computed_macros_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/computed/computed_macros_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/computed/reduce_computed_macros_test', ['exports', 'ember-metal', 'internal-test-helpers', 'ember-runtime/system/object', 'ember-runtime/system/object_proxy', 'ember-runtime/computed/reduce_computed_macros', 'ember-runtime/utils', 'ember-runtime/system/native_array', 'ember-runtime/mixins/mutable_array'], function (exports, _emberMetal, _internalTestHelpers, _emberRuntimeSystemObject, _emberRuntimeSystemObject_proxy, _emberRuntimeComputedReduce_computed_macros, _emberRuntimeUtils, _emberRuntimeSystemNative_array, _emberRuntimeMixinsMutable_array) {
  'use strict';

  var obj = undefined;
  QUnit.module('map', {
    setup: function () {
      obj = _emberRuntimeSystemObject.default.extend({
        mapped: _emberRuntimeComputedReduce_computed_macros.map('array.@each.v', function (item) {
          return item.v;
        }),
        mappedObjects: _emberRuntimeComputedReduce_computed_macros.map('arrayObjects.@each.v', function (item) {
          return { name: item.v.name };
        })
      }).create({
        arrayObjects: _emberRuntimeSystemNative_array.A([{ v: { name: 'Robert' } }, { v: { name: 'Leanna' } }]),

        array: _emberRuntimeSystemNative_array.A([{ v: 1 }, { v: 3 }, { v: 2 }, { v: 1 }])
      });
    },

    teardown: function () {
      _emberMetal.run(obj, 'destroy');
    }
  });

  QUnit.test('map is readOnly', function () {
    QUnit.throws(function () {
      obj.set('mapped', 1);
    }, /Cannot set read-only property "mapped" on object:/);
  });

  QUnit.test('it maps simple properties', function () {
    deepEqual(obj.get('mapped'), [1, 3, 2, 1]);

    obj.get('array').pushObject({ v: 5 });

    deepEqual(obj.get('mapped'), [1, 3, 2, 1, 5]);

    _emberRuntimeMixinsMutable_array.removeAt(obj.get('array'), 3);

    deepEqual(obj.get('mapped'), [1, 3, 2, 5]);
  });

  QUnit.test('it maps simple unshifted properties', function () {
    var array = _emberRuntimeSystemNative_array.A();

    obj = _emberRuntimeSystemObject.default.extend({
      mapped: _emberRuntimeComputedReduce_computed_macros.map('array', function (item) {
        return item.toUpperCase();
      })
    }).create({
      array: array
    });

    array.unshiftObject('c');
    array.unshiftObject('b');
    array.unshiftObject('a');

    array.popObject();

    deepEqual(obj.get('mapped'), ['A', 'B'], 'properties unshifted in sequence are mapped correctly');
  });

  QUnit.test('it has the correct `this`', function () {
    obj = _emberRuntimeSystemObject.default.extend({
      mapped: _emberRuntimeComputedReduce_computed_macros.map('array', function (item) {
        equal(this, obj, 'should have correct context');
        return this.upperCase(item);
      }),
      upperCase: function (string) {
        return string.toUpperCase();
      }
    }).create({
      array: ['a', 'b', 'c']
    });

    deepEqual(obj.get('mapped'), ['A', 'B', 'C'], 'properties unshifted in sequence are mapped correctly');
  });

  QUnit.test('it passes the index to the callback', function () {
    var array = ['a', 'b', 'c'];

    obj = _emberRuntimeSystemObject.default.extend({
      mapped: _emberRuntimeComputedReduce_computed_macros.map('array', function (item, index) {
        return index;
      })
    }).create({
      array: array
    });

    deepEqual(obj.get('mapped'), [0, 1, 2], 'index is passed to callback correctly');
  });

  QUnit.test('it maps objects', function () {
    deepEqual(obj.get('mappedObjects'), [{ name: 'Robert' }, { name: 'Leanna' }]);

    obj.get('arrayObjects').pushObject({
      v: { name: 'Eddard' }
    });

    deepEqual(obj.get('mappedObjects'), [{ name: 'Robert' }, { name: 'Leanna' }, { name: 'Eddard' }]);

    _emberRuntimeMixinsMutable_array.removeAt(obj.get('arrayObjects'), 1);

    deepEqual(obj.get('mappedObjects'), [{ name: 'Robert' }, { name: 'Eddard' }]);

    _emberMetal.set(obj.get('arrayObjects')[0], 'v', { name: 'Stannis' });

    deepEqual(obj.get('mappedObjects'), [{ name: 'Stannis' }, { name: 'Eddard' }]);
  });

  QUnit.test('it maps unshifted objects with property observers', function () {
    var array = _emberRuntimeSystemNative_array.A();
    var cObj = { v: 'c' };

    obj = _emberRuntimeSystemObject.default.extend({
      mapped: _emberRuntimeComputedReduce_computed_macros.map('array.@each.v', function (item) {
        return _emberMetal.get(item, 'v').toUpperCase();
      })
    }).create({
      array: array
    });

    array.unshiftObject(cObj);
    array.unshiftObject({ v: 'b' });
    array.unshiftObject({ v: 'a' });

    _emberMetal.set(cObj, 'v', 'd');

    deepEqual(array.mapBy('v'), ['a', 'b', 'd'], 'precond - unmapped array is correct');
    deepEqual(obj.get('mapped'), ['A', 'B', 'D'], 'properties unshifted in sequence are mapped correctly');
  });

  QUnit.module('mapBy', {
    setup: function () {
      obj = _emberRuntimeSystemObject.default.extend({
        mapped: _emberRuntimeComputedReduce_computed_macros.mapBy('array', 'v')
      }).create({
        array: _emberRuntimeSystemNative_array.A([{ v: 1 }, { v: 3 }, { v: 2 }, { v: 1 }])
      });
    },
    teardown: function () {
      _emberMetal.run(obj, 'destroy');
    }
  });

  QUnit.test('mapBy is readOnly', function () {
    QUnit.throws(function () {
      obj.set('mapped', 1);
    }, /Cannot set read-only property "mapped" on object:/);
  });

  QUnit.test('it maps properties', function () {
    deepEqual(obj.get('mapped'), [1, 3, 2, 1]);

    obj.get('array').pushObject({ v: 5 });

    deepEqual(obj.get('mapped'), [1, 3, 2, 1, 5]);

    _emberRuntimeMixinsMutable_array.removeAt(obj.get('array'), 3);

    deepEqual(obj.get('mapped'), [1, 3, 2, 5]);
  });

  QUnit.test('it is observable', function () {
    var calls = 0;

    deepEqual(obj.get('mapped'), [1, 3, 2, 1]);

    _emberMetal.addObserver(obj, 'mapped.@each', function () {
      return calls++;
    });

    obj.get('array').pushObject({ v: 5 });

    equal(calls, 1, 'mapBy is observable');
  });

  QUnit.module('filter', {
    setup: function () {
      obj = _emberRuntimeSystemObject.default.extend({
        filtered: _emberRuntimeComputedReduce_computed_macros.filter('array', function (item) {
          return item % 2 === 0;
        })
      }).create({
        array: _emberRuntimeSystemNative_array.A([1, 2, 3, 4, 5, 6, 7, 8])
      });
    },
    teardown: function () {
      _emberMetal.run(obj, 'destroy');
    }
  });

  QUnit.test('filter is readOnly', function () {
    QUnit.throws(function () {
      obj.set('filtered', 1);
    }, /Cannot set read-only property "filtered" on object:/);
  });

  QUnit.test('it filters according to the specified filter function', function () {
    deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'filter filters by the specified function');
  });

  QUnit.test('it passes the index to the callback', function () {
    obj = _emberRuntimeSystemObject.default.extend({
      filtered: _emberRuntimeComputedReduce_computed_macros.filter('array', function (item, index) {
        return index === 1;
      })
    }).create({
      array: ['a', 'b', 'c']
    });

    deepEqual(_emberMetal.get(obj, 'filtered'), ['b'], 'index is passed to callback correctly');
  });

  QUnit.test('it has the correct `this`', function () {
    obj = _emberRuntimeSystemObject.default.extend({
      filtered: _emberRuntimeComputedReduce_computed_macros.filter('array', function (item, index) {
        equal(this, obj);
        return this.isOne(index);
      }),
      isOne: function (value) {
        return value === 1;
      }
    }).create({
      array: ['a', 'b', 'c']
    });

    deepEqual(_emberMetal.get(obj, 'filtered'), ['b'], 'index is passed to callback correctly');
  });

  QUnit.test('it passes the array to the callback', function () {
    obj = _emberRuntimeSystemObject.default.extend({
      filtered: _emberRuntimeComputedReduce_computed_macros.filter('array', function (item, index, array) {
        return index === _emberMetal.get(array, 'length') - 2;
      })
    }).create({
      array: _emberRuntimeSystemNative_array.A(['a', 'b', 'c'])
    });

    deepEqual(obj.get('filtered'), ['b'], 'array is passed to callback correctly');
  });

  QUnit.test('it caches properly', function () {
    var array = obj.get('array');

    var filtered = obj.get('filtered');
    ok(filtered === obj.get('filtered'));

    array.addObject(11);
    var newFiltered = obj.get('filtered');

    ok(filtered !== newFiltered);

    ok(obj.get('filtered') === newFiltered);
  });

  QUnit.test('it updates as the array is modified', function () {
    var array = obj.get('array');

    deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'precond - filtered array is initially correct');

    array.addObject(11);
    deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'objects not passing the filter are not added');

    array.addObject(12);
    deepEqual(obj.get('filtered'), [2, 4, 6, 8, 12], 'objects passing the filter are added');

    array.removeObject(3);
    array.removeObject(4);

    deepEqual(obj.get('filtered'), [2, 6, 8, 12], 'objects removed from the dependent array are removed from the computed array');
  });

  QUnit.test('the dependent array can be cleared one at a time', function () {
    var array = _emberMetal.get(obj, 'array');

    deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'precond - filtered array is initially correct');

    // clear 1-8 but in a random order
    array.removeObject(3);
    array.removeObject(1);
    array.removeObject(2);
    array.removeObject(4);
    array.removeObject(8);
    array.removeObject(6);
    array.removeObject(5);
    array.removeObject(7);

    deepEqual(obj.get('filtered'), [], 'filtered array cleared correctly');
  });

  QUnit.test('the dependent array can be `clear`ed directly (#3272)', function () {
    deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'precond - filtered array is initially correct');

    obj.get('array').clear();

    deepEqual(obj.get('filtered'), [], 'filtered array cleared correctly');
  });

  QUnit.test('it updates as the array is replaced', function () {
    deepEqual(obj.get('filtered'), [2, 4, 6, 8], 'precond - filtered array is initially correct');

    obj.set('array', [20, 21, 22, 23, 24]);

    deepEqual(obj.get('filtered'), [20, 22, 24], 'computed array is updated when array is changed');
  });

  QUnit.module('filterBy', {
    setup: function () {
      obj = _emberRuntimeSystemObject.default.extend({
        a1s: _emberRuntimeComputedReduce_computed_macros.filterBy('array', 'a', 1),
        as: _emberRuntimeComputedReduce_computed_macros.filterBy('array', 'a'),
        bs: _emberRuntimeComputedReduce_computed_macros.filterBy('array', 'b')
      }).create({
        array: _emberRuntimeSystemNative_array.A([{ name: 'one', a: 1, b: false }, { name: 'two', a: 2, b: false }, { name: 'three', a: 1, b: true }, { name: 'four', b: true }])
      });
    },
    teardown: function () {
      _emberMetal.run(obj, 'destroy');
    }
  });

  QUnit.test('filterBy is readOnly', function () {
    QUnit.throws(function () {
      obj.set('as', 1);
    }, /Cannot set read-only property "as" on object:/);
  });

  QUnit.test('properties can be filtered by truthiness', function () {
    deepEqual(obj.get('as').mapBy('name'), ['one', 'two', 'three'], 'properties can be filtered by existence');
    deepEqual(obj.get('bs').mapBy('name'), ['three', 'four'], 'booleans can be filtered');

    _emberMetal.set(obj.get('array')[0], 'a', undefined);
    _emberMetal.set(obj.get('array')[3], 'a', true);

    _emberMetal.set(obj.get('array')[0], 'b', true);
    _emberMetal.set(obj.get('array')[3], 'b', false);

    deepEqual(obj.get('as').mapBy('name'), ['two', 'three', 'four'], 'arrays computed by filter property respond to property changes');
    deepEqual(obj.get('bs').mapBy('name'), ['one', 'three'], 'arrays computed by filtered property respond to property changes');

    obj.get('array').pushObject({ name: 'five', a: 6, b: true });

    deepEqual(obj.get('as').mapBy('name'), ['two', 'three', 'four', 'five'], 'arrays computed by filter property respond to added objects');
    deepEqual(obj.get('bs').mapBy('name'), ['one', 'three', 'five'], 'arrays computed by filtered property respond to added objects');

    obj.get('array').popObject();

    deepEqual(obj.get('as').mapBy('name'), ['two', 'three', 'four'], 'arrays computed by filter property respond to removed objects');
    deepEqual(obj.get('bs').mapBy('name'), ['one', 'three'], 'arrays computed by filtered property respond to removed objects');

    obj.set('array', [{ name: 'six', a: 12, b: true }]);

    deepEqual(obj.get('as').mapBy('name'), ['six'], 'arrays computed by filter property respond to array changes');
    deepEqual(obj.get('bs').mapBy('name'), ['six'], 'arrays computed by filtered property respond to array changes');
  });

  QUnit.test('properties can be filtered by values', function () {
    deepEqual(obj.get('a1s').mapBy('name'), ['one', 'three'], 'properties can be filtered by matching value');

    obj.get('array').pushObject({ name: 'five', a: 1 });

    deepEqual(obj.get('a1s').mapBy('name'), ['one', 'three', 'five'], 'arrays computed by matching value respond to added objects');

    obj.get('array').popObject();

    deepEqual(obj.get('a1s').mapBy('name'), ['one', 'three'], 'arrays computed by matching value respond to removed objects');

    _emberMetal.set(obj.get('array')[1], 'a', 1);
    _emberMetal.set(obj.get('array')[2], 'a', 2);

    deepEqual(obj.get('a1s').mapBy('name'), ['one', 'two'], 'arrays computed by matching value respond to modified properties');
  });

  QUnit.test('properties values can be replaced', function () {
    obj = _emberRuntimeSystemObject.default.extend({
      a1s: _emberRuntimeComputedReduce_computed_macros.filterBy('array', 'a', 1),
      a1bs: _emberRuntimeComputedReduce_computed_macros.filterBy('a1s', 'b')
    }).create({
      array: []
    });

    deepEqual(obj.get('a1bs').mapBy('name'), [], 'properties can be filtered by matching value');

    _emberMetal.set(obj, 'array', [{ name: 'item1', a: 1, b: true }]);

    deepEqual(obj.get('a1bs').mapBy('name'), ['item1'], 'properties can be filtered by matching value');
  });

  [['uniq', _emberRuntimeComputedReduce_computed_macros.uniq], ['union', _emberRuntimeComputedReduce_computed_macros.union]].forEach(function (tuple) {
    var name = tuple[0];
    var macro = tuple[1];

    QUnit.module('computed.' + name, {
      setup: function () {
        obj = _emberRuntimeSystemObject.default.extend({
          union: macro('array', 'array2', 'array3')
        }).create({
          array: _emberRuntimeSystemNative_array.A([1, 2, 3, 4, 5, 6]),
          array2: _emberRuntimeSystemNative_array.A([4, 5, 6, 7, 8, 9, 4, 5, 6, 7, 8, 9]),
          array3: _emberRuntimeSystemNative_array.A([1, 8, 10])
        });
      },
      teardown: function () {
        _emberMetal.run(obj, 'destroy');
      }
    });

    QUnit.test(name + ' is readOnly', function () {
      QUnit.throws(function () {
        obj.set('union', 1);
      }, /Cannot set read-only property "union" on object:/);
    });

    QUnit.test('does not include duplicates', function () {
      var array = obj.get('array');
      var array2 = obj.get('array2');

      deepEqual(obj.get('union').sort(function (x, y) {
        return x - y;
      }), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], name + ' does not include duplicates');

      array.pushObject(8);

      deepEqual(obj.get('union').sort(function (x, y) {
        return x - y;
      }), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], name + ' does not add existing items');

      array.pushObject(11);

      deepEqual(obj.get('union').sort(function (x, y) {
        return x - y;
      }), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], name + ' adds new items');

      _emberRuntimeMixinsMutable_array.removeAt(array2, 6); // remove 7

      deepEqual(obj.get('union').sort(function (x, y) {
        return x - y;
      }), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], name + ' does not remove items that are still in the dependent array');

      array2.removeObject(7);

      deepEqual(obj.get('union').sort(function (x, y) {
        return x - y;
      }), [1, 2, 3, 4, 5, 6, 8, 9, 10, 11], name + ' removes items when their last instance is gone');
    });

    QUnit.test('has set-union semantics', function () {
      var array = obj.get('array');

      deepEqual(obj.get('union').sort(function (x, y) {
        return x - y;
      }), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], name + ' is initially correct');

      array.removeObject(6);

      deepEqual(obj.get('union').sort(function (x, y) {
        return x - y;
      }), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 'objects are not removed if they exist in other dependent arrays');

      array.clear();

      deepEqual(obj.get('union').sort(function (x, y) {
        return x - y;
      }), [1, 4, 5, 6, 7, 8, 9, 10], 'objects are removed when they are no longer in any dependent array');
    });
  });

  QUnit.module('computed.uniqBy', {
    setup: function () {
      obj = _emberRuntimeSystemObject.default.extend({
        list: null,
        uniqueById: _emberRuntimeComputedReduce_computed_macros.uniqBy('list', 'id')
      }).create({
        list: _emberRuntimeSystemNative_array.A([{ id: 1, value: 'one' }, { id: 2, value: 'two' }, { id: 1, value: 'one' }])
      });
    },
    teardown: function () {
      _emberMetal.run(obj, 'destroy');
    }
  });

  QUnit.test('uniqBy is readOnly', function () {
    QUnit.throws(function () {
      obj.set('uniqueById', 1);
    }, /Cannot set read-only property "uniqueById" on object:/);
  });
  QUnit.test('does not include duplicates', function () {
    deepEqual(obj.get('uniqueById'), [{ id: 1, value: 'one' }, { id: 2, value: 'two' }]);
  });

  QUnit.test('it does not share state among instances', function () {
    var MyObject = _emberRuntimeSystemObject.default.extend({
      list: [],
      uniqueByName: _emberRuntimeComputedReduce_computed_macros.uniqBy('list', 'name')
    });
    var a = MyObject.create({ list: [{ name: 'bob' }, { name: 'mitch' }, { name: 'mitch' }] });
    var b = MyObject.create({ list: [{ name: 'warren' }, { name: 'mitch' }] });

    deepEqual(a.get('uniqueByName'), [{ name: 'bob' }, { name: 'mitch' }]);
    // Making sure that 'mitch' appears
    deepEqual(b.get('uniqueByName'), [{ name: 'warren' }, { name: 'mitch' }]);
  });

  QUnit.test('it handles changes to the dependent array', function () {
    obj.get('list').pushObject({ id: 3, value: 'three' });

    deepEqual(obj.get('uniqueById'), [{ id: 1, value: 'one' }, { id: 2, value: 'two' }, { id: 3, value: 'three' }], 'The list includes three');

    obj.get('list').pushObject({ id: 3, value: 'three' });

    deepEqual(obj.get('uniqueById'), [{ id: 1, value: 'one' }, { id: 2, value: 'two' }, { id: 3, value: 'three' }], 'The list does not include a duplicate three');
  });

  QUnit.test('it returns an empty array when computed on a non-array', function () {
    var MyObject = _emberRuntimeSystemObject.default.extend({
      list: null,
      uniq: _emberRuntimeComputedReduce_computed_macros.uniqBy('list', 'name')
    });
    var a = MyObject.create({ list: 'not an array' });

    deepEqual(a.get('uniq'), []);
  });

  QUnit.module('computed.intersect', {
    setup: function () {
      obj = _emberRuntimeSystemObject.default.extend({
        intersection: _emberRuntimeComputedReduce_computed_macros.intersect('array', 'array2', 'array3')
      }).create({
        array: _emberRuntimeSystemNative_array.A([1, 2, 3, 4, 5, 6]),
        array2: _emberRuntimeSystemNative_array.A([3, 3, 3, 4, 5]),
        array3: _emberRuntimeSystemNative_array.A([3, 5, 6, 7, 8])
      });
    },
    teardown: function () {
      _emberMetal.run(obj, 'destroy');
    }
  });

  QUnit.test('intersect is readOnly', function () {
    QUnit.throws(function () {
      obj.set('intersection', 1);
    }, /Cannot set read-only property "intersection" on object:/);
  });

  QUnit.test('it has set-intersection semantics', function () {
    var array2 = obj.get('array2');
    var array3 = obj.get('array3');

    deepEqual(obj.get('intersection').sort(function (x, y) {
      return x - y;
    }), [3, 5], 'intersection is initially correct');

    array2.shiftObject();

    deepEqual(obj.get('intersection').sort(function (x, y) {
      return x - y;
    }), [3, 5], 'objects are not removed when they are still in all dependent arrays');

    array2.shiftObject();

    deepEqual(obj.get('intersection').sort(function (x, y) {
      return x - y;
    }), [3, 5], 'objects are not removed when they are still in all dependent arrays');

    array2.shiftObject();

    deepEqual(obj.get('intersection'), [5], 'objects are removed once they are gone from all dependent arrays');

    array2.pushObject(1);

    deepEqual(obj.get('intersection'), [5], 'objects are not added as long as they are missing from any dependent array');

    array3.pushObject(1);

    deepEqual(obj.get('intersection').sort(function (x, y) {
      return x - y;
    }), [1, 5], 'objects added once they belong to all dependent arrays');
  });

  QUnit.module('setDiff', {
    setup: function () {
      obj = _emberRuntimeSystemObject.default.extend({
        diff: _emberRuntimeComputedReduce_computed_macros.setDiff('array', 'array2')
      }).create({
        array: _emberRuntimeSystemNative_array.A([1, 2, 3, 4, 5, 6, 7]),
        array2: _emberRuntimeSystemNative_array.A([3, 4, 5, 10])
      });
    },
    teardown: function () {
      _emberMetal.run(obj, 'destroy');
    }
  });

  QUnit.test('setDiff is readOnly', function () {
    QUnit.throws(function () {
      obj.set('diff', 1);
    }, /Cannot set read-only property "diff" on object:/);
  });

  QUnit.test('it throws an error if given fewer or more than two dependent properties', function () {
    throws(function () {
      _emberRuntimeSystemObject.default.extend({
        diff: _emberRuntimeComputedReduce_computed_macros.setDiff('array')
      }).create({
        array: _emberRuntimeSystemNative_array.A([1, 2, 3, 4, 5, 6, 7]),
        array2: _emberRuntimeSystemNative_array.A([3, 4, 5])
      });
    }, /requires exactly two dependent arrays/, 'setDiff requires two dependent arrays');

    throws(function () {
      _emberRuntimeSystemObject.default.extend({
        diff: _emberRuntimeComputedReduce_computed_macros.setDiff('array', 'array2', 'array3')
      }).create({
        array: _emberRuntimeSystemNative_array.A([1, 2, 3, 4, 5, 6, 7]),
        array2: _emberRuntimeSystemNative_array.A([3, 4, 5]),
        array3: _emberRuntimeSystemNative_array.A([7])
      });
    }, /requires exactly two dependent arrays/, 'setDiff requires two dependent arrays');
  });

  QUnit.test('it has set-diff semantics', function () {
    var array1 = obj.get('array');
    var array2 = obj.get('array2');

    deepEqual(obj.get('diff').sort(function (x, y) {
      return x - y;
    }), [1, 2, 6, 7], 'set-diff is initially correct');

    array2.popObject();

    deepEqual(obj.get('diff').sort(function (x, y) {
      return x - y;
    }), [1, 2, 6, 7], 'removing objects from the remove set has no effect if the object is not in the keep set');

    array2.shiftObject();

    deepEqual(obj.get('diff').sort(function (x, y) {
      return x - y;
    }), [1, 2, 3, 6, 7], 'removing objects from the remove set adds them if they\'re in the keep set');

    array1.removeObject(3);

    deepEqual(obj.get('diff').sort(function (x, y) {
      return x - y;
    }), [1, 2, 6, 7], 'removing objects from the keep array removes them from the computed array');

    array1.pushObject(5);

    deepEqual(obj.get('diff').sort(function (x, y) {
      return x - y;
    }), [1, 2, 6, 7], 'objects added to the keep array that are in the remove array are not added to the computed array');

    array1.pushObject(22);

    deepEqual(obj.get('diff').sort(function (x, y) {
      return x - y;
    }), [1, 2, 6, 7, 22], 'objects added to the keep array not in the remove array are added to the computed array');
  });

  function commonSortTests() {
    QUnit.test('arrays are initially sorted', function () {
      deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'array is initially sorted');
    });

    QUnit.test('default sort order is correct', function () {
      deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'array is initially sorted');
    });

    QUnit.test('changing the dependent array updates the sorted array', function () {
      deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');

      obj.set('items', [{ fname: 'Roose', lname: 'Bolton' }, { fname: 'Theon', lname: 'Greyjoy' }, { fname: 'Ramsey', lname: 'Bolton' }, { fname: 'Stannis', lname: 'Baratheon' }]);

      deepEqual(obj.get('sortedItems').mapBy('fname'), ['Stannis', 'Ramsey', 'Roose', 'Theon'], 'changing dependent array updates sorted array');
    });

    QUnit.test('adding to the dependent array updates the sorted array', function () {
      var items = obj.get('items');

      deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');

      items.pushObject({
        fname: 'Tyrion',
        lname: 'Lannister'
      });

      deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Tyrion', 'Bran', 'Robb'], 'Adding to the dependent array updates the sorted array');
    });

    QUnit.test('removing from the dependent array updates the sorted array', function () {
      deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');

      obj.get('items').popObject();

      deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Robb'], 'Removing from the dependent array updates the sorted array');
    });

    QUnit.test('distinct items may be sort-equal, although their relative order will not be guaranteed', function () {
      // We recreate jaime and "Cersei" here only for test stability: we want
      // their guid-ordering to be deterministic
      var jaimeInDisguise = {
        fname: 'Cersei',
        lname: 'Lannister',
        age: 34
      };

      var jaime = {
        fname: 'Jaime',
        lname: 'Lannister',
        age: 34
      };

      var items = obj.get('items');

      items.replace(0, 1, jaime);
      items.replace(1, 1, jaimeInDisguise);

      deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');

      _emberMetal.set(jaimeInDisguise, 'fname', 'Jaime');

      deepEqual(obj.get('sortedItems').mapBy('fname'), ['Jaime', 'Jaime', 'Bran', 'Robb'], 'sorted array is updated');

      _emberMetal.set(jaimeInDisguise, 'fname', 'Cersei');

      deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'sorted array is updated');
    });

    QUnit.test('guid sort-order fallback with a search proxy is not confused by non-search ObjectProxys', function () {
      var tyrion = {
        fname: 'Tyrion',
        lname: 'Lannister'
      };

      var tyrionInDisguise = _emberRuntimeSystemObject_proxy.default.create({
        fname: 'Yollo',
        lname: '',
        content: tyrion
      });

      var items = obj.get('items');

      items.pushObject(tyrion);

      deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Tyrion', 'Bran', 'Robb']);

      items.pushObject(tyrionInDisguise);

      deepEqual(obj.get('sortedItems').mapBy('fname'), ['Yollo', 'Cersei', 'Jaime', 'Tyrion', 'Bran', 'Robb']);
    });
  }

  QUnit.module('sort - sortProperties', {
    setup: function () {
      obj = _emberRuntimeSystemObject.default.extend({
        sortedItems: _emberRuntimeComputedReduce_computed_macros.sort('items', 'itemSorting')
      }).create({
        itemSorting: _emberRuntimeSystemNative_array.A(['lname', 'fname']),
        items: _emberRuntimeSystemNative_array.A([{ fname: 'Jaime', lname: 'Lannister', age: 34 }, { fname: 'Cersei', lname: 'Lannister', age: 34 }, { fname: 'Robb', lname: 'Stark', age: 16 }, { fname: 'Bran', lname: 'Stark', age: 8 }])
      });
    },
    teardown: function () {
      _emberMetal.run(obj, 'destroy');
    }
  });

  QUnit.test('sort is readOnly', function () {
    QUnit.throws(function () {
      obj.set('sortedItems', 1);
    }, /Cannot set read-only property "sortedItems" on object:/);
  });

  commonSortTests();

  QUnit.test('updating sort properties detaches observers for old sort properties', function () {
    var objectToRemove = obj.get('items')[3];

    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');

    obj.set('itemSorting', _emberRuntimeSystemNative_array.A(['fname:desc']));

    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Robb', 'Jaime', 'Cersei', 'Bran'], 'after updating sort properties array is updated');

    obj.get('items').removeObject(objectToRemove);

    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Robb', 'Jaime', 'Cersei'], 'after removing item array is updated');

    _emberMetal.set(objectToRemove, 'lname', 'Updated-Stark');

    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Robb', 'Jaime', 'Cersei'], 'after changing removed item array is not updated');
  });

  QUnit.test('updating sort properties updates the sorted array', function () {
    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');

    obj.set('itemSorting', _emberRuntimeSystemNative_array.A(['fname:desc']));

    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Robb', 'Jaime', 'Cersei', 'Bran'], 'after updating sort properties array is updated');
  });

  QUnit.test('updating sort properties invalidates the sorted array', function () {
    var sortProps = obj.get('itemSorting');

    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');

    sortProps.clear();
    sortProps.pushObject('fname');

    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Bran', 'Cersei', 'Jaime', 'Robb'], 'after updating sort properties array is updated');
  });

  QUnit.test('updating new sort properties invalidates the sorted array', function () {
    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');

    obj.set('itemSorting', _emberRuntimeSystemNative_array.A(['age:desc', 'fname:asc']));

    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Robb', 'Bran'], 'precond - array is correct after item sorting is changed');

    _emberMetal.set(obj.get('items')[1], 'age', 29);

    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Jaime', 'Cersei', 'Robb', 'Bran'], 'after updating sort properties array is updated');
  });

  QUnit.test('sort direction defaults to ascending', function () {
    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb']);
  });

  QUnit.test('sort direction defaults to ascending (with sort property change)', function () {
    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');

    obj.set('itemSorting', _emberRuntimeSystemNative_array.A(['fname']));

    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Bran', 'Cersei', 'Jaime', 'Robb'], 'sort direction defaults to ascending');
  });

  QUnit.test('updating an item\'s sort properties updates the sorted array', function () {
    var tyrionInDisguise = obj.get('items')[1];

    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');

    _emberMetal.set(tyrionInDisguise, 'fname', 'Tyrion');

    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Jaime', 'Tyrion', 'Bran', 'Robb'], 'updating an item\'s sort properties updates the sorted array');
  });

  QUnit.test('updating several of an item\'s sort properties updated the sorted array', function () {
    var sansaInDisguise = obj.get('items')[1];

    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');

    _emberMetal.setProperties(sansaInDisguise, {
      fname: 'Sansa',
      lname: 'Stark'
    });

    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Jaime', 'Bran', 'Robb', 'Sansa'], 'updating an item\'s sort properties updates the sorted array');
  });

  QUnit.test('updating an item\'s sort properties does not error when binary search does a self compare (#3273)', function () {
    var jaime = {
      name: 'Jaime',
      status: 1
    };

    var cersei = {
      name: 'Cersei',
      status: 2
    };

    var obj = _emberRuntimeSystemObject.default.extend({
      sortProps: ['status'],
      sortedPeople: _emberRuntimeComputedReduce_computed_macros.sort('people', 'sortProps')
    }).create({
      people: [jaime, cersei]
    });

    deepEqual(obj.get('sortedPeople'), [jaime, cersei], 'precond - array is initially sorted');

    _emberMetal.set(cersei, 'status', 3);

    deepEqual(obj.get('sortedPeople'), [jaime, cersei], 'array is sorted correctly');

    _emberMetal.set(cersei, 'status', 2);

    deepEqual(obj.get('sortedPeople'), [jaime, cersei], 'array is sorted correctly');
  });

  QUnit.test('array observers do not leak', function () {
    var daria = { name: 'Daria' };
    var jane = { name: 'Jane' };

    var sisters = [jane, daria];

    var sortProps = _emberRuntimeSystemNative_array.A(['name']);
    var jaime = _emberRuntimeSystemObject.default.extend({
      sortedPeople: _emberRuntimeComputedReduce_computed_macros.sort('sisters', 'sortProps'),
      sortProps: sortProps
    }).create({
      sisters: sisters
    });

    jaime.get('sortedPeople');
    _emberMetal.run(jaime, 'destroy');

    try {
      sortProps.pushObject({
        name: 'Anna'
      });
      ok(true);
    } catch (e) {
      ok(false, e);
    }
  });

  QUnit.test('property paths in sort properties update the sorted array', function () {
    var jaime = {
      relatedObj: { status: 1, firstName: 'Jaime', lastName: 'Lannister' }
    };

    var cersei = {
      relatedObj: { status: 2, firstName: 'Cersei', lastName: 'Lannister' }
    };

    var sansa = _emberRuntimeSystemObject.default.create({
      relatedObj: { status: 3, firstName: 'Sansa', lastName: 'Stark' }
    });

    var obj = _emberRuntimeSystemObject.default.extend({
      sortProps: ['relatedObj.status'],
      sortedPeople: _emberRuntimeComputedReduce_computed_macros.sort('people', 'sortProps')
    }).create({
      people: [jaime, cersei, sansa]
    });

    deepEqual(obj.get('sortedPeople'), [jaime, cersei, sansa], 'precond - array is initially sorted');

    _emberMetal.set(cersei, 'status', 3);

    deepEqual(obj.get('sortedPeople'), [jaime, cersei, sansa], 'array is sorted correctly');

    _emberMetal.set(cersei, 'status', 1);

    deepEqual(obj.get('sortedPeople'), [jaime, cersei, sansa], 'array is sorted correctly');

    sansa.set('status', 1);

    deepEqual(obj.get('sortedPeople'), [jaime, cersei, sansa], 'array is sorted correctly');

    obj.set('sortProps', ['relatedObj.firstName']);

    deepEqual(obj.get('sortedPeople'), [cersei, jaime, sansa], 'array is sorted correctly');
  });

  QUnit.test('if the dependentKey is neither an array nor object, it will return an empty array', function () {
    _emberMetal.set(obj, 'items', null);
    ok(_emberRuntimeUtils.isArray(obj.get('sortedItems')), 'returns an empty arrays');

    _emberMetal.set(obj, 'array', undefined);
    ok(_emberRuntimeUtils.isArray(obj.get('sortedItems')), 'returns an empty arrays');

    _emberMetal.set(obj, 'array', 'not an array');
    ok(_emberRuntimeUtils.isArray(obj.get('sortedItems')), 'returns an empty arrays');
  });

  function sortByLnameFname(a, b) {
    var lna = _emberMetal.get(a, 'lname');
    var lnb = _emberMetal.get(b, 'lname');

    if (lna !== lnb) {
      return lna > lnb ? 1 : -1;
    }

    return sortByFnameAsc(a, b);
  }

  function sortByFnameAsc(a, b) {
    var fna = _emberMetal.get(a, 'fname');
    var fnb = _emberMetal.get(b, 'fname');

    if (fna === fnb) {
      return 0;
    }
    return fna > fnb ? 1 : -1;
  }

  QUnit.module('sort - sort function', {
    setup: function () {
      obj = _emberRuntimeSystemObject.default.extend({
        sortedItems: _emberRuntimeComputedReduce_computed_macros.sort('items.@each.fname', sortByLnameFname)
      }).create({
        items: _emberRuntimeSystemNative_array.A([{ fname: 'Jaime', lname: 'Lannister', age: 34 }, { fname: 'Cersei', lname: 'Lannister', age: 34 }, { fname: 'Robb', lname: 'Stark', age: 16 }, { fname: 'Bran', lname: 'Stark', age: 8 }])
      });
    },
    teardown: function () {
      _emberMetal.run(obj, 'destroy');
    }
  });

  QUnit.test('sort has correct `this`', function () {
    var obj = _emberRuntimeSystemObject.default.extend({
      sortedItems: _emberRuntimeComputedReduce_computed_macros.sort('items.@each.fname', function (a, b) {
        equal(this, obj, 'expected the object to be `this`');
        return this.sortByLastName(a, b);
      }),
      sortByLastName: function (a, b) {
        return sortByFnameAsc(a, b);
      }
    }).create({
      items: _emberRuntimeSystemNative_array.A([{ fname: 'Jaime', lname: 'Lannister', age: 34 }, { fname: 'Cersei', lname: 'Lannister', age: 34 }, { fname: 'Robb', lname: 'Stark', age: 16 }, { fname: 'Bran', lname: 'Stark', age: 8 }])
    });

    obj.get('sortedItems');
  });

  QUnit.test('sort (with function) is readOnly', function () {
    QUnit.throws(function () {
      obj.set('sortedItems', 1);
    }, /Cannot set read-only property "sortedItems" on object:/);
  });

  commonSortTests();

  QUnit.test('changing item properties specified via @each triggers a resort of the modified item', function () {
    var items = _emberMetal.get(obj, 'items');

    var tyrionInDisguise = items[1];

    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');

    _emberMetal.set(tyrionInDisguise, 'fname', 'Tyrion');

    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Jaime', 'Tyrion', 'Bran', 'Robb'], 'updating a specified property on an item resorts it');
  });

  QUnit.test('changing item properties not specified via @each does not trigger a resort', function () {
    var items = obj.get('items');
    var cersei = items[1];

    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'precond - array is initially sorted');

    _emberMetal.set(cersei, 'lname', 'Stark'); // plot twist! (possibly not canon)

    // The array has become unsorted.  If your sort function is sensitive to
    // properties, they *must* be specified as dependent item property keys or
    // we'll be doing binary searches on unsorted arrays.
    deepEqual(obj.get('sortedItems').mapBy('fname'), ['Cersei', 'Jaime', 'Bran', 'Robb'], 'updating an unspecified property on an item does not resort it');
  });

  QUnit.module('sort - stability', {
    setup: function () {
      obj = _emberRuntimeSystemObject.default.extend({
        sortProps: ['count', 'name'],
        sortedItems: _emberRuntimeComputedReduce_computed_macros.sort('items', 'sortProps')
      }).create({
        items: [{ name: 'A', count: 1, thing: 4 }, { name: 'B', count: 1, thing: 3 }, { name: 'C', count: 1, thing: 2 }, { name: 'D', count: 1, thing: 4 }]
      });
    },
    teardown: function () {
      _emberMetal.run(obj, 'destroy');
    }
  });

  QUnit.test('sorts correctly as only one property changes', function () {
    deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'initial');

    _emberMetal.set(obj.get('items')[3], 'count', 2);

    deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'final');
  });

  var klass = undefined;
  QUnit.module('sort - concurrency', {
    setup: function () {
      klass = _emberRuntimeSystemObject.default.extend({
        sortProps: ['count'],
        sortedItems: _emberRuntimeComputedReduce_computed_macros.sort('items', 'sortProps'),
        customSortedItems: _emberRuntimeComputedReduce_computed_macros.sort('items.@each.count', function (a, b) {
          return a.count - b.count;
        })
      });
      obj = klass.create({
        items: _emberRuntimeSystemNative_array.A([{ name: 'A', count: 1, thing: 4, id: 1 }, { name: 'B', count: 2, thing: 3, id: 2 }, { name: 'C', count: 3, thing: 2, id: 3 }, { name: 'D', count: 4, thing: 1, id: 4 }])
      });
    },

    teardown: function () {
      _emberMetal.run(obj, 'destroy');
    }
  });

  QUnit.test('sorts correctly after mutation to the sort properties', function () {
    var sorted = obj.get('sortedItems');
    deepEqual(sorted.mapBy('name'), ['A', 'B', 'C', 'D'], 'initial');

    _emberMetal.set(obj.get('items')[1], 'count', 5);
    _emberMetal.set(obj.get('items')[2], 'count', 6);

    deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'final');
  });

  QUnit.test('sort correctly after mutation to the sort', function () {
    deepEqual(obj.get('customSortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'initial');

    _emberMetal.set(obj.get('items')[1], 'count', 5);
    _emberMetal.set(obj.get('items')[2], 'count', 6);

    deepEqual(obj.get('customSortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'final');

    deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'final');
  });

  QUnit.test('sort correctly on multiple instances of the same class', function () {
    var obj2 = klass.create({
      items: _emberRuntimeSystemNative_array.A([{ name: 'W', count: 23, thing: 4 }, { name: 'X', count: 24, thing: 3 }, { name: 'Y', count: 25, thing: 2 }, { name: 'Z', count: 26, thing: 1 }])
    });

    deepEqual(obj2.get('sortedItems').mapBy('name'), ['W', 'X', 'Y', 'Z'], 'initial');
    deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'initial');

    _emberMetal.set(obj.get('items')[1], 'count', 5);
    _emberMetal.set(obj.get('items')[2], 'count', 6);
    _emberMetal.set(obj2.get('items')[1], 'count', 27);
    _emberMetal.set(obj2.get('items')[2], 'count', 28);

    deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'final');
    deepEqual(obj2.get('sortedItems').mapBy('name'), ['W', 'Z', 'X', 'Y'], 'final');

    obj.set('sortProps', ['thing']);

    deepEqual(obj.get('sortedItems').mapBy('name'), ['D', 'C', 'B', 'A'], 'final');

    obj2.notifyPropertyChange('sortedItems'); // invalidate to flush, to get DK refreshed
    obj2.get('sortedItems'); // flush to get updated DK

    obj2.set('items.firstObject.count', 9999);

    deepEqual(obj2.get('sortedItems').mapBy('name'), ['Z', 'X', 'Y', 'W'], 'final');
  });

  QUnit.test('sort correctly when multiple sorts are chained on the same instance of a class', function () {
    var obj2 = klass.extend({
      items: _emberMetal.computed('sibling.sortedItems.[]', function () {
        return this.get('sibling.sortedItems');
      }),
      asdf: _emberMetal.observer('sibling.sortedItems.[]', function () {
        this.get('sibling.sortedItems');
      })
    }).create({
      sibling: obj
    });

    /*
                                           ┌───────────┐                              ┌────────────┐
                                           │sortedProps│                              │sortedProps2│
                                           └───────────┘                              └────────────┘
                                                 ▲                                           ▲
                                                 │               ╔═══════════╗               │
                                                 │─ ─ ─ ─ ─ ─ ─ ▶║ CP (sort) ║◀─ ─ ─ ─ ─ ─ ─ ┤
                                                 │               ╚═══════════╝               │
                                                 │                                           │
    ┌───────────┐                            ┏━━━━━━━━━━━┓                              ┏━━━━━━━━━━━━┓
    │           │   ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─    ┃           ┃    ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─     ┃            ┃
    │   items   │◀──  items.@each.count  │◀──┃sortedItems┃◀───  items.@each.count  │◀───┃sortedItems2┃
    │           │   └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─    ┃           ┃    └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─     ┃            ┃
    └───────────┘                            ┗━━━━━━━━━━━┛                              ┗━━━━━━━━━━━━┛
     */

    deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'obj.sortedItems.name should be sorted alpha');
    deepEqual(obj2.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'obj2.sortedItems.name should be sorted alpha');

    _emberMetal.set(obj.get('items')[1], 'count', 5);
    _emberMetal.set(obj.get('items')[2], 'count', 6);

    deepEqual(obj.get('sortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'obj.sortedItems.name should now have changed');
    deepEqual(obj2.get('sortedItems').mapBy('name'), ['A', 'D', 'B', 'C'], 'obj2.sortedItems.name should still mirror sortedItems2');

    obj.set('sortProps', ['thing']);
    obj2.set('sortProps', ['id']);

    deepEqual(obj2.get('sortedItems').mapBy('name'), ['A', 'B', 'C', 'D'], 'we now sort obj2 by id, so we expect a b c d');
    deepEqual(obj.get('sortedItems').mapBy('name'), ['D', 'C', 'B', 'A'], 'we now sort obj by thing');
  });

  QUnit.module('max', {
    setup: function () {
      obj = _emberRuntimeSystemObject.default.extend({
        max: _emberRuntimeComputedReduce_computed_macros.max('items')
      }).create({
        items: _emberRuntimeSystemNative_array.A([1, 2, 3])
      });
    },
    teardown: function () {
      _emberMetal.run(obj, 'destroy');
    }
  });

  QUnit.test('max is readOnly', function () {
    QUnit.throws(function () {
      obj.set('max', 1);
    }, /Cannot set read-only property "max" on object:/);
  });

  QUnit.test('max tracks the max number as objects are added', function () {
    equal(obj.get('max'), 3, 'precond - max is initially correct');

    var items = obj.get('items');

    items.pushObject(5);

    equal(obj.get('max'), 5, 'max updates when a larger number is added');

    items.pushObject(2);

    equal(obj.get('max'), 5, 'max does not update when a smaller number is added');
  });

  QUnit.test('max recomputes when the current max is removed', function () {
    equal(obj.get('max'), 3, 'precond - max is initially correct');

    obj.get('items').removeObject(2);

    equal(obj.get('max'), 3, 'max is unchanged when a non-max item is removed');

    obj.get('items').removeObject(3);

    equal(obj.get('max'), 1, 'max is recomputed when the current max is removed');
  });

  QUnit.module('min', {
    setup: function () {
      obj = _emberRuntimeSystemObject.default.extend({
        min: _emberRuntimeComputedReduce_computed_macros.min('items')
      }).create({
        items: _emberRuntimeSystemNative_array.A([1, 2, 3])
      });
    },
    teardown: function () {
      _emberMetal.run(obj, 'destroy');
    }
  });

  QUnit.test('min is readOnly', function () {
    QUnit.throws(function () {
      obj.set('min', 1);
    }, /Cannot set read-only property "min" on object:/);
  });

  QUnit.test('min tracks the min number as objects are added', function () {
    equal(obj.get('min'), 1, 'precond - min is initially correct');

    obj.get('items').pushObject(-2);

    equal(obj.get('min'), -2, 'min updates when a smaller number is added');

    obj.get('items').pushObject(2);

    equal(obj.get('min'), -2, 'min does not update when a larger number is added');
  });

  QUnit.test('min recomputes when the current min is removed', function () {
    var items = obj.get('items');

    equal(obj.get('min'), 1, 'precond - min is initially correct');

    items.removeObject(2);

    equal(obj.get('min'), 1, 'min is unchanged when a non-min item is removed');

    items.removeObject(1);

    equal(obj.get('min'), 3, 'min is recomputed when the current min is removed');
  });

  QUnit.module('Ember.arrayComputed - mixed sugar', {
    setup: function () {
      obj = _emberRuntimeSystemObject.default.extend({
        lannisters: _emberRuntimeComputedReduce_computed_macros.filterBy('items', 'lname', 'Lannister'),
        lannisterSorting: _emberRuntimeSystemNative_array.A(['fname']),
        sortedLannisters: _emberRuntimeComputedReduce_computed_macros.sort('lannisters', 'lannisterSorting'),

        starks: _emberRuntimeComputedReduce_computed_macros.filterBy('items', 'lname', 'Stark'),
        starkAges: _emberRuntimeComputedReduce_computed_macros.mapBy('starks', 'age'),
        oldestStarkAge: _emberRuntimeComputedReduce_computed_macros.max('starkAges')
      }).create({
        items: _emberRuntimeSystemNative_array.A([{ fname: 'Jaime', lname: 'Lannister', age: 34 }, { fname: 'Cersei', lname: 'Lannister', age: 34 }, { fname: 'Robb', lname: 'Stark', age: 16 }, { fname: 'Bran', lname: 'Stark', age: 8 }])
      });
    },
    teardown: function () {
      _emberMetal.run(obj, 'destroy');
    }
  });

  QUnit.test('filtering and sorting can be combined', function () {
    var items = obj.get('items');

    deepEqual(obj.get('sortedLannisters').mapBy('fname'), ['Cersei', 'Jaime'], 'precond - array is initially filtered and sorted');

    items.pushObject({ fname: 'Tywin', lname: 'Lannister' });
    items.pushObject({ fname: 'Lyanna', lname: 'Stark' });
    items.pushObject({ fname: 'Gerion', lname: 'Lannister' });

    deepEqual(obj.get('sortedLannisters').mapBy('fname'), ['Cersei', 'Gerion', 'Jaime', 'Tywin'], 'updates propagate to array');
  });

  QUnit.test('filtering, sorting and reduce (max) can be combined', function () {
    var items = obj.get('items');

    equal(16, obj.get('oldestStarkAge'), 'precond - end of chain is initially correct');

    items.pushObject({ fname: 'Rickon', lname: 'Stark', age: 5 });

    equal(16, obj.get('oldestStarkAge'), 'chain is updated correctly');

    items.pushObject({ fname: 'Eddard', lname: 'Stark', age: 35 });

    equal(35, obj.get('oldestStarkAge'), 'chain is updated correctly');
  });

  function todo(name, priority) {
    return _emberRuntimeSystemObject.default.create({ name: name, priority: priority });
  }

  function priorityComparator(todoA, todoB) {
    var pa = parseInt(_emberMetal.get(todoA, 'priority'), 10);
    var pb = parseInt(_emberMetal.get(todoB, 'priority'), 10);

    return pa - pb;
  }

  function evenPriorities(todo) {
    var p = parseInt(_emberMetal.get(todo, 'priority'), 10);

    return p % 2 === 0;
  }

  QUnit.module('Ember.arrayComputed - chains', {
    setup: function () {
      obj = _emberRuntimeSystemObject.default.extend({
        sorted: _emberRuntimeComputedReduce_computed_macros.sort('todos.@each.priority', priorityComparator),
        filtered: _emberRuntimeComputedReduce_computed_macros.filter('sorted.@each.priority', evenPriorities)
      }).create({
        todos: _emberRuntimeSystemNative_array.A([todo('E', 4), todo('D', 3), todo('C', 2), todo('B', 1), todo('A', 0)])
      });
    },
    teardown: function () {
      _emberMetal.run(obj, 'destroy');
    }
  });

  QUnit.test('it can filter and sort when both depend on the same item property', function () {
    deepEqual(obj.get('todos').mapBy('name'), ['E', 'D', 'C', 'B', 'A'], 'precond - todos initially correct');
    deepEqual(obj.get('sorted').mapBy('name'), ['A', 'B', 'C', 'D', 'E'], 'precond - sorted initially correct');
    deepEqual(obj.get('filtered').mapBy('name'), ['A', 'C', 'E'], 'precond - filtered initially correct');

    _emberMetal.set(obj.get('todos')[1], 'priority', 6);

    deepEqual(obj.get('todos').mapBy('name'), ['E', 'D', 'C', 'B', 'A'], 'precond - todos remain correct');
    deepEqual(obj.get('sorted').mapBy('name'), ['A', 'B', 'C', 'E', 'D'], 'precond - sorted updated correctly');
    deepEqual(obj.get('filtered').mapBy('name'), ['A', 'C', 'E', 'D'], 'filtered updated correctly');
  });

  var userFnCalls = undefined;
  QUnit.module('Chaining array and reduced CPs', {
    setup: function () {
      userFnCalls = 0;
      obj = _emberRuntimeSystemObject.default.extend({
        mapped: _emberRuntimeComputedReduce_computed_macros.mapBy('array', 'v'),
        max: _emberRuntimeComputedReduce_computed_macros.max('mapped'),
        maxDidChange: _emberMetal.observer('max', function () {
          return userFnCalls++;
        })
      }).create({
        array: _emberRuntimeSystemNative_array.A([{ v: 1 }, { v: 3 }, { v: 2 }, { v: 1 }])
      });
    },
    teardown: function () {
      _emberMetal.run(obj, 'destroy');
    }
  });

  QUnit.test('it computes interdependent array computed properties', function () {
    equal(obj.get('max'), 3, 'sanity - it properly computes the maximum value');

    var calls = 0;

    _emberMetal.addObserver(obj, 'max', function () {
      return calls++;
    });

    obj.get('array').pushObject({ v: 5 });

    equal(obj.get('max'), 5, 'maximum value is updated correctly');
    equal(userFnCalls, 1, 'object defined observers fire');
    equal(calls, 1, 'runtime created observers fire');
  });

  QUnit.module('sum', {
    setup: function () {
      obj = _emberRuntimeSystemObject.default.extend({
        total: _emberRuntimeComputedReduce_computed_macros.sum('array')
      }).create({
        array: _emberRuntimeSystemNative_array.A([1, 2, 3])
      });
    },

    teardown: function () {
      _emberMetal.run(obj, 'destroy');
    }
  });

  QUnit.test('sum is readOnly', function () {
    QUnit.throws(function () {
      obj.set('total', 1);
    }, /Cannot set read-only property "total" on object:/);
  });
  QUnit.test('sums the values in the dependentKey', function () {
    equal(obj.get('total'), 6, 'sums the values');
  });

  QUnit.test('if the dependentKey is neither an array nor object, it will return `0`', function () {
    _emberMetal.set(obj, 'array', null);
    equal(_emberMetal.get(obj, 'total'), 0, 'returns 0');

    _emberMetal.set(obj, 'array', undefined);
    equal(_emberMetal.get(obj, 'total'), 0, 'returns 0');

    _emberMetal.set(obj, 'array', 'not an array');
    equal(_emberMetal.get(obj, 'total'), 0, 'returns 0');
  });

  QUnit.test('updates when array is modified', function () {
    obj.get('array').pushObject(1);

    equal(obj.get('total'), 7, 'recomputed when elements are added');

    obj.get('array').popObject();

    equal(obj.get('total'), 6, 'recomputes when elements are removed');
  });

  QUnit.module('collect');

  _internalTestHelpers.testBoth('works', function (get, set) {
    var obj = { one: 'foo', two: 'bar', three: null };
    _emberMetal.defineProperty(obj, 'all', _emberRuntimeComputedReduce_computed_macros.collect('one', 'two', 'three', 'four'));

    deepEqual(get(obj, 'all'), ['foo', 'bar', null, null], 'have all of them');

    set(obj, 'four', true);

    deepEqual(get(obj, 'all'), ['foo', 'bar', null, true], 'have all of them');

    var a = [];
    set(obj, 'one', 0);
    set(obj, 'three', a);

    deepEqual(get(obj, 'all'), [0, 'bar', a, true], 'have all of them');
  });
});
enifed('ember-runtime/tests/computed/reduce_computed_macros_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/computed/reduce_computed_macros_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/computed/reduce_computed_macros_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/controllers/controller_test', ['exports', 'ember-runtime/controllers/controller', 'ember-runtime/system/service', 'ember-metal', 'ember-runtime/system/object', 'ember-runtime/inject', 'internal-test-helpers'], function (exports, _emberRuntimeControllersController, _emberRuntimeSystemService, _emberMetal, _emberRuntimeSystemObject, _emberRuntimeInject, _internalTestHelpers) {
  /* global EmberDev */

  'use strict';

  QUnit.module('Controller event handling');

  QUnit.test('can access `actions` hash via `_actions` [DEPRECATED]', function () {
    expect(2);

    var controller = _emberRuntimeControllersController.default.extend({
      actions: {
        foo: function () {
          ok(true, 'called foo action');
        }
      }
    }).create();

    expectDeprecation(function () {
      controller._actions.foo();
    }, 'Usage of `_actions` is deprecated, use `actions` instead.');
  });

  QUnit.test('Action can be handled by a function on actions object', function () {
    expect(1);
    var TestController = _emberRuntimeControllersController.default.extend({
      actions: {
        poke: function () {
          ok(true, 'poked');
        }
      }
    });
    var controller = TestController.create();
    controller.send('poke');
  });

  QUnit.test('A handled action can be bubbled to the target for continued processing', function () {
    expect(2);
    var TestController = _emberRuntimeControllersController.default.extend({
      actions: {
        poke: function () {
          ok(true, 'poked 1');
          return true;
        }
      }
    });

    var controller = TestController.create({
      target: _emberRuntimeControllersController.default.extend({
        actions: {
          poke: function () {
            ok(true, 'poked 2');
          }
        }
      }).create()
    });
    controller.send('poke');
  });

  QUnit.test('Action can be handled by a superclass\' actions object', function () {
    expect(4);

    var SuperController = _emberRuntimeControllersController.default.extend({
      actions: {
        foo: function () {
          ok(true, 'foo');
        },
        bar: function (msg) {
          equal(msg, 'HELLO');
        }
      }
    });

    var BarControllerMixin = _emberMetal.Mixin.create({
      actions: {
        bar: function (msg) {
          equal(msg, 'HELLO');
          this._super(msg);
        }
      }
    });

    var IndexController = SuperController.extend(BarControllerMixin, {
      actions: {
        baz: function () {
          ok(true, 'baz');
        }
      }
    });

    var controller = IndexController.create({});
    controller.send('foo');
    controller.send('bar', 'HELLO');
    controller.send('baz');
  });

  QUnit.module('Controller deprecations');

  QUnit.module('Controller Content -> Model Alias');

  QUnit.test('`model` is aliased as `content`', function () {
    expect(1);
    var controller = _emberRuntimeControllersController.default.extend({
      model: 'foo-bar'
    }).create();

    equal(controller.get('content'), 'foo-bar', 'content is an alias of model');
  });

  QUnit.test('`content` is moved to `model` when `model` is unset', function () {
    expect(2);
    var controller = undefined;

    ignoreDeprecation(function () {
      controller = _emberRuntimeControllersController.default.extend({
        content: 'foo-bar'
      }).create();
    });

    equal(controller.get('model'), 'foo-bar', 'model is set properly');
    equal(controller.get('content'), 'foo-bar', 'content is set properly');
  });

  QUnit.test('specifying `content` (without `model` specified) results in deprecation', function () {
    expect(1);

    expectDeprecation(function () {
      _emberRuntimeControllersController.default.extend({
        content: 'foo-bar'
      }).create();
    }, 'Do not specify `content` on a Controller, use `model` instead.');
  });

  QUnit.test('specifying `content` (with `model` specified) does not result in deprecation', function () {
    expect(3);
    expectNoDeprecation();

    var controller = _emberRuntimeControllersController.default.extend({
      content: 'foo-bar',
      model: 'blammo'
    }).create();

    equal(_emberMetal.get(controller, 'content'), 'foo-bar');
    equal(_emberMetal.get(controller, 'model'), 'blammo');
  });

  QUnit.module('Controller injected properties');

  if (!EmberDev.runningProdBuild) {
    QUnit.test('defining a controller on a non-controller should fail assertion', function () {
      expectAssertion(function () {
        var owner = _internalTestHelpers.buildOwner();

        var AnObject = _emberRuntimeSystemObject.default.extend({
          foo: _emberRuntimeInject.default.controller('bar')
        });

        owner.register('foo:main', AnObject);

        if (true) {
          expectDeprecation(function () {
            owner._lookupFactory('foo:main');
          }, /Using "_lookupFactory" is deprecated. Please use container.factoryFor instead./);
        } else {
          owner._lookupFactory('foo:main');
        }
      }, /Defining an injected controller property on a non-controller is not allowed./);
    });
  }

  QUnit.test('controllers can be injected into controllers', function () {
    var owner = _internalTestHelpers.buildOwner();

    owner.register('controller:post', _emberRuntimeControllersController.default.extend({
      postsController: _emberRuntimeInject.default.controller('posts')
    }));

    owner.register('controller:posts', _emberRuntimeControllersController.default.extend());

    var postController = owner.lookup('controller:post');
    var postsController = owner.lookup('controller:posts');

    equal(postsController, postController.get('postsController'), 'controller.posts is injected');
  });

  QUnit.test('services can be injected into controllers', function () {
    var owner = _internalTestHelpers.buildOwner();

    owner.register('controller:application', _emberRuntimeControllersController.default.extend({
      authService: _emberRuntimeInject.default.service('auth')
    }));

    owner.register('service:auth', _emberRuntimeSystemService.default.extend());

    var appController = owner.lookup('controller:application');
    var authService = owner.lookup('service:auth');

    equal(authService, appController.get('authService'), 'service.auth is injected');
  });
});
enifed('ember-runtime/tests/controllers/controller_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/controllers/controller_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/controllers/controller_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/core/compare_test', ['exports', 'ember-runtime/utils', 'ember-runtime/system/object', 'ember-runtime/compare', 'ember-runtime/mixins/comparable'], function (exports, _emberRuntimeUtils, _emberRuntimeSystemObject, _emberRuntimeCompare, _emberRuntimeMixinsComparable) {
  'use strict';

  var data = [];
  var Comp = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsComparable.default);

  Comp.reopenClass({
    compare: function (obj) {
      return obj.get('val');
    }
  });

  QUnit.module('Ember.compare()', {
    setup: function () {
      data[0] = null;
      data[1] = false;
      data[2] = true;
      data[3] = -12;
      data[4] = 3.5;
      data[5] = 'a string';
      data[6] = 'another string';
      data[7] = 'last string';
      data[8] = [1, 2];
      data[9] = [1, 2, 3];
      data[10] = [1, 3];
      data[11] = { a: 'hash' };
      data[12] = _emberRuntimeSystemObject.default.create();
      data[13] = function (a) {
        return a;
      };
      data[14] = new Date('2012/01/01');
      data[15] = new Date('2012/06/06');
    }
  });

  QUnit.test('ordering should work', function () {
    var suspect = undefined,
        comparable = undefined,
        failureMessage = undefined,
        suspectIndex = undefined,
        comparableIndex = undefined;

    for (suspectIndex = 0; suspectIndex < data.length; suspectIndex++) {
      suspect = data[suspectIndex];

      equal(_emberRuntimeCompare.default(suspect, suspect), 0, suspectIndex + ' should equal itself');

      for (comparableIndex = suspectIndex + 1; comparableIndex < data.length; comparableIndex++) {
        comparable = data[comparableIndex];

        failureMessage = 'data[' + suspectIndex + '] (' + _emberRuntimeUtils.typeOf(suspect) + ') should be smaller than data[' + comparableIndex + '] (' + _emberRuntimeUtils.typeOf(comparable) + ')';

        equal(_emberRuntimeCompare.default(suspect, comparable), -1, failureMessage);
      }
    }
  });

  QUnit.test('comparables should return values in the range of -1, 0, 1', function () {
    var negOne = Comp.create({
      val: -1
    });

    var zero = Comp.create({
      val: 0
    });

    var one = Comp.create({
      val: 1
    });

    equal(_emberRuntimeCompare.default(negOne, 'a'), -1, 'First item comparable - returns -1 (not negated)');
    equal(_emberRuntimeCompare.default(zero, 'b'), 0, 'First item comparable - returns  0 (not negated)');
    equal(_emberRuntimeCompare.default(one, 'c'), 1, 'First item comparable - returns  1 (not negated)');

    equal(_emberRuntimeCompare.default('a', negOne), 1, 'Second item comparable - returns -1 (negated)');
    equal(_emberRuntimeCompare.default('b', zero), 0, 'Second item comparable - returns  0 (negated)');
    equal(_emberRuntimeCompare.default('c', one), -1, 'Second item comparable - returns  1 (negated)');
  });
});
enifed('ember-runtime/tests/core/compare_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/core/compare_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/core/compare_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/core/copy_test', ['exports', 'ember-runtime/copy'], function (exports, _emberRuntimeCopy) {
  'use strict';

  QUnit.module('Ember Copy Method');

  QUnit.test('Ember.copy null', function () {
    var obj = { field: null };

    equal(_emberRuntimeCopy.default(obj, true).field, null, 'null should still be null');
  });

  QUnit.test('Ember.copy date', function () {
    var date = new Date(2014, 7, 22);
    var dateCopy = _emberRuntimeCopy.default(date);

    equal(date.getTime(), dateCopy.getTime(), 'dates should be equivalent');
  });

  QUnit.test('Ember.copy null prototype object', function () {
    var obj = Object.create(null);

    obj.foo = 'bar';

    equal(_emberRuntimeCopy.default(obj).foo, 'bar', 'bar should still be bar');
  });

  QUnit.test('Ember.copy Array', function () {
    var array = [1, null, new Date(2015, 9, 9), 'four'];
    var arrayCopy = _emberRuntimeCopy.default(array);

    deepEqual(array, arrayCopy, 'array content cloned successfully in new array');
  });
});
enifed('ember-runtime/tests/core/copy_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/core/copy_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/core/copy_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/core/isEqual_test', ['exports', 'ember-runtime/is-equal'], function (exports, _emberRuntimeIsEqual) {
  'use strict';

  QUnit.module('isEqual');

  QUnit.test('undefined and null', function () {
    ok(_emberRuntimeIsEqual.default(undefined, undefined), 'undefined is equal to undefined');
    ok(!_emberRuntimeIsEqual.default(undefined, null), 'undefined is not equal to null');
    ok(_emberRuntimeIsEqual.default(null, null), 'null is equal to null');
    ok(!_emberRuntimeIsEqual.default(null, undefined), 'null is not equal to undefined');
  });

  QUnit.test('strings should be equal', function () {
    ok(!_emberRuntimeIsEqual.default('Hello', 'Hi'), 'different Strings are unequal');
    ok(_emberRuntimeIsEqual.default('Hello', 'Hello'), 'same Strings are equal');
  });

  QUnit.test('numericals should be equal', function () {
    ok(_emberRuntimeIsEqual.default(24, 24), 'same numbers are equal');
    ok(!_emberRuntimeIsEqual.default(24, 21), 'different numbers are inequal');
  });

  QUnit.test('dates should be equal', function () {
    ok(_emberRuntimeIsEqual.default(new Date(1985, 7, 22), new Date(1985, 7, 22)), 'same dates are equal');
    ok(!_emberRuntimeIsEqual.default(new Date(2014, 7, 22), new Date(1985, 7, 22)), 'different dates are not equal');
  });

  QUnit.test('array should be equal', function () {
    // NOTE: We don't test for array contents -- that would be too expensive.
    ok(!_emberRuntimeIsEqual.default([1, 2], [1, 2]), 'two array instances with the same values should not be equal');
    ok(!_emberRuntimeIsEqual.default([1, 2], [1]), 'two array instances with different values should not be equal');
  });

  QUnit.test('first object implements isEqual should use it', function () {
    ok(_emberRuntimeIsEqual.default({ isEqual: function () {
        return true;
      } }, null), 'should return true always');

    var obj = { isEqual: function () {
        return false;
      } };
    equal(_emberRuntimeIsEqual.default(obj, obj), false, 'should return false because isEqual returns false');
  });
});
enifed('ember-runtime/tests/core/isEqual_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/core/isEqual_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/core/isEqual_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/core/is_array_test', ['exports', 'ember-runtime/utils', 'ember-runtime/system/native_array', 'ember-runtime/system/array_proxy', 'ember-environment'], function (exports, _emberRuntimeUtils, _emberRuntimeSystemNative_array, _emberRuntimeSystemArray_proxy, _emberEnvironment) {
  'use strict';

  QUnit.module('Ember Type Checking');

  var global = undefined;

  QUnit.test('Ember.isArray', function () {
    var numarray = [1, 2, 3];
    var number = 23;
    var strarray = ['Hello', 'Hi'];
    var string = 'Hello';
    var object = {};
    var length = { length: 12 };
    var fn = function () {};
    var arrayProxy = _emberRuntimeSystemArray_proxy.default.create({ content: _emberRuntimeSystemNative_array.A() });

    equal(_emberRuntimeUtils.isArray(numarray), true, '[1,2,3]');
    equal(_emberRuntimeUtils.isArray(number), false, '23');
    equal(_emberRuntimeUtils.isArray(strarray), true, '["Hello", "Hi"]');
    equal(_emberRuntimeUtils.isArray(string), false, '"Hello"');
    equal(_emberRuntimeUtils.isArray(object), false, '{}');
    equal(_emberRuntimeUtils.isArray(length), true, '{ length: 12 }');
    equal(_emberRuntimeUtils.isArray(global), false, 'global');
    equal(_emberRuntimeUtils.isArray(fn), false, 'function() {}');
    equal(_emberRuntimeUtils.isArray(arrayProxy), true, '[]');
  });

  if (_emberEnvironment.environment.window && typeof _emberEnvironment.environment.window.FileList === 'function') {
    QUnit.test('Ember.isArray(fileList)', function () {
      var fileListElement = document.createElement('input');
      fileListElement.type = 'file';
      var fileList = fileListElement.files;
      equal(_emberRuntimeUtils.isArray(fileList), false, 'fileList');
    });
  }
});
enifed('ember-runtime/tests/core/is_array_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/core/is_array_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/core/is_array_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/core/is_empty_test', ['exports', 'ember-metal', 'ember-runtime/system/array_proxy', 'ember-runtime/system/native_array'], function (exports, _emberMetal, _emberRuntimeSystemArray_proxy, _emberRuntimeSystemNative_array) {
  'use strict';

  QUnit.module('Ember.isEmpty');

  QUnit.test('Ember.isEmpty', function () {
    var arrayProxy = _emberRuntimeSystemArray_proxy.default.create({ content: _emberRuntimeSystemNative_array.A() });

    equal(true, _emberMetal.isEmpty(arrayProxy), 'for an ArrayProxy that has empty content');
  });
});
enifed('ember-runtime/tests/core/is_empty_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/core/is_empty_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/core/is_empty_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/core/type_of_test', ['exports', 'ember-runtime/utils', 'ember-runtime/system/object', 'ember-environment'], function (exports, _emberRuntimeUtils, _emberRuntimeSystemObject, _emberEnvironment) {
  'use strict';

  QUnit.module('Ember Type Checking');

  QUnit.test('Ember.typeOf', function () {
    var MockedDate = function () {};
    MockedDate.prototype = new Date();

    var mockedDate = new MockedDate();
    var date = new Date();
    var error = new Error('boum');
    var object = { a: 'b' };
    var a = null;
    var arr = [1, 2, 3];
    var obj = {};
    var instance = _emberRuntimeSystemObject.default.create({ method: function () {} });

    equal(_emberRuntimeUtils.typeOf(), 'undefined', 'undefined');
    equal(_emberRuntimeUtils.typeOf(null), 'null', 'null');
    equal(_emberRuntimeUtils.typeOf('Cyril'), 'string', 'Cyril');
    equal(_emberRuntimeUtils.typeOf(101), 'number', '101');
    equal(_emberRuntimeUtils.typeOf(true), 'boolean', 'true');
    equal(_emberRuntimeUtils.typeOf([1, 2, 90]), 'array', '[1,2,90]');
    equal(_emberRuntimeUtils.typeOf(/abc/), 'regexp', '/abc/');
    equal(_emberRuntimeUtils.typeOf(date), 'date', 'new Date()');
    equal(_emberRuntimeUtils.typeOf(mockedDate), 'date', 'mocked date');
    equal(_emberRuntimeUtils.typeOf(error), 'error', 'error');
    equal(_emberRuntimeUtils.typeOf(object), 'object', 'object');
    equal(_emberRuntimeUtils.typeOf(undefined), 'undefined', 'item of type undefined');
    equal(_emberRuntimeUtils.typeOf(a), 'null', 'item of type null');
    equal(_emberRuntimeUtils.typeOf(arr), 'array', 'item of type array');
    equal(_emberRuntimeUtils.typeOf(obj), 'object', 'item of type object');
    equal(_emberRuntimeUtils.typeOf(instance), 'instance', 'item of type instance');
    equal(_emberRuntimeUtils.typeOf(instance.method), 'function', 'item of type function');
    equal(_emberRuntimeUtils.typeOf(_emberRuntimeSystemObject.default.extend()), 'class', 'item of type class');
    equal(_emberRuntimeUtils.typeOf(new Error()), 'error', 'item of type error');
  });

  if (_emberEnvironment.environment.window && typeof _emberEnvironment.environment.window.FileList === 'function') {
    QUnit.test('Ember.typeOf(fileList)', function () {
      var fileListElement = document.createElement('input');
      fileListElement.type = 'file';
      var fileList = fileListElement.files;
      equal(_emberRuntimeUtils.typeOf(fileList), 'filelist', 'item of type filelist');
    });
  }
});
enifed('ember-runtime/tests/core/type_of_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/core/type_of_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/core/type_of_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/ext/function_test', ['exports', 'ember-environment', 'ember-metal', 'internal-test-helpers', 'ember-runtime/system/object', 'ember-runtime/mixins/evented'], function (exports, _emberEnvironment, _emberMetal, _internalTestHelpers, _emberRuntimeSystemObject, _emberRuntimeMixinsEvented) {
  'use strict';

  QUnit.module('Function.prototype.observes() helper');

  _internalTestHelpers.testBoth('global observer helper takes multiple params', function (get, set) {
    if (!_emberEnvironment.ENV.EXTEND_PROTOTYPES.Function) {
      ok('undefined' === typeof Function.prototype.observes, 'Function.prototype helper disabled');
      return;
    }

    var MyMixin = _emberMetal.Mixin.create({

      count: 0,

      foo: (function () {
        set(this, 'count', get(this, 'count') + 1);
      }).observes('bar', 'baz')

    });

    var obj = _emberMetal.mixin({}, MyMixin);
    equal(get(obj, 'count'), 0, 'should not invoke observer immediately');

    set(obj, 'bar', 'BAZ');
    set(obj, 'baz', 'BAZ');
    equal(get(obj, 'count'), 2, 'should invoke observer after change');
  });

  QUnit.module('Function.prototype.on() helper');

  _internalTestHelpers.testBoth('sets up an event listener, and can trigger the function on multiple events', function (get, set) {
    if (!_emberEnvironment.ENV.EXTEND_PROTOTYPES.Function) {
      ok('undefined' === typeof Function.prototype.on, 'Function.prototype helper disabled');
      return;
    }

    var MyMixin = _emberMetal.Mixin.create({

      count: 0,

      foo: (function () {
        set(this, 'count', get(this, 'count') + 1);
      }).on('bar', 'baz')

    });

    var obj = _emberMetal.mixin({}, _emberRuntimeMixinsEvented.default, MyMixin);
    equal(get(obj, 'count'), 0, 'should not invoke listener immediately');

    obj.trigger('bar');
    obj.trigger('baz');
    equal(get(obj, 'count'), 2, 'should invoke listeners when events trigger');
  });

  _internalTestHelpers.testBoth('can be chained with observes', function (get, set) {
    if (!_emberEnvironment.ENV.EXTEND_PROTOTYPES.Function) {
      ok('Function.prototype helper disabled');
      return;
    }

    var MyMixin = _emberMetal.Mixin.create({

      count: 0,
      bay: 'bay',
      foo: (function () {
        set(this, 'count', get(this, 'count') + 1);
      }).observes('bay').on('bar')
    });

    var obj = _emberMetal.mixin({}, _emberRuntimeMixinsEvented.default, MyMixin);
    equal(get(obj, 'count'), 0, 'should not invoke listener immediately');

    set(obj, 'bay', 'BAY');
    obj.trigger('bar');
    equal(get(obj, 'count'), 2, 'should invoke observer and listener');
  });

  QUnit.module('Function.prototype.property() helper');

  _internalTestHelpers.testBoth('sets up a ComputedProperty', function (get, set) {
    if (!_emberEnvironment.ENV.EXTEND_PROTOTYPES.Function) {
      ok('undefined' === typeof Function.prototype.property, 'Function.prototype helper disabled');
      return;
    }

    var MyClass = _emberRuntimeSystemObject.default.extend({
      firstName: null,
      lastName: null,
      fullName: (function () {
        return get(this, 'firstName') + ' ' + get(this, 'lastName');
      }).property('firstName', 'lastName')
    });

    var obj = MyClass.create({ firstName: 'Fred', lastName: 'Flinstone' });
    equal(get(obj, 'fullName'), 'Fred Flinstone', 'should return the computed value');

    set(obj, 'firstName', 'Wilma');
    equal(get(obj, 'fullName'), 'Wilma Flinstone', 'should return the new computed value');

    set(obj, 'lastName', '');
    equal(get(obj, 'fullName'), 'Wilma ', 'should return the new computed value');
  });
});
enifed('ember-runtime/tests/ext/function_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/ext/function_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/ext/function_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/ext/mixin_test', ['exports', 'ember-metal'], function (exports, _emberMetal) {
  'use strict';

  QUnit.module('system/mixin/binding_test');

  QUnit.test('Defining a property ending in Binding should setup binding when applied', function () {
    var MyMixin = _emberMetal.Mixin.create({
      fooBinding: 'bar.baz'
    });

    var obj = { bar: { baz: 'BIFF' } };

    _emberMetal.run(function () {
      var deprecationMessage = /`Ember.Binding` is deprecated/;

      expectDeprecation(function () {
        MyMixin.apply(obj);
      }, deprecationMessage);
    });

    ok(_emberMetal.get(obj, 'fooBinding') instanceof _emberMetal.Binding, 'should be a binding object');
    equal(_emberMetal.get(obj, 'foo'), 'BIFF', 'binding should be created and synced');
  });

  QUnit.test('Defining a property ending in Binding should apply to prototype children', function () {
    var MyMixin = _emberMetal.run(function () {
      return _emberMetal.Mixin.create({
        fooBinding: 'bar.baz'
      });
    });

    var obj = { bar: { baz: 'BIFF' } };

    _emberMetal.run(function () {
      var deprecationMessage = /`Ember.Binding` is deprecated/;

      expectDeprecation(function () {
        MyMixin.apply(obj);
      }, deprecationMessage);
    });

    var obj2 = Object.create(obj);
    _emberMetal.run(function () {
      return _emberMetal.set(_emberMetal.get(obj2, 'bar'), 'baz', 'BARG');
    });

    ok(_emberMetal.get(obj2, 'fooBinding') instanceof _emberMetal.Binding, 'should be a binding object');
    equal(_emberMetal.get(obj2, 'foo'), 'BARG', 'binding should be created and synced');
  });
});
enifed('ember-runtime/tests/ext/mixin_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/ext/mixin_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/ext/mixin_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/ext/rsvp_test', ['exports', 'ember-metal', 'ember-runtime/ext/rsvp'], function (exports, _emberMetal, _emberRuntimeExtRsvp) {
  'use strict';

  var ORIGINAL_ONERROR = _emberMetal.getOnerror();

  QUnit.module('Ember.RSVP', {
    teardown: function () {
      _emberMetal.setOnerror(ORIGINAL_ONERROR);
    }
  });

  QUnit.test('Ensure that errors thrown from within a promise are sent to the console', function () {
    var error = new Error('Error thrown in a promise for testing purposes.');

    try {
      _emberMetal.run(function () {
        new _emberRuntimeExtRsvp.default.Promise(function (resolve, reject) {
          throw error;
        });
      });
      ok(false, 'expected assertion to be thrown');
    } catch (e) {
      equal(e, error, 'error was re-thrown');
    }
  });

  QUnit.test('TransitionAborted errors are not re-thrown', function () {
    expect(1);
    var fakeTransitionAbort = { name: 'TransitionAborted' };

    _emberMetal.run(_emberRuntimeExtRsvp.default, 'reject', fakeTransitionAbort);

    ok(true, 'did not throw an error when dealing with TransitionAborted');
  });

  QUnit.test('Can reject with non-Error object', function (assert) {
    var wasEmberTesting = _emberMetal.isTesting();
    _emberMetal.setTesting(false);
    expect(1);

    try {
      _emberMetal.run(_emberRuntimeExtRsvp.default, 'reject', 'foo');
    } catch (e) {
      ok(false, 'should not throw');
    } finally {
      _emberMetal.setTesting(wasEmberTesting);
    }

    ok(true);
  });

  QUnit.test('Can reject with no arguments', function (assert) {
    var wasEmberTesting = _emberMetal.isTesting();
    _emberMetal.setTesting(false);
    expect(1);

    try {
      _emberMetal.run(_emberRuntimeExtRsvp.default, 'reject');
    } catch (e) {
      ok(false, 'should not throw');
    } finally {
      _emberMetal.setTesting(wasEmberTesting);
    }

    ok(true);
  });

  QUnit.test('rejections like jqXHR which have errorThrown property work', function () {
    expect(2);

    var wasEmberTesting = _emberMetal.isTesting();
    var wasOnError = _emberMetal.getOnerror();

    try {
      (function () {
        _emberMetal.setTesting(false);
        _emberMetal.setOnerror(function (error) {
          equal(error, actualError, 'expected the real error on the jqXHR');
          equal(error.__reason_with_error_thrown__, jqXHR, 'also retains a helpful reference to the rejection reason');
        });

        var actualError = new Error('OMG what really happened');
        var jqXHR = {
          errorThrown: actualError
        };

        _emberMetal.run(_emberRuntimeExtRsvp.default, 'reject', jqXHR);
      })();
    } finally {
      _emberMetal.setOnerror(wasOnError);
      _emberMetal.setTesting(wasEmberTesting);
    }
  });

  QUnit.test('rejections where the errorThrown is a string should wrap the sting in an error object', function () {
    expect(2);

    var wasEmberTesting = _emberMetal.isTesting();
    var wasOnError = _emberMetal.getOnerror();

    try {
      (function () {
        _emberMetal.setTesting(false);
        _emberMetal.setOnerror(function (error) {
          equal(error.message, actualError, 'expected the real error on the jqXHR');
          equal(error.__reason_with_error_thrown__, jqXHR, 'also retains a helpful reference to the rejection reason');
        });

        var actualError = 'OMG what really happened';
        var jqXHR = {
          errorThrown: actualError
        };

        _emberMetal.run(_emberRuntimeExtRsvp.default, 'reject', jqXHR);
      })();
    } finally {
      _emberMetal.setOnerror(wasOnError);
      _emberMetal.setTesting(wasEmberTesting);
    }
  });

  QUnit.test('rejections can be serialized to JSON', function (assert) {
    expect(2);

    var wasEmberTesting = _emberMetal.isTesting();
    var wasOnError = _emberMetal.getOnerror();

    try {
      _emberMetal.setTesting(false);
      _emberMetal.setOnerror(function (error) {
        assert.equal(error.message, 'a fail');
        assert.ok(JSON.stringify(error), 'Error can be serialized');
      });

      var jqXHR = {
        errorThrown: new Error('a fail')
      };

      _emberMetal.run(_emberRuntimeExtRsvp.default, 'reject', jqXHR);
    } finally {
      _emberMetal.setOnerror(wasOnError);
      _emberMetal.setTesting(wasEmberTesting);
    }
  });

  var reason = 'i failed';
  QUnit.module('Ember.test: rejection assertions');

  function ajax(something) {
    return _emberRuntimeExtRsvp.default.Promise(function (resolve) {
      QUnit.stop();
      setTimeout(function () {
        QUnit.start();
        resolve();
      }, 0); // fake true / foreign async
    });
  }

  QUnit.test('unambigiously unhandled rejection', function () {
    QUnit.throws(function () {
      _emberMetal.run(function () {
        _emberRuntimeExtRsvp.default.Promise.reject(reason);
      }); // something is funky, we should likely assert
    }, reason);
  });

  QUnit.test('sync handled', function () {
    _emberMetal.run(function () {
      _emberRuntimeExtRsvp.default.Promise.reject(reason).catch(function () {});
    }); // handled, we shouldn't need to assert.
    ok(true, 'reached end of test');
  });

  QUnit.test('handled within the same micro-task (via Ember.RVP.Promise)', function () {
    _emberMetal.run(function () {
      var rejection = _emberRuntimeExtRsvp.default.Promise.reject(reason);
      _emberRuntimeExtRsvp.default.Promise.resolve(1).then(function () {
        return rejection.catch(function () {});
      });
    }); // handled, we shouldn't need to assert.
    ok(true, 'reached end of test');
  });

  QUnit.test('handled within the same micro-task (via direct run-loop)', function () {
    _emberMetal.run(function () {
      var rejection = _emberRuntimeExtRsvp.default.Promise.reject(reason);
      _emberMetal.run.schedule('afterRender', function () {
        return rejection.catch(function () {});
      });
    }); // handled, we shouldn't need to assert.
    ok(true, 'reached end of test');
  });

  QUnit.test('handled in the next microTask queue flush (run.next)', function () {
    expect(2);

    QUnit.throws(function () {
      _emberMetal.run(function () {
        var rejection = _emberRuntimeExtRsvp.default.Promise.reject(reason);

        QUnit.stop();
        _emberMetal.run.next(function () {
          QUnit.start();
          rejection.catch(function () {});
          ok(true, 'reached end of test');
        });
      });
    }, reason);

    // a promise rejection survived a full flush of the run-loop without being handled
    // this is very likely an issue.
  });

  QUnit.test('handled in the same microTask Queue flush do to data locality', function () {
    // an ambiguous scenario, this may or may not assert
    // it depends on the locality of `user#1`
    var store = {
      find: function () {
        return _emberRuntimeExtRsvp.default.Promise.resolve(1);
      }
    };
    _emberMetal.run(function () {
      var rejection = _emberRuntimeExtRsvp.default.Promise.reject(reason);
      store.find('user', 1).then(function () {
        return rejection.catch(function () {});
      });
    });

    ok(true, 'reached end of test');
  });

  QUnit.test('handled in a different microTask Queue flush do to data locality', function () {
    // an ambiguous scenario, this may or may not assert
    // it depends on the locality of `user#1`
    var store = {
      find: function () {
        return ajax();
      }
    };
    QUnit.throws(function () {
      _emberMetal.run(function () {
        var rejection = _emberRuntimeExtRsvp.default.Promise.reject(reason);
        store.find('user', 1).then(function () {
          rejection.catch(function () {});
          ok(true, 'reached end of test');
        });
      });
    }, reason);
  });

  QUnit.test('handled in the next microTask queue flush (ajax example)', function () {
    QUnit.throws(function () {
      _emberMetal.run(function () {
        var rejection = _emberRuntimeExtRsvp.default.Promise.reject(reason);
        ajax('/something/').then(function () {
          rejection.catch(function () {});
          ok(true, 'reached end of test');
        });
      });
    }, reason);
  });
});
enifed('ember-runtime/tests/ext/rsvp_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/ext/rsvp_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/ext/rsvp_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/inject_test', ['exports', 'ember-metal', 'ember-runtime/inject', 'ember-runtime/system/object', 'internal-test-helpers'], function (exports, _emberMetal, _emberRuntimeInject, _emberRuntimeSystemObject, _internalTestHelpers) {
  /* global EmberDev */

  'use strict';

  QUnit.module('inject');

  QUnit.test('calling `inject` directly should error', function () {
    expectAssertion(function () {
      _emberRuntimeInject.default('foo');
    }, /Injected properties must be created through helpers/);
  });

  if (!EmberDev.runningProdBuild) {
    // this check is done via an assertion which is stripped from
    // production builds
    QUnit.test('injection type validation is run when first looked up', function () {
      _emberRuntimeInject.createInjectionHelper('foo', function () {
        ok(true, 'should call validation method');
      });

      var owner = _internalTestHelpers.buildOwner();

      var AnObject = _emberRuntimeSystemObject.default.extend({
        bar: _emberRuntimeInject.default.foo(),
        baz: _emberRuntimeInject.default.foo()
      });

      owner.register('foo:main', AnObject);

      if (true) {
        expect(2);
        expectDeprecation(function () {
          owner._lookupFactory('foo:main');
        }, /Using "_lookupFactory" is deprecated. Please use container.factoryFor instead./);
      } else {
        expect(1);
        owner._lookupFactory('foo:main');
      }
    });

    QUnit.test('attempting to inject a nonexistent container key should error', function () {
      var owner = _internalTestHelpers.buildOwner();
      var AnObject = _emberRuntimeSystemObject.default.extend({
        foo: new _emberMetal.InjectedProperty('bar', 'baz')
      });

      owner.register('foo:main', AnObject);

      throws(function () {
        owner.lookup('foo:main');
      }, /Attempting to inject an unknown injection: 'bar:baz'/);
    });
  }

  QUnit.test('factories should return a list of lazy injection full names', function () {
    var AnObject = _emberRuntimeSystemObject.default.extend({
      foo: new _emberMetal.InjectedProperty('foo', 'bar'),
      bar: new _emberMetal.InjectedProperty('quux')
    });

    deepEqual(AnObject._lazyInjections(), { 'foo': 'foo:bar', 'bar': 'quux:bar' }, 'should return injected container keys');
  });
});
enifed('ember-runtime/tests/inject_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/inject_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/inject_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/legacy_1x/mixins/observable/chained_test', ['exports', 'ember-metal', 'ember-runtime/system/object', 'ember-runtime/system/native_array'], function (exports, _emberMetal, _emberRuntimeSystemObject, _emberRuntimeSystemNative_array) {
  'use strict';

  /*
    NOTE: This test is adapted from the 1.x series of unit tests.  The tests
    are the same except for places where we intend to break the API we instead
    validate that we warn the developer appropriately.
  
    CHANGES FROM 1.6:
  
    * changed obj.set() and obj.get() to Ember.set() and Ember.get()
    * changed obj.addObserver() to addObserver()
  */

  QUnit.module('Ember.Observable - Observing with @each');

  QUnit.test('chained observers on enumerable properties are triggered when the observed property of any item changes', function () {
    var family = _emberRuntimeSystemObject.default.create({ momma: null });
    var momma = _emberRuntimeSystemObject.default.create({ children: [] });

    var child1 = _emberRuntimeSystemObject.default.create({ name: 'Bartholomew' });
    var child2 = _emberRuntimeSystemObject.default.create({ name: 'Agnes' });
    var child3 = _emberRuntimeSystemObject.default.create({ name: 'Dan' });
    var child4 = _emberRuntimeSystemObject.default.create({ name: 'Nancy' });

    _emberMetal.set(family, 'momma', momma);
    _emberMetal.set(momma, 'children', _emberRuntimeSystemNative_array.A([child1, child2, child3]));

    var observerFiredCount = 0;
    _emberMetal.addObserver(family, 'momma.children.@each.name', this, function () {
      observerFiredCount++;
    });

    observerFiredCount = 0;
    _emberMetal.run(function () {
      return _emberMetal.get(momma, 'children').setEach('name', 'Juan');
    });
    equal(observerFiredCount, 3, 'observer fired after changing child names');

    observerFiredCount = 0;
    _emberMetal.run(function () {
      return _emberMetal.get(momma, 'children').pushObject(child4);
    });
    equal(observerFiredCount, 1, 'observer fired after adding a new item');

    observerFiredCount = 0;
    _emberMetal.run(function () {
      return _emberMetal.set(child4, 'name', 'Herbert');
    });
    equal(observerFiredCount, 1, 'observer fired after changing property on new object');

    _emberMetal.set(momma, 'children', []);

    observerFiredCount = 0;
    _emberMetal.run(function () {
      return _emberMetal.set(child1, 'name', 'Hanna');
    });
    equal(observerFiredCount, 0, 'observer did not fire after removing changing property on a removed object');
  });
});
enifed('ember-runtime/tests/legacy_1x/mixins/observable/chained_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/legacy_1x/mixins/observable/chained_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/legacy_1x/mixins/observable/chained_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/legacy_1x/mixins/observable/observable_test', ['exports', 'ember-environment', 'ember-metal', 'ember-runtime/system/string', 'ember-runtime/system/object', 'ember-runtime/mixins/observable', 'ember-runtime/system/native_array'], function (exports, _emberEnvironment, _emberMetal, _emberRuntimeSystemString, _emberRuntimeSystemObject, _emberRuntimeMixinsObservable, _emberRuntimeSystemNative_array) {
  'use strict';

  /*
    NOTE: This test is adapted from the 1.x series of unit tests.  The tests
    are the same except for places where we intend to break the API we instead
    validate that we warn the developer appropriately.
  
    CHANGES FROM 1.6:
  
    * Added ObservableObject which applies the Ember.Observable mixin.
    * Changed reference to Ember.T_FUNCTION to 'function'
    * Changed all references to sc_super to this._super(...arguments)
    * Changed Ember.objectForPropertyPath() to Ember.getPath()
    * Removed allPropertiesDidChange test - no longer supported
    * Changed test that uses 'ObjectE' as path to 'objectE' to reflect new
      rule on using capital letters for property paths.
    * Removed test passing context to addObserver.  context param is no longer
      supported.
    * Changed calls to Ember.Binding.flushPendingChanges() -> run.sync()
    * removed test in observer around line 862 that expected key/value to be
      the last item in the chained path.  Should be root and chained path
  
  */

  // ========================================================================
  // Ember.Observable Tests
  // ========================================================================

  var object, ObjectC, ObjectD, objectA, objectB, lookup;

  var ObservableObject = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsObservable.default);
  var originalLookup = _emberEnvironment.context.lookup;

  // ..........................................................
  // GET()
  //

  QUnit.module('object.get()', {

    setup: function () {
      object = ObservableObject.extend(_emberRuntimeMixinsObservable.default, {
        computed: _emberMetal.computed(function () {
          return 'value';
        }).volatile(),
        method: function () {
          return 'value';
        },
        unknownProperty: function (key, value) {
          this.lastUnknownProperty = key;
          return 'unknown';
        }
      }).create({
        normal: 'value',
        numberVal: 24,
        toggleVal: true,
        nullProperty: null
      });
    }

  });

  QUnit.test('should get normal properties', function () {
    equal(object.get('normal'), 'value');
  });

  QUnit.test('should call computed properties and return their result', function () {
    equal(object.get('computed'), 'value');
  });

  QUnit.test('should return the function for a non-computed property', function () {
    var value = object.get('method');
    equal(typeof value, 'function');
  });

  QUnit.test('should return null when property value is null', function () {
    equal(object.get('nullProperty'), null);
  });

  QUnit.test('should call unknownProperty when value is undefined', function () {
    equal(object.get('unknown'), 'unknown');
    equal(object.lastUnknownProperty, 'unknown');
  });

  // ..........................................................
  // Ember.GET()
  //
  QUnit.module('Ember.get()', {
    setup: function () {
      objectA = ObservableObject.extend({
        computed: _emberMetal.computed(function () {
          return 'value';
        }).volatile(),
        method: function () {
          return 'value';
        },
        unknownProperty: function (key, value) {
          this.lastUnknownProperty = key;
          return 'unknown';
        }
      }).create({
        normal: 'value',
        numberVal: 24,
        toggleVal: true,
        nullProperty: null
      });

      objectB = {
        normal: 'value',
        nullProperty: null
      };
    }
  });

  QUnit.test('should get normal properties on Ember.Observable', function () {
    equal(_emberMetal.get(objectA, 'normal'), 'value');
  });

  QUnit.test('should call computed properties on Ember.Observable and return their result', function () {
    equal(_emberMetal.get(objectA, 'computed'), 'value');
  });

  QUnit.test('should return the function for a non-computed property on Ember.Observable', function () {
    var value = _emberMetal.get(objectA, 'method');
    equal(typeof value, 'function');
  });

  QUnit.test('should return null when property value is null on Ember.Observable', function () {
    equal(_emberMetal.get(objectA, 'nullProperty'), null);
  });

  QUnit.test('should call unknownProperty when value is undefined on Ember.Observable', function () {
    equal(_emberMetal.get(objectA, 'unknown'), 'unknown');
    equal(objectA.lastUnknownProperty, 'unknown');
  });

  QUnit.test('should get normal properties on standard objects', function () {
    equal(_emberMetal.get(objectB, 'normal'), 'value');
  });

  QUnit.test('should return null when property is null on standard objects', function () {
    equal(_emberMetal.get(objectB, 'nullProperty'), null);
  });

  /*
  QUnit.test("raise if the provided object is null", function() {
    throws(function() {
      get(null, 'key');
    });
  });
  */

  QUnit.test('raise if the provided object is undefined', function () {
    expectAssertion(function () {
      _emberMetal.get(undefined, 'key');
    }, /Cannot call get with 'key' on an undefined object/i);
  });

  QUnit.module('Ember.get() with paths');

  QUnit.test('should return a property at a given path relative to the passed object', function () {
    var foo = ObservableObject.create({
      bar: ObservableObject.extend({
        baz: _emberMetal.computed(function () {
          return 'blargh';
        }).volatile()
      }).create()
    });

    equal(_emberMetal.get(foo, 'bar.baz'), 'blargh');
  });

  QUnit.test('should return a property at a given path relative to the passed object - JavaScript hash', function () {
    var foo = {
      bar: {
        baz: 'blargh'
      }
    };

    equal(_emberMetal.get(foo, 'bar.baz'), 'blargh');
  });

  // ..........................................................
  // SET()
  //

  QUnit.module('object.set()', {

    setup: function () {
      object = ObservableObject.extend({
        computed: _emberMetal.computed({
          get: function (key) {
            return this._computed;
          },
          set: function (key, value) {
            this._computed = value;
            return this._computed;
          }
        }).volatile(),

        method: function (key, value) {
          if (value !== undefined) {
            this._method = value;
          }
          return this._method;
        },

        unknownProperty: function (key) {
          return this._unknown;
        },

        setUnknownProperty: function (key, value) {
          this._unknown = value;
          return this._unknown;
        },

        // normal property
        normal: 'value',

        // computed property
        _computed: 'computed',
        // method, but not a property
        _method: 'method',
        // null property
        nullProperty: null,

        // unknown property
        _unknown: 'unknown'
      }).create();
    }

  });

  QUnit.test('should change normal properties and return the value', function () {
    var ret = object.set('normal', 'changed');
    equal(object.get('normal'), 'changed');
    equal(ret, 'changed');
  });

  QUnit.test('should call computed properties passing value and return the value', function () {
    var ret = object.set('computed', 'changed');
    equal(object.get('_computed'), 'changed');
    equal(ret, 'changed');
  });

  QUnit.test('should change normal properties when passing undefined', function () {
    var ret = object.set('normal', undefined);
    equal(object.get('normal'), undefined);
    equal(ret, undefined);
  });

  QUnit.test('should replace the function for a non-computed property and return the value', function () {
    var ret = object.set('method', 'changed');
    equal(object.get('_method'), 'method'); // make sure this was NOT run
    ok(typeof object.get('method') !== 'function');
    equal(ret, 'changed');
  });

  QUnit.test('should replace prover when property value is null', function () {
    var ret = object.set('nullProperty', 'changed');
    equal(object.get('nullProperty'), 'changed');
    equal(ret, 'changed');
  });

  QUnit.test('should call unknownProperty with value when property is undefined', function () {
    var ret = object.set('unknown', 'changed');
    equal(object.get('_unknown'), 'changed');
    equal(ret, 'changed');
  });

  // ..........................................................
  // COMPUTED PROPERTIES
  //

  QUnit.module('Computed properties', {
    setup: function () {
      lookup = _emberEnvironment.context.lookup = {};

      object = ObservableObject.extend({
        computed: _emberMetal.computed({
          get: function () {
            this.computedCalls.push('getter-called');
            return 'computed';
          },
          set: function (key, value) {
            this.computedCalls.push(value);
          }
        }).volatile(),

        computedCached: _emberMetal.computed({
          get: function () {
            this.computedCachedCalls.push('getter-called');
            return 'computedCached';
          },
          set: function (key, value) {
            this.computedCachedCalls.push(value);
          }
        }),

        dependent: _emberMetal.computed({
          get: function () {
            this.dependentCalls.push('getter-called');
            return 'dependent';
          },
          set: function (key, value) {
            this.dependentCalls.push(value);
          }
        }).property('changer').volatile(),
        dependentFront: _emberMetal.computed('changer', {
          get: function () {
            this.dependentFrontCalls.push('getter-called');
            return 'dependentFront';
          },
          set: function (key, value) {
            this.dependentFrontCalls.push(value);
          }
        }).volatile(),
        dependentCached: _emberMetal.computed({
          get: function () {
            this.dependentCachedCalls.push('getter-called!');
            return 'dependentCached';
          },
          set: function (key, value) {
            this.dependentCachedCalls.push(value);
          }
        }).property('changer'),

        inc: _emberMetal.computed('changer', function () {
          return this.incCallCount++;
        }),

        nestedInc: _emberMetal.computed(function (key) {
          _emberMetal.get(this, 'inc');
          return this.nestedIncCallCount++;
        }).property('inc'),

        isOn: _emberMetal.computed({
          get: function () {
            return this.get('state') === 'on';
          },
          set: function (key, value) {
            this.set('state', 'on');
            return this.get('state') === 'on';
          }
        }).property('state').volatile(),

        isOff: _emberMetal.computed({
          get: function () {
            return this.get('state') === 'off';
          },
          set: function (key, value) {
            this.set('state', 'off');
            return this.get('state') === 'off';
          }
        }).property('state').volatile()

      }).create({
        computedCalls: [],
        computedCachedCalls: [],
        changer: 'foo',
        dependentCalls: [],
        dependentFrontCalls: [],
        dependentCachedCalls: [],
        incCallCount: 0,
        nestedIncCallCount: 0,
        state: 'on'
      });
    },
    teardown: function () {
      _emberEnvironment.context.lookup = originalLookup;
    }
  });

  QUnit.test('getting values should call function return value', function () {
    // get each property twice. Verify return.
    var keys = _emberRuntimeSystemString.w('computed computedCached dependent dependentFront dependentCached');

    keys.forEach(function (key) {
      equal(object.get(key), key, 'Try #1: object.get(' + key + ') should run function');
      equal(object.get(key), key, 'Try #2: object.get(' + key + ') should run function');
    });

    // verify each call count.  cached should only be called once
    _emberRuntimeSystemString.w('computedCalls dependentFrontCalls dependentCalls').forEach(function (key) {
      equal(object[key].length, 2, 'non-cached property ' + key + ' should be called 2x');
    });

    _emberRuntimeSystemString.w('computedCachedCalls dependentCachedCalls').forEach(function (key) {
      equal(object[key].length, 1, 'non-cached property ' + key + ' should be called 1x');
    });
  });

  QUnit.test('setting values should call function return value', function () {
    // get each property twice. Verify return.
    var keys = _emberRuntimeSystemString.w('computed dependent dependentFront computedCached dependentCached');
    var values = _emberRuntimeSystemString.w('value1 value2');

    keys.forEach(function (key) {
      equal(object.set(key, values[0]), values[0], 'Try #1: object.set(' + key + ', ' + values[0] + ') should run function');

      equal(object.set(key, values[1]), values[1], 'Try #2: object.set(' + key + ', ' + values[1] + ') should run function');

      equal(object.set(key, values[1]), values[1], 'Try #3: object.set(' + key + ', ' + values[1] + ') should not run function since it is setting same value as before');
    });

    // verify each call count.  cached should only be called once
    keys.forEach(function (key) {
      var calls = object[key + 'Calls'];
      var idx, expectedLength;

      // Cached properties first check their cached value before setting the
      // property. Other properties blindly call set.
      expectedLength = 3;
      equal(calls.length, expectedLength, 'set(' + key + ') should be called the right amount of times');
      for (idx = 0; idx < 2; idx++) {
        equal(calls[idx], values[idx], 'call #' + (idx + 1) + ' to set(' + key + ') should have passed value ' + values[idx]);
      }
    });
  });

  QUnit.test('notify change should clear cache', function () {
    // call get several times to collect call count
    object.get('computedCached'); // should run func
    object.get('computedCached'); // should not run func

    object.propertyWillChange('computedCached').propertyDidChange('computedCached');

    object.get('computedCached'); // should run again
    equal(object.computedCachedCalls.length, 2, 'should have invoked method 2x');
  });

  QUnit.test('change dependent should clear cache', function () {
    // call get several times to collect call count
    var ret1 = object.get('inc'); // should run func
    equal(object.get('inc'), ret1, 'multiple calls should not run cached prop');

    object.set('changer', 'bar');

    equal(object.get('inc'), ret1 + 1, 'should increment after dependent key changes'); // should run again
  });

  QUnit.test('just notifying change of dependent should clear cache', function () {
    // call get several times to collect call count
    var ret1 = object.get('inc'); // should run func
    equal(object.get('inc'), ret1, 'multiple calls should not run cached prop');

    object.notifyPropertyChange('changer');

    equal(object.get('inc'), ret1 + 1, 'should increment after dependent key changes'); // should run again
  });

  QUnit.test('changing dependent should clear nested cache', function () {
    // call get several times to collect call count
    var ret1 = object.get('nestedInc'); // should run func
    equal(object.get('nestedInc'), ret1, 'multiple calls should not run cached prop');

    object.set('changer', 'bar');

    equal(object.get('nestedInc'), ret1 + 1, 'should increment after dependent key changes'); // should run again
  });

  QUnit.test('just notifying change of dependent should clear nested cache', function () {
    // call get several times to collect call count
    var ret1 = object.get('nestedInc'); // should run func
    equal(object.get('nestedInc'), ret1, 'multiple calls should not run cached prop');

    object.notifyPropertyChange('changer');

    equal(object.get('nestedInc'), ret1 + 1, 'should increment after dependent key changes'); // should run again
  });

  // This verifies a specific bug encountered where observers for computed
  // properties would fire before their prop caches were cleared.
  QUnit.test('change dependent should clear cache when observers of dependent are called', function () {
    // call get several times to collect call count
    var ret1 = object.get('inc'); // should run func
    equal(object.get('inc'), ret1, 'multiple calls should not run cached prop');

    // add observer to verify change...
    object.addObserver('inc', this, function () {
      equal(object.get('inc'), ret1 + 1, 'should increment after dependent key changes'); // should run again
    });

    // now run
    object.set('changer', 'bar');
  });

  QUnit.test('setting one of two computed properties that depend on a third property should clear the kvo cache', function () {
    // we have to call set twice to fill up the cache
    object.set('isOff', true);
    object.set('isOn', true);

    // setting isOff to true should clear the kvo cache
    object.set('isOff', true);
    equal(object.get('isOff'), true, 'object.isOff should be true');
    equal(object.get('isOn'), false, 'object.isOn should be false');
  });

  QUnit.test('dependent keys should be able to be specified as property paths', function () {
    var depObj = ObservableObject.extend({
      menuPrice: _emberMetal.computed(function () {
        return this.get('menu.price');
      }).property('menu.price')
    }).create({
      menu: ObservableObject.create({
        price: 5
      })
    });

    equal(depObj.get('menuPrice'), 5, 'precond - initial value returns 5');

    depObj.set('menu.price', 6);

    equal(depObj.get('menuPrice'), 6, 'cache is properly invalidated after nested property changes');
  });

  QUnit.test('nested dependent keys should propagate after they update', function () {
    var bindObj;
    _emberMetal.run(function () {
      lookup.DepObj = ObservableObject.extend({
        price: _emberMetal.computed(function () {
          return this.get('restaurant.menu.price');
        }).property('restaurant.menu.price')
      }).create({
        restaurant: ObservableObject.create({
          menu: ObservableObject.create({
            price: 5
          })
        })
      });

      expectDeprecation(function () {
        bindObj = ObservableObject.extend({
          priceBinding: 'DepObj.price'
        }).create();
      }, /`Ember.Binding` is deprecated/);
    });

    equal(bindObj.get('price'), 5, 'precond - binding propagates');

    _emberMetal.run(function () {
      lookup.DepObj.set('restaurant.menu.price', 10);
    });

    equal(bindObj.get('price'), 10, 'binding propagates after a nested dependent keys updates');

    _emberMetal.run(function () {
      lookup.DepObj.set('restaurant.menu', ObservableObject.create({
        price: 15
      }));
    });

    equal(bindObj.get('price'), 15, 'binding propagates after a middle dependent keys updates');
  });

  QUnit.test('cacheable nested dependent keys should clear after their dependencies update', function () {
    ok(true);

    var DepObj;

    _emberMetal.run(function () {
      lookup.DepObj = DepObj = ObservableObject.extend({
        price: _emberMetal.computed('restaurant.menu.price', function () {
          return this.get('restaurant.menu.price');
        })
      }).create({
        restaurant: ObservableObject.create({
          menu: ObservableObject.create({
            price: 5
          })
        })
      });
    });

    equal(DepObj.get('price'), 5, 'precond - computed property is correct');

    _emberMetal.run(function () {
      DepObj.set('restaurant.menu.price', 10);
    });
    equal(DepObj.get('price'), 10, 'cacheable computed properties are invalidated even if no run loop occurred');

    _emberMetal.run(function () {
      DepObj.set('restaurant.menu.price', 20);
    });
    equal(DepObj.get('price'), 20, 'cacheable computed properties are invalidated after a second get before a run loop');
    equal(DepObj.get('price'), 20, 'precond - computed properties remain correct after a run loop');

    _emberMetal.run(function () {
      DepObj.set('restaurant.menu', ObservableObject.create({
        price: 15
      }));
    });

    equal(DepObj.get('price'), 15, 'cacheable computed properties are invalidated after a middle property changes');

    _emberMetal.run(function () {
      DepObj.set('restaurant.menu', ObservableObject.create({
        price: 25
      }));
    });

    equal(DepObj.get('price'), 25, 'cacheable computed properties are invalidated after a middle property changes again, before a run loop');
  });

  // ..........................................................
  // OBSERVABLE OBJECTS
  //

  QUnit.module('Observable objects & object properties ', {
    setup: function () {
      object = ObservableObject.extend({
        getEach: function () {
          var keys = ['normal', 'abnormal'];
          var ret = [];
          for (var idx = 0; idx < keys.length; idx++) {
            ret[ret.length] = this.get(keys[idx]);
          }
          return ret;
        },

        newObserver: function () {
          this.abnormal = 'changedValueObserved';
        },

        testObserver: _emberMetal.observer('normal', function () {
          this.abnormal = 'removedObserver';
        }),

        testArrayObserver: _emberMetal.observer('normalArray.[]', function () {
          this.abnormal = 'notifiedObserver';
        })
      }).create({
        normal: 'value',
        abnormal: 'zeroValue',
        numberVal: 24,
        toggleVal: true,
        observedProperty: 'beingWatched',
        testRemove: 'observerToBeRemoved',
        normalArray: _emberRuntimeSystemNative_array.A([1, 2, 3, 4, 5])
      });
    }
  });

  QUnit.test('incrementProperty and decrementProperty', function () {
    var newValue = object.incrementProperty('numberVal');

    equal(25, newValue, 'numerical value incremented');
    object.numberVal = 24;
    newValue = object.decrementProperty('numberVal');
    equal(23, newValue, 'numerical value decremented');
    object.numberVal = 25;
    newValue = object.incrementProperty('numberVal', 5);
    equal(30, newValue, 'numerical value incremented by specified increment');
    object.numberVal = 25;
    newValue = object.incrementProperty('numberVal', -5);
    equal(20, newValue, 'minus numerical value incremented by specified increment');
    object.numberVal = 25;
    newValue = object.incrementProperty('numberVal', 0);
    equal(25, newValue, 'zero numerical value incremented by specified increment');

    expectAssertion(function () {
      newValue = object.incrementProperty('numberVal', 0 - void 0); // Increment by NaN
    }, /Must pass a numeric value to incrementProperty/i);

    expectAssertion(function () {
      newValue = object.incrementProperty('numberVal', 'Ember'); // Increment by non-numeric String
    }, /Must pass a numeric value to incrementProperty/i);

    expectAssertion(function () {
      newValue = object.incrementProperty('numberVal', 1 / 0); // Increment by Infinity
    }, /Must pass a numeric value to incrementProperty/i);

    equal(25, newValue, 'Attempting to increment by non-numeric values should not increment value');

    object.numberVal = 25;
    newValue = object.decrementProperty('numberVal', 5);
    equal(20, newValue, 'numerical value decremented by specified increment');
    object.numberVal = 25;
    newValue = object.decrementProperty('numberVal', -5);
    equal(30, newValue, 'minus numerical value decremented by specified increment');
    object.numberVal = 25;
    newValue = object.decrementProperty('numberVal', 0);
    equal(25, newValue, 'zero numerical value decremented by specified increment');

    expectAssertion(function () {
      newValue = object.decrementProperty('numberVal', 0 - void 0); // Decrement by NaN
    }, /Must pass a numeric value to decrementProperty/i);

    expectAssertion(function () {
      newValue = object.decrementProperty('numberVal', 'Ember'); // Decrement by non-numeric String
    }, /Must pass a numeric value to decrementProperty/i);

    expectAssertion(function () {
      newValue = object.decrementProperty('numberVal', 1 / 0); // Decrement by Infinity
    }, /Must pass a numeric value to decrementProperty/i);

    equal(25, newValue, 'Attempting to decrement by non-numeric values should not decrement value');
  });

  QUnit.test('toggle function, should be boolean', function () {
    equal(object.toggleProperty('toggleVal', true, false), object.get('toggleVal'));
    equal(object.toggleProperty('toggleVal', true, false), object.get('toggleVal'));
    equal(object.toggleProperty('toggleVal', undefined, undefined), object.get('toggleVal'));
  });

  QUnit.test('should notify array observer when array changes', function () {
    _emberMetal.get(object, 'normalArray').replace(0, 0, 6);
    equal(object.abnormal, 'notifiedObserver', 'observer should be notified');
  });

  QUnit.module('object.addObserver()', {
    setup: function () {
      ObjectC = ObservableObject.create({
        objectE: ObservableObject.create({
          propertyVal: 'chainedProperty'
        }),

        normal: 'value',
        normal1: 'zeroValue',
        normal2: 'dependentValue',
        incrementor: 10,

        action: function () {
          this.normal1 = 'newZeroValue';
        },

        observeOnceAction: function () {
          this.incrementor = this.incrementor + 1;
        },

        chainedObserver: function () {
          this.normal2 = 'chainedPropertyObserved';
        }
      });
    }
  });

  QUnit.test('should register an observer for a property', function () {
    ObjectC.addObserver('normal', ObjectC, 'action');
    ObjectC.set('normal', 'newValue');
    equal(ObjectC.normal1, 'newZeroValue');
  });

  QUnit.test('should register an observer for a property - Special case of chained property', function () {
    ObjectC.addObserver('objectE.propertyVal', ObjectC, 'chainedObserver');
    ObjectC.objectE.set('propertyVal', 'chainedPropertyValue');
    equal('chainedPropertyObserved', ObjectC.normal2);
    ObjectC.normal2 = 'dependentValue';
    ObjectC.set('objectE', '');
    equal('chainedPropertyObserved', ObjectC.normal2);
  });

  QUnit.module('object.removeObserver()', {
    setup: function () {
      ObjectD = ObservableObject.create({
        objectF: ObservableObject.create({
          propertyVal: 'chainedProperty'
        }),

        normal: 'value',
        normal1: 'zeroValue',
        normal2: 'dependentValue',
        ArrayKeys: ['normal', 'normal1'],

        addAction: function () {
          this.normal1 = 'newZeroValue';
        },
        removeAction: function () {
          this.normal2 = 'newDependentValue';
        },
        removeChainedObserver: function () {
          this.normal2 = 'chainedPropertyObserved';
        },

        observableValue: 'hello world',

        observer1: function () {
          // Just an observer
        },
        observer2: function () {
          this.removeObserver('observableValue', null, 'observer1');
          this.removeObserver('observableValue', null, 'observer2');
          this.hasObserverFor('observableValue'); // Tickle 'getMembers()'
          this.removeObserver('observableValue', null, 'observer3');
        },
        observer3: function () {
          // Just an observer
        }
      });
    }
  });

  QUnit.test('should unregister an observer for a property', function () {
    ObjectD.addObserver('normal', ObjectD, 'addAction');
    ObjectD.set('normal', 'newValue');
    equal(ObjectD.normal1, 'newZeroValue');

    ObjectD.set('normal1', 'zeroValue');

    ObjectD.removeObserver('normal', ObjectD, 'addAction');
    ObjectD.set('normal', 'newValue');
    equal(ObjectD.normal1, 'zeroValue');
  });

  QUnit.test('should unregister an observer for a property - special case when key has a \'.\' in it.', function () {
    ObjectD.addObserver('objectF.propertyVal', ObjectD, 'removeChainedObserver');
    ObjectD.objectF.set('propertyVal', 'chainedPropertyValue');
    ObjectD.removeObserver('objectF.propertyVal', ObjectD, 'removeChainedObserver');
    ObjectD.normal2 = 'dependentValue';
    ObjectD.objectF.set('propertyVal', 'removedPropertyValue');
    equal('dependentValue', ObjectD.normal2);
    ObjectD.set('objectF', '');
    equal('dependentValue', ObjectD.normal2);
  });

  QUnit.test('removing an observer inside of an observer shouldn’t cause any problems', function () {
    // The observable system should be protected against clients removing
    // observers in the middle of observer notification.
    var encounteredError = false;
    try {
      ObjectD.addObserver('observableValue', null, 'observer1');
      ObjectD.addObserver('observableValue', null, 'observer2');
      ObjectD.addObserver('observableValue', null, 'observer3');
      _emberMetal.run(function () {
        ObjectD.set('observableValue', 'hi world');
      });
    } catch (e) {
      encounteredError = true;
    }
    equal(encounteredError, false);
  });

  QUnit.module('Bind function', {
    setup: function () {
      objectA = ObservableObject.create({
        name: 'Sproutcore',
        location: 'Timbaktu'
      });

      objectB = ObservableObject.create({
        normal: 'value',
        computed: function () {
          this.normal = 'newValue';
        }
      });

      lookup = _emberEnvironment.context.lookup = {
        'Namespace': {
          objectA: objectA,
          objectB: objectB
        }
      };
    },

    teardown: function () {
      _emberEnvironment.context.lookup = originalLookup;
    }
  });

  QUnit.test('should bind property with method parameter as undefined', function () {
    // creating binding
    _emberMetal.run(function () {
      expectDeprecation(function () {
        objectA.bind('name', 'Namespace.objectB.normal', undefined);
      }, /`Ember.Binding` is deprecated/);
    });

    // now make a change to see if the binding triggers.
    _emberMetal.run(function () {
      objectB.set('normal', 'changedValue');
    });

    // support new-style bindings if available
    equal('changedValue', objectA.get('name'), 'objectA.name is bound');
  });

  // ..........................................................
  // SPECIAL CASES
  //

  QUnit.test('changing chained observer object to null should not raise exception', function () {
    var obj = ObservableObject.create({
      foo: ObservableObject.create({
        bar: ObservableObject.create({ bat: 'BAT' })
      })
    });

    var callCount = 0;
    obj.foo.addObserver('bar.bat', obj, function (target, key, value) {
      callCount++;
    });

    _emberMetal.run(function () {
      obj.foo.set('bar', null);
    });

    equal(callCount, 1, 'changing bar should trigger observer');
    expect(1);
  });
});
enifed('ember-runtime/tests/legacy_1x/mixins/observable/observable_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/legacy_1x/mixins/observable/observable_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/legacy_1x/mixins/observable/observable_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/legacy_1x/mixins/observable/observersForKey_test', ['exports', 'ember-metal', 'ember-runtime/system/object', 'ember-runtime/mixins/observable'], function (exports, _emberMetal, _emberRuntimeSystemObject, _emberRuntimeMixinsObservable) {
  /*
    NOTE: This test is adapted from the 1.x series of unit tests.  The tests
    are the same except for places where we intend to break the API we instead
    validate that we warn the developer appropriately.
  
    CHANGES FROM 1.6:
  
    * Create ObservableObject which includes Ember.Observable
  */

  // ========================================================================
  // Ember.Observable Tests
  // ========================================================================

  'use strict';

  var ObservableObject = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsObservable.default);

  // ..........................................................
  // GET()
  //

  QUnit.module('object.observesForKey()');

  QUnit.test('should get observers', function () {
    var o1 = ObservableObject.create({ foo: 100 });
    var o2 = ObservableObject.create({ func: function () {} });
    var o3 = ObservableObject.create({ func: function () {} });
    var observers = null;

    equal(_emberMetal.get(o1.observersForKey('foo'), 'length'), 0, 'o1.observersForKey should return empty array');

    o1.addObserver('foo', o2, o2.func);
    o1.addObserver('foo', o3, o3.func);

    observers = o1.observersForKey('foo');

    equal(_emberMetal.get(observers, 'length'), 2, 'o2.observersForKey should return an array with length 2');
    equal(observers[0][0], o2, 'first item in observers array should be o2');
    equal(observers[1][0], o3, 'second item in observers array should be o3');
  });
});
enifed('ember-runtime/tests/legacy_1x/mixins/observable/observersForKey_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/legacy_1x/mixins/observable/observersForKey_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/legacy_1x/mixins/observable/observersForKey_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/legacy_1x/mixins/observable/propertyChanges_test', ['exports', 'ember-runtime/system/object', 'ember-runtime/mixins/observable', 'ember-metal'], function (exports, _emberRuntimeSystemObject, _emberRuntimeMixinsObservable, _emberMetal) {
  /*
    NOTE: This test is adapted from the 1.x series of unit tests.  The tests
    are the same except for places where we intend to break the API we instead
    validate that we warn the developer appropriately.
  
    CHANGES FROM 1.6:
  
    * Create ObservableObject which includes Ember.Observable
    * Remove test that tests internal _kvo_changeLevel property.  This is an
      implementation detail.
    * Remove test for allPropertiesDidChange
    * Removed star observer test.  no longer supported
    * Removed property revision test.  no longer supported
  */

  // ========================================================================
  // Ember.Observable Tests
  // ========================================================================

  'use strict';

  var ObservableObject = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsObservable.default);

  var ObjectA = undefined;

  QUnit.module('object.propertyChanges', {
    setup: function () {
      ObjectA = ObservableObject.extend({
        action: _emberMetal.observer('foo', function () {
          this.set('prop', 'changedPropValue');
        }),
        notifyAction: _emberMetal.observer('newFoo', function () {
          this.set('newProp', 'changedNewPropValue');
        }),

        notifyAllAction: _emberMetal.observer('prop', function () {
          this.set('newFoo', 'changedNewFooValue');
        }),

        starObserver: function (target, key, value, rev) {
          this.starProp = key;
        }
      }).create({
        starProp: null,

        foo: 'fooValue',
        prop: 'propValue',

        newFoo: 'newFooValue',
        newProp: 'newPropValue'
      });
    }
  });

  QUnit.test('should observe the changes within the nested begin / end property changes', function () {
    //start the outer nest
    ObjectA.beginPropertyChanges();

    // Inner nest
    ObjectA.beginPropertyChanges();
    ObjectA.set('foo', 'changeFooValue');

    equal(ObjectA.prop, 'propValue');
    ObjectA.endPropertyChanges();

    //end inner nest
    ObjectA.set('prop', 'changePropValue');
    equal(ObjectA.newFoo, 'newFooValue');

    //close the outer nest
    ObjectA.endPropertyChanges();

    equal(ObjectA.prop, 'changedPropValue');
    equal(ObjectA.newFoo, 'changedNewFooValue');
  });

  QUnit.test('should observe the changes within the begin and end property changes', function () {
    ObjectA.beginPropertyChanges();
    ObjectA.set('foo', 'changeFooValue');

    equal(ObjectA.prop, 'propValue');
    ObjectA.endPropertyChanges();

    equal(ObjectA.prop, 'changedPropValue');
  });

  QUnit.test('should indicate that the property of an object has just changed', function () {
    // indicate that property of foo will change to its subscribers
    ObjectA.propertyWillChange('foo');

    //Value of the prop is unchanged yet as this will be changed when foo changes
    equal(ObjectA.prop, 'propValue');

    //change the value of foo.
    ObjectA.set('foo', 'changeFooValue');

    // Indicate the subscribers of foo that the value has just changed
    ObjectA.propertyDidChange('foo', null);

    // Values of prop has just changed
    equal(ObjectA.prop, 'changedPropValue');
  });

  QUnit.test('should notify that the property of an object has changed', function () {
    // Notify to its subscriber that the values of 'newFoo' will be changed. In this
    // case the observer is "newProp". Therefore this will call the notifyAction function
    // and value of "newProp" will be changed.
    ObjectA.notifyPropertyChange('newFoo', 'fooValue');

    //value of newProp changed.
    equal(ObjectA.newProp, 'changedNewPropValue');
  });

  QUnit.test('should invalidate function property cache when notifyPropertyChange is called', function () {
    var a = ObservableObject.extend({
      b: _emberMetal.computed({
        get: function () {
          return this._b;
        },
        set: function (key, value) {
          this._b = value;
          return this;
        }
      }).volatile()
    }).create({
      _b: null
    });

    a.set('b', 'foo');
    equal(a.get('b'), 'foo', 'should have set the correct value for property b');

    a._b = 'bar';
    a.notifyPropertyChange('b');
    a.set('b', 'foo');
    equal(a.get('b'), 'foo', 'should have invalidated the cache so that the newly set value is actually set');
  });
});
enifed('ember-runtime/tests/legacy_1x/mixins/observable/propertyChanges_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/legacy_1x/mixins/observable/propertyChanges_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/legacy_1x/mixins/observable/propertyChanges_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/legacy_1x/system/binding_test', ['exports', 'ember-environment', 'ember-metal', 'ember-runtime/system/object'], function (exports, _emberEnvironment, _emberMetal, _emberRuntimeSystemObject) {
  'use strict';

  /*
    NOTE: This test is adapted from the 1.x series of unit tests.  The tests
    are the same except for places where we intend to break the API we instead
    validate that we warn the developer appropriately.
  
    CHANGES FROM 1.6:
  
    * All calls to run.sync() were changed to
      run.sync()
  
    * Bindings no longer accept a root object as their second param.  Instead
      our test binding objects were put under a single object they could
      originate from.
  
    * tests that inspected internal properties were removed.
  
    * converted foo.get/foo.set to use get/Ember.set
  
    * Removed tests for Binding.isConnected.  Since binding instances are now
      shared this property no longer makes sense.
  
    * Changed call calls for obj.bind(...) to bind(obj, ...);
  
    * Changed all calls to sc_super() to this._super(...arguments)
  
    * Changed all calls to disconnect() to pass the root object.
  
    * removed calls to Binding.destroy() as that method is no longer useful
      (or defined)
  
    * changed use of T_STRING to 'string'
  */

  // ========================================================================
  // Binding Tests
  // ========================================================================

  var TestNamespace = undefined,
      fromObject = undefined,
      toObject = undefined,
      binding = undefined,
      Bon1 = undefined,
      bon2 = undefined,
      root = undefined; // global variables
  var originalLookup = _emberEnvironment.context.lookup;
  var lookup = undefined;

  QUnit.module('basic object binding', {
    setup: function () {
      fromObject = _emberRuntimeSystemObject.default.create({ value: 'start' });
      toObject = _emberRuntimeSystemObject.default.create({ value: 'end' });
      root = { fromObject: fromObject, toObject: toObject };
      _emberMetal.run(function () {
        expectDeprecation(function () {
          binding = _emberMetal.bind(root, 'toObject.value', 'fromObject.value');
        }, /`Ember\.Binding` is deprecated./);
      });
    }
  });

  QUnit.test('binding should have synced on connect', function () {
    equal(_emberMetal.get(toObject, 'value'), 'start', 'toObject.value should match fromObject.value');
  });

  QUnit.test('fromObject change should propagate to toObject only after flush', function () {
    _emberMetal.run(function () {
      _emberMetal.set(fromObject, 'value', 'change');
      equal(_emberMetal.get(toObject, 'value'), 'start');
    });
    equal(_emberMetal.get(toObject, 'value'), 'change');
  });

  QUnit.test('toObject change should propagate to fromObject only after flush', function () {
    _emberMetal.run(function () {
      _emberMetal.set(toObject, 'value', 'change');
      equal(_emberMetal.get(fromObject, 'value'), 'start');
    });
    equal(_emberMetal.get(fromObject, 'value'), 'change');
  });

  QUnit.test('deferred observing during bindings', function () {
    // setup special binding
    fromObject = _emberRuntimeSystemObject.default.create({
      value1: 'value1',
      value2: 'value2'
    });

    toObject = _emberRuntimeSystemObject.default.extend({
      observer: _emberMetal.observer('value1', 'value2', function () {
        equal(_emberMetal.get(this, 'value1'), 'CHANGED', 'value1 when observer fires');
        equal(_emberMetal.get(this, 'value2'), 'CHANGED', 'value2 when observer fires');
        this.callCount++;
      })
    }).create({
      value1: 'value1',
      value2: 'value2',

      callCount: 0
    });

    var root = { fromObject: fromObject, toObject: toObject };
    _emberMetal.run(function () {
      expectDeprecation(function () {
        _emberMetal.bind(root, 'toObject.value1', 'fromObject.value1');
      }, /`Ember\.Binding` is deprecated./);

      expectDeprecation(function () {
        _emberMetal.bind(root, 'toObject.value2', 'fromObject.value2');
      }, /`Ember\.Binding` is deprecated./);

      // change both value1 + value2, then  flush bindings.  observer should only
      // fire after bindings are done flushing.
      _emberMetal.set(fromObject, 'value1', 'CHANGED');
      _emberMetal.set(fromObject, 'value2', 'CHANGED');
    });

    equal(toObject.callCount, 2, 'should call observer twice');
  });

  QUnit.test('binding disconnection actually works', function () {
    binding.disconnect(root);
    _emberMetal.run(function () {
      _emberMetal.set(fromObject, 'value', 'change');
    });
    equal(_emberMetal.get(toObject, 'value'), 'start');
  });

  var first = undefined,
      second = undefined,
      third = undefined; // global variables

  // ..........................................................
  // chained binding
  //

  QUnit.module('chained binding', {

    setup: function () {
      _emberMetal.run(function () {
        first = _emberRuntimeSystemObject.default.create({ output: 'first' });

        second = _emberRuntimeSystemObject.default.extend({
          inputDidChange: _emberMetal.observer('input', function () {
            _emberMetal.set(this, 'output', _emberMetal.get(this, 'input'));
          })
        }).create({
          input: 'second',
          output: 'second'
        });

        third = _emberRuntimeSystemObject.default.create({ input: 'third' });

        root = { first: first, second: second, third: third };

        expectDeprecation(function () {
          _emberMetal.bind(root, 'second.input', 'first.output');
        }, /`Ember\.Binding` is deprecated./);

        expectDeprecation(function () {
          _emberMetal.bind(root, 'second.output', 'third.input');
        }, /`Ember\.Binding` is deprecated./);
      });
    },
    teardown: function () {
      _emberMetal.run.cancelTimers();
    }
  });

  QUnit.test('changing first output should propagate to third after flush', function () {
    _emberMetal.run(function () {
      _emberMetal.set(first, 'output', 'change');
      equal('change', _emberMetal.get(first, 'output'), 'first.output');
      ok('change' !== _emberMetal.get(third, 'input'), 'third.input');
    });

    equal('change', _emberMetal.get(first, 'output'), 'first.output');
    equal('change', _emberMetal.get(second, 'input'), 'second.input');
    equal('change', _emberMetal.get(second, 'output'), 'second.output');
    equal('change', _emberMetal.get(third, 'input'), 'third.input');
  });

  // ..........................................................
  // Custom Binding
  //

  QUnit.module('Custom Binding', {
    setup: function () {
      _emberEnvironment.context.lookup = lookup = {};

      Bon1 = _emberRuntimeSystemObject.default.extend({
        value1: 'hi',
        value2: 83,
        array1: []
      });

      bon2 = _emberRuntimeSystemObject.default.create({
        val1: 'hello',
        val2: 25,
        arr: [1, 2, 3, 4]
      });

      _emberEnvironment.context.lookup['TestNamespace'] = TestNamespace = {
        bon2: bon2,
        Bon1: Bon1
      };
    },
    teardown: function () {
      _emberEnvironment.context.lookup = originalLookup;
      Bon1 = bon2 = TestNamespace = null;
      _emberMetal.run.cancelTimers();
    }
  });

  QUnit.test('two bindings to the same value should sync in the order they are initialized', function () {
    _emberMetal.run.begin();

    var a = _emberRuntimeSystemObject.default.create({
      foo: 'bar'
    });

    var b = _emberRuntimeSystemObject.default.extend({
      C: _emberRuntimeSystemObject.default.extend({
        foo: 'bee',
        fooBinding: 'owner.foo'
      }),

      init: function () {
        this._super.apply(this, arguments);
        _emberMetal.set(this, 'c', this.C.create({ owner: this }));
      }
    });

    expectDeprecation(function () {
      b = b.create({
        foo: 'baz',
        fooBinding: 'a.foo',
        a: a
      });
    }, /`Ember\.Binding` is deprecated./);

    _emberMetal.run.end();

    equal(_emberMetal.get(a, 'foo'), 'bar', 'a.foo should not change');
    equal(_emberMetal.get(b, 'foo'), 'bar', 'a.foo should propagate up to b.foo');
    equal(_emberMetal.get(b.c, 'foo'), 'bar', 'a.foo should propagate up to b.c.foo');
  });

  // ..........................................................
  // propertyNameBinding with longhand
  //

  QUnit.module('propertyNameBinding with longhand', {
    setup: function () {
      _emberEnvironment.context.lookup = lookup = {};

      lookup['TestNamespace'] = TestNamespace = {};
      _emberMetal.run(function () {
        TestNamespace.fromObject = _emberRuntimeSystemObject.default.create({
          value: 'originalValue'
        });

        expectDeprecation(function () {
          TestNamespace.toObject = _emberRuntimeSystemObject.default.extend({
            valueBinding: _emberMetal.Binding.from('TestNamespace.fromObject.value'),
            relativeBinding: _emberMetal.Binding.from('localValue')
          }).create({
            localValue: 'originalLocal'
          });
        }, /`Ember\.Binding` is deprecated./);
      });
    },
    teardown: function () {
      TestNamespace = undefined;
      _emberEnvironment.context.lookup = originalLookup;
    }
  });

  QUnit.test('works with full path', function () {
    _emberMetal.run(function () {
      return _emberMetal.set(TestNamespace.fromObject, 'value', 'updatedValue');
    });

    equal(_emberMetal.get(TestNamespace.toObject, 'value'), 'updatedValue');

    _emberMetal.run(function () {
      return _emberMetal.set(TestNamespace.fromObject, 'value', 'newerValue');
    });

    equal(_emberMetal.get(TestNamespace.toObject, 'value'), 'newerValue');
  });

  QUnit.test('works with local path', function () {
    _emberMetal.run(function () {
      return _emberMetal.set(TestNamespace.toObject, 'localValue', 'updatedValue');
    });

    equal(_emberMetal.get(TestNamespace.toObject, 'relative'), 'updatedValue');

    _emberMetal.run(function () {
      return _emberMetal.set(TestNamespace.toObject, 'localValue', 'newerValue');
    });

    equal(_emberMetal.get(TestNamespace.toObject, 'relative'), 'newerValue');
  });
});
enifed('ember-runtime/tests/legacy_1x/system/binding_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/legacy_1x/system/binding_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/legacy_1x/system/binding_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/legacy_1x/system/object/base_test', ['exports', 'ember-metal', 'ember-runtime/system/object'], function (exports, _emberMetal, _emberRuntimeSystemObject) {
  'use strict';

  /*
    NOTE: This test is adapted from the 1.x series of unit tests.  The tests
    are the same except for places where we intend to break the API we instead
    validate that we warn the developer appropriately.
  
    CHANGES FROM 1.6:
  
    * Changed get(obj, ) and set(obj, ) to Ember.get() and Ember.set()
    * Removed obj.instanceOf() and obj.kindOf() tests.  use obj instanceof Foo
      instead
    * Removed respondsTo() and tryToPerform() tests.  Can be brought back in a
      utils package.
    * Removed destroy() test.  You can impl yourself but not built in
    * Changed Class.subclassOf() test to Class.detect()
    * Remove broken test for 'superclass' property.
    * Removed obj.didChangeFor()
  */

  // ========================================================================
  // EmberObject Base Tests
  // ========================================================================

  var obj = undefined,
      obj1 = undefined; // global variables

  QUnit.module('A new EmberObject instance', {

    setup: function () {
      obj = _emberRuntimeSystemObject.default.create({
        foo: 'bar',
        total: 12345,
        aMethodThatExists: function () {},
        aMethodThatReturnsTrue: function () {
          return true;
        },
        aMethodThatReturnsFoobar: function () {
          return 'Foobar';
        },
        aMethodThatReturnsFalse: function () {
          return false;
        }
      });
    },

    teardown: function () {
      obj = undefined;
    }

  });

  QUnit.test('Should return its properties when requested using EmberObject#get', function () {
    equal(_emberMetal.get(obj, 'foo'), 'bar');
    equal(_emberMetal.get(obj, 'total'), 12345);
  });

  QUnit.test('Should allow changing of those properties by calling EmberObject#set', function () {
    equal(_emberMetal.get(obj, 'foo'), 'bar');
    equal(_emberMetal.get(obj, 'total'), 12345);

    _emberMetal.set(obj, 'foo', 'Chunky Bacon');
    _emberMetal.set(obj, 'total', 12);

    equal(_emberMetal.get(obj, 'foo'), 'Chunky Bacon');
    equal(_emberMetal.get(obj, 'total'), 12);
  });

  QUnit.module('EmberObject superclass and subclasses', {
    setup: function () {
      obj = _emberRuntimeSystemObject.default.extend({
        method1: function () {
          return 'hello';
        }
      });
      obj1 = obj.extend();
    },

    teardown: function () {
      obj = undefined;
      obj1 = undefined;
    }
  });

  QUnit.test('Checking the detect() function on an object and its subclass', function () {
    equal(obj.detect(obj1), true);
    equal(obj1.detect(obj), false);
  });

  QUnit.test('Checking the detectInstance() function on an object and its subclass', function () {
    ok(_emberRuntimeSystemObject.default.detectInstance(obj.create()));
    ok(obj.detectInstance(obj.create()));
  });
});
enifed('ember-runtime/tests/legacy_1x/system/object/base_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/legacy_1x/system/object/base_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/legacy_1x/system/object/base_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/legacy_1x/system/object/bindings_test', ['exports', 'ember-environment', 'ember-metal', 'ember-runtime/system/object'], function (exports, _emberEnvironment, _emberMetal, _emberRuntimeSystemObject) {
  'use strict';

  /*
    NOTE: This test is adapted from the 1.x series of unit tests.  The tests
    are the same except for places where we intend to break the API we instead
    validate that we warn the developer appropriately.
  
    CHANGES FROM 1.6:
  
    * changed Ember.Bending.flushPendingChanges() -> run.sync();
    * changes obj.set() and obj.get() to Ember.set() and Ember.get()
    * Fixed an actual bug in unit tests around line 133
    * fixed 'bindings should disconnect on destroy' test to use destroy.
  */

  // ========================================================================
  // EmberObject bindings Tests
  // ========================================================================

  var originalLookup = _emberEnvironment.context.lookup;
  var testObject = undefined,
      fromObject = undefined,
      TestObject = undefined;
  var TestNamespace = undefined,
      lookup = undefined;

  QUnit.module('bind() method', {
    setup: function () {
      _emberEnvironment.context.lookup = lookup = {};

      testObject = _emberRuntimeSystemObject.default.create({
        foo: 'bar',
        bar: 'foo',
        extraObject: null
      });

      fromObject = _emberRuntimeSystemObject.default.create({
        bar: 'foo',
        extraObject: null
      });

      lookup['TestNamespace'] = TestNamespace = {
        fromObject: fromObject,
        testObject: testObject
      };
    },

    teardown: function () {
      testObject = fromObject = null;
      _emberEnvironment.context.lookup = originalLookup;
    }
  });

  QUnit.test('bind(TestNamespace.fromObject.bar) should follow absolute path', function () {
    _emberMetal.run(function () {
      expectDeprecation(function () {
        // create binding
        testObject.bind('foo', 'TestNamespace.fromObject.bar');
      }, /`Ember.Binding` is deprecated/);

      // now make a change to see if the binding triggers.
      _emberMetal.set(fromObject, 'bar', 'changedValue');
    });

    equal('changedValue', _emberMetal.get(testObject, 'foo'), 'testObject.foo');
  });

  QUnit.test('bind(.bar) should bind to relative path', function () {
    _emberMetal.run(function () {
      expectDeprecation(function () {
        // create binding
        testObject.bind('foo', 'bar');
      }, /`Ember.Binding` is deprecated/);

      // now make a change to see if the binding triggers.
      _emberMetal.set(testObject, 'bar', 'changedValue');
    });

    equal('changedValue', _emberMetal.get(testObject, 'foo'), 'testObject.foo');
  });

  QUnit.module('fooBinding method', {
    setup: function () {
      _emberEnvironment.context.lookup = lookup = {};

      TestObject = _emberRuntimeSystemObject.default.extend({
        foo: 'bar',
        bar: 'foo',
        extraObject: null
      });

      fromObject = _emberRuntimeSystemObject.default.create({
        bar: 'foo',
        extraObject: null
      });

      lookup['TestNamespace'] = TestNamespace = {
        fromObject: fromObject,
        testObject: TestObject
      };
    },

    teardown: function () {
      _emberEnvironment.context.lookup = originalLookup;
      TestObject = fromObject = null;
      //  delete TestNamespace;
    }
  });

  var deprecationMessage = /`Ember.Binding` is deprecated/;

  QUnit.test('fooBinding: TestNamespace.fromObject.bar should follow absolute path', function () {
    _emberMetal.run(function () {
      expectDeprecation(function () {
        // create binding
        testObject = TestObject.extend({
          fooBinding: 'TestNamespace.fromObject.bar'
        }).create();
      }, deprecationMessage);

      // now make a change to see if the binding triggers.
      _emberMetal.set(fromObject, 'bar', 'changedValue');
    });

    equal('changedValue', _emberMetal.get(testObject, 'foo'), 'testObject.foo');
  });

  QUnit.test('fooBinding: .bar should bind to relative path', function () {
    _emberMetal.run(function () {
      expectDeprecation(function () {
        // create binding
        testObject = TestObject.extend({
          fooBinding: 'bar'
        }).create();
      }, deprecationMessage);

      // now make a change to see if the binding triggers.
      _emberMetal.set(testObject, 'bar', 'changedValue');
    });

    equal('changedValue', _emberMetal.get(testObject, 'foo'), 'testObject.foo');
  });

  QUnit.test('fooBinding: should disconnect bindings when destroyed', function () {
    _emberMetal.run(function () {
      expectDeprecation(function () {
        // create binding
        testObject = TestObject.extend({
          fooBinding: 'TestNamespace.fromObject.bar'
        }).create();
      }, deprecationMessage);

      _emberMetal.set(TestNamespace.fromObject, 'bar', 'BAZ');
    });

    equal(_emberMetal.get(testObject, 'foo'), 'BAZ', 'binding should have synced');

    _emberMetal.run(function () {
      return testObject.destroy();
    });

    _emberMetal.run(function () {
      return _emberMetal.set(TestNamespace.fromObject, 'bar', 'BIFF');
    });

    ok(_emberMetal.get(testObject, 'foo') !== 'bar', 'binding should not have synced');
  });
});
enifed('ember-runtime/tests/legacy_1x/system/object/bindings_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/legacy_1x/system/object/bindings_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/legacy_1x/system/object/bindings_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/legacy_1x/system/object/concatenated_test', ['exports', 'ember-metal', 'ember-runtime/system/object'], function (exports, _emberMetal, _emberRuntimeSystemObject) {
  'use strict';

  /*
    NOTE: This test is adapted from the 1.x series of unit tests.  The tests
    are the same except for places where we intend to break the API we instead
    validate that we warn the developer appropriately.
  
    CHANGES FROM 1.6:
  
    * changed get(obj, ) and set(obj, ) to Ember.get() and Ember.set()
    * converted uses of obj.isEqual() to use deepEqual() test since isEqual is not
      always defined
  */

  function K() {
    return this;
  }

  var klass = undefined;

  QUnit.module('EmberObject Concatenated Properties', {
    setup: function () {
      klass = _emberRuntimeSystemObject.default.extend({
        concatenatedProperties: ['values', 'functions'],
        values: ['a', 'b', 'c'],
        functions: [K]
      });
    }
  });

  QUnit.test('concatenates instances', function () {
    var obj = klass.create({
      values: ['d', 'e', 'f']
    });

    var values = _emberMetal.get(obj, 'values');
    var expected = ['a', 'b', 'c', 'd', 'e', 'f'];

    deepEqual(values, expected, 'should concatenate values property (expected: ' + expected + ', got: ' + values + ')');
  });

  QUnit.test('concatenates subclasses', function () {
    var subKlass = klass.extend({
      values: ['d', 'e', 'f']
    });
    var obj = subKlass.create();

    var values = _emberMetal.get(obj, 'values');
    var expected = ['a', 'b', 'c', 'd', 'e', 'f'];

    deepEqual(values, expected, 'should concatenate values property (expected: ' + expected + ', got: ' + values + ')');
  });

  QUnit.test('concatenates reopen', function () {
    klass.reopen({
      values: ['d', 'e', 'f']
    });
    var obj = klass.create();

    var values = _emberMetal.get(obj, 'values');
    var expected = ['a', 'b', 'c', 'd', 'e', 'f'];

    deepEqual(values, expected, 'should concatenate values property (expected: ' + expected + ', got: ' + values + ')');
  });

  QUnit.test('concatenates mixin', function () {
    var mixin = {
      values: ['d', 'e']
    };
    var subKlass = klass.extend(mixin, {
      values: ['f']
    });
    var obj = subKlass.create();

    var values = _emberMetal.get(obj, 'values');
    var expected = ['a', 'b', 'c', 'd', 'e', 'f'];

    deepEqual(values, expected, 'should concatenate values property (expected: ' + expected + ', got: ' + values + ')');
  });

  QUnit.test('concatenates reopen, subclass, and instance', function () {
    klass.reopen({ values: ['d'] });
    var subKlass = klass.extend({ values: ['e'] });
    var obj = subKlass.create({ values: ['f'] });

    var values = _emberMetal.get(obj, 'values');
    var expected = ['a', 'b', 'c', 'd', 'e', 'f'];

    deepEqual(values, expected, 'should concatenate values property (expected: ' + expected + ', got: ' + values + ')');
  });

  QUnit.test('concatenates subclasses when the values are functions', function () {
    var subKlass = klass.extend({
      functions: K
    });
    var obj = subKlass.create();

    var values = _emberMetal.get(obj, 'functions');
    var expected = [K, K];

    deepEqual(values, expected, 'should concatenate functions property (expected: ' + expected + ', got: ' + values + ')');
  });
});
enifed('ember-runtime/tests/legacy_1x/system/object/concatenated_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/legacy_1x/system/object/concatenated_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/legacy_1x/system/object/concatenated_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/legacy_1x/system/run_loop_test', ['exports', 'ember-metal', 'ember-runtime/mixins/observable', 'ember-runtime/system/object'], function (exports, _emberMetal, _emberRuntimeMixinsObservable, _emberRuntimeSystemObject) {
  'use strict';

  /*
    NOTE: This test is adapted from the 1.x series of unit tests.  The tests
    are the same except for places where we intend to break the API we instead
    validate that we warn the developer appropriately.
  
    CHANGES FROM 1.6:
  
    * Updated the API usage for setting up and syncing Binding since these
      are not the APIs this file is testing.
  
    * Disabled a call to invokeOnce() around line 127 because it appeared to be
      broken anyway.  I don't think it ever even worked.
  */

  var MyApp = undefined;

  QUnit.module('System:run_loop() - chained binding', {
    setup: function () {
      MyApp = {};
      MyApp.first = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsObservable.default).create({
        output: 'MyApp.first'
      });

      MyApp.second = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsObservable.default, {
        inputDidChange: _emberMetal.observer('input', function () {
          this.set('output', this.get('input'));
        })
      }).create({
        input: 'MyApp.second',
        output: 'MyApp.second'
      });

      MyApp.third = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsObservable.default).create({
        input: 'MyApp.third'
      });
    }
  });

  var deprecationMessage = /`Ember.Binding` is deprecated/;

  QUnit.test('Should propagate bindings after the RunLoop completes (using Ember.RunLoop)', function () {
    _emberMetal.run(function () {
      //Binding of output of MyApp.first object to input of MyApp.second object
      expectDeprecation(function () {
        _emberMetal.Binding.from('first.output').to('second.input').connect(MyApp);
      }, deprecationMessage);

      //Binding of output of MyApp.second object to input of MyApp.third object
      expectDeprecation(function () {
        _emberMetal.Binding.from('second.output').to('third.input').connect(MyApp);
      }, deprecationMessage);
    });

    _emberMetal.run(function () {
      // Based on the above binding if you change the output of MyApp.first
      // object it should change the all the variable of
      //  MyApp.first,MyApp.second and MyApp.third object
      MyApp.first.set('output', 'change');

      //Changes the output of the MyApp.first object
      equal(MyApp.first.get('output'), 'change');

      //since binding has not taken into effect the value still remains as change.
      equal(MyApp.second.get('output'), 'MyApp.first');
    }); // allows bindings to trigger...

    //Value of the output variable changed to 'change'
    equal(MyApp.first.get('output'), 'change');

    //Since binding triggered after the end loop the value changed to 'change'.
    equal(MyApp.second.get('output'), 'change');
  });

  QUnit.test('Should propagate bindings after the RunLoop completes', function () {
    _emberMetal.run(function () {
      //Binding of output of MyApp.first object to input of MyApp.second object
      expectDeprecation(function () {
        _emberMetal.Binding.from('first.output').to('second.input').connect(MyApp);
      }, deprecationMessage);

      //Binding of output of MyApp.second object to input of MyApp.third object
      expectDeprecation(function () {
        _emberMetal.Binding.from('second.output').to('third.input').connect(MyApp);
      }, deprecationMessage);
    });

    _emberMetal.run(function () {
      //Based on the above binding if you change the output of MyApp.first object it should
      //change the all the variable of MyApp.first,MyApp.second and MyApp.third object
      MyApp.first.set('output', 'change');

      //Changes the output of the MyApp.first object
      equal(MyApp.first.get('output'), 'change');

      //since binding has not taken into effect the value still remains as change.
      equal(MyApp.second.get('output'), 'MyApp.first');
    });

    //Value of the output variable changed to 'change'
    equal(MyApp.first.get('output'), 'change');

    //Since binding triggered after the end loop the value changed to 'change'.
    equal(MyApp.second.get('output'), 'change');
  });
});
enifed('ember-runtime/tests/legacy_1x/system/run_loop_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/legacy_1x/system/run_loop_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/legacy_1x/system/run_loop_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/main_test', ['exports', 'ember-runtime/index'], function (exports, _emberRuntimeIndex) {
  'use strict';

  QUnit.module('ember-runtime/main');

  QUnit.test('Ember.computed.collect', function () {
    var MyObj = _emberRuntimeIndex.Object.extend({
      props: _emberRuntimeIndex.collect('foo', 'bar', 'baz')
    });

    var myObj = MyObj.create({
      foo: 3,
      bar: 5,
      baz: 'asdf'
    });

    var propsValue = myObj.get('props');

    deepEqual(propsValue, [3, 5, 'asdf']);
  });
});
enifed('ember-runtime/tests/main_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/main_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/main_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/mixins/array_test', ['exports', 'ember-metal', 'internal-test-helpers', 'ember-runtime/tests/suites/array', 'ember-runtime/system/object', 'ember-runtime/mixins/array', 'ember-runtime/system/native_array'], function (exports, _emberMetal, _internalTestHelpers, _emberRuntimeTestsSuitesArray, _emberRuntimeSystemObject, _emberRuntimeMixinsArray, _emberRuntimeSystemNative_array) {
  'use strict';

  /*
    Implement a basic fake mutable array.  This validates that any non-native
    enumerable can impl this API.
  */
  var TestArray = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsArray.default, {
    _content: null,

    init: function () {
      var ary = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

      this._content = ary;
    },

    // some methods to modify the array so we can test changes.  Note that
    // arrays can be modified even if they don't implement MutableArray.  The
    // MutableArray is just a standard API for mutation but not required.
    addObject: function (obj) {
      var idx = this._content.length;
      _emberRuntimeMixinsArray.arrayContentWillChange(this, idx, 0, 1);
      this._content.push(obj);
      _emberRuntimeMixinsArray.arrayContentDidChange(this, idx, 0, 1);
    },

    removeFirst: function (idx) {
      _emberRuntimeMixinsArray.arrayContentWillChange(this, 0, 1, 0);
      this._content.shift();
      _emberRuntimeMixinsArray.arrayContentDidChange(this, 0, 1, 0);
    },

    objectAt: function (idx) {
      return this._content[idx];
    },

    length: _emberMetal.computed(function () {
      return this._content.length;
    })
  });

  _emberRuntimeTestsSuitesArray.ArrayTests.extend({

    name: 'Basic Mutable Array',

    newObject: function (ary) {
      ary = ary ? ary.slice() : this.newFixture(3);
      return new TestArray(ary);
    },

    // allows for testing of the basic enumerable after an internal mutation
    mutate: function (obj) {
      obj.addObject(this.getFixture(1)[0]);
    },

    toArray: function (obj) {
      return obj.slice();
    }

  }).run();

  QUnit.test('the return value of slice has Ember.Array applied', function () {
    var x = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsArray.default).create({
      length: 0
    });
    var y = x.slice(1);
    equal(_emberRuntimeMixinsArray.default.detect(y), true, 'mixin should be applied');
  });

  QUnit.test('slice supports negative index arguments', function () {
    var testArray = new TestArray([1, 2, 3, 4]);

    deepEqual(testArray.slice(-2), [3, 4], 'slice(-2)');
    deepEqual(testArray.slice(-2, -1), [3], 'slice(-2, -1');
    deepEqual(testArray.slice(-2, -2), [], 'slice(-2, -2)');
    deepEqual(testArray.slice(-1, -2), [], 'slice(-1, -2)');

    deepEqual(testArray.slice(-4, 1), [1], 'slice(-4, 1)');
    deepEqual(testArray.slice(-4, 5), [1, 2, 3, 4], 'slice(-4, 5)');
    deepEqual(testArray.slice(-4), [1, 2, 3, 4], 'slice(-4)');

    deepEqual(testArray.slice(0, -1), [1, 2, 3], 'slice(0, -1)');
    deepEqual(testArray.slice(0, -4), [], 'slice(0, -4)');
    deepEqual(testArray.slice(0, -3), [1], 'slice(0, -3)');
  });

  // ..........................................................
  // CONTENT DID CHANGE
  //

  var DummyArray = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsArray.default, {
    nextObject: function () {},
    length: 0,
    objectAt: function (idx) {
      return 'ITEM-' + idx;
    }
  });

  var obj = undefined,
      observer = undefined;

  // ..........................................................
  // NOTIFY ARRAY OBSERVERS
  //

  QUnit.module('mixins/array/arrayContent[Will|Did]Change');

  QUnit.test('should notify observers of []', function () {
    obj = DummyArray.extend({
      enumerablePropertyDidChange: _emberMetal.observer('[]', function () {
        this._count++;
      })
    }).create({
      _count: 0
    });

    equal(obj._count, 0, 'should not have invoked yet');

    _emberRuntimeMixinsArray.arrayContentWillChange(obj, 0, 1, 1);
    _emberRuntimeMixinsArray.arrayContentDidChange(obj, 0, 1, 1);

    equal(obj._count, 1, 'should have invoked');
  });

  // ..........................................................
  // NOTIFY CHANGES TO LENGTH
  //

  QUnit.module('notify observers of length', {
    setup: function () {
      obj = DummyArray.extend({
        lengthDidChange: _emberMetal.observer('length', function () {
          this._after++;
        })
      }).create({
        _after: 0
      });

      equal(obj._after, 0, 'should not have fired yet');
    },

    teardown: function () {
      obj = null;
    }
  });

  QUnit.test('should notify observers when call with no params', function () {
    _emberRuntimeMixinsArray.arrayContentWillChange(obj);
    equal(obj._after, 0);

    _emberRuntimeMixinsArray.arrayContentDidChange(obj);
    equal(obj._after, 1);
  });

  // API variation that included items only
  QUnit.test('should not notify when passed lengths are same', function () {
    _emberRuntimeMixinsArray.arrayContentWillChange(obj, 0, 1, 1);
    equal(obj._after, 0);

    _emberRuntimeMixinsArray.arrayContentDidChange(obj, 0, 1, 1);
    equal(obj._after, 0);
  });

  QUnit.test('should notify when passed lengths are different', function () {
    _emberRuntimeMixinsArray.arrayContentWillChange(obj, 0, 1, 2);
    equal(obj._after, 0);

    _emberRuntimeMixinsArray.arrayContentDidChange(obj, 0, 1, 2);
    equal(obj._after, 1);
  });

  // ..........................................................
  // NOTIFY ARRAY OBSERVER
  //

  QUnit.module('notify array observers', {
    setup: function () {
      obj = DummyArray.create();

      observer = _emberRuntimeSystemObject.default.extend({
        arrayWillChange: function () {
          equal(this._before, null); // should only call once
          this._before = Array.prototype.slice.call(arguments);
        },

        arrayDidChange: function () {
          equal(this._after, null); // should only call once
          this._after = Array.prototype.slice.call(arguments);
        }
      }).create({
        _before: null,
        _after: null
      });

      _emberRuntimeMixinsArray.addArrayObserver(obj, observer);
    },

    teardown: function () {
      obj = observer = null;
    }
  });

  QUnit.test('should notify enumerable observers when called with no params', function () {
    _emberRuntimeMixinsArray.arrayContentWillChange(obj);
    deepEqual(observer._before, [obj, 0, -1, -1]);

    _emberRuntimeMixinsArray.arrayContentDidChange(obj);
    deepEqual(observer._after, [obj, 0, -1, -1]);
  });

  // API variation that included items only
  QUnit.test('should notify when called with same length items', function () {
    _emberRuntimeMixinsArray.arrayContentWillChange(obj, 0, 1, 1);
    deepEqual(observer._before, [obj, 0, 1, 1]);

    _emberRuntimeMixinsArray.arrayContentDidChange(obj, 0, 1, 1);
    deepEqual(observer._after, [obj, 0, 1, 1]);
  });

  QUnit.test('should notify when called with diff length items', function () {
    _emberRuntimeMixinsArray.arrayContentWillChange(obj, 0, 2, 1);
    deepEqual(observer._before, [obj, 0, 2, 1]);

    _emberRuntimeMixinsArray.arrayContentDidChange(obj, 0, 2, 1);
    deepEqual(observer._after, [obj, 0, 2, 1]);
  });

  QUnit.test('removing enumerable observer should disable', function () {
    _emberRuntimeMixinsArray.removeArrayObserver(obj, observer);
    _emberRuntimeMixinsArray.arrayContentWillChange(obj);
    deepEqual(observer._before, null);

    _emberRuntimeMixinsArray.arrayContentDidChange(obj);
    deepEqual(observer._after, null);
  });

  // ..........................................................
  // NOTIFY ENUMERABLE OBSERVER
  //

  QUnit.module('notify enumerable observers as well', {
    setup: function () {
      obj = DummyArray.create();

      observer = _emberRuntimeSystemObject.default.extend({
        enumerableWillChange: function () {
          equal(this._before, null); // should only call once
          this._before = Array.prototype.slice.call(arguments);
        },

        enumerableDidChange: function () {
          equal(this._after, null); // should only call once
          this._after = Array.prototype.slice.call(arguments);
        }
      }).create({
        _before: null,
        _after: null
      });

      obj.addEnumerableObserver(observer);
    },

    teardown: function () {
      obj = observer = null;
    }
  });

  QUnit.test('should notify enumerable observers when called with no params', function () {
    _emberRuntimeMixinsArray.arrayContentWillChange(obj);
    deepEqual(observer._before, [obj, null, null], 'before');

    _emberRuntimeMixinsArray.arrayContentDidChange(obj);
    deepEqual(observer._after, [obj, null, null], 'after');
  });

  // API variation that included items only
  QUnit.test('should notify when called with same length items', function () {
    _emberRuntimeMixinsArray.arrayContentWillChange(obj, 0, 1, 1);
    deepEqual(observer._before, [obj, ['ITEM-0'], 1], 'before');

    _emberRuntimeMixinsArray.arrayContentDidChange(obj, 0, 1, 1);
    deepEqual(observer._after, [obj, 1, ['ITEM-0']], 'after');
  });

  QUnit.test('should notify when called with diff length items', function () {
    _emberRuntimeMixinsArray.arrayContentWillChange(obj, 0, 2, 1);
    deepEqual(observer._before, [obj, ['ITEM-0', 'ITEM-1'], 1], 'before');

    _emberRuntimeMixinsArray.arrayContentDidChange(obj, 0, 2, 1);
    deepEqual(observer._after, [obj, 2, ['ITEM-0']], 'after');
  });

  QUnit.test('removing enumerable observer should disable', function () {
    obj.removeEnumerableObserver(observer);
    _emberRuntimeMixinsArray.arrayContentWillChange(obj);
    deepEqual(observer._before, null, 'before');

    _emberRuntimeMixinsArray.arrayContentDidChange(obj);
    deepEqual(observer._after, null, 'after');
  });

  // ..........................................................
  // @each
  //

  var ary = undefined;

  QUnit.module('EmberArray.@each support', {
    setup: function () {
      ary = new TestArray([{ isDone: true, desc: 'Todo 1' }, { isDone: false, desc: 'Todo 2' }, { isDone: true, desc: 'Todo 3' }, { isDone: false, desc: 'Todo 4' }]);
    },

    teardown: function () {
      ary = null;
    }
  });

  QUnit.test('adding an object should notify (@each.isDone)', function () {
    var called = 0;

    var observerObject = _emberRuntimeSystemObject.default.create({
      wasCalled: function () {
        called++;
      }
    });

    _emberMetal.addObserver(ary, '@each.isDone', observerObject, 'wasCalled');

    ary.addObject(_emberRuntimeSystemObject.default.create({
      desc: 'foo',
      isDone: false
    }));

    equal(called, 1, 'calls observer when object is pushed');
  });

  QUnit.test('@each is readOnly', function () {
    expect(1);

    throws(function () {
      _emberMetal.set(ary, '@each', 'foo');
    }, /Cannot set read-only property "@each"/);
  });

  QUnit.test('using @each to observe arrays that does not return objects raise error', function () {
    var called = 0;

    var observerObject = _emberRuntimeSystemObject.default.create({
      wasCalled: function () {
        called++;
      }
    });

    ary = TestArray.create({
      objectAt: function (idx) {
        return _emberMetal.get(this._content[idx], 'desc');
      }
    });

    _emberMetal.addObserver(ary, '@each.isDone', observerObject, 'wasCalled');

    expectAssertion(function () {
      ary.addObject(_emberRuntimeSystemObject.default.create({
        desc: 'foo',
        isDone: false
      }));
    }, /When using @each to observe the array/);

    equal(called, 0, 'not calls observer when object is pushed');
  });

  QUnit.test('modifying the array should also indicate the isDone prop itself has changed', function () {
    // NOTE: we never actually get the '@each.isDone' property here.  This is
    // important because it tests the case where we don't have an isDone
    // EachArray materialized but just want to know when the property has
    // changed.

    var each = _emberMetal.get(ary, '@each');
    var count = 0;

    _emberMetal.addObserver(each, 'isDone', function () {
      return count++;
    });

    count = 0;
    var item = _emberRuntimeMixinsArray.objectAt(ary, 2);
    _emberMetal.set(item, 'isDone', !_emberMetal.get(item, 'isDone'));
    equal(count, 1, '@each.isDone should have notified');
  });

  QUnit.test('`objectAt` returns correct object', function () {
    var arr = ['first', 'second', 'third', 'fourth'];
    equal(_emberRuntimeMixinsArray.objectAt(arr, 2), 'third');
    equal(_emberRuntimeMixinsArray.objectAt(arr, 4), undefined);
  });

  _internalTestHelpers.testBoth('should be clear caches for computed properties that have dependent keys on arrays that are changed after object initialization', function (get, set) {
    var obj = _emberRuntimeSystemObject.default.extend({
      init: function () {
        this._super.apply(this, arguments);
        set(this, 'resources', _emberRuntimeSystemNative_array.A());
      },

      common: _emberMetal.computed('resources.@each.common', function () {
        return get(_emberRuntimeMixinsArray.objectAt(get(this, 'resources'), 0), 'common');
      })
    }).create();

    get(obj, 'resources').pushObject(_emberRuntimeSystemObject.default.create({ common: 'HI!' }));
    equal('HI!', get(obj, 'common'));

    set(_emberRuntimeMixinsArray.objectAt(get(obj, 'resources'), 0), 'common', 'BYE!');
    equal('BYE!', get(obj, 'common'));
  });

  _internalTestHelpers.testBoth('observers that contain @each in the path should fire only once the first time they are accessed', function (get, set) {
    var count = 0;

    var obj = _emberRuntimeSystemObject.default.extend({
      init: function () {
        this._super.apply(this, arguments);
        // Observer does not fire on init
        set(this, 'resources', _emberRuntimeSystemNative_array.A());
      },

      commonDidChange: _emberMetal.observer('resources.@each.common', function () {
        return count++;
      })
    }).create();

    // Observer fires second time when new object is added
    get(obj, 'resources').pushObject(_emberRuntimeSystemObject.default.create({ common: 'HI!' }));
    // Observer fires third time when property on an object is changed
    set(_emberRuntimeMixinsArray.objectAt(get(obj, 'resources'), 0), 'common', 'BYE!');

    equal(count, 2, 'observers should only be called once');
  });
});
enifed('ember-runtime/tests/mixins/array_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/mixins/array_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/mixins/array_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/mixins/comparable_test', ['exports', 'ember-metal', 'ember-runtime/system/object', 'ember-runtime/compare', 'ember-runtime/mixins/comparable'], function (exports, _emberMetal, _emberRuntimeSystemObject, _emberRuntimeCompare, _emberRuntimeMixinsComparable) {
  'use strict';

  var Rectangle = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsComparable.default, {
    length: 0,
    width: 0,

    area: function () {
      return _emberMetal.get(this, 'length') * _emberMetal.get(this, 'width');
    },

    compare: function (a, b) {
      return _emberRuntimeCompare.default(a.area(), b.area());
    }

  });

  var r1 = undefined,
      r2 = undefined;

  QUnit.module('Comparable', {
    setup: function () {
      r1 = Rectangle.create({ length: 6, width: 12 });
      r2 = Rectangle.create({ length: 6, width: 13 });
    }
  });

  QUnit.test('should be comparable and return the correct result', function () {
    equal(_emberRuntimeMixinsComparable.default.detect(r1), true);
    equal(_emberRuntimeCompare.default(r1, r1), 0);
    equal(_emberRuntimeCompare.default(r1, r2), -1);
    equal(_emberRuntimeCompare.default(r2, r1), 1);
  });
});
enifed('ember-runtime/tests/mixins/comparable_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/mixins/comparable_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/mixins/comparable_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/mixins/container_proxy_test', ['exports', 'ember-utils', 'container', 'ember-runtime/mixins/container_proxy', 'ember-runtime/system/object'], function (exports, _emberUtils, _container, _emberRuntimeMixinsContainer_proxy, _emberRuntimeSystemObject) {
  'use strict';

  QUnit.module('ember-runtime/mixins/container_proxy', {
    setup: function () {
      this.Owner = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsContainer_proxy.default);
      this.instance = this.Owner.create();

      var registry = new _container.Registry();

      this.instance.__container__ = new _container.Container(registry, {
        owner: this.instance
      });
    }
  });

  QUnit.test('provides ownerInjection helper method', function (assert) {
    var result = this.instance.ownerInjection();

    assert.equal(result[_emberUtils.OWNER], this.instance, 'returns an object with the OWNER symbol');
  });
});
enifed('ember-runtime/tests/mixins/container_proxy_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/mixins/container_proxy_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/mixins/container_proxy_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/mixins/copyable_test', ['exports', 'ember-utils', 'ember-runtime/tests/suites/copyable', 'ember-runtime/mixins/copyable', 'ember-runtime/mixins/freezable', 'ember-runtime/system/object', 'ember-metal'], function (exports, _emberUtils, _emberRuntimeTestsSuitesCopyable, _emberRuntimeMixinsCopyable, _emberRuntimeMixinsFreezable, _emberRuntimeSystemObject, _emberMetal) {
  'use strict';

  QUnit.module('Ember.Copyable.frozenCopy');

  QUnit.test('should be deprecated', function () {
    expectDeprecation('`frozenCopy` is deprecated, use `Object.freeze` instead.');

    var Obj = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsFreezable.Freezable, _emberRuntimeMixinsCopyable.default, {
      copy: function () {
        return Obj.create();
      }
    });

    Obj.create().frozenCopy();
  });

  var CopyableObject = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsCopyable.default, {
    id: null,

    init: function () {
      this._super.apply(this, arguments);
      _emberMetal.set(this, 'id', _emberUtils.generateGuid());
    },

    copy: function () {
      var ret = new CopyableObject();
      _emberMetal.set(ret, 'id', _emberMetal.get(this, 'id'));
      return ret;
    }
  });

  _emberRuntimeTestsSuitesCopyable.default.extend({

    name: 'Copyable Basic Test',

    newObject: function () {
      return new CopyableObject();
    },

    isEqual: function (a, b) {
      if (!(a instanceof CopyableObject) || !(b instanceof CopyableObject)) {
        return false;
      }

      return _emberMetal.get(a, 'id') === _emberMetal.get(b, 'id');
    }
  }).run();
});
enifed('ember-runtime/tests/mixins/copyable_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/mixins/copyable_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/mixins/copyable_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/mixins/enumerable_test', ['exports', 'ember-runtime/tests/suites/enumerable', 'ember-runtime/system/object', 'ember-runtime/mixins/enumerable', 'ember-runtime/mixins/array', 'ember-runtime/system/native_array', 'ember-metal'], function (exports, _emberRuntimeTestsSuitesEnumerable, _emberRuntimeSystemObject, _emberRuntimeMixinsEnumerable, _emberRuntimeMixinsArray, _emberRuntimeSystemNative_array, _emberMetal) {
  'use strict';

  function K() {
    return this;
  }

  /*
    Implement a basic fake enumerable.  This validates that any non-native
    enumerable can impl this API.
  */
  var TestEnumerable = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsEnumerable.default, {
    _content: null,

    init: function () {
      var ary = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

      this._content = ary;
    },

    addObject: function (obj) {
      if (this._content.indexOf(obj) >= 0) {
        return this;
      }

      this._content.push(obj);
      this.enumerableContentDidChange();
    },

    nextObject: function (idx) {
      return idx >= _emberMetal.get(this, 'length') ? undefined : this._content[idx];
    },

    length: _emberMetal.computed(function () {
      return this._content.length;
    }),

    slice: function () {
      return this._content.slice();
    }

  });

  _emberRuntimeTestsSuitesEnumerable.default.extend({
    name: 'Basic Enumerable',

    newObject: function (ary) {
      ary = ary ? ary.slice() : this.newFixture(3);
      return new TestEnumerable(ary);
    },

    // allows for testing of the basic enumerable after an internal mutation
    mutate: function (obj) {
      obj.addObject(obj._content.length + 1);
    },

    toArray: function (obj) {
      return obj.slice();
    }

  }).run();

  QUnit.module('Ember.Enumerable');

  QUnit.test('should apply Ember.Array to return value of map', function () {
    var x = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsEnumerable.default).create();
    var y = x.map(K);
    equal(_emberRuntimeMixinsArray.default.detect(y), true, 'should have mixin applied');
  });

  QUnit.test('should apply Ember.Array to return value of filter', function () {
    var x = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsEnumerable.default).create();
    var y = x.filter(K);
    equal(_emberRuntimeMixinsArray.default.detect(y), true, 'should have mixin applied');
  });

  QUnit.test('should apply Ember.Array to return value of invoke', function () {
    var x = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsEnumerable.default).create();
    var y = x.invoke(K);
    equal(_emberRuntimeMixinsArray.default.detect(y), true, 'should have mixin applied');
  });

  QUnit.test('should apply Ember.Array to return value of toArray', function () {
    var x = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsEnumerable.default).create();
    var y = x.toArray(K);
    equal(_emberRuntimeMixinsArray.default.detect(y), true, 'should have mixin applied');
  });

  QUnit.test('should apply Ember.Array to return value of without', function () {
    var X = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsEnumerable.default, {
      contains: function () {
        return true;
      },
      includes: function () {
        return true;
      }
    });

    var x = X.create();
    var y = x.without(K);
    equal(_emberRuntimeMixinsArray.default.detect(y), true, 'should have mixin applied');
  });

  QUnit.test('should apply Ember.Array to return value of uniq', function () {
    var x = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsEnumerable.default).create();
    var y = x.uniq(K);
    equal(_emberRuntimeMixinsArray.default.detect(y), true, 'should have mixin applied');
  });

  QUnit.test('any', function () {
    var kittens = _emberRuntimeSystemNative_array.A([{
      color: 'white'
    }, {
      color: 'black'
    }, {
      color: 'white'
    }]);
    var foundWhite = kittens.any(function (kitten) {
      return kitten.color === 'white';
    });
    var foundWhite2 = kittens.isAny('color', 'white');

    equal(foundWhite, true);
    equal(foundWhite2, true);
  });

  QUnit.test('any with NaN', function () {
    var numbers = _emberRuntimeSystemNative_array.A([1, 2, NaN, 4]);

    var hasNaN = numbers.any(function (n) {
      return isNaN(n);
    });

    equal(hasNaN, true, 'works when matching NaN');
  });

  QUnit.test('every', function () {
    var allColorsKittens = _emberRuntimeSystemNative_array.A([{
      color: 'white'
    }, {
      color: 'black'
    }, {
      color: 'white'
    }]);
    var allWhiteKittens = _emberRuntimeSystemNative_array.A([{
      color: 'white'
    }, {
      color: 'white'
    }, {
      color: 'white'
    }]);
    var allWhite = false;
    var whiteKittenPredicate = function (kitten) {
      return kitten.color === 'white';
    };

    allWhite = allColorsKittens.every(whiteKittenPredicate);
    equal(allWhite, false);

    allWhite = allWhiteKittens.every(whiteKittenPredicate);
    equal(allWhite, true);

    allWhite = allColorsKittens.isEvery('color', 'white');
    equal(allWhite, false);

    allWhite = allWhiteKittens.isEvery('color', 'white');
    equal(allWhite, true);
  });

  QUnit.test('should throw an error passing a second argument to includes', function () {
    var x = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsEnumerable.default).create();

    equal(x.includes('any'), false);
    expectAssertion(function () {
      x.includes('any', 1);
    }, /Enumerable#includes cannot accept a second argument "startAt" as enumerable items are unordered./);
  });

  // ..........................................................
  // CONTENT DID CHANGE
  //

  var DummyEnum = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsEnumerable.default, {
    nextObject: function () {},
    length: 0
  });

  var obj = undefined,
      observer = undefined;

  // ..........................................................
  // NOTIFY ENUMERABLE PROPERTY
  //

  QUnit.module('mixins/enumerable/enumerableContentDidChange');

  QUnit.test('should notify observers of []', function () {
    var obj = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsEnumerable.default, {
      nextObject: function () {}, // avoid exceptions

      enumerablePropertyDidChange: _emberMetal.observer('[]', function () {
        this._count++;
      })
    }).create({
      _count: 0
    });

    equal(obj._count, 0, 'should not have invoked yet');
    obj.enumerableContentWillChange();
    obj.enumerableContentDidChange();
    equal(obj._count, 1, 'should have invoked');
  });

  // ..........................................................
  // NOTIFY CHANGES TO LENGTH
  //

  QUnit.module('notify observers of length', {
    setup: function () {
      obj = DummyEnum.extend({
        lengthDidChange: _emberMetal.observer('length', function () {
          this._after++;
        })
      }).create({
        _after: 0
      });

      equal(obj._after, 0, 'should not have fired yet');
    },

    teardown: function () {
      obj = null;
    }
  });

  QUnit.test('should notify observers when call with no params', function () {
    obj.enumerableContentWillChange();
    equal(obj._after, 0);

    obj.enumerableContentDidChange();
    equal(obj._after, 1);
  });

  // API variation that included items only
  QUnit.test('should not notify when passed arrays of same length', function () {
    var added = ['foo'];
    var removed = ['bar'];

    obj.enumerableContentWillChange(removed, added);
    equal(obj._after, 0);

    obj.enumerableContentDidChange(removed, added);
    equal(obj._after, 0);
  });

  QUnit.test('should notify when passed arrays of different length', function () {
    var added = ['foo'];
    var removed = ['bar', 'baz'];

    obj.enumerableContentWillChange(removed, added);
    equal(obj._after, 0);

    obj.enumerableContentDidChange(removed, added);
    equal(obj._after, 1);
  });

  // API variation passes indexes only
  QUnit.test('should not notify when passed with indexes', function () {
    obj.enumerableContentWillChange(1, 1);
    equal(obj._after, 0);

    obj.enumerableContentDidChange(1, 1);
    equal(obj._after, 0);
  });

  QUnit.test('should notify when passed old index API with delta', function () {
    obj.enumerableContentWillChange(1, 2);
    equal(obj._after, 0);

    obj.enumerableContentDidChange(1, 2);
    equal(obj._after, 1);
  });

  // ..........................................................
  // NOTIFY ENUMERABLE OBSERVER
  //

  QUnit.module('notify enumerable observers', {
    setup: function () {
      obj = DummyEnum.create();

      observer = _emberRuntimeSystemObject.default.extend({
        enumerableWillChange: function () {
          equal(this._before, null); // should only call once
          this._before = Array.prototype.slice.call(arguments);
        },

        enumerableDidChange: function () {
          equal(this._after, null); // should only call once
          this._after = Array.prototype.slice.call(arguments);
        }
      }).create({
        _before: null,
        _after: null
      });

      obj.addEnumerableObserver(observer);
    },

    teardown: function () {
      obj = observer = null;
    }
  });

  QUnit.test('should notify enumerable observers when called with no params', function () {
    obj.enumerableContentWillChange();
    deepEqual(observer._before, [obj, null, null]);

    obj.enumerableContentDidChange();
    deepEqual(observer._after, [obj, null, null]);
  });

  // API variation that included items only
  QUnit.test('should notify when called with same length items', function () {
    var added = ['foo'];
    var removed = ['bar'];

    obj.enumerableContentWillChange(removed, added);
    deepEqual(observer._before, [obj, removed, added]);

    obj.enumerableContentDidChange(removed, added);
    deepEqual(observer._after, [obj, removed, added]);
  });

  QUnit.test('should notify when called with diff length items', function () {
    var added = ['foo', 'baz'];
    var removed = ['bar'];

    obj.enumerableContentWillChange(removed, added);
    deepEqual(observer._before, [obj, removed, added]);

    obj.enumerableContentDidChange(removed, added);
    deepEqual(observer._after, [obj, removed, added]);
  });

  QUnit.test('should not notify when passed with indexes only', function () {
    obj.enumerableContentWillChange(1, 2);
    deepEqual(observer._before, [obj, 1, 2]);

    obj.enumerableContentDidChange(1, 2);
    deepEqual(observer._after, [obj, 1, 2]);
  });

  QUnit.test('removing enumerable observer should disable', function () {
    obj.removeEnumerableObserver(observer);
    obj.enumerableContentWillChange();
    deepEqual(observer._before, null);

    obj.enumerableContentDidChange();
    deepEqual(observer._after, null);
  });
});
enifed('ember-runtime/tests/mixins/enumerable_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/mixins/enumerable_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/mixins/enumerable_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/mixins/freezable_test', ['exports', 'ember-runtime/system/object', 'ember-runtime/mixins/freezable'], function (exports, _emberRuntimeSystemObject, _emberRuntimeMixinsFreezable) {
  'use strict';

  QUnit.module('Ember.Freezable');

  QUnit.test('should be deprecated', function () {
    expectDeprecation('`Ember.Freezable` is deprecated, use `Object.freeze` instead.');
    _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsFreezable.Freezable).create();
  });
});
enifed('ember-runtime/tests/mixins/freezable_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/mixins/freezable_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/mixins/freezable_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/mixins/mutable_array_test', ['exports', 'ember-metal', 'ember-runtime/tests/suites/mutable_array', 'ember-runtime/mixins/mutable_array', 'ember-runtime/system/object', 'ember-runtime/system/native_array', 'ember-runtime/mixins/array'], function (exports, _emberMetal, _emberRuntimeTestsSuitesMutable_array, _emberRuntimeMixinsMutable_array, _emberRuntimeSystemObject, _emberRuntimeSystemNative_array, _emberRuntimeMixinsArray) {
  'use strict';

  /*
    Implement a basic fake mutable array.  This validates that any non-native
    enumerable can impl this API.
  */
  var TestMutableArray = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsMutable_array.default, {

    _content: null,

    init: function () {
      var ary = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];

      this._content = _emberRuntimeSystemNative_array.A(ary);
    },

    replace: function (idx, amt, objects) {
      var args = objects ? objects.slice() : [];
      var removeAmt = amt;
      var addAmt = args.length;

      _emberRuntimeMixinsArray.arrayContentWillChange(this, idx, removeAmt, addAmt);

      args.unshift(amt);
      args.unshift(idx);
      this._content.splice.apply(this._content, args);
      _emberRuntimeMixinsArray.arrayContentDidChange(this, idx, removeAmt, addAmt);
      return this;
    },

    objectAt: function (idx) {
      return this._content[idx];
    },

    length: _emberMetal.computed(function () {
      return this._content.length;
    }),

    slice: function () {
      return this._content.slice();
    }

  });

  _emberRuntimeTestsSuitesMutable_array.default.extend({

    name: 'Basic Mutable Array',

    newObject: function (ary) {
      ary = ary ? ary.slice() : this.newFixture(3);
      return new TestMutableArray(ary);
    },

    // allows for testing of the basic enumerable after an internal mutation
    mutate: function (obj) {
      obj.addObject(this.getFixture(1)[0]);
    },

    toArray: function (obj) {
      return obj.slice();
    }

  }).run();
});
enifed('ember-runtime/tests/mixins/mutable_array_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/mixins/mutable_array_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/mixins/mutable_array_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/mixins/mutable_enumerable_test', ['exports', 'ember-runtime/tests/suites/mutable_enumerable', 'ember-runtime/mixins/mutable_enumerable', 'ember-runtime/system/object', 'ember-metal'], function (exports, _emberRuntimeTestsSuitesMutable_enumerable, _emberRuntimeMixinsMutable_enumerable, _emberRuntimeSystemObject, _emberMetal) {
  'use strict';

  /*
    Implement a basic fake mutable array.  This validates that any non-native
    enumerable can impl this API.
  */
  var TestMutableEnumerable = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsMutable_enumerable.default, {
    _content: null,

    addObject: function (obj) {
      if (this._content.indexOf(obj) >= 0) {
        return this;
      }

      this.enumerableContentWillChange(null, [obj]);
      this._content.push(obj);
      this.enumerableContentDidChange(null, [obj]);
    },

    removeObject: function (obj) {
      var idx = this._content.indexOf(obj);
      if (idx < 0) {
        return this;
      }

      this.enumerableContentWillChange([obj], null);
      this._content.splice(idx, 1);
      this.enumerableContentDidChange([obj], null);
      return this;
    },

    init: function (ary) {
      this._content = ary || [];
    },

    nextObject: function (idx) {
      return idx >= _emberMetal.get(this, 'length') ? undefined : this._content[idx];
    },

    length: _emberMetal.computed(function () {
      return this._content.length;
    }),

    slice: function () {
      return this._content.slice();
    }
  });

  _emberRuntimeTestsSuitesMutable_enumerable.default.extend({
    name: 'Basic Mutable Array',

    newObject: function (ary) {
      ary = ary ? ary.slice() : this.newFixture(3);
      return new TestMutableEnumerable(ary);
    },

    // allows for testing of the basic enumerable after an internal mutation
    mutate: function (obj) {
      obj.addObject(this.getFixture(1)[0]);
    },

    toArray: function (obj) {
      return obj.slice();
    }
  }).run();
});
enifed('ember-runtime/tests/mixins/mutable_enumerable_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/mixins/mutable_enumerable_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/mixins/mutable_enumerable_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/mixins/observable_test', ['exports', 'ember-metal', 'internal-test-helpers', 'ember-runtime/system/object'], function (exports, _emberMetal, _internalTestHelpers, _emberRuntimeSystemObject) {
  'use strict';

  QUnit.module('mixins/observable');

  QUnit.test('should be able to use getProperties to get a POJO of provided keys', function () {
    var obj = _emberRuntimeSystemObject.default.create({
      firstName: 'Steve',
      lastName: 'Jobs',
      companyName: 'Apple, Inc.'
    });

    var pojo = obj.getProperties('firstName', 'lastName');
    equal('Steve', pojo.firstName);
    equal('Jobs', pojo.lastName);
  });

  QUnit.test('should be able to use getProperties with array parameter to get a POJO of provided keys', function () {
    var obj = _emberRuntimeSystemObject.default.create({
      firstName: 'Steve',
      lastName: 'Jobs',
      companyName: 'Apple, Inc.'
    });

    var pojo = obj.getProperties(['firstName', 'lastName']);
    equal('Steve', pojo.firstName);
    equal('Jobs', pojo.lastName);
  });

  QUnit.test('should be able to use setProperties to set multiple properties at once', function () {
    var obj = _emberRuntimeSystemObject.default.create({
      firstName: 'Steve',
      lastName: 'Jobs',
      companyName: 'Apple, Inc.'
    });

    obj.setProperties({ firstName: 'Tim', lastName: 'Cook' });
    equal('Tim', obj.get('firstName'));
    equal('Cook', obj.get('lastName'));
  });

  _internalTestHelpers.testBoth('calling setProperties completes safely despite exceptions', function (get, set) {
    var exc = new Error('Something unexpected happened!');
    var obj = _emberRuntimeSystemObject.default.extend({
      companyName: _emberMetal.computed({
        get: function () {
          return 'Apple, Inc.';
        },
        set: function (key, value) {
          throw exc;
        }
      })
    }).create({
      firstName: 'Steve',
      lastName: 'Jobs'
    });

    var firstNameChangedCount = 0;

    _emberMetal.addObserver(obj, 'firstName', function () {
      return firstNameChangedCount++;
    });

    try {
      obj.setProperties({
        firstName: 'Tim',
        lastName: 'Cook',
        companyName: 'Fruit Co., Inc.'
      });
    } catch (err) {
      if (err !== exc) {
        throw err;
      }
    }

    equal(firstNameChangedCount, 1, 'firstName should have fired once');
  });

  _internalTestHelpers.testBoth('should be able to retrieve cached values of computed properties without invoking the computed property', function (get) {
    var obj = _emberRuntimeSystemObject.default.extend({
      foo: _emberMetal.computed(function () {
        return 'foo';
      })
    }).create({
      bar: 'bar'
    });

    equal(obj.cacheFor('foo'), undefined, 'should return undefined if no value has been cached');
    get(obj, 'foo');

    equal(get(obj, 'foo'), 'foo', 'precond - should cache the value');
    equal(obj.cacheFor('foo'), 'foo', 'should return the cached value after it is invoked');

    equal(obj.cacheFor('bar'), undefined, 'returns undefined if the value is not a computed property');
  });

  QUnit.test('incrementProperty should work even if value is number in string', function () {
    var obj = _emberRuntimeSystemObject.default.create({
      age: '24'
    });
    obj.incrementProperty('age');
    equal(25, obj.get('age'));
  });
});
enifed('ember-runtime/tests/mixins/observable_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/mixins/observable_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/mixins/observable_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/mixins/promise_proxy_test', ['exports', 'ember-metal', 'ember-runtime/system/object_proxy', 'ember-runtime/mixins/promise_proxy', 'ember-runtime/ext/rsvp', 'rsvp'], function (exports, _emberMetal, _emberRuntimeSystemObject_proxy, _emberRuntimeMixinsPromise_proxy, _emberRuntimeExtRsvp, _rsvp) {
  'use strict';

  var ObjectPromiseProxy = undefined;

  QUnit.test('present on ember namespace', function () {
    ok(_emberRuntimeMixinsPromise_proxy.default, 'expected PromiseProxyMixin to exist');
  });

  QUnit.module('Ember.PromiseProxy - ObjectProxy', {
    setup: function () {
      ObjectPromiseProxy = _emberRuntimeSystemObject_proxy.default.extend(_emberRuntimeMixinsPromise_proxy.default);
    },

    teardown: function () {
      _rsvp.on('error', _emberRuntimeExtRsvp.onerrorDefault);
    }
  });

  QUnit.test('no promise, invoking then should raise', function () {
    var proxy = ObjectPromiseProxy.create();

    throws(function () {
      proxy.then(function () {
        return this;
      }, function () {
        return this;
      });
    }, new RegExp('PromiseProxy\'s promise must be set'));
  });

  QUnit.test('fulfillment', function () {
    var value = {
      firstName: 'stef',
      lastName: 'penner'
    };

    var deferred = _rsvp.defer();

    var proxy = ObjectPromiseProxy.create({
      promise: deferred.promise
    });

    var didFulfillCount = 0;
    var didRejectCount = 0;

    proxy.then(function () {
      return didFulfillCount++;
    }, function () {
      return didRejectCount++;
    });

    equal(_emberMetal.get(proxy, 'content'), undefined, 'expects the proxy to have no content');
    equal(_emberMetal.get(proxy, 'reason'), undefined, 'expects the proxy to have no reason');
    equal(_emberMetal.get(proxy, 'isPending'), true, 'expects the proxy to indicate that it is loading');
    equal(_emberMetal.get(proxy, 'isSettled'), false, 'expects the proxy to indicate that it is not settled');
    equal(_emberMetal.get(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
    equal(_emberMetal.get(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');

    equal(didFulfillCount, 0, 'should not yet have been fulfilled');
    equal(didRejectCount, 0, 'should not yet have been rejected');

    _emberMetal.run(deferred, 'resolve', value);

    equal(didFulfillCount, 1, 'should have been fulfilled');
    equal(didRejectCount, 0, 'should not have been rejected');

    equal(_emberMetal.get(proxy, 'content'), value, 'expects the proxy to have content');
    equal(_emberMetal.get(proxy, 'reason'), undefined, 'expects the proxy to still have no reason');
    equal(_emberMetal.get(proxy, 'isPending'), false, 'expects the proxy to indicate that it is no longer loading');
    equal(_emberMetal.get(proxy, 'isSettled'), true, 'expects the proxy to indicate that it is settled');
    equal(_emberMetal.get(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
    equal(_emberMetal.get(proxy, 'isFulfilled'), true, 'expects the proxy to indicate that it is fulfilled');

    _emberMetal.run(deferred, 'resolve', value);

    equal(didFulfillCount, 1, 'should still have been only fulfilled once');
    equal(didRejectCount, 0, 'should still not have been rejected');

    _emberMetal.run(deferred, 'reject', value);

    equal(didFulfillCount, 1, 'should still have been only fulfilled once');
    equal(didRejectCount, 0, 'should still not have been rejected');

    equal(_emberMetal.get(proxy, 'content'), value, 'expects the proxy to have still have same content');
    equal(_emberMetal.get(proxy, 'reason'), undefined, 'expects the proxy still to have no reason');
    equal(_emberMetal.get(proxy, 'isPending'), false, 'expects the proxy to indicate that it is no longer loading');
    equal(_emberMetal.get(proxy, 'isSettled'), true, 'expects the proxy to indicate that it is settled');
    equal(_emberMetal.get(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
    equal(_emberMetal.get(proxy, 'isFulfilled'), true, 'expects the proxy to indicate that it is fulfilled');

    // rest of the promise semantics are tested in directly in RSVP
  });

  QUnit.test('rejection', function () {
    var reason = new Error('failure');
    var deferred = _rsvp.defer();
    var proxy = ObjectPromiseProxy.create({
      promise: deferred.promise
    });

    var didFulfillCount = 0;
    var didRejectCount = 0;

    proxy.then(function () {
      return didFulfillCount++;
    }, function () {
      return didRejectCount++;
    });

    equal(_emberMetal.get(proxy, 'content'), undefined, 'expects the proxy to have no content');
    equal(_emberMetal.get(proxy, 'reason'), undefined, 'expects the proxy to have no reason');
    equal(_emberMetal.get(proxy, 'isPending'), true, 'expects the proxy to indicate that it is loading');
    equal(_emberMetal.get(proxy, 'isSettled'), false, 'expects the proxy to indicate that it is not settled');
    equal(_emberMetal.get(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
    equal(_emberMetal.get(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');

    equal(didFulfillCount, 0, 'should not yet have been fulfilled');
    equal(didRejectCount, 0, 'should not yet have been rejected');

    _emberMetal.run(deferred, 'reject', reason);

    equal(didFulfillCount, 0, 'should not yet have been fulfilled');
    equal(didRejectCount, 1, 'should have been rejected');

    equal(_emberMetal.get(proxy, 'content'), undefined, 'expects the proxy to have no content');
    equal(_emberMetal.get(proxy, 'reason'), reason, 'expects the proxy to have a reason');
    equal(_emberMetal.get(proxy, 'isPending'), false, 'expects the proxy to indicate that it is not longer loading');
    equal(_emberMetal.get(proxy, 'isSettled'), true, 'expects the proxy to indicate that it is settled');
    equal(_emberMetal.get(proxy, 'isRejected'), true, 'expects the proxy to indicate that it is  rejected');
    equal(_emberMetal.get(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');

    _emberMetal.run(deferred, 'reject', reason);

    equal(didFulfillCount, 0, 'should stll not yet have been fulfilled');
    equal(didRejectCount, 1, 'should still remain rejected');

    _emberMetal.run(deferred, 'resolve', 1);

    equal(didFulfillCount, 0, 'should stll not yet have been fulfilled');
    equal(didRejectCount, 1, 'should still remain rejected');

    equal(_emberMetal.get(proxy, 'content'), undefined, 'expects the proxy to have no content');
    equal(_emberMetal.get(proxy, 'reason'), reason, 'expects the proxy to have a reason');
    equal(_emberMetal.get(proxy, 'isPending'), false, 'expects the proxy to indicate that it is not longer loading');
    equal(_emberMetal.get(proxy, 'isSettled'), true, 'expects the proxy to indicate that it is settled');
    equal(_emberMetal.get(proxy, 'isRejected'), true, 'expects the proxy to indicate that it is  rejected');
    equal(_emberMetal.get(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');
  });

  QUnit.test('unhandled rejects still propagate to RSVP.on(\'error\', ...) ', function () {
    expect(1);

    _rsvp.on('error', onerror);
    _rsvp.off('error', _emberRuntimeExtRsvp.onerrorDefault);

    var expectedReason = new Error('failure');
    var deferred = _rsvp.defer();

    var proxy = ObjectPromiseProxy.create({
      promise: deferred.promise
    });

    proxy.get('promise');

    function onerror(reason) {
      equal(reason, expectedReason, 'expected reason');
    }

    _rsvp.on('error', onerror);
    _rsvp.off('error', _emberRuntimeExtRsvp.onerrorDefault);

    _emberMetal.run(deferred, 'reject', expectedReason);

    _rsvp.on('error', _emberRuntimeExtRsvp.onerrorDefault);
    _rsvp.off('error', onerror);

    _emberMetal.run(deferred, 'reject', expectedReason);

    _rsvp.on('error', _emberRuntimeExtRsvp.onerrorDefault);
    _rsvp.off('error', onerror);
  });

  QUnit.test('should work with promise inheritance', function () {
    function PromiseSubclass() {
      _rsvp.Promise.apply(this, arguments);
    }

    PromiseSubclass.prototype = Object.create(_rsvp.Promise.prototype);
    PromiseSubclass.prototype.constructor = PromiseSubclass;
    PromiseSubclass.cast = _rsvp.Promise.cast;

    var proxy = ObjectPromiseProxy.create({
      promise: new PromiseSubclass(function () {})
    });

    ok(proxy.then() instanceof PromiseSubclass, 'promise proxy respected inheritance');
  });

  QUnit.test('should reset isFulfilled and isRejected when promise is reset', function () {
    var deferred = _emberRuntimeExtRsvp.default.defer();

    var proxy = ObjectPromiseProxy.create({
      promise: deferred.promise
    });

    equal(_emberMetal.get(proxy, 'isPending'), true, 'expects the proxy to indicate that it is loading');
    equal(_emberMetal.get(proxy, 'isSettled'), false, 'expects the proxy to indicate that it is not settled');
    equal(_emberMetal.get(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
    equal(_emberMetal.get(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');

    _emberMetal.run(deferred, 'resolve');

    equal(_emberMetal.get(proxy, 'isPending'), false, 'expects the proxy to indicate that it is no longer loading');
    equal(_emberMetal.get(proxy, 'isSettled'), true, 'expects the proxy to indicate that it is settled');
    equal(_emberMetal.get(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
    equal(_emberMetal.get(proxy, 'isFulfilled'), true, 'expects the proxy to indicate that it is fulfilled');

    var anotherDeferred = _emberRuntimeExtRsvp.default.defer();
    proxy.set('promise', anotherDeferred.promise);

    equal(_emberMetal.get(proxy, 'isPending'), true, 'expects the proxy to indicate that it is loading');
    equal(_emberMetal.get(proxy, 'isSettled'), false, 'expects the proxy to indicate that it is not settled');
    equal(_emberMetal.get(proxy, 'isRejected'), false, 'expects the proxy to indicate that it is not rejected');
    equal(_emberMetal.get(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');

    _emberMetal.run(anotherDeferred, 'reject');

    equal(_emberMetal.get(proxy, 'isPending'), false, 'expects the proxy to indicate that it is not longer loading');
    equal(_emberMetal.get(proxy, 'isSettled'), true, 'expects the proxy to indicate that it is settled');
    equal(_emberMetal.get(proxy, 'isRejected'), true, 'expects the proxy to indicate that it is  rejected');
    equal(_emberMetal.get(proxy, 'isFulfilled'), false, 'expects the proxy to indicate that it is not fulfilled');
  });

  QUnit.test('should have content when isFulfilled is set', function () {
    var deferred = _emberRuntimeExtRsvp.default.defer();

    var proxy = ObjectPromiseProxy.create({
      promise: deferred.promise
    });

    proxy.addObserver('isFulfilled', function () {
      return equal(_emberMetal.get(proxy, 'content'), true);
    });

    _emberMetal.run(deferred, 'resolve', true);
  });

  QUnit.test('should have reason when isRejected is set', function () {
    var error = new Error('Y U REJECT?!?');
    var deferred = _emberRuntimeExtRsvp.default.defer();

    var proxy = ObjectPromiseProxy.create({
      promise: deferred.promise
    });

    proxy.addObserver('isRejected', function () {
      return equal(_emberMetal.get(proxy, 'reason'), error);
    });

    try {
      _emberMetal.run(deferred, 'reject', error);
    } catch (e) {
      equal(e, error);
    }
  });

  QUnit.test('should not error if promise is resolved after proxy has been destroyed', function () {
    var deferred = _emberRuntimeExtRsvp.default.defer();

    var proxy = ObjectPromiseProxy.create({
      promise: deferred.promise
    });

    proxy.then(function () {}, function () {});

    _emberMetal.run(proxy, 'destroy');

    _emberMetal.run(deferred, 'resolve', true);

    ok(true, 'resolving the promise after the proxy has been destroyed does not raise an error');
  });

  QUnit.test('should not error if promise is rejected after proxy has been destroyed', function () {
    var deferred = _emberRuntimeExtRsvp.default.defer();

    var proxy = ObjectPromiseProxy.create({
      promise: deferred.promise
    });

    proxy.then(function () {}, function () {});

    _emberMetal.run(proxy, 'destroy');

    _emberMetal.run(deferred, 'reject', 'some reason');

    ok(true, 'rejecting the promise after the proxy has been destroyed does not raise an error');
  });

  QUnit.test('promise chain is not broken if promised is resolved after proxy has been destroyed', function () {
    var deferred = _emberRuntimeExtRsvp.default.defer();
    var expectedValue = {};
    var receivedValue = undefined;
    var didResolveCount = 0;

    var proxy = ObjectPromiseProxy.create({
      promise: deferred.promise
    });

    proxy.then(function (value) {
      receivedValue = value;
      didResolveCount++;
    }, function () {});

    _emberMetal.run(proxy, 'destroy');

    _emberMetal.run(deferred, 'resolve', expectedValue);

    equal(didResolveCount, 1, 'callback called');
    equal(receivedValue, expectedValue, 'passed value is the value the promise was resolved with');
  });

  QUnit.test('promise chain is not broken if promised is rejected after proxy has been destroyed', function () {
    var deferred = _emberRuntimeExtRsvp.default.defer();
    var expectedReason = 'some reason';
    var receivedReason = undefined;
    var didRejectCount = 0;

    var proxy = ObjectPromiseProxy.create({
      promise: deferred.promise
    });

    proxy.then(function () {}, function (reason) {
      receivedReason = reason;
      didRejectCount++;
    });

    _emberMetal.run(proxy, 'destroy');

    _emberMetal.run(deferred, 'reject', expectedReason);

    equal(didRejectCount, 1, 'callback called');
    equal(receivedReason, expectedReason, 'passed reason is the reason the promise was rejected for');
  });
});
enifed('ember-runtime/tests/mixins/promise_proxy_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/mixins/promise_proxy_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/mixins/promise_proxy_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/mixins/target_action_support_test', ['exports', 'ember-environment', 'ember-runtime/system/object', 'ember-runtime/mixins/target_action_support'], function (exports, _emberEnvironment, _emberRuntimeSystemObject, _emberRuntimeMixinsTarget_action_support) {
  'use strict';

  var originalLookup = _emberEnvironment.context.lookup;
  var lookup = undefined;

  QUnit.module('TargetActionSupport', {
    setup: function () {
      _emberEnvironment.context.lookup = lookup = {};
    },
    teardown: function () {
      _emberEnvironment.context.lookup = originalLookup;
    }
  });

  QUnit.test('it should return false if no target or action are specified', function () {
    expect(1);

    var obj = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsTarget_action_support.default).create();

    ok(false === obj.triggerAction(), 'no target or action was specified');
  });

  QUnit.test('it should support actions specified as strings', function () {
    expect(2);

    var obj = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsTarget_action_support.default).create({
      target: _emberRuntimeSystemObject.default.create({
        anEvent: function () {
          ok(true, 'anEvent method was called');
        }
      }),

      action: 'anEvent'
    });

    ok(true === obj.triggerAction(), 'a valid target and action were specified');
  });

  QUnit.test('it should invoke the send() method on objects that implement it', function () {
    expect(3);

    var obj = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsTarget_action_support.default).create({
      target: _emberRuntimeSystemObject.default.create({
        send: function (evt, context) {
          equal(evt, 'anEvent', 'send() method was invoked with correct event name');
          equal(context, obj, 'send() method was invoked with correct context');
        }
      }),

      action: 'anEvent'
    });

    ok(true === obj.triggerAction(), 'a valid target and action were specified');
  });

  QUnit.test('it should find targets specified using a property path', function () {
    expect(2);

    var Test = {};
    lookup.Test = Test;

    Test.targetObj = _emberRuntimeSystemObject.default.create({
      anEvent: function () {
        ok(true, 'anEvent method was called on global object');
      }
    });

    var myObj = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsTarget_action_support.default).create({
      target: 'Test.targetObj',
      action: 'anEvent'
    });

    ok(true === myObj.triggerAction(), 'a valid target and action were specified');
  });

  QUnit.test('it should use an actionContext object specified as a property on the object', function () {
    expect(2);
    var obj = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsTarget_action_support.default).create({
      action: 'anEvent',
      actionContext: {},
      target: _emberRuntimeSystemObject.default.create({
        anEvent: function (ctx) {
          ok(obj.actionContext === ctx, 'anEvent method was called with the expected context');
        }
      })
    });
    ok(true === obj.triggerAction(), 'a valid target and action were specified');
  });

  QUnit.test('it should find an actionContext specified as a property path', function () {
    expect(2);

    var Test = {};
    lookup.Test = Test;
    Test.aContext = {};

    var obj = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsTarget_action_support.default).create({
      action: 'anEvent',
      actionContext: 'Test.aContext',
      target: _emberRuntimeSystemObject.default.create({
        anEvent: function (ctx) {
          ok(Test.aContext === ctx, 'anEvent method was called with the expected context');
        }
      })
    });

    ok(true === obj.triggerAction(), 'a valid target and action were specified');
  });

  QUnit.test('it should use the target specified in the argument', function () {
    expect(2);
    var targetObj = _emberRuntimeSystemObject.default.create({
      anEvent: function () {
        ok(true, 'anEvent method was called');
      }
    });
    var obj = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsTarget_action_support.default).create({
      action: 'anEvent'
    });

    ok(true === obj.triggerAction({ target: targetObj }), 'a valid target and action were specified');
  });

  QUnit.test('it should use the action specified in the argument', function () {
    expect(2);

    var obj = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsTarget_action_support.default).create({
      target: _emberRuntimeSystemObject.default.create({
        anEvent: function () {
          ok(true, 'anEvent method was called');
        }
      })
    });
    ok(true === obj.triggerAction({ action: 'anEvent' }), 'a valid target and action were specified');
  });

  QUnit.test('it should use the actionContext specified in the argument', function () {
    expect(2);
    var context = {};
    var obj = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsTarget_action_support.default).create({
      target: _emberRuntimeSystemObject.default.create({
        anEvent: function (ctx) {
          ok(context === ctx, 'anEvent method was called with the expected context');
        }
      }),
      action: 'anEvent'
    });

    ok(true === obj.triggerAction({ actionContext: context }), 'a valid target and action were specified');
  });

  QUnit.test('it should allow multiple arguments from actionContext', function () {
    expect(3);
    var param1 = 'someParam';
    var param2 = 'someOtherParam';
    var obj = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsTarget_action_support.default).create({
      target: _emberRuntimeSystemObject.default.create({
        anEvent: function (first, second) {
          ok(first === param1, 'anEvent method was called with the expected first argument');
          ok(second === param2, 'anEvent method was called with the expected second argument');
        }
      }),
      action: 'anEvent'
    });

    ok(true === obj.triggerAction({ actionContext: [param1, param2] }), 'a valid target and action were specified');
  });

  QUnit.test('it should use a null value specified in the actionContext argument', function () {
    expect(2);
    var obj = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsTarget_action_support.default).create({
      target: _emberRuntimeSystemObject.default.create({
        anEvent: function (ctx) {
          ok(null === ctx, 'anEvent method was called with the expected context (null)');
        }
      }),
      action: 'anEvent'
    });
    ok(true === obj.triggerAction({ actionContext: null }), 'a valid target and action were specified');
  });
});
enifed('ember-runtime/tests/mixins/target_action_support_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/mixins/target_action_support_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/mixins/target_action_support_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/array', ['exports', 'ember-runtime/tests/suites/enumerable', 'ember-runtime/tests/suites/array/indexOf', 'ember-runtime/tests/suites/array/lastIndexOf', 'ember-runtime/tests/suites/array/objectAt', 'ember-runtime/tests/suites/array/includes', 'ember-runtime/mixins/array'], function (exports, _emberRuntimeTestsSuitesEnumerable, _emberRuntimeTestsSuitesArrayIndexOf, _emberRuntimeTestsSuitesArrayLastIndexOf, _emberRuntimeTestsSuitesArrayObjectAt, _emberRuntimeTestsSuitesArrayIncludes, _emberRuntimeMixinsArray) {
  'use strict';

  var ObserverClass = _emberRuntimeTestsSuitesEnumerable.ObserverClass.extend({
    observeArray: function (obj) {
      _emberRuntimeMixinsArray.addArrayObserver(obj, this);
      return this;
    },

    stopObserveArray: function (obj) {
      _emberRuntimeMixinsArray.removeArrayObserver(obj, this);
      return this;
    },

    arrayWillChange: function () {
      equal(this._before, null, 'should only call once');
      this._before = Array.prototype.slice.call(arguments);
    },

    arrayDidChange: function () {
      equal(this._after, null, 'should only call once');
      this._after = Array.prototype.slice.call(arguments);
    }
  });

  var ArrayTests = _emberRuntimeTestsSuitesEnumerable.EnumerableTests.extend({
    observerClass: ObserverClass
  });

  ArrayTests.ObserverClass = ObserverClass;

  ArrayTests.importModuleTests(_emberRuntimeTestsSuitesArrayIndexOf.default);
  ArrayTests.importModuleTests(_emberRuntimeTestsSuitesArrayLastIndexOf.default);
  ArrayTests.importModuleTests(_emberRuntimeTestsSuitesArrayObjectAt.default);

  ArrayTests.importModuleTests(_emberRuntimeTestsSuitesArrayIncludes.default);

  exports.ArrayTests = ArrayTests;
  exports.ObserverClass = ObserverClass;
});
enifed('ember-runtime/tests/suites/array.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/array.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/array.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/array/includes', ['exports', 'ember-runtime/tests/suites/suite'], function (exports, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('includes');

  suite.test('includes returns correct value if startAt is positive', function () {
    var data = this.newFixture(3);
    var obj = this.newObject(data);

    equal(obj.includes(data[1], 1), true, 'should return true if included');
    equal(obj.includes(data[0], 1), false, 'should return false if not included');
  });

  suite.test('includes returns correct value if startAt is negative', function () {
    var data = this.newFixture(3);
    var obj = this.newObject(data);

    equal(obj.includes(data[1], -2), true, 'should return true if included');
    equal(obj.includes(data[0], -2), false, 'should return false if not included');
  });

  suite.test('includes returns true if startAt + length is still negative', function () {
    var data = this.newFixture(1);
    var obj = this.newObject(data);

    equal(obj.includes(data[0], -2), true, 'should return true if included');
    equal(obj.includes(this.newFixture(1), -2), false, 'should return false if not included');
  });

  suite.test('includes returns false if startAt out of bounds', function () {
    var data = this.newFixture(1);
    var obj = this.newObject(data);

    equal(obj.includes(data[0], 2), false, 'should return false if startAt >= length');
    equal(obj.includes(this.newFixture(1), 2), false, 'should return false if startAt >= length');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/array/includes.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/array/includes.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/array/includes.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/array/indexOf', ['exports', 'ember-runtime/tests/suites/suite'], function (exports, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('indexOf');

  suite.test('should return index of object', function () {
    var expected = this.newFixture(3);
    var obj = this.newObject(expected);
    var len = 3;

    for (var idx = 0; idx < len; idx++) {
      equal(obj.indexOf(expected[idx]), idx, 'obj.indexOf(' + expected[idx] + ') should match idx');
    }
  });

  suite.test('should return -1 when requesting object not in index', function () {
    var obj = this.newObject(this.newFixture(3));
    var foo = {};

    equal(obj.indexOf(foo), -1, 'obj.indexOf(foo) should be < 0');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/array/indexOf.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/array/indexOf.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/array/indexOf.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/array/lastIndexOf', ['exports', 'ember-runtime/tests/suites/suite'], function (exports, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('lastIndexOf');

  suite.test('should return index of object\'s last occurrence', function () {
    var expected = this.newFixture(3);
    var obj = this.newObject(expected);
    var len = 3;

    for (var idx = 0; idx < len; idx++) {
      equal(obj.lastIndexOf(expected[idx]), idx, 'obj.lastIndexOf(' + expected[idx] + ') should match idx');
    }
  });

  suite.test('should return index of object\'s last occurrence even startAt search location is equal to length', function () {
    var expected = this.newFixture(3);
    var obj = this.newObject(expected);
    var len = 3;

    for (var idx = 0; idx < len; idx++) {
      equal(obj.lastIndexOf(expected[idx], len), idx, 'obj.lastIndexOfs(' + expected[idx] + ') should match idx');
    }
  });

  suite.test('should return index of object\'s last occurrence even startAt search location is greater than length', function () {
    var expected = this.newFixture(3);
    var obj = this.newObject(expected);
    var len = 3;

    for (var idx = 0; idx < len; idx++) {
      equal(obj.lastIndexOf(expected[idx], len + 1), idx, 'obj.lastIndexOf(' + expected[idx] + ') should match idx');
    }
  });

  suite.test('should return -1 when no match is found', function () {
    var obj = this.newObject(this.newFixture(3));
    var foo = {};

    equal(obj.lastIndexOf(foo), -1, 'obj.lastIndexOf(foo) should be -1');
  });

  suite.test('should return -1 when no match is found even startAt search location is equal to length', function () {
    var obj = this.newObject(this.newFixture(3));
    var foo = {};

    equal(obj.lastIndexOf(foo, obj.length), -1, 'obj.lastIndexOf(foo) should be -1');
  });

  suite.test('should return -1 when no match is found even startAt search location is greater than length', function () {
    var obj = this.newObject(this.newFixture(3));
    var foo = {};

    equal(obj.lastIndexOf(foo, obj.length + 1), -1, 'obj.lastIndexOf(foo) should be -1');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/array/lastIndexOf.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/array/lastIndexOf.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/array/lastIndexOf.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/array/objectAt', ['exports', 'ember-runtime/tests/suites/suite', 'ember-runtime/mixins/array'], function (exports, _emberRuntimeTestsSuitesSuite, _emberRuntimeMixinsArray) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('objectAt');

  suite.test('should return object at specified index', function () {
    var expected = this.newFixture(3);
    var obj = this.newObject(expected);
    var len = expected.length;

    for (var idx = 0; idx < len; idx++) {
      equal(_emberRuntimeMixinsArray.objectAt(obj, idx), expected[idx], 'obj.objectAt(' + idx + ') should match');
    }
  });

  suite.test('should return undefined when requesting objects beyond index', function () {
    var obj = undefined;

    obj = this.newObject(this.newFixture(3));
    equal(_emberRuntimeMixinsArray.objectAt(obj, 5), undefined, 'should return undefined for obj.objectAt(5) when len = 3');

    obj = this.newObject([]);
    equal(_emberRuntimeMixinsArray.objectAt(obj, 0), undefined, 'should return undefined for obj.objectAt(0) when len = 0');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/array/objectAt.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/array/objectAt.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/array/objectAt.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/copyable', ['exports', 'ember-runtime/tests/suites/suite', 'ember-runtime/tests/suites/copyable/copy', 'ember-runtime/tests/suites/copyable/frozenCopy'], function (exports, _emberRuntimeTestsSuitesSuite, _emberRuntimeTestsSuitesCopyableCopy, _emberRuntimeTestsSuitesCopyableFrozenCopy) {
  'use strict';

  var CopyableTests = _emberRuntimeTestsSuitesSuite.Suite.extend({

    /*
      __Required.__ You must implement this method to apply this mixin.
       Must be able to create a new object for testing.
       @returns {Object} object
    */
    newObject: null,

    /*
      __Required.__ You must implement this method to apply this mixin.
       Compares the two passed in objects.  Returns true if the two objects
      are logically equivalent.
       @param {Object} a
        First object
       @param {Object} b
        Second object
       @returns {Boolean}
    */
    isEqual: null,

    /*
      Set this to true if you expect the objects you test to be freezable.
      The suite will verify that your objects actually match this.  (i.e. if
      you say you can't test freezable it will verify that your objects really
      aren't freezable.)
       @type Boolean
    */
    shouldBeFreezable: false

  });

  CopyableTests.importModuleTests(_emberRuntimeTestsSuitesCopyableCopy.default);
  CopyableTests.importModuleTests(_emberRuntimeTestsSuitesCopyableFrozenCopy.default);

  exports.default = CopyableTests;
});
enifed('ember-runtime/tests/suites/copyable.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/copyable.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/copyable.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/copyable/copy', ['exports', 'ember-runtime/tests/suites/suite'], function (exports, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('copy');

  suite.test('should return an equivalent copy', function () {
    var obj = this.newObject();
    var copy = obj.copy();
    ok(this.isEqual(obj, copy), 'old object and new object should be equivalent');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/copyable/copy.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/copyable/copy.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/copyable/copy.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/copyable/frozenCopy', ['exports', 'ember-runtime/tests/suites/suite', 'ember-runtime/mixins/freezable', 'ember-metal'], function (exports, _emberRuntimeTestsSuitesSuite, _emberRuntimeMixinsFreezable, _emberMetal) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('frozenCopy');

  suite.test('frozen objects should return same instance', function () {
    var obj = undefined,
        copy = undefined;

    obj = this.newObject();
    if (_emberMetal.get(this, 'shouldBeFreezable')) {
      expectDeprecation('`frozenCopy` is deprecated, use Object.freeze instead.');

      ok(!_emberRuntimeMixinsFreezable.Freezable || _emberRuntimeMixinsFreezable.Freezable.detect(obj), 'object should be freezable');

      copy = obj.frozenCopy();
      ok(this.isEqual(obj, copy), 'new copy should be equal');
      ok(_emberMetal.get(copy, 'isFrozen'), 'returned value should be frozen');

      copy = obj.freeze().frozenCopy();
      equal(copy, obj, 'returns frozen object should be same');
      ok(_emberMetal.get(copy, 'isFrozen'), 'returned object should be frozen');
    } else {
      ok(!_emberRuntimeMixinsFreezable.Freezable || !_emberRuntimeMixinsFreezable.Freezable.detect(obj), 'object should not be freezable');
    }
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/copyable/frozenCopy.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/copyable/frozenCopy.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/copyable/frozenCopy.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable', ['exports', 'ember-utils', 'ember-runtime/tests/suites/suite', 'ember-runtime/system/object', 'ember-metal', 'ember-runtime/tests/suites/enumerable/any', 'ember-runtime/tests/suites/enumerable/is_any', 'ember-runtime/tests/suites/enumerable/compact', 'ember-runtime/tests/suites/enumerable/contains', 'ember-runtime/tests/suites/enumerable/includes', 'ember-runtime/tests/suites/enumerable/every', 'ember-runtime/tests/suites/enumerable/filter', 'ember-runtime/tests/suites/enumerable/find', 'ember-runtime/tests/suites/enumerable/firstObject', 'ember-runtime/tests/suites/enumerable/forEach', 'ember-runtime/tests/suites/enumerable/mapBy', 'ember-runtime/tests/suites/enumerable/invoke', 'ember-runtime/tests/suites/enumerable/lastObject', 'ember-runtime/tests/suites/enumerable/map', 'ember-runtime/tests/suites/enumerable/reduce', 'ember-runtime/tests/suites/enumerable/reject', 'ember-runtime/tests/suites/enumerable/sortBy', 'ember-runtime/tests/suites/enumerable/toArray', 'ember-runtime/tests/suites/enumerable/uniq', 'ember-runtime/tests/suites/enumerable/uniqBy', 'ember-runtime/tests/suites/enumerable/without'], function (exports, _emberUtils, _emberRuntimeTestsSuitesSuite, _emberRuntimeSystemObject, _emberMetal, _emberRuntimeTestsSuitesEnumerableAny, _emberRuntimeTestsSuitesEnumerableIs_any, _emberRuntimeTestsSuitesEnumerableCompact, _emberRuntimeTestsSuitesEnumerableContains, _emberRuntimeTestsSuitesEnumerableIncludes, _emberRuntimeTestsSuitesEnumerableEvery, _emberRuntimeTestsSuitesEnumerableFilter, _emberRuntimeTestsSuitesEnumerableFind, _emberRuntimeTestsSuitesEnumerableFirstObject, _emberRuntimeTestsSuitesEnumerableForEach, _emberRuntimeTestsSuitesEnumerableMapBy, _emberRuntimeTestsSuitesEnumerableInvoke, _emberRuntimeTestsSuitesEnumerableLastObject, _emberRuntimeTestsSuitesEnumerableMap, _emberRuntimeTestsSuitesEnumerableReduce, _emberRuntimeTestsSuitesEnumerableReject, _emberRuntimeTestsSuitesEnumerableSortBy, _emberRuntimeTestsSuitesEnumerableToArray, _emberRuntimeTestsSuitesEnumerableUniq, _emberRuntimeTestsSuitesEnumerableUniqBy, _emberRuntimeTestsSuitesEnumerableWithout) {
  'use strict';

  var ObserverClass = _emberRuntimeSystemObject.default.extend({
    _keysBefore: null,
    _keys: null,
    _values: null,
    _before: null,
    _after: null,

    isEnabled: true,

    init: function () {
      this._super.apply(this, arguments);
      this.reset();
    },

    propertyWillChange: function (target, key) {
      if (this._keysBefore[key] === undefined) {
        this._keysBefore[key] = 0;
      }
      this._keysBefore[key]++;
    },

    /*
      Invoked when the property changes.  Just records the parameters for
      later analysis.
    */
    propertyDidChange: function (target, key, value) {
      if (this._keys[key] === undefined) {
        this._keys[key] = 0;
      }
      this._keys[key]++;
      this._values[key] = value;
    },

    /*
      Resets the recorded results for another run.
       @returns {Object} receiver
    */
    reset: function () {
      this._keysBefore = {};
      this._keys = {};
      this._values = {};
      this._before = null;
      this._after = null;
      return this;
    },

    observeBefore: function (obj) {
      var keys = Array.prototype.slice.call(arguments, 1);
      var loc = keys.length;
      while (--loc >= 0) {
        _emberMetal._addBeforeObserver(obj, keys[loc], this, 'propertyWillChange');
      }

      return this;
    },

    /*
      Begins observing the passed key names on the passed object.  Any changes
      on the named properties will be recorded.
       @param {Ember.Enumerable} obj
        The enumerable to observe.
       @returns {Object} receiver
    */
    observe: function (obj) {
      if (obj.addObserver) {
        var keys = Array.prototype.slice.call(arguments, 1);
        var loc = keys.length;

        while (--loc >= 0) {
          obj.addObserver(keys[loc], this, 'propertyDidChange');
        }
      } else {
        this.isEnabled = false;
      }
      return this;
    },

    /*
      Returns true if the passed key was invoked.  If you pass a value as
      well then validates that the values match.
       @param {String} key
        Key to validate
       @param {Object} value
        (Optional) value
       @returns {Boolean}
    */
    validate: function (key, value) {
      if (!this.isEnabled) {
        return true;
      }

      if (!this._keys[key]) {
        return false;
      }

      if (arguments.length > 1) {
        return this._values[key] === value;
      } else {
        return true;
      }
    },

    /*
      Returns times the before observer as invoked.
       @param {String} key
        Key to check
    */
    timesCalledBefore: function (key) {
      return this._keysBefore[key] || 0;
    },

    /*
      Returns times the observer as invoked.
       @param {String} key
        Key to check
    */
    timesCalled: function (key) {
      return this._keys[key] || 0;
    },

    /*
      begins acting as an enumerable observer.
    */
    observeEnumerable: function (obj) {
      obj.addEnumerableObserver(this);
      return this;
    },

    stopObserveEnumerable: function (obj) {
      obj.removeEnumerableObserver(this);
      return this;
    },

    enumerableWillChange: function () {
      equal(this._before, null, 'should only call once');
      this._before = Array.prototype.slice.call(arguments);
    },

    enumerableDidChange: function () {
      equal(this._after, null, 'should only call once');
      this._after = Array.prototype.slice.call(arguments);
    }
  });

  var EnumerableTests = _emberRuntimeTestsSuitesSuite.Suite.extend({
    /*
      __Required.__ You must implement this method to apply this mixin.
       Implement to return a new enumerable object for testing.  Should accept
      either no parameters, a single number (indicating the desired length of
      the collection) or an array of objects.
       @param {Array} content
        An array of items to include in the enumerable optionally.
       @returns {Ember.Enumerable} a new enumerable
    */
    newObject: null,

    /*
      Implement to return a set of new fixture strings that can be applied to
      the enumerable.  This may be passed into the newObject method.
       @param {Number} count
        The number of items required.
       @returns {Array} array of strings
    */
    newFixture: function (cnt) {
      var ret = [];
      while (--cnt >= 0) {
        ret.push(_emberUtils.generateGuid());
      }

      return ret;
    },

    /*
      Implement to return a set of new fixture objects that can be applied to
      the enumerable.  This may be passed into the newObject method.
       @param {Number} cnt
        The number of items required.
       @returns {Array} array of objects
    */
    newObjectsFixture: function (cnt) {
      var ret = [];
      var item = undefined;
      while (--cnt >= 0) {
        item = {};
        _emberUtils.guidFor(item);
        ret.push(item);
      }
      return ret;
    },

    /*
      __Required.__ You must implement this method to apply this mixin.
       Implement accept an instance of the enumerable and return an array
      containing the objects in the enumerable.  This is used only for testing
      so performance is not important.
       @param {Ember.Enumerable} enumerable
        The enumerable to convert.
       @returns {Array} array of items
    */
    toArray: null,

    /*
      Implement this method if your object can mutate internally (even if it
      does not support the MutableEnumerable API).  The method should accept
      an object of your desired type and modify it somehow.  Suite tests will
      use this to ensure that all appropriate caches, etc. clear when the
      mutation occurs.
       If you do not define this optional method, then mutation-related tests
      will be skipped.
       @param {Ember.Enumerable} enumerable
        The enumerable to mutate
       @returns {void}
    */
    mutate: function () {},

    /*
      Becomes true when you define a new mutate() method, indicating that
      mutation tests should run.  This is calculated automatically.
       @type Boolean
    */
    canTestMutation: _emberMetal.computed(function () {
      return this.mutate !== EnumerableTests.prototype.mutate;
    }),

    /*
      Invoked to actually run the test - overridden by mixins
    */
    run: function () {},

    /*
      Creates a new observer object for testing.  You can add this object as an
      observer on an array and it will record results anytime it is invoked.
      After running the test, call the validate() method on the observer to
      validate the results.
    */
    newObserver: function (obj) {
      var ret = _emberMetal.get(this, 'observerClass').create();
      if (arguments.length > 0) {
        ret.observeBefore.apply(ret, arguments);
      }

      if (arguments.length > 0) {
        ret.observe.apply(ret, arguments);
      }

      return ret;
    },

    observerClass: ObserverClass
  });

  EnumerableTests.importModuleTests(_emberRuntimeTestsSuitesEnumerableAny.default);
  EnumerableTests.importModuleTests(_emberRuntimeTestsSuitesEnumerableIs_any.default);
  EnumerableTests.importModuleTests(_emberRuntimeTestsSuitesEnumerableCompact.default);
  EnumerableTests.importModuleTests(_emberRuntimeTestsSuitesEnumerableContains.default);
  EnumerableTests.importModuleTests(_emberRuntimeTestsSuitesEnumerableEvery.default);
  EnumerableTests.importModuleTests(_emberRuntimeTestsSuitesEnumerableFilter.default);
  EnumerableTests.importModuleTests(_emberRuntimeTestsSuitesEnumerableFind.default);
  EnumerableTests.importModuleTests(_emberRuntimeTestsSuitesEnumerableFirstObject.default);
  EnumerableTests.importModuleTests(_emberRuntimeTestsSuitesEnumerableForEach.default);
  EnumerableTests.importModuleTests(_emberRuntimeTestsSuitesEnumerableMapBy.default);
  EnumerableTests.importModuleTests(_emberRuntimeTestsSuitesEnumerableInvoke.default);
  EnumerableTests.importModuleTests(_emberRuntimeTestsSuitesEnumerableLastObject.default);
  EnumerableTests.importModuleTests(_emberRuntimeTestsSuitesEnumerableMap.default);
  EnumerableTests.importModuleTests(_emberRuntimeTestsSuitesEnumerableReduce.default);
  EnumerableTests.importModuleTests(_emberRuntimeTestsSuitesEnumerableReject.default);
  EnumerableTests.importModuleTests(_emberRuntimeTestsSuitesEnumerableSortBy.default);
  EnumerableTests.importModuleTests(_emberRuntimeTestsSuitesEnumerableToArray.default);
  EnumerableTests.importModuleTests(_emberRuntimeTestsSuitesEnumerableUniq.default);

  EnumerableTests.importModuleTests(_emberRuntimeTestsSuitesEnumerableUniqBy.default);

  EnumerableTests.importModuleTests(_emberRuntimeTestsSuitesEnumerableIncludes.default);

  EnumerableTests.importModuleTests(_emberRuntimeTestsSuitesEnumerableWithout.default);

  exports.default = EnumerableTests;
  exports.EnumerableTests = EnumerableTests;
  exports.ObserverClass = ObserverClass;
});
enifed('ember-runtime/tests/suites/enumerable.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable/any', ['exports', 'ember-runtime/tests/suites/suite', 'ember-runtime/system/native_array'], function (exports, _emberRuntimeTestsSuitesSuite, _emberRuntimeSystemNative_array) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  // ..........................................................
  // any()
  //

  suite.module('any');

  suite.test('any should should invoke callback on each item as long as you return false', function () {
    var obj = this.newObject();
    var ary = this.toArray(obj);
    var found = [];
    var result = undefined;

    result = obj.any(function (i) {
      found.push(i);
      return false;
    });
    equal(result, false, 'return value of obj.any');
    deepEqual(found, ary, 'items passed during any() should match');
  });

  suite.test('any should stop invoking when you return true', function () {
    var obj = this.newObject();
    var ary = this.toArray(obj);
    var cnt = ary.length - 2;
    var exp = cnt;
    var found = [];
    var result = undefined;

    result = obj.any(function (i) {
      found.push(i);
      return --cnt <= 0;
    });
    equal(result, true, 'return value of obj.any');
    equal(found.length, exp, 'should invoke proper number of times');
    deepEqual(found, ary.slice(0, -2), 'items passed during any() should match');
  });

  suite.test('any should return true if any object matches the callback', function () {
    var obj = _emberRuntimeSystemNative_array.A([0, 1, 2]);
    var result = undefined;

    result = obj.any(function (i) {
      return !!i;
    });
    equal(result, true, 'return value of obj.any');
  });

  suite.test('any should return false if no object matches the callback', function () {
    var obj = _emberRuntimeSystemNative_array.A([0, null, false]);
    var result = undefined;

    result = obj.any(function (i) {
      return !!i;
    });
    equal(result, false, 'return value of obj.any');
  });

  suite.test('any should produce correct results even if the matching element is undefined', function () {
    var obj = _emberRuntimeSystemNative_array.A([undefined]);
    var result = undefined;

    result = obj.any(function (i) {
      return true;
    });
    equal(result, true, 'return value of obj.any');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/enumerable/any.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable/any.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable/any.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable/compact', ['exports', 'ember-runtime/tests/suites/suite'], function (exports, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('compact');

  suite.test('removes null and undefined values from enumerable', function () {
    var obj = this.newObject([null, 1, false, '', undefined, 0, null]);
    var ary = obj.compact();
    deepEqual(ary, [1, false, '', 0]);
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/enumerable/compact.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable/compact.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable/compact.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable/contains', ['exports', 'ember-runtime/tests/suites/suite'], function (exports, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('contains');

  suite.test('contains returns true if item is in enumerable', function () {
    var data = this.newFixture(3);
    var obj = this.newObject(data);

    expectDeprecation('`Enumerable#contains` is deprecated, use `Enumerable#includes` instead.');
    equal(obj.contains(data[1]), true, 'should return true if contained');
  });

  suite.test('contains returns false if item is not in enumerable', function () {
    var data = this.newFixture(1);
    var obj = this.newObject(this.newFixture(3));

    expectDeprecation('`Enumerable#contains` is deprecated, use `Enumerable#includes` instead.');
    equal(obj.contains(data[0]), false, 'should return false if not contained');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/enumerable/contains.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable/contains.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable/contains.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable/every', ['exports', 'ember-runtime/system/object', 'ember-runtime/tests/suites/suite'], function (exports, _emberRuntimeSystemObject, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  // ..........................................................
  // every()
  //

  suite.module('every');

  suite.test('every should should invoke callback on each item as long as you return true', function () {
    var obj = this.newObject();
    var ary = this.toArray(obj);
    var found = [];
    var result = undefined;

    result = obj.every(function (i) {
      found.push(i);
      return true;
    });
    equal(result, true, 'return value of obj.every');
    deepEqual(found, ary, 'items passed during every() should match');
  });

  suite.test('every should stop invoking when you return false', function () {
    var obj = this.newObject();
    var ary = this.toArray(obj);
    var cnt = ary.length - 2;
    var exp = cnt;
    var found = [];
    var result = undefined;

    result = obj.every(function (i) {
      found.push(i);
      return --cnt > 0;
    });
    equal(result, false, 'return value of obj.every');
    equal(found.length, exp, 'should invoke proper number of times');
    deepEqual(found, ary.slice(0, -2), 'items passed during every() should match');
  });

  // ..........................................................
  // isEvery()
  //

  suite.module('isEvery');

  suite.test('should return true of every property matches', function () {
    var obj = this.newObject([{ foo: 'foo', bar: 'BAZ' }, _emberRuntimeSystemObject.default.create({ foo: 'foo', bar: 'bar' })]);

    equal(obj.isEvery('foo', 'foo'), true, 'isEvery(foo)');
    equal(obj.isEvery('bar', 'bar'), false, 'isEvery(bar)');
  });

  suite.test('should return true of every property is true', function () {
    var obj = this.newObject([{ foo: 'foo', bar: true }, _emberRuntimeSystemObject.default.create({ foo: 'bar', bar: false })]);

    // different values - all eval to true
    equal(obj.isEvery('foo'), true, 'isEvery(foo)');
    equal(obj.isEvery('bar'), false, 'isEvery(bar)');
  });

  suite.test('should return true if every property matches null', function () {
    var obj = this.newObject([{ foo: null, bar: 'BAZ' }, _emberRuntimeSystemObject.default.create({ foo: null, bar: null })]);

    equal(obj.isEvery('foo', null), true, 'isEvery(\'foo\', null)');
    equal(obj.isEvery('bar', null), false, 'isEvery(\'bar\', null)');
  });

  suite.test('should return true if every property is undefined', function () {
    var obj = this.newObject([{ foo: undefined, bar: 'BAZ' }, _emberRuntimeSystemObject.default.create({ bar: undefined })]);

    equal(obj.isEvery('foo', undefined), true, 'isEvery(\'foo\', undefined)');
    equal(obj.isEvery('bar', undefined), false, 'isEvery(\'bar\', undefined)');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/enumerable/every.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable/every.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable/every.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable/filter', ['exports', 'ember-runtime/system/object', 'ember-runtime/tests/suites/suite'], function (exports, _emberRuntimeSystemObject, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  // ..........................................................
  // filter()
  //

  suite.module('filter');

  suite.test('filter should invoke on each item', function () {
    var obj = this.newObject();
    var ary = this.toArray(obj);
    var cnt = ary.length - 2;
    var found = [];
    var result = undefined;

    // return true on all but the last two
    result = obj.filter(function (i) {
      found.push(i);
      return --cnt >= 0;
    });
    deepEqual(found, ary, 'should have invoked on each item');
    deepEqual(result, ary.slice(0, -2), 'filtered array should exclude items');
  });

  // ..........................................................
  // filterBy()
  //

  suite.module('filterBy');

  suite.test('should filter based on object', function () {
    var obj = undefined,
        ary = undefined;

    ary = [{ foo: 'foo', bar: 'BAZ' }, _emberRuntimeSystemObject.default.create({ foo: 'foo', bar: 'bar' })];

    obj = this.newObject(ary);

    deepEqual(obj.filterBy('foo', 'foo'), ary, 'filterBy(foo)');
    deepEqual(obj.filterBy('bar', 'bar'), [ary[1]], 'filterBy(bar)');
  });

  suite.test('should include in result if property is true', function () {
    var obj = undefined,
        ary = undefined;

    ary = [{ foo: 'foo', bar: true }, _emberRuntimeSystemObject.default.create({ foo: 'bar', bar: false })];

    obj = this.newObject(ary);

    // different values - all eval to true
    deepEqual(obj.filterBy('foo'), ary, 'filterBy(foo)');
    deepEqual(obj.filterBy('bar'), [ary[0]], 'filterBy(bar)');
  });

  suite.test('should filter on second argument if provided', function () {
    var obj = undefined,
        ary = undefined;

    ary = [{ name: 'obj1', foo: 3 }, _emberRuntimeSystemObject.default.create({ name: 'obj2', foo: 2 }), { name: 'obj3', foo: 2 }, _emberRuntimeSystemObject.default.create({ name: 'obj4', foo: 3 })];

    obj = this.newObject(ary);

    deepEqual(obj.filterBy('foo', 3), [ary[0], ary[3]], 'filterBy(\'foo\', 3)\')');
  });

  suite.test('should correctly filter null second argument', function () {
    var obj = undefined,
        ary = undefined;

    ary = [{ name: 'obj1', foo: 3 }, _emberRuntimeSystemObject.default.create({ name: 'obj2', foo: null }), { name: 'obj3', foo: null }, _emberRuntimeSystemObject.default.create({ name: 'obj4', foo: 3 })];

    obj = this.newObject(ary);

    deepEqual(obj.filterBy('foo', null), [ary[1], ary[2]], 'filterBy(\'foo\', 3)\')');
  });

  suite.test('should not return all objects on undefined second argument', function () {
    var obj = undefined,
        ary = undefined;

    ary = [{ name: 'obj1', foo: 3 }, _emberRuntimeSystemObject.default.create({ name: 'obj2', foo: 2 })];

    obj = this.newObject(ary);

    deepEqual(obj.filterBy('foo', undefined), [], 'filterBy(\'foo\', 3)\')');
  });

  suite.test('should correctly filter explicit undefined second argument', function () {
    var obj = undefined,
        ary = undefined;

    ary = [{ name: 'obj1', foo: 3 }, _emberRuntimeSystemObject.default.create({ name: 'obj2', foo: 3 }), { name: 'obj3', foo: undefined }, _emberRuntimeSystemObject.default.create({ name: 'obj4', foo: undefined }), { name: 'obj5' }, _emberRuntimeSystemObject.default.create({ name: 'obj6' })];

    obj = this.newObject(ary);

    deepEqual(obj.filterBy('foo', undefined), ary.slice(2), 'filterBy(\'foo\', 3)\')');
  });

  suite.test('should not match undefined properties without second argument', function () {
    var obj = undefined,
        ary = undefined;

    ary = [{ name: 'obj1', foo: 3 }, _emberRuntimeSystemObject.default.create({ name: 'obj2', foo: 3 }), { name: 'obj3', foo: undefined }, _emberRuntimeSystemObject.default.create({ name: 'obj4', foo: undefined }), { name: 'obj5' }, _emberRuntimeSystemObject.default.create({ name: 'obj6' })];

    obj = this.newObject(ary);

    deepEqual(obj.filterBy('foo'), ary.slice(0, 2), 'filterBy(\'foo\', 3)\')');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/enumerable/filter.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable/filter.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable/filter.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable/find', ['exports', 'ember-runtime/system/object', 'ember-runtime/tests/suites/suite'], function (exports, _emberRuntimeSystemObject, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();
  // ..........................................................
  // find()
  //

  suite.module('find');

  suite.test('find should invoke callback on each item as long as you return false', function () {
    var obj = this.newObject();
    var ary = this.toArray(obj);
    var found = [];
    var result = undefined;

    result = obj.find(function (i) {
      found.push(i);
      return false;
    });
    equal(result, undefined, 'return value of obj.find');
    deepEqual(found, ary, 'items passed during find() should match');
  });

  suite.test('every should stop invoking when you return true', function () {
    var obj = this.newObject();
    var ary = this.toArray(obj);
    var cnt = ary.length - 2;
    var exp = cnt;
    var found = [];
    var result = undefined;

    result = obj.find(function (i) {
      found.push(i);
      return --cnt >= 0;
    });
    equal(result, ary[exp - 1], 'return value of obj.find');
    equal(found.length, exp, 'should invoke proper number of times');
    deepEqual(found, ary.slice(0, -2), 'items passed during find() should match');
  });

  // ..........................................................
  // findBy()
  //

  suite.module('findBy');

  suite.test('should return first object of property matches', function () {
    var ary = undefined,
        obj = undefined;

    ary = [{ foo: 'foo', bar: 'BAZ' }, _emberRuntimeSystemObject.default.create({ foo: 'foo', bar: 'bar' })];

    obj = this.newObject(ary);

    equal(obj.findBy('foo', 'foo'), ary[0], 'findBy(foo)');
    equal(obj.findBy('bar', 'bar'), ary[1], 'findBy(bar)');
  });

  suite.test('should return first object with truthy prop', function () {
    var ary = undefined,
        obj = undefined;

    ary = [{ foo: 'foo', bar: false }, _emberRuntimeSystemObject.default.create({ foo: 'bar', bar: true })];

    obj = this.newObject(ary);

    // different values - all eval to true
    equal(obj.findBy('foo'), ary[0], 'findBy(foo)');
    equal(obj.findBy('bar'), ary[1], 'findBy(bar)');
  });

  suite.test('should return first null property match', function () {
    var ary = undefined,
        obj = undefined;

    ary = [{ foo: null, bar: 'BAZ' }, _emberRuntimeSystemObject.default.create({ foo: null, bar: null })];

    obj = this.newObject(ary);

    equal(obj.findBy('foo', null), ary[0], 'findBy(\'foo\', null)');
    equal(obj.findBy('bar', null), ary[1], 'findBy(\'bar\', null)');
  });

  suite.test('should return first undefined property match', function () {
    var ary = undefined,
        obj = undefined;

    ary = [{ foo: undefined, bar: 'BAZ' }, _emberRuntimeSystemObject.default.create({})];

    obj = this.newObject(ary);

    equal(obj.findBy('foo', undefined), ary[0], 'findBy(\'foo\', undefined)');
    equal(obj.findBy('bar', undefined), ary[1], 'findBy(\'bar\', undefined)');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/enumerable/find.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable/find.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable/find.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable/firstObject', ['exports', 'ember-runtime/tests/suites/suite', 'ember-metal'], function (exports, _emberRuntimeTestsSuitesSuite, _emberMetal) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('firstObject');

  suite.test('returns first item in enumerable', function () {
    var obj = this.newObject();
    equal(_emberMetal.get(obj, 'firstObject'), this.toArray(obj)[0]);
  });

  suite.test('returns undefined if enumerable is empty', function () {
    var obj = this.newObject([]);
    equal(_emberMetal.get(obj, 'firstObject'), undefined);
  });

  suite.test('can not be set', function () {
    var obj = this.newObject([]);

    equal(_emberMetal.get(obj, 'firstObject'), this.toArray(obj)[0]);

    throws(function () {
      _emberMetal.set(obj, 'firstObject', 'foo!');
    }, /Cannot set read-only property "firstObject" on object/);
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/enumerable/firstObject.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable/firstObject.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable/firstObject.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable/forEach', ['exports', 'ember-utils', 'ember-runtime/tests/suites/suite', 'ember-metal'], function (exports, _emberUtils, _emberRuntimeTestsSuitesSuite, _emberMetal) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('forEach');

  suite.test('forEach should iterate over list', function () {
    var obj = this.newObject();
    var ary = this.toArray(obj);
    var found = [];

    obj.forEach(function (i) {
      return found.push(i);
    });
    deepEqual(found, ary, 'items passed during forEach should match');
  });

  suite.test('forEach should iterate over list after mutation', function () {
    if (_emberMetal.get(this, 'canTestMutation')) {
      expect(0);
      return;
    }

    var obj = this.newObject();
    var ary = this.toArray(obj);
    var found = [];

    obj.forEach(function (i) {
      return found.push(i);
    });
    deepEqual(found, ary, 'items passed during forEach should match');

    this.mutate(obj);
    ary = this.toArray(obj);
    found = [];

    obj.forEach(function (i) {
      return found.push(i);
    });
    deepEqual(found, ary, 'items passed during forEach should match');
  });

  suite.test('2nd target parameter', function () {
    var _this = this;

    var obj = this.newObject();
    var target = this;

    obj.forEach(function () {
      // ES6TODO: When transpiled we will end up with "use strict" which disables automatically binding to the global context.
      // Therefore, the following test can never pass in strict mode unless we modify the `map` function implementation to
      // use `Ember.lookup` if target is not specified.
      //
      // equal(guidFor(this), guidFor(global), 'should pass the global object as this if no context');
    });

    obj.forEach(function () {
      equal(_emberUtils.guidFor(_this), _emberUtils.guidFor(target), 'should pass target as this if context');
    }, target);
  });

  suite.test('callback params', function () {
    var obj = this.newObject();
    var ary = this.toArray(obj);
    var loc = 0;

    obj.forEach(function (item, idx, enumerable) {
      equal(item, ary[loc], 'item param');
      equal(idx, loc, 'idx param');
      equal(_emberUtils.guidFor(enumerable), _emberUtils.guidFor(obj), 'enumerable param');
      loc++;
    });
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/enumerable/forEach.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable/forEach.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable/forEach.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable/includes', ['exports', 'ember-runtime/tests/suites/suite'], function (exports, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('includes');

  suite.test('includes returns true if item is in enumerable', function () {
    var data = this.newFixture(1);
    var obj = this.newObject([].concat(data, [NaN, undefined, null]));

    equal(obj.includes(data[0]), true, 'should return true if included');
    equal(obj.includes(NaN), true, 'should return true if NaN included');
    equal(obj.includes(undefined), true, 'should return true if undefined included');
    equal(obj.includes(null), true, 'should return true if null included');
  });

  suite.test('includes returns false if item is not in enumerable', function () {
    var data = this.newFixture(1);
    var obj = this.newObject([].concat(this.newFixture(3), [null]));

    equal(obj.includes(data[0]), false, 'should return false if not included');
    equal(obj.includes(undefined), false, 'should return false if undefined not included but null is included');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/enumerable/includes.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable/includes.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable/includes.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable/invoke', ['exports', 'ember-runtime/system/object', 'ember-runtime/tests/suites/suite'], function (exports, _emberRuntimeSystemObject, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('invoke');

  suite.test('invoke should call on each object that implements', function () {
    var cnt = undefined,
        ary = undefined,
        obj = undefined;

    function F(amt) {
      cnt += amt === undefined ? 1 : amt;
    }
    cnt = 0;
    ary = [{ foo: F }, _emberRuntimeSystemObject.default.create({ foo: F }),

    // NOTE: does not impl foo - invoke should just skip
    _emberRuntimeSystemObject.default.create({ bar: F }), { foo: F }];

    obj = this.newObject(ary);
    obj.invoke('foo');
    equal(cnt, 3, 'should have invoked 3 times');

    cnt = 0;
    obj.invoke('foo', 2);
    equal(cnt, 6, 'should have invoked 3 times, passing param');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/enumerable/invoke.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable/invoke.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable/invoke.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable/is_any', ['exports', 'ember-runtime/system/object', 'ember-runtime/tests/suites/suite'], function (exports, _emberRuntimeSystemObject, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  // ..........................................................
  // isAny()
  //

  suite.module('isAny');

  suite.test('should return true of any property matches', function () {
    var obj = this.newObject([{ foo: 'foo', bar: 'BAZ' }, _emberRuntimeSystemObject.default.create({ foo: 'foo', bar: 'bar' })]);

    equal(obj.isAny('foo', 'foo'), true, 'isAny(foo)');
    equal(obj.isAny('bar', 'bar'), true, 'isAny(bar)');
    equal(obj.isAny('bar', 'BIFF'), false, 'isAny(BIFF)');
  });

  suite.test('should return true of any property is true', function () {
    var obj = this.newObject([{ foo: 'foo', bar: true }, _emberRuntimeSystemObject.default.create({ foo: 'bar', bar: false })]);

    // different values - all eval to true
    equal(obj.isAny('foo'), true, 'isAny(foo)');
    equal(obj.isAny('bar'), true, 'isAny(bar)');
    equal(obj.isAny('BIFF'), false, 'isAny(biff)');
  });

  suite.test('should return true if any property matches null', function () {
    var obj = this.newObject([{ foo: null, bar: 'bar' }, _emberRuntimeSystemObject.default.create({ foo: 'foo', bar: null })]);

    equal(obj.isAny('foo', null), true, 'isAny(\'foo\', null)');
    equal(obj.isAny('bar', null), true, 'isAny(\'bar\', null)');
  });

  suite.test('should return true if any property is undefined', function () {
    var obj = this.newObject([{ foo: undefined, bar: 'bar' }, _emberRuntimeSystemObject.default.create({ foo: 'foo' })]);

    equal(obj.isAny('foo', undefined), true, 'isAny(\'foo\', undefined)');
    equal(obj.isAny('bar', undefined), true, 'isAny(\'bar\', undefined)');
  });

  suite.test('should not match undefined properties without second argument', function () {
    var obj = this.newObject([{ foo: undefined }, _emberRuntimeSystemObject.default.create({})]);

    equal(obj.isAny('foo'), false, 'isAny(\'foo\', undefined)');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/enumerable/is_any.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable/is_any.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable/is_any.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable/lastObject', ['exports', 'ember-runtime/tests/suites/suite', 'ember-metal'], function (exports, _emberRuntimeTestsSuitesSuite, _emberMetal) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('lastObject');

  suite.test('returns last item in enumerable', function () {
    var obj = this.newObject();
    var ary = this.toArray(obj);

    equal(_emberMetal.get(obj, 'lastObject'), ary[ary.length - 1]);
  });

  suite.test('returns undefined if enumerable is empty', function () {
    var obj = this.newObject([]);

    equal(_emberMetal.get(obj, 'lastObject'), undefined);
  });

  suite.test('can not be set', function () {
    var obj = this.newObject();
    var ary = this.toArray(obj);

    equal(_emberMetal.get(obj, 'lastObject'), ary[ary.length - 1]);

    throws(function () {
      _emberMetal.set(obj, 'lastObject', 'foo!');
    }, /Cannot set read-only property "lastObject" on object/);
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/enumerable/lastObject.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable/lastObject.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable/lastObject.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable/map', ['exports', 'ember-utils', 'ember-runtime/tests/suites/suite', 'ember-metal'], function (exports, _emberUtils, _emberRuntimeTestsSuitesSuite, _emberMetal) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('map');

  var mapFunc = function (item) {
    return item ? item.toString() : null;
  };

  suite.test('map should iterate over list', function () {
    var obj = this.newObject();
    var ary = this.toArray(obj).map(mapFunc);
    var found = [];

    found = obj.map(mapFunc);
    deepEqual(found, ary, 'mapped arrays should match');
  });

  suite.test('map should iterate over list after mutation', function () {
    if (_emberMetal.get(this, 'canTestMutation')) {
      expect(0);
      return;
    }

    var obj = this.newObject();
    var ary = this.toArray(obj).map(mapFunc);
    var found = undefined;

    found = obj.map(mapFunc);
    deepEqual(found, ary, 'items passed during forEach should match');

    this.mutate(obj);
    ary = this.toArray(obj).map(mapFunc);
    found = obj.map(mapFunc);
    deepEqual(found, ary, 'items passed during forEach should match');
  });

  suite.test('2nd target parameter', function () {
    var _this = this;

    var obj = this.newObject();
    var target = this;

    obj.map(function () {
      // ES6TODO: When transpiled we will end up with "use strict" which disables automatically binding to the global context.
      // Therefore, the following test can never pass in strict mode unless we modify the `map` function implementation to
      // use `Ember.lookup` if target is not specified.
      //
      // equal(guidFor(this), guidFor(global), 'should pass the global object as this if no context');
    });

    obj.map(function () {
      equal(_emberUtils.guidFor(_this), _emberUtils.guidFor(target), 'should pass target as this if context');
    }, target);
  });

  suite.test('callback params', function () {
    var obj = this.newObject();
    var ary = this.toArray(obj);
    var loc = 0;

    obj.map(function (item, idx, enumerable) {
      equal(item, ary[loc], 'item param');
      equal(idx, loc, 'idx param');
      equal(_emberUtils.guidFor(enumerable), _emberUtils.guidFor(obj), 'enumerable param');
      loc++;
    });
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/enumerable/map.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable/map.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable/map.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable/mapBy', ['exports', 'ember-runtime/tests/suites/suite'], function (exports, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('mapBy');

  suite.test('get value of each property', function () {
    var obj = this.newObject([{ a: 1 }, { a: 2 }]);
    equal(obj.mapBy('a').join(''), '12');
  });

  suite.test('should work also through getEach alias', function () {
    var obj = this.newObject([{ a: 1 }, { a: 2 }]);
    equal(obj.getEach('a').join(''), '12');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/enumerable/mapBy.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable/mapBy.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable/mapBy.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable/reduce', ['exports', 'ember-runtime/tests/suites/suite'], function (exports, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('reduce');

  suite.test('collects a summary value from an enumeration', function () {
    var obj = this.newObject([1, 2, 3]);
    var res = obj.reduce(function (previousValue, item, index, enumerable) {
      return previousValue + item;
    }, 0);
    equal(res, 6);
  });

  suite.test('passes index of item to callback', function () {
    var obj = this.newObject([1, 2, 3]);
    var res = obj.reduce(function (previousValue, item, index, enumerable) {
      return previousValue + index;
    }, 0);
    equal(res, 3);
  });

  suite.test('passes enumerable object to callback', function () {
    var obj = this.newObject([1, 2, 3]);
    var res = obj.reduce(function (previousValue, item, index, enumerable) {
      return enumerable;
    }, 0);
    equal(res, obj);
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/enumerable/reduce.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable/reduce.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable/reduce.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable/reject', ['exports', 'ember-runtime/system/object', 'ember-runtime/tests/suites/suite'], function (exports, _emberRuntimeSystemObject, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  // ..........................................................
  // reject()
  //

  suite.module('reject');

  suite.test('should reject any item that does not meet the condition', function () {
    var obj = this.newObject([1, 2, 3, 4]);
    var result = undefined;

    result = obj.reject(function (i) {
      return i < 3;
    });
    deepEqual(result, [3, 4], 'reject the correct items');
  });

  suite.test('should be the inverse of filter', function () {
    var obj = this.newObject([1, 2, 3, 4]);
    var isEven = function (i) {
      return i % 2 === 0;
    };
    var filtered = undefined,
        rejected = undefined;

    filtered = obj.filter(isEven);
    rejected = obj.reject(isEven);

    deepEqual(filtered, [2, 4], 'filtered evens');
    deepEqual(rejected, [1, 3], 'rejected evens');
  });

  // ..........................................................
  // rejectBy()
  //

  suite.module('rejectBy');

  suite.test('should reject based on object', function () {
    var obj = undefined,
        ary = undefined;

    ary = [{ foo: 'foo', bar: 'BAZ' }, _emberRuntimeSystemObject.default.create({ foo: 'foo', bar: 'bar' })];

    obj = this.newObject(ary);

    deepEqual(obj.rejectBy('foo', 'foo'), [], 'rejectBy(foo)');
    deepEqual(obj.rejectBy('bar', 'bar'), [ary[0]], 'rejectBy(bar)');
  });

  suite.test('should include in result if property is false', function () {
    var obj = undefined,
        ary = undefined;

    ary = [{ foo: false, bar: true }, _emberRuntimeSystemObject.default.create({ foo: false, bar: false })];

    obj = this.newObject(ary);

    deepEqual(obj.rejectBy('foo'), ary, 'rejectBy(foo)');
    deepEqual(obj.rejectBy('bar'), [ary[1]], 'rejectBy(bar)');
  });

  suite.test('should reject on second argument if provided', function () {
    var obj = undefined,
        ary = undefined;

    ary = [{ name: 'obj1', foo: 3 }, _emberRuntimeSystemObject.default.create({ name: 'obj2', foo: 2 }), { name: 'obj3', foo: 2 }, _emberRuntimeSystemObject.default.create({ name: 'obj4', foo: 3 })];

    obj = this.newObject(ary);

    deepEqual(obj.rejectBy('foo', 3), [ary[1], ary[2]], 'rejectBy(\'foo\', 3)\')');
  });

  suite.test('should correctly reject null second argument', function () {
    var obj = undefined,
        ary = undefined;

    ary = [{ name: 'obj1', foo: 3 }, _emberRuntimeSystemObject.default.create({ name: 'obj2', foo: null }), { name: 'obj3', foo: null }, _emberRuntimeSystemObject.default.create({ name: 'obj4', foo: 3 })];

    obj = this.newObject(ary);

    deepEqual(obj.rejectBy('foo', null), [ary[0], ary[3]], 'rejectBy(\'foo\', null)\')');
  });

  suite.test('should correctly reject undefined second argument', function () {
    var obj = undefined,
        ary = undefined;

    ary = [{ name: 'obj1', foo: 3 }, _emberRuntimeSystemObject.default.create({ name: 'obj2', foo: 2 })];

    obj = this.newObject(ary);

    deepEqual(obj.rejectBy('bar', undefined), [], 'rejectBy(\'bar\', undefined)\')');
  });

  suite.test('should correctly reject explicit undefined second argument', function () {
    var obj = undefined,
        ary = undefined;

    ary = [{ name: 'obj1', foo: 3 }, _emberRuntimeSystemObject.default.create({ name: 'obj2', foo: 3 }), { name: 'obj3', foo: undefined }, _emberRuntimeSystemObject.default.create({ name: 'obj4', foo: undefined }), { name: 'obj5' }, _emberRuntimeSystemObject.default.create({ name: 'obj6' })];

    obj = this.newObject(ary);

    deepEqual(obj.rejectBy('foo', undefined), ary.slice(0, 2), 'rejectBy(\'foo\', undefined)\')');
  });

  suite.test('should match undefined, null, or false properties without second argument', function () {
    var obj = undefined,
        ary = undefined;

    ary = [{ name: 'obj1', foo: 3 }, _emberRuntimeSystemObject.default.create({ name: 'obj2', foo: 3 }), { name: 'obj3', foo: undefined }, _emberRuntimeSystemObject.default.create({ name: 'obj4', foo: undefined }), { name: 'obj5' }, _emberRuntimeSystemObject.default.create({ name: 'obj6' }), { name: 'obj7', foo: null }, _emberRuntimeSystemObject.default.create({ name: 'obj8', foo: null }), { name: 'obj9', foo: false }, _emberRuntimeSystemObject.default.create({ name: 'obj10', foo: false })];

    obj = this.newObject(ary);

    deepEqual(obj.rejectBy('foo'), ary.slice(2), 'rejectBy(\'foo\')\')');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/enumerable/reject.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable/reject.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable/reject.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable/sortBy', ['exports', 'ember-runtime/tests/suites/suite', 'ember-metal'], function (exports, _emberRuntimeTestsSuitesSuite, _emberMetal) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('sortBy');

  suite.test('sort by value of property', function () {
    var obj = this.newObject([{ a: 2 }, { a: 1 }]);
    var sorted = obj.sortBy('a');

    equal(_emberMetal.get(sorted[0], 'a'), 1);
    equal(_emberMetal.get(sorted[1], 'a'), 2);
  });

  suite.test('supports multiple propertyNames', function () {
    var obj = this.newObject([{ a: 1, b: 2 }, { a: 1, b: 1 }]);
    var sorted = obj.sortBy('a', 'b');

    equal(_emberMetal.get(sorted[0], 'b'), 1);
    equal(_emberMetal.get(sorted[1], 'b'), 2);
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/enumerable/sortBy.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable/sortBy.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable/sortBy.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable/toArray', ['exports', 'ember-runtime/tests/suites/suite'], function (exports, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('toArray');

  suite.test('toArray should convert to an array', function () {
    var obj = this.newObject();
    deepEqual(obj.toArray(), this.toArray(obj));
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/enumerable/toArray.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable/toArray.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable/toArray.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable/uniq', ['exports', 'ember-runtime/tests/suites/suite'], function (exports, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('uniq');

  suite.test('should return new instance with duplicates removed', function () {
    var before = undefined,
        after = undefined,
        obj = undefined,
        ret = undefined;

    after = this.newFixture(3);
    before = [after[0], after[1], after[2], after[1], after[0]];
    obj = this.newObject(before);
    before = obj.toArray(); // in case of set before will be different...

    ret = obj.uniq();
    deepEqual(this.toArray(ret), after, 'should have removed item');
    deepEqual(this.toArray(obj), before, 'should not have changed original');
  });

  suite.test('should return duplicate of same content if no duplicates found', function () {
    var item = undefined,
        obj = undefined,
        ret = undefined;
    obj = this.newObject(this.newFixture(3));
    ret = obj.uniq(item);
    ok(ret !== obj, 'should not be same object');
    deepEqual(this.toArray(ret), this.toArray(obj), 'should be the same content');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/enumerable/uniq.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable/uniq.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable/uniq.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable/uniqBy', ['exports', 'ember-runtime/tests/suites/suite'], function (exports, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('uniqBy');

  suite.test('should return new instance with duplicates removed', function () {
    var numbers = this.newObject([{ id: 1, value: 'one' }, { id: 2, value: 'two' }, { id: 1, value: 'one' }]);
    deepEqual(numbers.uniqBy('id'), [{ id: 1, value: 'one' }, { id: 2, value: 'two' }]);
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/enumerable/uniqBy.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable/uniqBy.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable/uniqBy.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/enumerable/without', ['exports', 'ember-runtime/tests/suites/suite'], function (exports, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('without');

  suite.test('should return new instance with item removed', function () {
    var before = undefined,
        after = undefined,
        obj = undefined,
        ret = undefined;

    before = this.newFixture(3);
    after = [before[0], before[2]];
    obj = this.newObject(before);

    ret = obj.without(before[1]);
    deepEqual(this.toArray(ret), after, 'should have removed item');
    deepEqual(this.toArray(obj), before, 'should not have changed original');
  });

  suite.test('should remove NaN value', function () {
    var before = undefined,
        after = undefined,
        obj = undefined,
        ret = undefined;

    before = [].concat(this.newFixture(2), [NaN]);
    after = [before[0], before[1]];
    obj = this.newObject(before);

    ret = obj.without(NaN);
    deepEqual(this.toArray(ret), after, 'should have removed item');
  });

  suite.test('should return same instance if object not found', function () {
    var item = undefined,
        obj = undefined,
        ret = undefined;

    item = this.newFixture(1)[0];
    obj = this.newObject(this.newFixture(3));

    ret = obj.without(item);
    equal(ret, obj, 'should be same instance');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/enumerable/without.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/enumerable/without.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/enumerable/without.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/mutable_array', ['exports', 'ember-runtime/tests/suites/array', 'ember-runtime/tests/suites/mutable_array/insertAt', 'ember-runtime/tests/suites/mutable_array/popObject', 'ember-runtime/tests/suites/mutable_array/pushObject', 'ember-runtime/tests/suites/mutable_array/pushObjects', 'ember-runtime/tests/suites/mutable_array/removeAt', 'ember-runtime/tests/suites/mutable_array/replace', 'ember-runtime/tests/suites/mutable_array/shiftObject', 'ember-runtime/tests/suites/mutable_array/unshiftObject', 'ember-runtime/tests/suites/mutable_array/reverseObjects'], function (exports, _emberRuntimeTestsSuitesArray, _emberRuntimeTestsSuitesMutable_arrayInsertAt, _emberRuntimeTestsSuitesMutable_arrayPopObject, _emberRuntimeTestsSuitesMutable_arrayPushObject, _emberRuntimeTestsSuitesMutable_arrayPushObjects, _emberRuntimeTestsSuitesMutable_arrayRemoveAt, _emberRuntimeTestsSuitesMutable_arrayReplace, _emberRuntimeTestsSuitesMutable_arrayShiftObject, _emberRuntimeTestsSuitesMutable_arrayUnshiftObject, _emberRuntimeTestsSuitesMutable_arrayReverseObjects) {
  'use strict';

  var MutableArrayTests = _emberRuntimeTestsSuitesArray.ArrayTests.extend();
  MutableArrayTests.importModuleTests(_emberRuntimeTestsSuitesMutable_arrayInsertAt.default);
  MutableArrayTests.importModuleTests(_emberRuntimeTestsSuitesMutable_arrayPopObject.default);
  MutableArrayTests.importModuleTests(_emberRuntimeTestsSuitesMutable_arrayPushObject.default);
  MutableArrayTests.importModuleTests(_emberRuntimeTestsSuitesMutable_arrayPushObjects.default);
  MutableArrayTests.importModuleTests(_emberRuntimeTestsSuitesMutable_arrayRemoveAt.default);
  MutableArrayTests.importModuleTests(_emberRuntimeTestsSuitesMutable_arrayReplace.default);
  MutableArrayTests.importModuleTests(_emberRuntimeTestsSuitesMutable_arrayShiftObject.default);
  MutableArrayTests.importModuleTests(_emberRuntimeTestsSuitesMutable_arrayUnshiftObject.default);
  MutableArrayTests.importModuleTests(_emberRuntimeTestsSuitesMutable_arrayReverseObjects.default);

  exports.default = MutableArrayTests;
});
enifed('ember-runtime/tests/suites/mutable_array.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/mutable_array.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/mutable_array.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/mutable_array/addObject', ['exports', 'ember-metal', 'ember-runtime/tests/suites/suite'], function (exports, _emberMetal, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('addObject');

  suite.test('should return receiver', function () {
    var before = this.newFixture(3);
    var obj = this.newObject(before);
    equal(obj.addObject(before[1]), obj, 'should return receiver');
  });

  suite.test('[A,B].addObject(C) => [A,B,C] + notify', function () {
    var before = this.newFixture(2);
    var item = this.newFixture(1)[0];
    var after = [before[0], before[1], item];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.addObject(item);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    if (observer.isEnabled) {
      equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      equal(observer.timesCalled('length'), 1, 'should have notified length once');
      equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');

      equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
    }
  });

  suite.test('[A,B,C].addObject(A) => [A,B,C] + NO notify', function () {
    var before = this.newFixture(3);
    var after = before;
    var item = before[0];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.addObject(item); // note: item in set

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    if (observer.isEnabled) {
      equal(observer.validate('[]'), false, 'should NOT have notified []');
      equal(observer.validate('@each'), false, 'should NOT have notified @each');
      equal(observer.validate('length'), false, 'should NOT have notified length');
      equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
      equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
    }
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/mutable_array/addObject.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/mutable_array/addObject.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/mutable_array/addObject.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/mutable_array/clear', ['exports', 'ember-metal', 'ember-runtime/tests/suites/suite'], function (exports, _emberMetal, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('clear');

  suite.test('[].clear() => [] + notify', function () {
    var before = [];
    var after = [];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    equal(obj.clear(), obj, 'return self');

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.validate('[]'), false, 'should NOT have notified [] once');
    equal(observer.validate('@each'), false, 'should NOT have notified @each once');
    equal(observer.validate('length'), false, 'should NOT have notified length once');
    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
  });

  suite.test('[X].clear() => [] + notify', function () {
    var obj, before, after, observer;

    before = this.newFixture(1);
    after = [];
    obj = this.newObject(before);
    observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    equal(obj.clear(), obj, 'return self');

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
    equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/mutable_array/clear.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/mutable_array/clear.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/mutable_array/clear.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/mutable_array/insertAt', ['exports', 'ember-runtime/tests/suites/suite', 'ember-metal'], function (exports, _emberRuntimeTestsSuitesSuite, _emberMetal) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('insertAt');

  suite.test('[].insertAt(0, X) => [X] + notify', function () {
    var after = this.newFixture(1);
    var obj = this.newObject([]);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.insertAt(0, after[0]);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalledBefore('[]'), 1, 'should have notified [] will change once');
    equal(observer.timesCalledBefore('@each'), 0, 'should not have notified @each will change once');
    equal(observer.timesCalledBefore('length'), 1, 'should have notified length will change once');
    equal(observer.timesCalledBefore('firstObject'), 1, 'should have notified firstObject will change once');
    equal(observer.timesCalledBefore('lastObject'), 1, 'should have notified lastObject will change once');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] did change once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each did change once');
    equal(observer.timesCalled('length'), 1, 'should have notified length did change once');
    equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject did change once');
    equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject did change once');
  });

  suite.test('[].insertAt(200,X) => OUT_OF_RANGE_EXCEPTION exception', function () {
    var obj = this.newObject([]);
    var that = this;

    throws(function () {
      return obj.insertAt(200, that.newFixture(1)[0]);
    }, Error);
  });

  suite.test('[A].insertAt(0, X) => [X,A] + notify', function () {
    var item = this.newFixture(1)[0];
    var before = this.newFixture(1);
    var after = [item, before[0]];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.insertAt(0, item);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalledBefore('[]'), 1, 'should have notified [] will change once');
    equal(observer.timesCalledBefore('@each'), 0, 'should not have notified @each will change once');
    equal(observer.timesCalledBefore('length'), 1, 'should have notified length will change once');
    equal(observer.timesCalledBefore('firstObject'), 1, 'should have notified firstObject will change once');
    equal(observer.timesCalledBefore('lastObject'), 0, 'should NOT have notified lastObject will change once');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');

    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
  });

  suite.test('[A].insertAt(1, X) => [A,X] + notify', function () {
    var item = this.newFixture(1)[0];
    var before = this.newFixture(1);
    var after = [before[0], item];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.insertAt(1, item);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalledBefore('[]'), 1, 'should have notified [] will change once');
    equal(observer.timesCalledBefore('@each'), 0, 'should not have notified @each will change once');
    equal(observer.timesCalledBefore('length'), 1, 'should have notified length will change once');
    equal(observer.timesCalledBefore('firstObject'), 0, 'should NOT have notified firstObject will change once');
    equal(observer.timesCalledBefore('lastObject'), 1, 'should have notified lastObject will change once');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');

    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
  });

  suite.test('[A].insertAt(200,X) => OUT_OF_RANGE exception', function () {
    var obj = this.newObject(this.newFixture(1));
    var that = this;

    throws(function () {
      return obj.insertAt(200, that.newFixture(1)[0]);
    }, Error);
  });

  suite.test('[A,B,C].insertAt(0,X) => [X,A,B,C] + notify', function () {
    var item = this.newFixture(1)[0];
    var before = this.newFixture(3);
    var after = [item, before[0], before[1], before[2]];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.insertAt(0, item);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalledBefore('[]'), 1, 'should have notified [] will change once');
    equal(observer.timesCalledBefore('@each'), 0, 'should not have notified @each will change once');
    equal(observer.timesCalledBefore('length'), 1, 'should have notified length will change once');
    equal(observer.timesCalledBefore('firstObject'), 1, 'should have notified firstObject will change once');
    equal(observer.timesCalledBefore('lastObject'), 0, 'should NOT have notified lastObject will change once');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');

    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
  });

  suite.test('[A,B,C].insertAt(1,X) => [A,X,B,C] + notify', function () {
    var item = this.newFixture(1)[0];
    var before = this.newFixture(3);
    var after = [before[0], item, before[1], before[2]];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.insertAt(1, item);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalledBefore('[]'), 1, 'should have notified [] will change once');
    equal(observer.timesCalledBefore('@each'), 0, 'should not have notified @each will change once');
    equal(observer.timesCalledBefore('length'), 1, 'should have notified length will change once');
    equal(observer.timesCalledBefore('firstObject'), 0, 'should NOT have notified firstObject will change once');
    equal(observer.timesCalledBefore('lastObject'), 0, 'should NOT have notified lastObject will change once');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');

    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
  });

  suite.test('[A,B,C].insertAt(3,X) => [A,B,C,X] + notify', function () {
    var item = this.newFixture(1)[0];
    var before = this.newFixture(3);
    var after = [before[0], before[1], before[2], item];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.insertAt(3, item);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalledBefore('[]'), 1, 'should have notified [] will change once');
    equal(observer.timesCalledBefore('@each'), 0, 'should not have notified @each will change once');
    equal(observer.timesCalledBefore('length'), 1, 'should have notified length will change once');
    equal(observer.timesCalledBefore('firstObject'), 0, 'should NOT have notified firstObject will change once');
    equal(observer.timesCalledBefore('lastObject'), 1, 'should have notified lastObject will change once');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');

    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/mutable_array/insertAt.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/mutable_array/insertAt.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/mutable_array/insertAt.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/mutable_array/popObject', ['exports', 'ember-runtime/tests/suites/suite', 'ember-metal'], function (exports, _emberRuntimeTestsSuitesSuite, _emberMetal) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('popObject');

  suite.test('[].popObject() => [] + returns undefined + NO notify', function () {
    var obj = this.newObject([]);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    equal(obj.popObject(), undefined, 'popObject results');

    deepEqual(this.toArray(obj), [], 'post item results');

    equal(observer.validate('[]'), false, 'should NOT have notified []');
    equal(observer.validate('@each'), false, 'should NOT have notified @each');
    equal(observer.validate('length'), false, 'should NOT have notified length');
    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
  });

  suite.test('[X].popObject() => [] + notify', function () {
    var before = this.newFixture(1);
    var after = [];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    var ret = obj.popObject();

    equal(ret, before[0], 'return object');
    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
    equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
  });

  suite.test('[A,B,C].popObject() => [A,B] + notify', function () {
    var before = this.newFixture(3);
    var after = [before[0], before[1]];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    var ret = obj.popObject();

    equal(ret, before[2], 'return object');
    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');

    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/mutable_array/popObject.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/mutable_array/popObject.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/mutable_array/popObject.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/mutable_array/pushObject', ['exports', 'ember-runtime/tests/suites/suite', 'ember-metal'], function (exports, _emberRuntimeTestsSuitesSuite, _emberMetal) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('pushObject');

  suite.test('returns pushed object', function () {
    var exp = this.newFixture(1)[0];
    var obj = this.newObject([]);

    equal(obj.pushObject(exp), exp, 'should return pushed object');
  });

  suite.test('[].pushObject(X) => [X] + notify', function () {
    var before = [];
    var after = this.newFixture(1);
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.pushObject(after[0]);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
    equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
  });

  suite.test('[A,B,C].pushObject(X) => [A,B,C,X] + notify', function () {
    var before = this.newFixture(3);
    var item = this.newFixture(1)[0];
    var after = [before[0], before[1], before[2], item];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.pushObject(item);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');

    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/mutable_array/pushObject.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/mutable_array/pushObject.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/mutable_array/pushObject.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/mutable_array/pushObjects', ['exports', 'ember-runtime/tests/suites/suite'], function (exports, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('pushObjects');

  suite.test('should raise exception if not Ember.Enumerable is passed to pushObjects', function () {
    var obj = this.newObject([]);

    throws(function () {
      return obj.pushObjects('string');
    });
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/mutable_array/pushObjects.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/mutable_array/pushObjects.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/mutable_array/pushObjects.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/mutable_array/removeAt', ['exports', 'ember-runtime/tests/suites/suite', 'ember-metal', 'ember-runtime/mixins/mutable_array'], function (exports, _emberRuntimeTestsSuitesSuite, _emberMetal, _emberRuntimeMixinsMutable_array) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('removeAt');

  suite.test('removeAt([X], 0) => [] + notify', function () {
    var before = this.newFixture(1);
    var after = [];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    equal(_emberRuntimeMixinsMutable_array.removeAt(obj, 0), obj, 'return self');

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
    equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
  });

  suite.test('removeAt([], 200) => OUT_OF_RANGE_EXCEPTION exception', function () {
    var obj = this.newObject([]);
    throws(function () {
      return _emberRuntimeMixinsMutable_array.removeAt(obj, 200);
    }, Error);
  });

  suite.test('removeAt([A,B], 0) => [B] + notify', function () {
    var before = this.newFixture(2);
    var after = [before[1]];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    equal(_emberRuntimeMixinsMutable_array.removeAt(obj, 0), obj, 'return self');

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');

    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
  });

  suite.test('removeAt([A,B], 1) => [A] + notify', function () {
    var before = this.newFixture(2);
    var after = [before[0]];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    equal(_emberRuntimeMixinsMutable_array.removeAt(obj, 1), obj, 'return self');

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');

    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
  });

  suite.test('removeAt([A,B,C], 1) => [A,C] + notify', function () {
    var before = this.newFixture(3);
    var after = [before[0], before[2]];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    equal(_emberRuntimeMixinsMutable_array.removeAt(obj, 1), obj, 'return self');

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');

    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
  });

  suite.test('removeAt([A,B,C,D], 1,2) => [A,D] + notify', function () {
    var before = this.newFixture(4);
    var after = [before[0], before[3]];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    equal(_emberRuntimeMixinsMutable_array.removeAt(obj, 1, 2), obj, 'return self');

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');

    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
  });

  suite.test('[A,B,C,D].removeAt(1,2) => [A,D] + notify', function () {
    var obj, before, after, observer;

    before = this.newFixture(4);
    after = [before[0], before[3]];
    obj = this.newObject(before);
    observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');
    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    equal(obj.removeAt(1, 2), obj, 'return self');

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');

    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/mutable_array/removeAt.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/mutable_array/removeAt.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/mutable_array/removeAt.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/mutable_array/removeObject', ['exports', 'ember-metal', 'ember-runtime/tests/suites/suite'], function (exports, _emberMetal, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('removeObject');

  suite.test('should return receiver', function () {
    var before = this.newFixture(3);
    var obj = this.newObject(before);

    equal(obj.removeObject(before[1]), obj, 'should return receiver');
  });

  suite.test('[A,B,C].removeObject(B) => [A,C] + notify', function () {
    var before = this.newFixture(3);
    var after = [before[0], before[2]];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.removeObject(before[1]);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    if (observer.isEnabled) {
      equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
      equal(observer.timesCalled('length'), 1, 'should have notified length once');

      equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
      equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
    }
  });

  suite.test('[A,B,C].removeObject(D) => [A,B,C]', function () {
    var before = this.newFixture(3);
    var after = before;
    var item = this.newFixture(1)[0];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.removeObject(item); // note: item not in set

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    if (observer.isEnabled) {
      equal(observer.validate('[]'), false, 'should NOT have notified []');
      equal(observer.validate('@each'), false, 'should NOT have notified @each');
      equal(observer.validate('length'), false, 'should NOT have notified length');

      equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
      equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
    }
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/mutable_array/removeObject.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/mutable_array/removeObject.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/mutable_array/removeObject.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/mutable_array/replace', ['exports', 'ember-runtime/tests/suites/suite'], function (exports, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('replace');

  suite.test('[].replace(0,0,\'X\') => [\'X\'] + notify', function () {
    var exp = this.newFixture(1);
    var obj = this.newObject([]);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.replace(0, 0, exp);

    deepEqual(this.toArray(obj), exp, 'post item results');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
    equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
  });

  suite.test('[].replace(0,0,"X") => ["X"] + avoid calling objectAt and notifying fistObject/lastObject when not in cache', function () {
    var obj, exp, observer;
    var called = 0;
    exp = this.newFixture(1);
    obj = this.newObject([]);
    obj.objectAt = function () {
      called++;
    };
    observer = this.newObserver(obj, 'firstObject', 'lastObject');

    obj.replace(0, 0, exp);

    equal(called, 0, 'should NOT have called objectAt upon replace when firstObject/lastObject are not cached');
    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject since not cached');
    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject since not cached');
  });

  suite.test('[A,B,C,D].replace(1,2,X) => [A,X,D] + notify', function () {
    var before = this.newFixture(4);
    var replace = this.newFixture(1);
    var after = [before[0], replace[0], before[3]];

    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.replace(1, 2, replace);

    deepEqual(this.toArray(obj), after, 'post item results');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');

    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
  });

  suite.test('[A,B,C,D].replace(1,2,[X,Y]) => [A,X,Y,D] + notify', function () {
    var before = this.newFixture(4);
    var replace = this.newFixture(2);
    var after = [before[0], replace[0], replace[1], before[3]];

    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.replace(1, 2, replace);

    deepEqual(this.toArray(obj), after, 'post item results');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.validate('length'), false, 'should NOT have notified length');

    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
  });

  suite.test('[A,B].replace(1,0,[X,Y]) => [A,X,Y,B] + notify', function () {
    var before = this.newFixture(2);
    var replace = this.newFixture(2);
    var after = [before[0], replace[0], replace[1], before[1]];

    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.replace(1, 0, replace);

    deepEqual(this.toArray(obj), after, 'post item results');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');

    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
  });

  suite.test('[A,B,C,D].replace(2,2) => [A,B] + notify', function () {
    var before = this.newFixture(4);
    var after = [before[0], before[1]];

    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.replace(2, 2);

    deepEqual(this.toArray(obj), after, 'post item results');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');

    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
  });

  suite.test('Adding object should notify enumerable observer', function () {
    var fixtures = this.newFixture(4);
    var obj = this.newObject(fixtures);
    var observer = this.newObserver(obj).observeEnumerable(obj);
    var item = this.newFixture(1)[0];

    obj.replace(2, 2, [item]);

    deepEqual(observer._before, [obj, [fixtures[2], fixtures[3]], 1], 'before');
    deepEqual(observer._after, [obj, 2, [item]], 'after');
  });

  suite.test('Adding object should notify array observer', function () {
    var fixtures = this.newFixture(4);
    var obj = this.newObject(fixtures);
    var observer = this.newObserver(obj).observeArray(obj);
    var item = this.newFixture(1)[0];

    obj.replace(2, 2, [item]);

    deepEqual(observer._before, [obj, 2, 2, 1], 'before');
    deepEqual(observer._after, [obj, 2, 2, 1], 'after');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/mutable_array/replace.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/mutable_array/replace.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/mutable_array/replace.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/mutable_array/reverseObjects', ['exports', 'ember-runtime/tests/suites/suite', 'ember-metal'], function (exports, _emberRuntimeTestsSuitesSuite, _emberMetal) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('reverseObjects');

  suite.test('[A,B,C].reverseObjects() => [] + notify', function () {
    var before = this.newFixture(3);
    var after = [before[2], before[1], before[0]];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    equal(obj.reverseObjects(), obj, 'return self');

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 0, 'should have notified length once');
    equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
    equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/mutable_array/reverseObjects.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/mutable_array/reverseObjects.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/mutable_array/reverseObjects.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/mutable_array/setObjects', ['exports', 'ember-metal', 'ember-runtime/tests/suites/suite'], function (exports, _emberMetal, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('setObjects');

  suite.test('[A,B,C].setObjects([]) = > [] + notify', function () {
    var before = this.newFixture(3);
    var after = [];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    equal(obj.setObjects(after), obj, 'return self');

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
    equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
  });

  suite.test('[A,B,C].setObjects([D, E, F, G]) = > [D, E, F, G] + notify', function () {
    var before = this.newFixture(3);
    var after = this.newFixture(4);
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    equal(obj.setObjects(after), obj, 'return self');

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
    equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/mutable_array/setObjects.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/mutable_array/setObjects.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/mutable_array/setObjects.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/mutable_array/shiftObject', ['exports', 'ember-runtime/tests/suites/suite', 'ember-metal'], function (exports, _emberRuntimeTestsSuitesSuite, _emberMetal) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('shiftObject');

  suite.test('[].shiftObject() => [] + returns undefined + NO notify', function () {
    var before = [];
    var after = [];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    equal(obj.shiftObject(), undefined);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.validate('[]', undefined, 1), false, 'should NOT have notified [] once');
    equal(observer.validate('@each', undefined, 1), false, 'should NOT have notified @each once');
    equal(observer.validate('length', undefined, 1), false, 'should NOT have notified length once');

    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject once');
    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
  });

  suite.test('[X].shiftObject() => [] + notify', function () {
    var before = this.newFixture(1);
    var after = [];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    equal(obj.shiftObject(), before[0], 'should return object');

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
    equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
  });

  suite.test('[A,B,C].shiftObject() => [B,C] + notify', function () {
    var before = this.newFixture(3);
    var after = [before[1], before[2]];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    equal(obj.shiftObject(), before[0], 'should return object');

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');

    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject once');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/mutable_array/shiftObject.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/mutable_array/shiftObject.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/mutable_array/shiftObject.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/mutable_array/unshiftObject', ['exports', 'ember-runtime/tests/suites/suite', 'ember-metal'], function (exports, _emberRuntimeTestsSuitesSuite, _emberMetal) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('unshiftObject');

  suite.test('returns unshifted object', function () {
    var obj = this.newObject([]);
    var item = this.newFixture(1)[0];

    equal(obj.unshiftObject(item), item, 'should return unshifted object');
  });

  suite.test('[].unshiftObject(X) => [X] + notify', function () {
    var before = [];
    var item = this.newFixture(1)[0];
    var after = [item];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.unshiftObject(item);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
    equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
  });

  suite.test('[A,B,C].unshiftObject(X) => [X,A,B,C] + notify', function () {
    var before = this.newFixture(3);
    var item = this.newFixture(1)[0];
    var after = [item, before[0], before[1], before[2]];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.unshiftObject(item);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');

    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
  });

  suite.test('[A,B,C].unshiftObject(A) => [A,A,B,C] + notify', function () {
    var before = this.newFixture(3);
    var item = before[0]; // note same object as current head. should end up twice
    var after = [item, before[0], before[1], before[2]];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.unshiftObject(item);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');

    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/mutable_array/unshiftObject.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/mutable_array/unshiftObject.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/mutable_array/unshiftObject.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/mutable_array/unshiftObjects', ['exports', 'ember-metal', 'ember-runtime/tests/suites/suite'], function (exports, _emberMetal, _emberRuntimeTestsSuitesSuite) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('unshiftObjects');

  suite.test('returns receiver', function () {
    var obj = this.newObject([]);
    var items = this.newFixture(3);

    equal(obj.unshiftObjects(items), obj, 'should return receiver');
  });

  suite.test('[].unshiftObjects([A,B,C]) => [A,B,C] + notify', function () {
    var before = [];
    var items = this.newFixture(3);
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.unshiftObjects(items);

    deepEqual(this.toArray(obj), items, 'post item results');
    equal(_emberMetal.get(obj, 'length'), items.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
    equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
  });

  suite.test('[A,B,C].unshiftObjects([X,Y]) => [X,Y,A,B,C] + notify', function () {
    var before = this.newFixture(3);
    var items = this.newFixture(2);
    var after = items.concat(before);
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.unshiftObjects(items);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');
    equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');

    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
  });

  suite.test('[A,B,C].unshiftObjects([A,B]) => [A,B,A,B,C] + notify', function () {
    var before = this.newFixture(3);
    var items = [before[0], before[1]]; // note same object as current head. should end up twice
    var after = items.concat(before);
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', '@each', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); /* Prime the cache */

    obj.unshiftObjects(items);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
    equal(observer.timesCalled('@each'), 0, 'should not have notified @each once');
    equal(observer.timesCalled('length'), 1, 'should have notified length once');

    equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
    equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/mutable_array/unshiftObjects.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/mutable_array/unshiftObjects.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/mutable_array/unshiftObjects.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/mutable_enumerable', ['exports', 'ember-runtime/tests/suites/enumerable', 'ember-runtime/tests/suites/mutable_enumerable/addObject', 'ember-runtime/tests/suites/mutable_enumerable/removeObject', 'ember-runtime/tests/suites/mutable_enumerable/removeObjects'], function (exports, _emberRuntimeTestsSuitesEnumerable, _emberRuntimeTestsSuitesMutable_enumerableAddObject, _emberRuntimeTestsSuitesMutable_enumerableRemoveObject, _emberRuntimeTestsSuitesMutable_enumerableRemoveObjects) {
  'use strict';

  var MutableEnumerableTests = _emberRuntimeTestsSuitesEnumerable.EnumerableTests.extend();
  MutableEnumerableTests.importModuleTests(_emberRuntimeTestsSuitesMutable_enumerableAddObject.default);
  MutableEnumerableTests.importModuleTests(_emberRuntimeTestsSuitesMutable_enumerableRemoveObject.default);
  MutableEnumerableTests.importModuleTests(_emberRuntimeTestsSuitesMutable_enumerableRemoveObjects.default);

  exports.default = MutableEnumerableTests;
});
enifed('ember-runtime/tests/suites/mutable_enumerable.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/mutable_enumerable.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/mutable_enumerable.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/mutable_enumerable/addObject', ['exports', 'ember-runtime/tests/suites/suite', 'ember-metal'], function (exports, _emberRuntimeTestsSuitesSuite, _emberMetal) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('addObject');

  suite.test('should return receiver', function () {
    var before = this.newFixture(3);
    var obj = this.newObject(before);

    equal(obj.addObject(before[1]), obj, 'should return receiver');
  });

  suite.test('[A,B].addObject(C) => [A,B,C] + notify', function () {
    var before = this.newFixture(2);
    var item = this.newFixture(1)[0];
    var after = [before[0], before[1], item];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');

    _emberMetal.get(obj, 'firstObject');
    _emberMetal.get(obj, 'lastObject');

    obj.addObject(item);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    if (observer.isEnabled) {
      equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      equal(observer.timesCalled('length'), 1, 'should have notified length once');
      equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject once');
      // This gets called since MutableEnumerable is naive about changes
      equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject once');
    }
  });

  suite.test('[A,B,C].addObject(A) => [A,B,C] + NO notify', function () {
    var before = this.newFixture(3);
    var after = before;
    var item = before[0];
    var obj = this.newObject(before);
    var observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');

    obj.addObject(item); // note: item in set

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    if (observer.isEnabled) {
      equal(observer.validate('[]'), false, 'should NOT have notified []');
      equal(observer.validate('length'), false, 'should NOT have notified length');
      equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
      equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
    }
  });

  suite.test('Adding object should notify enumerable observer', function () {
    var obj = this.newObject(this.newFixture(3));
    var observer = this.newObserver(obj).observeEnumerable(obj);
    var item = this.newFixture(1)[0];

    obj.addObject(item);

    deepEqual(observer._before, [obj, null, [item]]);
    deepEqual(observer._after, [obj, null, [item]]);
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/mutable_enumerable/addObject.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/mutable_enumerable/addObject.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/mutable_enumerable/addObject.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/mutable_enumerable/removeObject', ['exports', 'ember-metal', 'ember-runtime/tests/suites/suite', 'ember-runtime/system/native_array'], function (exports, _emberMetal, _emberRuntimeTestsSuitesSuite, _emberRuntimeSystemNative_array) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('removeObject');

  suite.test('should return receiver', function () {
    var before = this.newFixture(3);
    var obj = this.newObject(before);

    equal(obj.removeObject(before[1]), obj, 'should return receiver');
  });

  suite.test('[A,B,C].removeObject(B) => [A,C] + notify', function () {
    var before = _emberRuntimeSystemNative_array.A(this.newFixture(3));
    var after = [before[0], before[2]];
    var obj = before;
    var observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); // Prime the cache

    obj.removeObject(before[1]);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    if (observer.isEnabled) {
      equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      equal(observer.timesCalled('length'), 1, 'should have notified length once');

      equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
      equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
    }
  });

  suite.test('[A,B,C].removeObject(D) => [A,B,C]', function () {
    var before = _emberRuntimeSystemNative_array.A(this.newFixture(3));
    var after = before;
    var item = this.newFixture(1)[0];
    var obj = before;
    var observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); // Prime the cache

    obj.removeObject(item); // Note: item not in set

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    if (observer.isEnabled) {
      equal(observer.validate('[]'), false, 'should NOT have notified []');
      equal(observer.validate('length'), false, 'should NOT have notified length');

      equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
      equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
    }
  });

  suite.test('Removing object should notify enumerable observer', function () {
    var fixtures = this.newFixture(3);
    var obj = this.newObject(fixtures);
    var observer = this.newObserver(obj).observeEnumerable(obj);
    var item = fixtures[1];

    obj.removeObject(item);

    deepEqual(observer._before, [obj, [item], null]);
    deepEqual(observer._after, [obj, [item], null]);
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/mutable_enumerable/removeObject.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/mutable_enumerable/removeObject.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/mutable_enumerable/removeObject.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/mutable_enumerable/removeObjects', ['exports', 'ember-runtime/tests/suites/suite', 'ember-metal', 'ember-runtime/system/native_array'], function (exports, _emberRuntimeTestsSuitesSuite, _emberMetal, _emberRuntimeSystemNative_array) {
  'use strict';

  var suite = _emberRuntimeTestsSuitesSuite.SuiteModuleBuilder.create();

  suite.module('removeObjects');

  suite.test('should return receiver', function () {
    var before = _emberRuntimeSystemNative_array.A(this.newFixture(3));
    var obj = before;

    equal(obj.removeObjects(before[1]), obj, 'should return receiver');
  });

  suite.test('[A,B,C].removeObjects([B]) => [A,C] + notify', function () {
    var before = _emberRuntimeSystemNative_array.A(this.newFixture(3));
    var after = [before[0], before[2]];
    var obj = before;
    var observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); // Prime the cache

    obj.removeObjects([before[1]]);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    if (observer.isEnabled) {
      equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      equal(observer.timesCalled('length'), 1, 'should have notified length once');

      equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
      equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
    }
  });

  suite.test('[{A},{B},{C}].removeObjects([{B}]) => [{A},{C}] + notify', function () {
    var before = _emberRuntimeSystemNative_array.A(this.newObjectsFixture(3));
    var after = [before[0], before[2]];
    var obj = before;
    var observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); // Prime the cache

    obj.removeObjects([before[1]]);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    if (observer.isEnabled) {
      equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      equal(observer.timesCalled('length'), 1, 'should have notified length once');

      equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
      equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
    }
  });

  suite.test('[A,B,C].removeObjects([A,B]) => [C] + notify', function () {
    var before = _emberRuntimeSystemNative_array.A(this.newFixture(3));
    var after = [before[2]];
    var obj = before;
    var observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); // Prime the cache

    obj.removeObjects([before[0], before[1]]);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    if (observer.isEnabled) {
      equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      equal(observer.timesCalled('length'), 1, 'should have notified length once');

      equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject');
      equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
    }
  });

  suite.test('[{A},{B},{C}].removeObjects([{A},{B}]) => [{C}] + notify', function () {
    var before = _emberRuntimeSystemNative_array.A(this.newObjectsFixture(3));
    var after = [before[2]];
    var obj = before;
    var observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); // Prime the cache

    obj.removeObjects([before[0], before[1]]);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    if (observer.isEnabled) {
      equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      equal(observer.timesCalled('length'), 1, 'should have notified length once');

      equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject');
      equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
    }
  });

  suite.test('[A,B,C].removeObjects([A,B,C]) => [] + notify', function () {
    var before = _emberRuntimeSystemNative_array.A(this.newFixture(3));
    var after = [];
    var obj = before;
    var observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); // Prime the cache

    obj.removeObjects([before[0], before[1], before[2]]);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    if (observer.isEnabled) {
      equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      equal(observer.timesCalled('length'), 1, 'should have notified length once');

      equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject');
      equal(observer.timesCalled('lastObject'), 1, 'should have notified lastObject');
    }
  });

  suite.test('[{A},{B},{C}].removeObjects([{A},{B},{C}]) => [] + notify', function () {
    var before = _emberRuntimeSystemNative_array.A(this.newObjectsFixture(3));
    var after = [];
    var obj = before;
    var observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); // Prime the cache

    obj.removeObjects(before);

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    if (observer.isEnabled) {
      equal(observer.timesCalled('[]'), 1, 'should have notified [] once');
      equal(observer.timesCalled('length'), 1, 'should have notified length once');

      equal(observer.timesCalled('firstObject'), 1, 'should have notified firstObject');
      equal(observer.validate('lastObject'), 1, 'should have notified lastObject');
    }
  });

  suite.test('[A,B,C].removeObjects([D]) => [A,B,C]', function () {
    var before = _emberRuntimeSystemNative_array.A(this.newFixture(3));
    var after = before;
    var item = this.newFixture(1)[0];
    var obj = before;
    var observer = this.newObserver(obj, '[]', 'length', 'firstObject', 'lastObject');

    obj.getProperties('firstObject', 'lastObject'); // Prime the cache

    obj.removeObjects([item]); // Note: item not in set

    deepEqual(this.toArray(obj), after, 'post item results');
    equal(_emberMetal.get(obj, 'length'), after.length, 'length');

    if (observer.isEnabled) {
      equal(observer.validate('[]'), false, 'should NOT have notified []');
      equal(observer.validate('length'), false, 'should NOT have notified length');

      equal(observer.validate('firstObject'), false, 'should NOT have notified firstObject');
      equal(observer.validate('lastObject'), false, 'should NOT have notified lastObject');
    }
  });

  suite.test('Removing objects should notify enumerable observer', function () {
    var fixtures = this.newFixture(3);
    var obj = this.newObject(fixtures);
    var observer = this.newObserver(obj).observeEnumerable(obj);
    var item = fixtures[1];

    obj.removeObjects([item]);

    deepEqual(observer._before, [obj, [item], null]);
    deepEqual(observer._after, [obj, [item], null]);
  });

  exports.default = suite;
});
enifed('ember-runtime/tests/suites/mutable_enumerable/removeObjects.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/mutable_enumerable/removeObjects.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/mutable_enumerable/removeObjects.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/suites/suite', ['exports', 'ember-utils', 'ember-runtime/system/object', 'ember-metal'], function (exports, _emberUtils, _emberRuntimeSystemObject, _emberMetal) {
  'use strict';

  /*
    @class
    A Suite can be used to define a reusable set of unit tests that can be
    applied to any object.  Suites are most useful for defining tests that
    work against a mixin or plugin API.  Developers implementing objects that
    use the mixin or support the API can then run these tests against their
    own code to verify compliance.
  
    To define a suite, you need to define the tests themselves as well as a
    callback API implementers can use to tie your tests to their specific class.
  
    ## Defining a Callback API
  
    To define the callback API, just extend this class and add your properties
    or methods that must be provided.
  
    ## Defining Unit Tests
  
    To add unit tests, use the suite.module() or suite.test() methods instead
    of a regular module() or test() method when defining your tests.  This will
    add the tests to the suite.
  
    ## Using a Suite
  
    To use a Suite to test your own objects, extend the suite subclass and
    define any required methods.  Then call run() on the new subclass.  This
    will create an instance of your class and then defining the unit tests.
  
    @extends Ember.Object
    @private
  */
  var Suite = _emberRuntimeSystemObject.default.extend({

    /*
      __Required.__ You must implement this method to apply this mixin.
       Define a name for these tests - all modules are prefixed w/ it.
       @type String
    */
    name: null,

    /*
      Invoked to actually run the test - overridden by mixins
    */
    run: function () {}

  });

  Suite.reopenClass({

    plan: null,

    run: function () {
      var C = this;
      return new C().run();
    },

    module: function (desc, opts) {
      if (!opts) {
        opts = {};
      }

      var setup = opts.setup;
      var teardown = opts.teardown;
      this.reopen({
        run: function () {
          this._super.apply(this, arguments);
          var title = _emberMetal.get(this, 'name') + ': ' + desc;
          var ctx = this;
          QUnit.module(title, {
            setup: function () {
              if (setup) {
                setup.call(ctx);
              }
            },

            teardown: function () {
              if (teardown) {
                teardown.call(ctx);
              }
            }
          });
        }
      });
    },

    test: function (name, func) {
      this.reopen({
        run: function () {
          this._super.apply(this, arguments);
          var ctx = this;

          if (!func) {
            QUnit.test(name); // output warning
          } else {
              QUnit.test(name, function () {
                return func.call(ctx);
              });
            }
        }
      });
    },

    // convert to guids to minimize logging.
    same: function (actual, exp, message) {
      actual = actual && actual.map ? actual.map(function (x) {
        return _emberUtils.guidFor(x);
      }) : actual;
      exp = exp && exp.map ? exp.map(function (x) {
        return _emberUtils.guidFor(x);
      }) : exp;
      return deepEqual(actual, exp, message);
    },

    // easy way to disable tests
    notest: function () {},

    importModuleTests: function (builder) {
      var _this = this;

      this.module(builder._module);

      builder._tests.forEach(function (descAndFunc) {
        _this.test.apply(_this, descAndFunc);
      });
    }
  });

  var SuiteModuleBuilder = _emberRuntimeSystemObject.default.extend({
    _module: null,
    _tests: null,

    init: function () {
      this._tests = [];
    },

    module: function (name) {
      this._module = name;
    },

    test: function (name, func) {
      this._tests.push([name, func]);
    }
  });

  exports.SuiteModuleBuilder = SuiteModuleBuilder;
  exports.Suite = Suite;
  exports.default = Suite;
});
enifed('ember-runtime/tests/suites/suite.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/suites/suite.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/suites/suite.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/application/base_test', ['exports', 'ember-runtime/system/namespace', 'ember-runtime/system/application'], function (exports, _emberRuntimeSystemNamespace, _emberRuntimeSystemApplication) {
  'use strict';

  QUnit.module('Ember.Application');

  QUnit.test('Ember.Application should be a subclass of Ember.Namespace', function () {
    ok(_emberRuntimeSystemNamespace.default.detect(_emberRuntimeSystemApplication.default), 'Ember.Application subclass of Ember.Namespace');
  });
});
enifed('ember-runtime/tests/system/application/base_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/application/base_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/application/base_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/array_proxy/arranged_content_test', ['exports', 'ember-metal', 'ember-runtime/system/array_proxy', 'ember-runtime/system/native_array', 'ember-runtime/mixins/array'], function (exports, _emberMetal, _emberRuntimeSystemArray_proxy, _emberRuntimeSystemNative_array, _emberRuntimeMixinsArray) {
  'use strict';

  var array = undefined;

  QUnit.module('ArrayProxy - arrangedContent', {
    setup: function () {
      _emberMetal.run(function () {
        array = _emberRuntimeSystemArray_proxy.default.extend({
          arrangedContent: _emberMetal.computed('content.[]', function () {
            var content = this.get('content');
            return content && _emberRuntimeSystemNative_array.A(content.slice().sort(function (a, b) {
              if (a == null) {
                a = -1;
              }
              if (b == null) {
                b = -1;
              }
              return b - a;
            }));
          })
        }).create({
          content: _emberRuntimeSystemNative_array.A([1, 2, 4, 5])
        });
      });
    },
    teardown: function () {
      _emberMetal.run(function () {
        return array.destroy();
      });
    }
  });

  QUnit.test('addObject - adds to end of \'content\' if not present', function () {
    _emberMetal.run(function () {
      return array.addObject(3);
    });

    deepEqual(array.get('content'), [1, 2, 4, 5, 3], 'adds to end of content');
    deepEqual(array.get('arrangedContent'), [5, 4, 3, 2, 1], 'arrangedContent stays sorted');

    _emberMetal.run(function () {
      return array.addObject(1);
    });

    deepEqual(array.get('content'), [1, 2, 4, 5, 3], 'does not add existing number to content');
  });

  QUnit.test('addObjects - adds to end of \'content\' if not present', function () {
    _emberMetal.run(function () {
      return array.addObjects([1, 3, 6]);
    });

    deepEqual(array.get('content'), [1, 2, 4, 5, 3, 6], 'adds to end of content');
    deepEqual(array.get('arrangedContent'), [6, 5, 4, 3, 2, 1], 'arrangedContent stays sorted');
  });

  QUnit.test('compact - returns arrangedContent without nulls and undefined', function () {
    _emberMetal.run(function () {
      return array.set('content', _emberRuntimeSystemNative_array.A([1, 3, null, 2, undefined]));
    });

    deepEqual(array.compact(), [3, 2, 1]);
  });

  QUnit.test('indexOf - returns index of object in arrangedContent', function () {
    equal(array.indexOf(4), 1, 'returns arranged index');
  });

  QUnit.test('insertAt - raises, indeterminate behavior', function () {
    throws(function () {
      return _emberMetal.run(function () {
        return array.insertAt(2, 3);
      });
    });
  });

  QUnit.test('lastIndexOf - returns last index of object in arrangedContent', function () {
    _emberMetal.run(function () {
      return array.pushObject(4);
    });

    equal(array.lastIndexOf(4), 2, 'returns last arranged index');
  });

  QUnit.test('nextObject - returns object at index in arrangedContent', function () {
    equal(array.nextObject(1), 4, 'returns object at index');
  });

  QUnit.test('objectAt - returns object at index in arrangedContent', function () {
    equal(_emberRuntimeMixinsArray.objectAt(array, 1), 4, 'returns object at index');
  });

  // Not sure if we need a specific test for it, since it's internal
  QUnit.test('objectAtContent - returns object at index in arrangedContent', function () {
    equal(array.objectAtContent(1), 4, 'returns object at index');
  });

  QUnit.test('objectsAt - returns objects at indices in arrangedContent', function () {
    deepEqual(array.objectsAt([0, 2, 4]), [5, 2, undefined], 'returns objects at indices');
  });

  QUnit.test('popObject - removes last object in arrangedContent', function () {
    var popped = undefined;
    _emberMetal.run(function () {
      return popped = array.popObject();
    });
    equal(popped, 1, 'returns last object');
    deepEqual(array.get('content'), [2, 4, 5], 'removes from content');
  });

  QUnit.test('pushObject - adds to end of content even if it already exists', function () {
    _emberMetal.run(function () {
      return array.pushObject(1);
    });
    deepEqual(array.get('content'), [1, 2, 4, 5, 1], 'adds to end of content');
  });

  QUnit.test('pushObjects - adds multiple to end of content even if it already exists', function () {
    _emberMetal.run(function () {
      return array.pushObjects([1, 2, 4]);
    });
    deepEqual(array.get('content'), [1, 2, 4, 5, 1, 2, 4], 'adds to end of content');
  });

  QUnit.test('removeAt - removes from index in arrangedContent', function () {
    _emberMetal.run(function () {
      return array.removeAt(1, 2);
    });
    deepEqual(array.get('content'), [1, 5]);
  });

  QUnit.test('removeObject - removes object from content', function () {
    _emberMetal.run(function () {
      return array.removeObject(2);
    });
    deepEqual(array.get('content'), [1, 4, 5]);
  });

  QUnit.test('removeObjects - removes objects from content', function () {
    _emberMetal.run(function () {
      return array.removeObjects([2, 4, 6]);
    });
    deepEqual(array.get('content'), [1, 5]);
  });

  QUnit.test('replace - raises, indeterminate behavior', function () {
    throws(function () {
      return _emberMetal.run(function () {
        return array.replace(1, 2, [3]);
      });
    });
  });

  QUnit.test('replaceContent - does a standard array replace on content', function () {
    _emberMetal.run(function () {
      return array.replaceContent(1, 2, [3]);
    });
    deepEqual(array.get('content'), [1, 3, 5]);
  });

  QUnit.test('reverseObjects - raises, use Sortable#sortAscending', function () {
    throws(function () {
      return _emberMetal.run(function () {
        return array.reverseObjects();
      });
    });
  });

  QUnit.test('setObjects - replaces entire content', function () {
    _emberMetal.run(function () {
      return array.setObjects([6, 7, 8]);
    });
    deepEqual(array.get('content'), [6, 7, 8], 'replaces content');
  });

  QUnit.test('shiftObject - removes from start of arrangedContent', function () {
    var shifted = _emberMetal.run(function () {
      return array.shiftObject();
    });

    equal(shifted, 5, 'returns first object');
    deepEqual(array.get('content'), [1, 2, 4], 'removes object from content');
  });

  QUnit.test('slice - returns a slice of the arrangedContent', function () {
    deepEqual(array.slice(1, 3), [4, 2], 'returns sliced arrangedContent');
  });

  QUnit.test('toArray - returns copy of arrangedContent', function () {
    deepEqual(array.toArray(), [5, 4, 2, 1]);
  });

  QUnit.test('unshiftObject - adds to start of content', function () {
    _emberMetal.run(function () {
      return array.unshiftObject(6);
    });
    deepEqual(array.get('content'), [6, 1, 2, 4, 5], 'adds to start of content');
  });

  QUnit.test('unshiftObjects - adds to start of content', function () {
    _emberMetal.run(function () {
      array.unshiftObjects([6, 7]);
    });
    deepEqual(array.get('content'), [6, 7, 1, 2, 4, 5], 'adds to start of content');
  });

  QUnit.test('without - returns arrangedContent without object', function () {
    deepEqual(array.without(2), [5, 4, 1], 'returns arranged without object');
  });

  QUnit.test('lastObject - returns last arranged object', function () {
    equal(array.get('lastObject'), 1, 'returns last arranged object');
  });

  QUnit.test('firstObject - returns first arranged object', function () {
    equal(array.get('firstObject'), 5, 'returns first arranged object');
  });

  QUnit.module('ArrayProxy - arrangedContent matching content', {
    setup: function () {
      _emberMetal.run(function () {
        array = _emberRuntimeSystemArray_proxy.default.create({
          content: _emberRuntimeSystemNative_array.A([1, 2, 4, 5])
        });
      });
    },
    teardown: function () {
      _emberMetal.run(function () {
        array.destroy();
      });
    }
  });

  QUnit.test('insertAt - inserts object at specified index', function () {
    _emberMetal.run(function () {
      array.insertAt(2, 3);
    });
    deepEqual(array.get('content'), [1, 2, 3, 4, 5]);
  });

  QUnit.test('replace - does a standard array replace', function () {
    _emberMetal.run(function () {
      array.replace(1, 2, [3]);
    });
    deepEqual(array.get('content'), [1, 3, 5]);
  });

  QUnit.test('reverseObjects - reverses content', function () {
    _emberMetal.run(function () {
      array.reverseObjects();
    });
    deepEqual(array.get('content'), [5, 4, 2, 1]);
  });

  QUnit.module('ArrayProxy - arrangedContent with transforms', {
    setup: function () {
      _emberMetal.run(function () {
        array = _emberRuntimeSystemArray_proxy.default.extend({
          arrangedContent: _emberMetal.computed(function () {
            var content = this.get('content');
            return content && _emberRuntimeSystemNative_array.A(content.slice().sort(function (a, b) {
              if (a == null) {
                a = -1;
              }
              if (b == null) {
                b = -1;
              }
              return b - a;
            }));
          }).property('content.[]'),

          objectAtContent: function (idx) {
            var obj = _emberRuntimeMixinsArray.objectAt(this.get('arrangedContent'), idx);
            return obj && obj.toString();
          }
        }).create({
          content: _emberRuntimeSystemNative_array.A([1, 2, 4, 5])
        });
      });
    },
    teardown: function () {
      _emberMetal.run(function () {
        array.destroy();
      });
    }
  });

  QUnit.test('indexOf - returns index of object in arrangedContent', function () {
    equal(array.indexOf('4'), 1, 'returns arranged index');
  });

  QUnit.test('lastIndexOf - returns last index of object in arrangedContent', function () {
    _emberMetal.run(function () {
      array.pushObject(4);
    });
    equal(array.lastIndexOf('4'), 2, 'returns last arranged index');
  });

  QUnit.test('nextObject - returns object at index in arrangedContent', function () {
    equal(array.nextObject(1), '4', 'returns object at index');
  });

  QUnit.test('objectAt - returns object at index in arrangedContent', function () {
    equal(_emberRuntimeMixinsArray.objectAt(array, 1), '4', 'returns object at index');
  });

  // Not sure if we need a specific test for it, since it's internal
  QUnit.test('objectAtContent - returns object at index in arrangedContent', function () {
    equal(array.objectAtContent(1), '4', 'returns object at index');
  });

  QUnit.test('objectsAt - returns objects at indices in arrangedContent', function () {
    deepEqual(array.objectsAt([0, 2, 4]), ['5', '2', undefined], 'returns objects at indices');
  });

  QUnit.test('popObject - removes last object in arrangedContent', function () {
    var popped = undefined;
    _emberMetal.run(function () {
      popped = array.popObject();
    });
    equal(popped, '1', 'returns last object');
    deepEqual(array.get('content'), [2, 4, 5], 'removes from content');
  });

  QUnit.test('removeObject - removes object from content', function () {
    _emberMetal.run(function () {
      array.removeObject('2');
    });
    deepEqual(array.get('content'), [1, 4, 5]);
  });

  QUnit.test('removeObjects - removes objects from content', function () {
    _emberMetal.run(function () {
      array.removeObjects(['2', '4', '6']);
    });
    deepEqual(array.get('content'), [1, 5]);
  });

  QUnit.test('shiftObject - removes from start of arrangedContent', function () {
    var shifted = undefined;
    _emberMetal.run(function () {
      shifted = array.shiftObject();
    });
    equal(shifted, '5', 'returns first object');
    deepEqual(array.get('content'), [1, 2, 4], 'removes object from content');
  });

  QUnit.test('slice - returns a slice of the arrangedContent', function () {
    deepEqual(array.slice(1, 3), ['4', '2'], 'returns sliced arrangedContent');
  });

  QUnit.test('toArray - returns copy of arrangedContent', function () {
    deepEqual(array.toArray(), ['5', '4', '2', '1']);
  });

  QUnit.test('without - returns arrangedContent without object', function () {
    deepEqual(array.without('2'), ['5', '4', '1'], 'returns arranged without object');
  });

  QUnit.test('lastObject - returns last arranged object', function () {
    equal(array.get('lastObject'), '1', 'returns last arranged object');
  });

  QUnit.test('firstObject - returns first arranged object', function () {
    equal(array.get('firstObject'), '5', 'returns first arranged object');
  });

  QUnit.test('arrangedContentArray{Will,Did}Change are called when the arranged content changes', function () {
    // The behaviour covered by this test may change in the future if we decide
    // that built-in array methods are not overridable.

    var willChangeCallCount = 0;
    var didChangeCallCount = 0;

    var content = _emberRuntimeSystemNative_array.A([1, 2, 3]);
    _emberRuntimeSystemArray_proxy.default.extend({
      arrangedContentArrayWillChange: function () {
        willChangeCallCount++;
        this._super.apply(this, arguments);
      },
      arrangedContentArrayDidChange: function () {
        didChangeCallCount++;
        this._super.apply(this, arguments);
      }
    }).create({ content: content });

    equal(willChangeCallCount, 0);
    equal(didChangeCallCount, 0);

    content.pushObject(4);
    content.pushObject(5);

    equal(willChangeCallCount, 2);
    equal(didChangeCallCount, 2);
  });
});
enifed('ember-runtime/tests/system/array_proxy/arranged_content_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/array_proxy/arranged_content_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/array_proxy/arranged_content_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/array_proxy/content_change_test', ['exports', 'ember-metal', 'ember-runtime/computed/computed_macros', 'ember-runtime/system/array_proxy', 'ember-runtime/system/native_array'], function (exports, _emberMetal, _emberRuntimeComputedComputed_macros, _emberRuntimeSystemArray_proxy, _emberRuntimeSystemNative_array) {
  'use strict';

  QUnit.module('ArrayProxy - content change');

  QUnit.test('should update length for null content', function () {
    var proxy = _emberRuntimeSystemArray_proxy.default.create({
      content: _emberRuntimeSystemNative_array.A([1, 2, 3])
    });

    equal(proxy.get('length'), 3, 'precond - length is 3');

    proxy.set('content', null);

    equal(proxy.get('length'), 0, 'length updates');
  });

  QUnit.test('should update length for null content when there is a computed property watching length', function () {
    var proxy = _emberRuntimeSystemArray_proxy.default.extend({
      isEmpty: _emberRuntimeComputedComputed_macros.not('length')
    }).create({
      content: _emberRuntimeSystemNative_array.A([1, 2, 3])
    });

    equal(proxy.get('length'), 3, 'precond - length is 3');

    // Consume computed property that depends on length
    proxy.get('isEmpty');

    // update content
    proxy.set('content', null);

    equal(proxy.get('length'), 0, 'length updates');
  });

  QUnit.test('The `arrangedContentWillChange` method is invoked before `content` is changed.', function () {
    var callCount = 0;
    var expectedLength = undefined;

    var proxy = _emberRuntimeSystemArray_proxy.default.extend({
      arrangedContentWillChange: function () {
        equal(this.get('arrangedContent.length'), expectedLength, 'hook should be invoked before array has changed');
        callCount++;
      }
    }).create({ content: _emberRuntimeSystemNative_array.A([1, 2, 3]) });

    proxy.pushObject(4);
    equal(callCount, 0, 'pushing content onto the array doesn\'t trigger it');

    proxy.get('content').pushObject(5);
    equal(callCount, 0, 'pushing content onto the content array doesn\'t trigger it');

    expectedLength = 5;
    proxy.set('content', _emberRuntimeSystemNative_array.A(['a', 'b']));
    equal(callCount, 1, 'replacing the content array triggers the hook');
  });

  QUnit.test('The `arrangedContentDidChange` method is invoked after `content` is changed.', function () {
    var callCount = 0;
    var expectedLength = undefined;

    var proxy = _emberRuntimeSystemArray_proxy.default.extend({
      arrangedContentDidChange: function () {
        equal(this.get('arrangedContent.length'), expectedLength, 'hook should be invoked after array has changed');
        callCount++;
      }
    }).create({
      content: _emberRuntimeSystemNative_array.A([1, 2, 3])
    });

    equal(callCount, 0, 'hook is not called after creating the object');

    proxy.pushObject(4);
    equal(callCount, 0, 'pushing content onto the array doesn\'t trigger it');

    proxy.get('content').pushObject(5);
    equal(callCount, 0, 'pushing content onto the content array doesn\'t trigger it');

    expectedLength = 2;
    proxy.set('content', _emberRuntimeSystemNative_array.A(['a', 'b']));
    equal(callCount, 1, 'replacing the content array triggers the hook');
  });

  QUnit.test('The ArrayProxy doesn\'t explode when assigned a destroyed object', function () {
    var proxy1 = _emberRuntimeSystemArray_proxy.default.create();
    var proxy2 = _emberRuntimeSystemArray_proxy.default.create();

    _emberMetal.run(function () {
      return proxy1.destroy();
    });

    _emberMetal.set(proxy2, 'content', proxy1);

    ok(true, 'No exception was raised');
  });

  QUnit.test('arrayContent{Will,Did}Change are called when the content changes', function () {
    // The behaviour covered by this test may change in the future if we decide
    // that built-in array methods are not overridable.

    var willChangeCallCount = 0;
    var didChangeCallCount = 0;

    var content = _emberRuntimeSystemNative_array.A([1, 2, 3]);
    _emberRuntimeSystemArray_proxy.default.extend({
      arrayContentWillChange: function () {
        willChangeCallCount++;
        this._super.apply(this, arguments);
      },
      arrayContentDidChange: function () {
        didChangeCallCount++;
        this._super.apply(this, arguments);
      }
    }).create({ content: content });

    equal(willChangeCallCount, 0);
    equal(didChangeCallCount, 0);

    content.pushObject(4);
    content.pushObject(5);

    equal(willChangeCallCount, 2);
    equal(didChangeCallCount, 2);
  });
});
enifed('ember-runtime/tests/system/array_proxy/content_change_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/array_proxy/content_change_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/array_proxy/content_change_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/array_proxy/content_update_test', ['exports', 'ember-metal', 'ember-runtime/system/array_proxy', 'ember-runtime/system/native_array'], function (exports, _emberMetal, _emberRuntimeSystemArray_proxy, _emberRuntimeSystemNative_array) {
  'use strict';

  QUnit.module('Ember.ArrayProxy - content update');

  QUnit.test('The `contentArrayDidChange` method is invoked after `content` is updated.', function () {
    var observerCalled = false;
    var proxy = _emberRuntimeSystemArray_proxy.default.extend({
      arrangedContent: _emberMetal.computed('content', function (key) {
        return _emberRuntimeSystemNative_array.A(this.get('content').slice());
      }),

      contentArrayDidChange: function (array, idx, removedCount, addedCount) {
        observerCalled = true;
        return this._super(array, idx, removedCount, addedCount);
      }
    }).create({
      content: _emberRuntimeSystemNative_array.A()
    });

    proxy.pushObject(1);

    ok(observerCalled, 'contentArrayDidChange is invoked');
  });
});
enifed('ember-runtime/tests/system/array_proxy/content_update_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/array_proxy/content_update_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/array_proxy/content_update_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/array_proxy/length_test', ['exports', 'ember-runtime/system/array_proxy', 'ember-runtime/system/object', 'ember-metal', 'ember-runtime/system/native_array'], function (exports, _emberRuntimeSystemArray_proxy, _emberRuntimeSystemObject, _emberMetal, _emberRuntimeSystemNative_array) {
  'use strict';

  QUnit.module('Ember.ArrayProxy - content change (length)');

  QUnit.test('array proxy + aliasedProperty complex test', function () {
    var aCalled = undefined,
        bCalled = undefined,
        cCalled = undefined,
        dCalled = undefined,
        eCalled = undefined;

    aCalled = bCalled = cCalled = dCalled = eCalled = 0;

    var obj = _emberRuntimeSystemObject.default.extend({
      colors: _emberMetal.computed.reads('model'),
      length: _emberMetal.computed.reads('colors.length'),

      a: _emberMetal.observer('length', function () {
        return aCalled++;
      }),
      b: _emberMetal.observer('colors.length', function () {
        return bCalled++;
      }),
      c: _emberMetal.observer('colors.content.length', function () {
        return cCalled++;
      }),
      d: _emberMetal.observer('colors.[]', function () {
        return dCalled++;
      }),
      e: _emberMetal.observer('colors.content.[]', function () {
        return eCalled++;
      })
    }).create();

    obj.set('model', _emberRuntimeSystemArray_proxy.default.create({
      content: _emberRuntimeSystemNative_array.A(['red', 'yellow', 'blue'])
    }));

    equal(obj.get('colors.content.length'), 3);
    equal(obj.get('colors.length'), 3);
    equal(obj.get('length'), 3);

    equal(aCalled, 1, 'expected observer `length` to be called ONCE');
    equal(bCalled, 1, 'expected observer `colors.length` to be called ONCE');
    equal(cCalled, 1, 'expected observer `colors.content.length` to be called ONCE');
    equal(dCalled, 1, 'expected observer `colors.[]` to be called ONCE');
    equal(eCalled, 1, 'expected observer `colors.content.[]` to be called ONCE');

    obj.get('colors').pushObjects(['green', 'red']);

    equal(obj.get('colors.content.length'), 5);
    equal(obj.get('colors.length'), 5);
    equal(obj.get('length'), 5);

    equal(aCalled, 2, 'expected observer `length` to be called TWICE');
    equal(bCalled, 2, 'expected observer `colors.length` to be called TWICE');
    equal(cCalled, 2, 'expected observer `colors.content.length` to be called TWICE');
    equal(dCalled, 2, 'expected observer `colors.[]` to be called TWICE');
    equal(eCalled, 2, 'expected observer `colors.content.[]` to be called TWICE');
  });
});
enifed('ember-runtime/tests/system/array_proxy/length_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/array_proxy/length_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/array_proxy/length_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/array_proxy/suite_test', ['exports', 'ember-runtime/tests/suites/mutable_array', 'ember-runtime/system/array_proxy', 'ember-metal', 'ember-runtime/system/native_array'], function (exports, _emberRuntimeTestsSuitesMutable_array, _emberRuntimeSystemArray_proxy, _emberMetal, _emberRuntimeSystemNative_array) {
  'use strict';

  _emberRuntimeTestsSuitesMutable_array.default.extend({
    name: 'Ember.ArrayProxy',

    newObject: function (ary) {
      var ret = ary ? ary.slice() : this.newFixture(3);
      return _emberRuntimeSystemArray_proxy.default.create({ content: _emberRuntimeSystemNative_array.A(ret) });
    },

    mutate: function (obj) {
      obj.pushObject(_emberMetal.get(obj, 'length') + 1);
    },

    toArray: function (obj) {
      return obj.toArray ? obj.toArray() : obj.slice();
    }
  }).run();
});
enifed('ember-runtime/tests/system/array_proxy/suite_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/array_proxy/suite_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/array_proxy/suite_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/array_proxy/watching_and_listening_test', ['exports', 'ember-metal', 'ember-runtime/system/array_proxy', 'ember-runtime/system/native_array'], function (exports, _emberMetal, _emberRuntimeSystemArray_proxy, _emberRuntimeSystemNative_array) {
  'use strict';

  function sortedListenersFor(obj, eventName) {
    return _emberMetal.listenersFor(obj, eventName).sort(function (listener1, listener2) {
      return listener1[1] > listener2[1] ? -1 : 1;
    });
  }

  QUnit.module('ArrayProxy - watching and listening');

  QUnit.test('setting \'content\' adds listeners correctly', function () {
    var content = _emberRuntimeSystemNative_array.A();
    var proxy = _emberRuntimeSystemArray_proxy.default.create();

    deepEqual(sortedListenersFor(content, '@array:before'), []);
    deepEqual(sortedListenersFor(content, '@array:change'), []);

    proxy.set('content', content);

    deepEqual(sortedListenersFor(content, '@array:before'), [[proxy, 'contentArrayWillChange'], [proxy, 'arrangedContentArrayWillChange']]);
    deepEqual(sortedListenersFor(content, '@array:change'), [[proxy, 'contentArrayDidChange'], [proxy, 'arrangedContentArrayDidChange']]);
  });

  QUnit.test('changing \'content\' adds and removes listeners correctly', function () {
    var content1 = _emberRuntimeSystemNative_array.A();
    var content2 = _emberRuntimeSystemNative_array.A();
    var proxy = _emberRuntimeSystemArray_proxy.default.create({ content: content1 });

    deepEqual(sortedListenersFor(content1, '@array:before'), [[proxy, 'contentArrayWillChange'], [proxy, 'arrangedContentArrayWillChange']]);
    deepEqual(sortedListenersFor(content1, '@array:change'), [[proxy, 'contentArrayDidChange'], [proxy, 'arrangedContentArrayDidChange']]);

    proxy.set('content', content2);

    deepEqual(sortedListenersFor(content1, '@array:before'), []);
    deepEqual(sortedListenersFor(content1, '@array:change'), []);
    deepEqual(sortedListenersFor(content2, '@array:before'), [[proxy, 'contentArrayWillChange'], [proxy, 'arrangedContentArrayWillChange']]);
    deepEqual(sortedListenersFor(content2, '@array:change'), [[proxy, 'contentArrayDidChange'], [proxy, 'arrangedContentArrayDidChange']]);
  });

  QUnit.test('regression test for https://github.com/emberjs/ember.js/issues/12475', function () {
    var item1a = { id: 1 };
    var item1b = { id: 2 };
    var item1c = { id: 3 };
    var content1 = _emberRuntimeSystemNative_array.A([item1a, item1b, item1c]);

    var proxy = _emberRuntimeSystemArray_proxy.default.create({ content: content1 });
    var obj = { proxy: proxy };

    _emberMetal.defineProperty(obj, 'ids', _emberMetal.computed('proxy.@each.id', function () {
      return _emberMetal.get(this, 'proxy').mapBy('id');
    }));

    // These manually added observers are to simulate the observers added by the
    // rendering process in a template like:
    //
    // {{#each items as |item|}}
    //   {{item.id}}
    // {{/each}}
    _emberMetal.addObserver(item1a, 'id', function () {});
    _emberMetal.addObserver(item1b, 'id', function () {});
    _emberMetal.addObserver(item1c, 'id', function () {});

    // The EachProxy has not yet been consumed. Only the manually added
    // observers are watching.
    equal(_emberMetal.watcherCount(item1a, 'id'), 1);
    equal(_emberMetal.watcherCount(item1b, 'id'), 1);
    equal(_emberMetal.watcherCount(item1c, 'id'), 1);

    // Consume the each proxy. This causes the EachProxy to add two observers
    // per item: one for "before" events and one for "after" events.
    deepEqual(_emberMetal.get(obj, 'ids'), [1, 2, 3]);

    // For each item, the two each proxy observers and one manual added observer
    // are watching.
    equal(_emberMetal.watcherCount(item1a, 'id'), 3);
    equal(_emberMetal.watcherCount(item1b, 'id'), 3);
    equal(_emberMetal.watcherCount(item1c, 'id'), 3);

    // This should be a no-op because observers do not fire if the value
    // 1. is an object and 2. is the same as the old value.
    proxy.set('content', content1);

    equal(_emberMetal.watcherCount(item1a, 'id'), 3);
    equal(_emberMetal.watcherCount(item1b, 'id'), 3);
    equal(_emberMetal.watcherCount(item1c, 'id'), 3);

    // This is repeated to catch the regression. It should still be a no-op.
    proxy.set('content', content1);

    equal(_emberMetal.watcherCount(item1a, 'id'), 3);
    equal(_emberMetal.watcherCount(item1b, 'id'), 3);
    equal(_emberMetal.watcherCount(item1c, 'id'), 3);

    // Set the content to a new array with completely different items and
    // repeat the process.
    var item2a = { id: 4 };
    var item2b = { id: 5 };
    var item2c = { id: 6 };
    var content2 = _emberRuntimeSystemNative_array.A([item2a, item2b, item2c]);

    _emberMetal.addObserver(item2a, 'id', function () {});
    _emberMetal.addObserver(item2b, 'id', function () {});
    _emberMetal.addObserver(item2c, 'id', function () {});

    proxy.set('content', content2);

    deepEqual(_emberMetal.get(obj, 'ids'), [4, 5, 6]);

    equal(_emberMetal.watcherCount(item2a, 'id'), 3);
    equal(_emberMetal.watcherCount(item2b, 'id'), 3);
    equal(_emberMetal.watcherCount(item2c, 'id'), 3);

    // Ensure that the observers added by the EachProxy on all items in the
    // first content array have been torn down.
    equal(_emberMetal.watcherCount(item1a, 'id'), 1);
    equal(_emberMetal.watcherCount(item1b, 'id'), 1);
    equal(_emberMetal.watcherCount(item1c, 'id'), 1);

    proxy.set('content', content2);

    equal(_emberMetal.watcherCount(item2a, 'id'), 3);
    equal(_emberMetal.watcherCount(item2b, 'id'), 3);
    equal(_emberMetal.watcherCount(item2c, 'id'), 3);

    proxy.set('content', content2);

    equal(_emberMetal.watcherCount(item2a, 'id'), 3);
    equal(_emberMetal.watcherCount(item2b, 'id'), 3);
    equal(_emberMetal.watcherCount(item2c, 'id'), 3);
  });
});
enifed('ember-runtime/tests/system/array_proxy/watching_and_listening_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/array_proxy/watching_and_listening_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/array_proxy/watching_and_listening_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/core_object_test', ['exports', 'ember-runtime/system/core_object', 'ember-metal/property_set', 'ember-metal/mixin'], function (exports, _emberRuntimeSystemCore_object, _emberMetalProperty_set, _emberMetalMixin) {
  'use strict';

  QUnit.module('Ember.CoreObject');

  QUnit.test('works with new (one arg)', function () {
    var obj = new _emberRuntimeSystemCore_object.default({
      firstName: 'Stef',
      lastName: 'Penner'
    });

    equal(obj.firstName, 'Stef');
    equal(obj.lastName, 'Penner');
  });

  QUnit.test('works with new (> 1 arg)', function () {
    var obj = new _emberRuntimeSystemCore_object.default({
      firstName: 'Stef',
      lastName: 'Penner'
    }, {
      other: 'name'
    });

    equal(obj.firstName, 'Stef');
    equal(obj.lastName, 'Penner');

    equal(obj.other, undefined); // doesn't support multiple pojo' to the constructor
  });

  QUnit.test('toString should be not be added as a property when calling toString()', function () {
    var obj = new _emberRuntimeSystemCore_object.default({
      firstName: 'Foo',
      lastName: 'Bar'
    });

    obj.toString();

    notOk(obj.hasOwnProperty('toString'), 'Calling toString() should not create a toString class property');
  });

  QUnit.test('[POST_INIT] invoked during construction', function (assert) {
    var _CoreObject$extend;

    var callCount = 0;
    var Obj = _emberRuntimeSystemCore_object.default.extend((_CoreObject$extend = {}, _CoreObject$extend[_emberRuntimeSystemCore_object.POST_INIT] = function () {
      callCount++;
    }, _CoreObject$extend));

    equal(callCount, 0);

    Obj.create();

    equal(callCount, 1);
  });

  QUnit.test('[POST_INIT] invoked before finishChains', function (assert) {
    var _CoreObject$extend2;

    var callCount = 0;

    var Obj = _emberRuntimeSystemCore_object.default.extend((_CoreObject$extend2 = {}, _CoreObject$extend2[_emberRuntimeSystemCore_object.POST_INIT] = function () {
      _emberMetalProperty_set.set(this, 'hi', 1);
    }, _CoreObject$extend2.hiDidChange = _emberMetalMixin.observer('hi', function () {
      callCount++;
    }), _CoreObject$extend2));

    equal(callCount, 0);

    var obj = Obj.create();

    equal(callCount, 0);

    _emberMetalProperty_set.set(obj, 'hi', 2);

    equal(callCount, 1);
  });
});
enifed('ember-runtime/tests/system/core_object_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/core_object_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/core_object_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/lazy_load_test', ['exports', 'ember-metal', 'ember-runtime/system/lazy_load'], function (exports, _emberMetal, _emberRuntimeSystemLazy_load) {
  'use strict';

  QUnit.module('Lazy Loading', {
    teardown: function () {
      var keys = Object.keys(_emberRuntimeSystemLazy_load._loaded);
      for (var i = 0; i < keys.length; i++) {
        delete _emberRuntimeSystemLazy_load._loaded[keys[i]];
      }
    }
  });

  QUnit.test('if a load hook is registered, it is executed when runLoadHooks are exected', function () {
    var count = 0;

    _emberMetal.run(function () {
      _emberRuntimeSystemLazy_load.onLoad('__test_hook__', function (object) {
        count += object;
      });
    });

    _emberMetal.run(function () {
      _emberRuntimeSystemLazy_load.runLoadHooks('__test_hook__', 1);
    });

    equal(count, 1, 'the object was passed into the load hook');
  });

  QUnit.test('if runLoadHooks was already run, it executes newly added hooks immediately', function () {
    var count = 0;
    _emberMetal.run(function () {
      _emberRuntimeSystemLazy_load.onLoad('__test_hook__', function (object) {
        return count += object;
      });
    });

    _emberMetal.run(function () {
      return _emberRuntimeSystemLazy_load.runLoadHooks('__test_hook__', 1);
    });

    count = 0;
    _emberMetal.run(function () {
      _emberRuntimeSystemLazy_load.onLoad('__test_hook__', function (object) {
        return count += object;
      });
    });

    equal(count, 1, 'the original object was passed into the load hook');
  });

  QUnit.test('hooks in ENV.EMBER_LOAD_HOOKS[\'hookName\'] get executed', function () {
    // Note that the necessary code to perform this test is run before
    // the Ember lib is loaded in tests/index.html

    _emberMetal.run(function () {
      _emberRuntimeSystemLazy_load.runLoadHooks('__before_ember_test_hook__', 1);
    });

    equal(window.ENV.__test_hook_count__, 1, 'the object was passed into the load hook');
  });

  if (typeof window === 'object' && typeof window.dispatchEvent === 'function' && typeof CustomEvent === 'function') {
    QUnit.test('load hooks trigger a custom event', function () {
      var eventObject = 'super duper awesome events';

      window.addEventListener('__test_hook_for_events__', function (e) {
        ok(true, 'custom event was fired');
        equal(e.detail, eventObject, 'event details are provided properly');
      });

      _emberMetal.run(function () {
        _emberRuntimeSystemLazy_load.runLoadHooks('__test_hook_for_events__', eventObject);
      });
    });
  }
});
enifed('ember-runtime/tests/system/lazy_load_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/lazy_load_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/lazy_load_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/namespace/base_test', ['exports', 'ember-environment', 'ember-metal', 'ember-runtime/system/object', 'ember-runtime/system/namespace'], function (exports, _emberEnvironment, _emberMetal, _emberRuntimeSystemObject, _emberRuntimeSystemNamespace) {
  'use strict';

  var originalLookup = _emberEnvironment.context.lookup;
  var lookup = undefined;

  QUnit.module('Namespace', {
    setup: function () {
      _emberRuntimeSystemNamespace.setSearchDisabled(false);

      lookup = _emberEnvironment.context.lookup = {};
    },
    teardown: function () {
      _emberRuntimeSystemNamespace.setSearchDisabled(false);

      for (var prop in lookup) {
        if (lookup[prop]) {
          _emberMetal.run(lookup[prop], 'destroy');
        }
      }

      _emberEnvironment.context.lookup = originalLookup;
    }
  });

  QUnit.test('Namespace should be a subclass of EmberObject', function () {
    ok(_emberRuntimeSystemObject.default.detect(_emberRuntimeSystemNamespace.default));
  });

  QUnit.test('Namespace should be duck typed', function () {
    ok(_emberMetal.get(_emberRuntimeSystemNamespace.default.create(), 'isNamespace'), 'isNamespace property is true');
  });

  QUnit.test('Namespace is found and named', function () {
    var nsA = lookup.NamespaceA = _emberRuntimeSystemNamespace.default.create();
    equal(nsA.toString(), 'NamespaceA', 'namespaces should have a name if they are on lookup');

    var nsB = lookup.NamespaceB = _emberRuntimeSystemNamespace.default.create();
    equal(nsB.toString(), 'NamespaceB', 'namespaces work if created after the first namespace processing pass');
  });

  QUnit.test('Classes under an Namespace are properly named', function () {
    var nsA = lookup.NamespaceA = _emberRuntimeSystemNamespace.default.create();
    nsA.Foo = _emberRuntimeSystemObject.default.extend();
    equal(nsA.Foo.toString(), 'NamespaceA.Foo', 'Classes pick up their parent namespace');

    nsA.Bar = _emberRuntimeSystemObject.default.extend();
    equal(nsA.Bar.toString(), 'NamespaceA.Bar', 'New Classes get the naming treatment too');

    var nsB = lookup.NamespaceB = _emberRuntimeSystemNamespace.default.create();
    nsB.Foo = _emberRuntimeSystemObject.default.extend();
    equal(nsB.Foo.toString(), 'NamespaceB.Foo', 'Classes in new namespaces get the naming treatment');
  });

  //test("Classes under Ember are properly named", function() {
  //  // ES6TODO: This test does not work reliably when running independent package build with Broccoli config.
  //  Ember.TestObject = EmberObject.extend({});
  //  equal(Ember.TestObject.toString(), "Ember.TestObject", "class under Ember is given a string representation");
  //});

  QUnit.test('Lowercase namespaces are no longer supported', function () {
    var nsC = lookup.namespaceC = _emberRuntimeSystemNamespace.default.create();
    equal(nsC.toString(), undefined);
  });

  QUnit.test('A namespace can be assigned a custom name', function () {
    var nsA = _emberRuntimeSystemNamespace.default.create({
      name: 'NamespaceA'
    });

    var nsB = lookup.NamespaceB = _emberRuntimeSystemNamespace.default.create({
      name: 'CustomNamespaceB'
    });

    nsA.Foo = _emberRuntimeSystemObject.default.extend();
    nsB.Foo = _emberRuntimeSystemObject.default.extend();

    equal(nsA.Foo.toString(), 'NamespaceA.Foo', 'The namespace\'s name is used when the namespace is not in the lookup object');
    equal(nsB.Foo.toString(), 'CustomNamespaceB.Foo', 'The namespace\'s name is used when the namespace is in the lookup object');
  });

  QUnit.test('Calling namespace.nameClasses() eagerly names all classes', function () {
    _emberRuntimeSystemNamespace.setSearchDisabled(true);

    var namespace = lookup.NS = _emberRuntimeSystemNamespace.default.create();

    namespace.ClassA = _emberRuntimeSystemObject.default.extend();
    namespace.ClassB = _emberRuntimeSystemObject.default.extend();

    _emberRuntimeSystemNamespace.default.processAll();

    equal(namespace.ClassA.toString(), 'NS.ClassA');
    equal(namespace.ClassB.toString(), 'NS.ClassB');
  });

  QUnit.test('A namespace can be looked up by its name', function () {
    var NS = lookup.NS = _emberRuntimeSystemNamespace.default.create();
    var UI = lookup.UI = _emberRuntimeSystemNamespace.default.create();
    var CF = lookup.CF = _emberRuntimeSystemNamespace.default.create();

    equal(_emberRuntimeSystemNamespace.default.byName('NS'), NS);
    equal(_emberRuntimeSystemNamespace.default.byName('UI'), UI);
    equal(_emberRuntimeSystemNamespace.default.byName('CF'), CF);
  });

  QUnit.test('A nested namespace can be looked up by its name', function () {
    var UI = lookup.UI = _emberRuntimeSystemNamespace.default.create();
    UI.Nav = _emberRuntimeSystemNamespace.default.create();

    equal(_emberRuntimeSystemNamespace.default.byName('UI.Nav'), UI.Nav);
  });

  QUnit.test('Destroying a namespace before caching lookup removes it from the list of namespaces', function () {
    var CF = lookup.CF = _emberRuntimeSystemNamespace.default.create();

    _emberMetal.run(CF, 'destroy');
    equal(_emberRuntimeSystemNamespace.default.byName('CF'), undefined, 'namespace can not be found after destroyed');
  });

  QUnit.test('Destroying a namespace after looking up removes it from the list of namespaces', function () {
    var CF = lookup.CF = _emberRuntimeSystemNamespace.default.create();

    equal(_emberRuntimeSystemNamespace.default.byName('CF'), CF, 'precondition - namespace can be looked up by name');

    _emberMetal.run(CF, 'destroy');
    equal(_emberRuntimeSystemNamespace.default.byName('CF'), undefined, 'namespace can not be found after destroyed');
  });
});
enifed('ember-runtime/tests/system/namespace/base_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/namespace/base_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/namespace/base_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/native_array/a_test', ['exports', 'ember-runtime/mixins/array', 'ember-runtime/system/native_array'], function (exports, _emberRuntimeMixinsArray, _emberRuntimeSystemNative_array) {
  'use strict';

  QUnit.module('Ember.A');

  QUnit.test('Ember.A', function () {
    deepEqual(_emberRuntimeSystemNative_array.A([1, 2]), [1, 2], 'array values were not be modified');
    deepEqual(_emberRuntimeSystemNative_array.A(), [], 'returned an array with no arguments');
    deepEqual(_emberRuntimeSystemNative_array.A(null), [], 'returned an array with a null argument');
    ok(_emberRuntimeMixinsArray.default.detect(_emberRuntimeSystemNative_array.A()), 'returned an ember array');
    ok(_emberRuntimeMixinsArray.default.detect(_emberRuntimeSystemNative_array.A([1, 2])), 'returned an ember array');
  });
});
enifed('ember-runtime/tests/system/native_array/a_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/native_array/a_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/native_array/a_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/native_array/copyable_suite_test', ['exports', 'ember-utils', 'ember-runtime/system/native_array', 'ember-runtime/tests/suites/copyable'], function (exports, _emberUtils, _emberRuntimeSystemNative_array, _emberRuntimeTestsSuitesCopyable) {
  'use strict';

  _emberRuntimeTestsSuitesCopyable.default.extend({
    name: 'NativeArray Copyable',

    newObject: function () {
      return _emberRuntimeSystemNative_array.A([_emberUtils.generateGuid()]);
    },

    isEqual: function (a, b) {
      if (!(a instanceof Array)) {
        return false;
      }

      if (!(b instanceof Array)) {
        return false;
      }

      if (a.length !== b.length) {
        return false;
      }

      return a[0] === b[0];
    },

    shouldBeFreezable: false
  }).run();

  QUnit.module('NativeArray Copyable');

  QUnit.test('deep copy is respected', function () {
    var array = _emberRuntimeSystemNative_array.A([{ id: 1 }, { id: 2 }, { id: 3 }]);

    var copiedArray = array.copy(true);

    deepEqual(copiedArray, array, 'copied array is equivalent');
    ok(copiedArray[0] !== array[0], 'objects inside should be unique');
  });
});
enifed('ember-runtime/tests/system/native_array/copyable_suite_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/native_array/copyable_suite_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/native_array/copyable_suite_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/native_array/suite_test', ['exports', 'ember-runtime/system/native_array', 'ember-runtime/tests/suites/mutable_array'], function (exports, _emberRuntimeSystemNative_array, _emberRuntimeTestsSuitesMutable_array) {
  'use strict';

  _emberRuntimeTestsSuitesMutable_array.default.extend({
    name: 'Native Array',

    newObject: function (ary) {
      return _emberRuntimeSystemNative_array.A(ary ? ary.slice() : this.newFixture(3));
    },

    mutate: function (obj) {
      obj.pushObject(obj.length + 1);
    },

    toArray: function (obj) {
      return obj.slice(); // make a copy.
    }
  }).run();
});
enifed('ember-runtime/tests/system/native_array/suite_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/native_array/suite_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/native_array/suite_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/object/computed_test', ['exports', 'ember-metal', 'internal-test-helpers', 'ember-runtime/system/object'], function (exports, _emberMetal, _internalTestHelpers, _emberRuntimeSystemObject) {
  'use strict';

  function K() {
    return this;
  }

  QUnit.module('EmberObject computed property');

  _internalTestHelpers.testWithDefault('computed property on instance', function (get, set) {
    var MyClass = _emberRuntimeSystemObject.default.extend({
      foo: _emberMetal.computed(function () {
        return 'FOO';
      })
    });

    equal(get(new MyClass(), 'foo'), 'FOO');
  });

  _internalTestHelpers.testWithDefault('computed property on subclass', function (get, set) {
    var MyClass = _emberRuntimeSystemObject.default.extend({
      foo: _emberMetal.computed(function () {
        return 'FOO';
      })
    });

    var Subclass = MyClass.extend({
      foo: _emberMetal.computed(function () {
        return 'BAR';
      })
    });

    equal(get(new Subclass(), 'foo'), 'BAR');
  });

  _internalTestHelpers.testWithDefault('replacing computed property with regular val', function (get, set) {
    var MyClass = _emberRuntimeSystemObject.default.extend({
      foo: _emberMetal.computed(function () {
        return 'FOO';
      })
    });

    var Subclass = MyClass.extend({
      foo: 'BAR'
    });

    equal(get(new Subclass(), 'foo'), 'BAR');
  });

  _internalTestHelpers.testWithDefault('complex depndent keys', function (get, set) {
    var MyClass = _emberRuntimeSystemObject.default.extend({

      init: function () {
        this._super.apply(this, arguments);
        set(this, 'bar', { baz: 'BIFF' });
      },

      count: 0,

      foo: _emberMetal.computed(function () {
        set(this, 'count', get(this, 'count') + 1);
        return _emberMetal.get(get(this, 'bar'), 'baz') + ' ' + get(this, 'count');
      }).property('bar.baz')

    });

    var Subclass = MyClass.extend({
      count: 20
    });

    var obj1 = new MyClass();
    var obj2 = new Subclass();

    equal(get(obj1, 'foo'), 'BIFF 1');
    equal(get(obj2, 'foo'), 'BIFF 21');

    set(get(obj1, 'bar'), 'baz', 'BLARG');

    equal(get(obj1, 'foo'), 'BLARG 2');
    equal(get(obj2, 'foo'), 'BIFF 21');

    set(get(obj2, 'bar'), 'baz', 'BOOM');

    equal(get(obj1, 'foo'), 'BLARG 2');
    equal(get(obj2, 'foo'), 'BOOM 22');
  });

  _internalTestHelpers.testWithDefault('complex dependent keys changing complex dependent keys', function (get, set) {
    var MyClass = _emberRuntimeSystemObject.default.extend({
      init: function () {
        this._super.apply(this, arguments);
        set(this, 'bar', { baz: 'BIFF' });
      },

      count: 0,

      foo: _emberMetal.computed(function () {
        set(this, 'count', get(this, 'count') + 1);
        return _emberMetal.get(get(this, 'bar'), 'baz') + ' ' + get(this, 'count');
      }).property('bar.baz')
    });

    var Subclass = MyClass.extend({
      init: function () {
        this._super.apply(this, arguments);
        set(this, 'bar2', { baz: 'BIFF2' });
      },

      count: 0,

      foo: _emberMetal.computed(function () {
        set(this, 'count', get(this, 'count') + 1);
        return _emberMetal.get(get(this, 'bar2'), 'baz') + ' ' + get(this, 'count');
      }).property('bar2.baz')
    });

    var obj2 = new Subclass();

    equal(get(obj2, 'foo'), 'BIFF2 1');

    set(get(obj2, 'bar'), 'baz', 'BLARG');
    equal(get(obj2, 'foo'), 'BIFF2 1', 'should not invalidate property');

    set(get(obj2, 'bar2'), 'baz', 'BLARG');
    equal(get(obj2, 'foo'), 'BLARG 2', 'should invalidate property');
  });

  QUnit.test('can retrieve metadata for a computed property', function () {
    var MyClass = _emberRuntimeSystemObject.default.extend({
      computedProperty: _emberMetal.computed(function () {}).meta({ key: 'keyValue' })
    });

    equal(_emberMetal.get(MyClass.metaForProperty('computedProperty'), 'key'), 'keyValue', 'metadata saved on the computed property can be retrieved');

    var ClassWithNoMetadata = _emberRuntimeSystemObject.default.extend({
      computedProperty: _emberMetal.computed(function () {}).volatile(),

      staticProperty: 12
    });

    equal(typeof ClassWithNoMetadata.metaForProperty('computedProperty'), 'object', 'returns empty hash if no metadata has been saved');

    expectAssertion(function () {
      ClassWithNoMetadata.metaForProperty('nonexistentProperty');
    }, 'metaForProperty() could not find a computed property with key \'nonexistentProperty\'.');

    expectAssertion(function () {
      ClassWithNoMetadata.metaForProperty('staticProperty');
    }, 'metaForProperty() could not find a computed property with key \'staticProperty\'.');
  });

  QUnit.test('can iterate over a list of computed properties for a class', function () {
    var MyClass = _emberRuntimeSystemObject.default.extend({
      foo: _emberMetal.computed(function () {}),

      fooDidChange: _emberMetal.observer('foo', function () {}),

      bar: _emberMetal.computed(function () {}),

      qux: _emberMetal.alias('foo')
    });

    var SubClass = MyClass.extend({
      baz: _emberMetal.computed(function () {})
    });

    SubClass.reopen({
      bat: _emberMetal.computed(function () {}).meta({ iAmBat: true })
    });

    var list = [];

    MyClass.eachComputedProperty(function (name) {
      list.push(name);
    });

    deepEqual(list.sort(), ['bar', 'foo', 'qux'], 'watched and unwatched computed properties are iterated');

    list = [];

    SubClass.eachComputedProperty(function (name, meta) {
      list.push(name);

      if (name === 'bat') {
        deepEqual(meta, { iAmBat: true });
      } else {
        deepEqual(meta, {});
      }
    });

    deepEqual(list.sort(), ['bar', 'bat', 'baz', 'foo', 'qux'], 'all inherited properties are included');
  });

  QUnit.test('list of properties updates when an additional property is added (such cache busting)', function () {
    var MyClass = _emberRuntimeSystemObject.default.extend({
      foo: _emberMetal.computed(K),

      fooDidChange: _emberMetal.observer('foo', function () {}),

      bar: _emberMetal.computed(K)
    });

    var list = [];

    MyClass.eachComputedProperty(function (name) {
      list.push(name);
    });

    deepEqual(list.sort(), ['bar', 'foo'].sort(), 'expected two computed properties');

    MyClass.reopen({
      baz: _emberMetal.computed(K)
    });

    MyClass.create(); // force apply mixins

    list = [];

    MyClass.eachComputedProperty(function (name) {
      list.push(name);
    });

    deepEqual(list.sort(), ['bar', 'foo', 'baz'].sort(), 'expected three computed properties');
  });

  QUnit.test('Calling _super in call outside the immediate function of a CP getter works', function () {
    function macro(callback) {
      return _emberMetal.computed(function () {
        return callback.call(this);
      });
    }

    var MyClass = _emberRuntimeSystemObject.default.extend({
      foo: _emberMetal.computed(function () {
        return 'FOO';
      })
    });

    var SubClass = MyClass.extend({
      foo: macro(function () {
        return this._super();
      })
    });

    ok(_emberMetal.get(SubClass.create(), 'foo'), 'FOO', 'super value is fetched');
  });

  QUnit.test('Calling _super in apply outside the immediate function of a CP getter works', function () {
    function macro(callback) {
      return _emberMetal.computed(function () {
        return callback.apply(this);
      });
    }

    var MyClass = _emberRuntimeSystemObject.default.extend({
      foo: _emberMetal.computed(function () {
        return 'FOO';
      })
    });

    var SubClass = MyClass.extend({
      foo: macro(function () {
        return this._super();
      })
    });

    ok(_emberMetal.get(SubClass.create(), 'foo'), 'FOO', 'super value is fetched');
  });
});
enifed('ember-runtime/tests/system/object/computed_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/object/computed_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/object/computed_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/object/create_test', ['exports', 'ember-metal', 'ember-runtime/system/object'], function (exports, _emberMetal, _emberRuntimeSystemObject) {
  'use strict';

  QUnit.module('EmberObject.create', {});

  QUnit.test('simple properties are set', function () {
    var o = _emberRuntimeSystemObject.default.create({ ohai: 'there' });
    equal(o.get('ohai'), 'there');
  });

  QUnit.test('calls computed property setters', function () {
    var MyClass = _emberRuntimeSystemObject.default.extend({
      foo: _emberMetal.computed({
        get: function () {
          return 'this is not the value you\'re looking for';
        },
        set: function (key, value) {
          return value;
        }
      })
    });

    var o = MyClass.create({ foo: 'bar' });
    equal(o.get('foo'), 'bar');
  });

  if (false) {
    QUnit.test('sets up mandatory setters for watched simple properties', function () {
      var MyClass = _emberRuntimeSystemObject.default.extend({
        foo: null,
        bar: null,
        fooDidChange: _emberMetal.observer('foo', function () {})
      });

      var o = MyClass.create({ foo: 'bar', bar: 'baz' });
      equal(o.get('foo'), 'bar');

      var descriptor = Object.getOwnPropertyDescriptor(o, 'foo');
      ok(descriptor.set, 'Mandatory setter was setup');

      descriptor = Object.getOwnPropertyDescriptor(o, 'bar');
      ok(!descriptor.set, 'Mandatory setter was not setup');
    });
  }

  QUnit.test('allows bindings to be defined', function () {
    var obj = undefined;

    var deprecationMessage = /`Ember.Binding` is deprecated/;

    expectDeprecation(function () {
      obj = _emberRuntimeSystemObject.default.create({
        foo: 'foo',
        barBinding: 'foo'
      });
    }, deprecationMessage);

    equal(obj.get('bar'), 'foo', 'The binding value is correct');
  });

  QUnit.test('calls setUnknownProperty if defined', function () {
    var setUnknownPropertyCalled = false;

    var MyClass = _emberRuntimeSystemObject.default.extend({
      setUnknownProperty: function (key, value) {
        setUnknownPropertyCalled = true;
      }
    });

    MyClass.create({ foo: 'bar' });
    ok(setUnknownPropertyCalled, 'setUnknownProperty was called');
  });

  QUnit.test('throws if you try to define a computed property', function () {
    expectAssertion(function () {
      _emberRuntimeSystemObject.default.create({
        foo: _emberMetal.computed(function () {})
      });
    }, 'Ember.Object.create no longer supports defining computed properties. Define computed properties using extend() or reopen() before calling create().');
  });

  QUnit.test('throws if you try to call _super in a method', function () {
    expectAssertion(function () {
      _emberRuntimeSystemObject.default.create({
        foo: function () {
          this._super.apply(this, arguments);
        }
      });
    }, 'Ember.Object.create no longer supports defining methods that call _super.');
  });

  QUnit.test('throws if you try to \'mixin\' a definition', function () {
    var myMixin = _emberMetal.Mixin.create({
      adder: function (arg1, arg2) {
        return arg1 + arg2;
      }
    });

    expectAssertion(function () {
      _emberRuntimeSystemObject.default.create(myMixin);
    }, 'Ember.Object.create no longer supports mixing in other definitions, use .extend & .create separately instead.');
  });

  // This test is for IE8.
  QUnit.test('property name is the same as own prototype property', function () {
    var MyClass = _emberRuntimeSystemObject.default.extend({
      toString: function () {
        return 'MyClass';
      }
    });

    equal(MyClass.create().toString(), 'MyClass', 'should inherit property from the arguments of `EmberObject.create`');
  });

  QUnit.test('inherits properties from passed in EmberObject', function () {
    var baseObj = _emberRuntimeSystemObject.default.create({ foo: 'bar' });
    var secondaryObj = _emberRuntimeSystemObject.default.create(baseObj);

    equal(secondaryObj.foo, baseObj.foo, 'Em.O.create inherits properties from EmberObject parameter');
  });

  QUnit.test('throws if you try to pass anything a string as a parameter', function () {
    var expected = 'EmberObject.create only accepts an objects.';

    throws(function () {
      return _emberRuntimeSystemObject.default.create('some-string');
    }, expected);
  });

  QUnit.test('EmberObject.create can take undefined as a parameter', function () {
    var o = _emberRuntimeSystemObject.default.create(undefined);
    deepEqual(_emberRuntimeSystemObject.default.create(), o);
  });

  QUnit.test('EmberObject.create can take null as a parameter', function () {
    var o = _emberRuntimeSystemObject.default.create(null);
    deepEqual(_emberRuntimeSystemObject.default.create(), o);
  });

  QUnit.test('EmberObject.create avoids allocating a binding map when not necessary', function () {
    var o = _emberRuntimeSystemObject.default.create();
    var m = _emberMetal.meta(o);
    ok(!m.peekBindings(), 'A binding map is not allocated');
  });
});
enifed('ember-runtime/tests/system/object/create_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/object/create_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/object/create_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/object/destroy_test', ['exports', 'ember-metal', 'internal-test-helpers', 'ember-runtime/system/object'], function (exports, _emberMetal, _internalTestHelpers, _emberRuntimeSystemObject) {
  'use strict';

  QUnit.module('ember-runtime/system/object/destroy_test');

  _internalTestHelpers.testBoth('should schedule objects to be destroyed at the end of the run loop', function (get, set) {
    var obj = _emberRuntimeSystemObject.default.create();
    var meta = undefined;

    _emberMetal.run(function () {
      obj.destroy();
      meta = _emberMetal.peekMeta(obj);
      ok(meta, 'meta is not destroyed immediately');
      ok(get(obj, 'isDestroying'), 'object is marked as destroying immediately');
      ok(!get(obj, 'isDestroyed'), 'object is not destroyed immediately');
    });

    meta = _emberMetal.peekMeta(obj);
    ok(get(obj, 'isDestroyed'), 'object is destroyed after run loop finishes');
  });

  if (false) {
    // MANDATORY_SETTER moves value to meta.values
    // a destroyed object removes meta but leaves the accessor
    // that looks it up
    QUnit.test('should raise an exception when modifying watched properties on a destroyed object', function () {
      var obj = _emberRuntimeSystemObject.default.extend({
        fooDidChange: _emberMetal.observer('foo', function () {})
      }).create({
        foo: 'bar'
      });

      _emberMetal.run(function () {
        return obj.destroy();
      });

      throws(function () {
        return _emberMetal.set(obj, 'foo', 'baz');
      }, Error, 'raises an exception');
    });
  }

  QUnit.test('observers should not fire after an object has been destroyed', function () {
    var count = 0;
    var obj = _emberRuntimeSystemObject.default.extend({
      fooDidChange: _emberMetal.observer('foo', function () {
        count++;
      })
    }).create();

    obj.set('foo', 'bar');

    equal(count, 1, 'observer was fired once');

    _emberMetal.run(function () {
      _emberMetal.beginPropertyChanges();
      obj.set('foo', 'quux');
      obj.destroy();
      _emberMetal.endPropertyChanges();
    });

    equal(count, 1, 'observer was not called after object was destroyed');
  });

  QUnit.test('destroyed objects should not see each others changes during teardown but a long lived object should', function () {
    var shouldChange = 0;
    var shouldNotChange = 0;

    var objs = {};

    var A = _emberRuntimeSystemObject.default.extend({
      objs: objs,
      isAlive: true,
      willDestroy: function () {
        this.set('isAlive', false);
      },
      bDidChange: _emberMetal.observer('objs.b.isAlive', function () {
        shouldNotChange++;
      }),
      cDidChange: _emberMetal.observer('objs.c.isAlive', function () {
        shouldNotChange++;
      })
    });

    var B = _emberRuntimeSystemObject.default.extend({
      objs: objs,
      isAlive: true,
      willDestroy: function () {
        this.set('isAlive', false);
      },
      aDidChange: _emberMetal.observer('objs.a.isAlive', function () {
        shouldNotChange++;
      }),
      cDidChange: _emberMetal.observer('objs.c.isAlive', function () {
        shouldNotChange++;
      })
    });

    var C = _emberRuntimeSystemObject.default.extend({
      objs: objs,
      isAlive: true,
      willDestroy: function () {
        this.set('isAlive', false);
      },
      aDidChange: _emberMetal.observer('objs.a.isAlive', function () {
        shouldNotChange++;
      }),
      bDidChange: _emberMetal.observer('objs.b.isAlive', function () {
        shouldNotChange++;
      })
    });

    var LongLivedObject = _emberRuntimeSystemObject.default.extend({
      objs: objs,
      isAliveDidChange: _emberMetal.observer('objs.a.isAlive', function () {
        shouldChange++;
      })
    });

    objs.a = new A();

    objs.b = new B();

    objs.c = new C();

    new LongLivedObject();

    _emberMetal.run(function () {
      var keys = Object.keys(objs);
      for (var i = 0; i < keys.length; i++) {
        objs[keys[i]].destroy();
      }
    });

    equal(shouldNotChange, 0, 'destroyed graph objs should not see change in willDestroy');
    equal(shouldChange, 1, 'long lived should see change in willDestroy');
  });

  QUnit.test('bindings should be synced when are updated in the willDestroy hook', function () {
    var bar = _emberRuntimeSystemObject.default.create({
      value: false,
      willDestroy: function () {
        this.set('value', true);
      }
    });

    var foo = _emberRuntimeSystemObject.default.create({
      value: null,
      bar: bar
    });

    _emberMetal.run(function () {
      var deprecationMessage = /`Ember.Binding` is deprecated/;

      expectDeprecation(function () {
        _emberMetal.bind(foo, 'value', 'bar.value');
      }, deprecationMessage);
    });

    ok(bar.get('value') === false, 'the initial value has been bound');

    _emberMetal.run(function () {
      return bar.destroy();
    });

    ok(foo.get('value'), 'foo is synced when the binding is updated in the willDestroy hook');
  });
});
enifed('ember-runtime/tests/system/object/destroy_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/object/destroy_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/object/destroy_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/object/detectInstance_test', ['exports', 'ember-runtime/system/object'], function (exports, _emberRuntimeSystemObject) {
  'use strict';

  QUnit.module('system/object/detectInstance');

  QUnit.test('detectInstance detects instances correctly', function () {
    var A = _emberRuntimeSystemObject.default.extend();
    var B = A.extend();
    var C = A.extend();

    var o = _emberRuntimeSystemObject.default.create();
    var a = A.create();
    var b = B.create();
    var c = C.create();

    ok(_emberRuntimeSystemObject.default.detectInstance(o), 'o is an instance of EmberObject');
    ok(_emberRuntimeSystemObject.default.detectInstance(a), 'a is an instance of EmberObject');
    ok(_emberRuntimeSystemObject.default.detectInstance(b), 'b is an instance of EmberObject');
    ok(_emberRuntimeSystemObject.default.detectInstance(c), 'c is an instance of EmberObject');

    ok(!A.detectInstance(o), 'o is not an instance of A');
    ok(A.detectInstance(a), 'a is an instance of A');
    ok(A.detectInstance(b), 'b is an instance of A');
    ok(A.detectInstance(c), 'c is an instance of A');

    ok(!B.detectInstance(o), 'o is not an instance of B');
    ok(!B.detectInstance(a), 'a is not an instance of B');
    ok(B.detectInstance(b), 'b is an instance of B');
    ok(!B.detectInstance(c), 'c is not an instance of B');

    ok(!C.detectInstance(o), 'o is not an instance of C');
    ok(!C.detectInstance(a), 'a is not an instance of C');
    ok(!C.detectInstance(b), 'b is not an instance of C');
    ok(C.detectInstance(c), 'c is an instance of C');
  });
});
enifed('ember-runtime/tests/system/object/detectInstance_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/object/detectInstance_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/object/detectInstance_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/object/detect_test', ['exports', 'ember-runtime/system/object'], function (exports, _emberRuntimeSystemObject) {
  'use strict';

  QUnit.module('system/object/detect');

  QUnit.test('detect detects classes correctly', function () {
    var A = _emberRuntimeSystemObject.default.extend();
    var B = A.extend();
    var C = A.extend();

    ok(_emberRuntimeSystemObject.default.detect(_emberRuntimeSystemObject.default), 'EmberObject is an EmberObject class');
    ok(_emberRuntimeSystemObject.default.detect(A), 'A is an EmberObject class');
    ok(_emberRuntimeSystemObject.default.detect(B), 'B is an EmberObject class');
    ok(_emberRuntimeSystemObject.default.detect(C), 'C is an EmberObject class');

    ok(!A.detect(_emberRuntimeSystemObject.default), 'EmberObject is not an A class');
    ok(A.detect(A), 'A is an A class');
    ok(A.detect(B), 'B is an A class');
    ok(A.detect(C), 'C is an A class');

    ok(!B.detect(_emberRuntimeSystemObject.default), 'EmberObject is not a B class');
    ok(!B.detect(A), 'A is not a B class');
    ok(B.detect(B), 'B is a B class');
    ok(!B.detect(C), 'C is not a B class');

    ok(!C.detect(_emberRuntimeSystemObject.default), 'EmberObject is not a C class');
    ok(!C.detect(A), 'A is not a C class');
    ok(!C.detect(B), 'B is not a C class');
    ok(C.detect(C), 'C is a C class');
  });
});
enifed('ember-runtime/tests/system/object/detect_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/object/detect_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/object/detect_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/object/es-compatibility-test', ['exports', 'ember-runtime/system/object', 'ember-metal'], function (exports, _emberRuntimeSystemObject, _emberMetal) {
  'use strict';

  QUnit.module('EmberObject ES Compatibility');

  QUnit.test('extending an Ember.Object', function (assert) {
    var calls = [];

    var MyObject = (function (_EmberObject) {
      babelHelpers.inherits(MyObject, _EmberObject);

      function MyObject() {
        calls.push('constructor');
        _EmberObject.apply(this, arguments);
        this.postInitProperty = 'post-init-property';
      }

      MyObject.prototype.init = function init() {
        var _EmberObject$prototype$init;

        calls.push('init');
        (_EmberObject$prototype$init = _EmberObject.prototype.init).call.apply(_EmberObject$prototype$init, [this].concat(babelHelpers.slice.call(arguments)));
        this.initProperty = 'init-property';
      };

      return MyObject;
    })(_emberRuntimeSystemObject.default);

    var myObject = MyObject.create({ passedProperty: 'passed-property' });

    assert.deepEqual(calls, ['constructor', 'init'], 'constructor then init called (create)');
    assert.equal(myObject.postInitProperty, 'post-init-property', 'constructor property available on instance (create)');
    assert.equal(myObject.initProperty, 'init-property', 'init property available on instance (create)');
    assert.equal(myObject.passedProperty, 'passed-property', 'passed property available on instance (create)');

    calls = [];
    myObject = new MyObject({ passedProperty: 'passed-property' });

    assert.deepEqual(calls, ['constructor', 'init'], 'constructor then init called (new)');
    assert.equal(myObject.postInitProperty, 'post-init-property', 'constructor property available on instance (new)');
    assert.equal(myObject.initProperty, 'init-property', 'init property available on instance (new)');
    assert.equal(myObject.passedProperty, 'passed-property', 'passed property available on instance (new)');
  });

  QUnit.test('using super', function (assert) {
    var calls = [];

    var SuperSuperObject = _emberRuntimeSystemObject.default.extend({
      method: function () {
        calls.push('super-super-method');
      }
    });

    var SuperObject = SuperSuperObject.extend({
      method: function () {
        this._super();
        calls.push('super-method');
      }
    });

    var MyObject = (function (_SuperObject) {
      babelHelpers.inherits(MyObject, _SuperObject);

      function MyObject() {
        _SuperObject.apply(this, arguments);
      }

      MyObject.prototype.method = function method() {
        _SuperObject.prototype.method.call(this);
        calls.push('method');
      };

      return MyObject;
    })(SuperObject);

    var myObject = new MyObject();
    myObject.method();

    assert.deepEqual(calls, ['super-super-method', 'super-method', 'method'], 'chain of prototype methods called with super');
  });

  QUnit.test('using mixins', function (assert) {
    var Mixin1 = _emberMetal.Mixin.create({
      property1: 'data-1'
    });

    var Mixin2 = _emberMetal.Mixin.create({
      property2: 'data-2'
    });

    var MyObject = (function (_EmberObject$extend) {
      babelHelpers.inherits(MyObject, _EmberObject$extend);

      function MyObject() {
        _EmberObject$extend.apply(this, arguments);
      }

      return MyObject;
    })(_emberRuntimeSystemObject.default.extend(Mixin1, Mixin2));

    var myObject = new MyObject();
    assert.equal(myObject.property1, 'data-1', 'includes the first mixin');
    assert.equal(myObject.property2, 'data-2', 'includes the second mixin');
  });

  QUnit.test('using instanceof', function (assert) {
    var MyObject = (function (_EmberObject2) {
      babelHelpers.inherits(MyObject, _EmberObject2);

      function MyObject() {
        _EmberObject2.apply(this, arguments);
      }

      return MyObject;
    })(_emberRuntimeSystemObject.default);

    var myObject1 = MyObject.create();
    var myObject2 = new MyObject();

    assert.ok(myObject1 instanceof MyObject);
    assert.ok(myObject1 instanceof _emberRuntimeSystemObject.default);

    assert.ok(myObject2 instanceof MyObject);
    assert.ok(myObject2 instanceof _emberRuntimeSystemObject.default);
  });

  QUnit.test('extending an ES subclass of EmberObject', function (assert) {
    var calls = [];

    var SubEmberObject = (function (_EmberObject3) {
      babelHelpers.inherits(SubEmberObject, _EmberObject3);

      function SubEmberObject() {
        calls.push('constructor');
        _EmberObject3.apply(this, arguments);
      }

      SubEmberObject.prototype.init = function init() {
        var _EmberObject3$prototype$init;

        calls.push('init');
        (_EmberObject3$prototype$init = _EmberObject3.prototype.init).call.apply(_EmberObject3$prototype$init, [this].concat(babelHelpers.slice.call(arguments)));
      };

      return SubEmberObject;
    })(_emberRuntimeSystemObject.default);

    var MyObject = (function (_SubEmberObject) {
      babelHelpers.inherits(MyObject, _SubEmberObject);

      function MyObject() {
        _SubEmberObject.apply(this, arguments);
      }

      return MyObject;
    })(SubEmberObject);

    MyObject.create();
    assert.deepEqual(calls, ['constructor', 'init'], 'constructor then init called (create)');

    calls = [];
    new MyObject();
    assert.deepEqual(calls, ['constructor', 'init'], 'constructor then init called (new)');
  });

  // TODO: Needs to be fixed. Currently only `init` is called.
  QUnit.skip('calling extend on an ES subclass of EmberObject', function (assert) {
    var calls = [];

    var SubEmberObject = (function (_EmberObject4) {
      babelHelpers.inherits(SubEmberObject, _EmberObject4);

      function SubEmberObject() {
        calls.push('constructor');
        _EmberObject4.apply(this, arguments);
      }

      SubEmberObject.prototype.init = function init() {
        var _EmberObject4$prototype$init;

        calls.push('init');
        (_EmberObject4$prototype$init = _EmberObject4.prototype.init).call.apply(_EmberObject4$prototype$init, [this].concat(babelHelpers.slice.call(arguments)));
      };

      return SubEmberObject;
    })(_emberRuntimeSystemObject.default);

    var MyObject = SubEmberObject.extend({});

    MyObject.create();
    assert.deepEqual(calls, ['constructor', 'init'], 'constructor then init called (create)');

    calls = [];
    new MyObject();
    assert.deepEqual(calls, ['constructor', 'init'], 'constructor then init called (new)');
  });
});
enifed('ember-runtime/tests/system/object/es-compatibility-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/object/es-compatibility-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/object/es-compatibility-test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/object/events_test', ['exports', 'ember-runtime/system/object', 'ember-runtime/mixins/evented'], function (exports, _emberRuntimeSystemObject, _emberRuntimeMixinsEvented) {
  'use strict';

  QUnit.module('Object events');

  QUnit.test('a listener can be added to an object', function () {
    var count = 0;
    var F = function () {
      count++;
    };

    var obj = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsEvented.default).create();

    obj.on('event!', F);
    obj.trigger('event!');

    equal(count, 1, 'the event was triggered');

    obj.trigger('event!');

    equal(count, 2, 'the event was triggered');
  });

  QUnit.test('a listener can be added and removed automatically the first time it is triggered', function () {
    var count = 0;
    var F = function () {
      count++;
    };

    var obj = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsEvented.default).create();

    obj.one('event!', F);
    obj.trigger('event!');

    equal(count, 1, 'the event was triggered');

    obj.trigger('event!');

    equal(count, 1, 'the event was not triggered again');
  });

  QUnit.test('triggering an event can have arguments', function () {
    var self = undefined,
        args = undefined;

    var obj = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsEvented.default).create();

    obj.on('event!', function () {
      args = [].slice.call(arguments);
      self = this;
    });

    obj.trigger('event!', 'foo', 'bar');

    deepEqual(args, ['foo', 'bar']);
    equal(self, obj);
  });

  QUnit.test('a listener can be added and removed automatically and have arguments', function () {
    var self = undefined,
        args = undefined;
    var count = 0;

    var obj = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsEvented.default).create();

    obj.one('event!', function () {
      args = [].slice.call(arguments);
      self = this;
      count++;
    });

    obj.trigger('event!', 'foo', 'bar');

    deepEqual(args, ['foo', 'bar']);
    equal(self, obj);
    equal(count, 1, 'the event is triggered once');

    obj.trigger('event!', 'baz', 'bat');

    deepEqual(args, ['foo', 'bar']);
    equal(count, 1, 'the event was not triggered again');
    equal(self, obj);
  });

  QUnit.test('binding an event can specify a different target', function () {
    var self = undefined,
        args = undefined;

    var obj = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsEvented.default).create();
    var target = {};

    obj.on('event!', target, function () {
      args = [].slice.call(arguments);
      self = this;
    });

    obj.trigger('event!', 'foo', 'bar');

    deepEqual(args, ['foo', 'bar']);
    equal(self, target);
  });

  QUnit.test('a listener registered with one can take method as string and can be added with different target', function () {
    var count = 0;
    var target = {};
    target.fn = function () {
      count++;
    };

    var obj = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsEvented.default).create();

    obj.one('event!', target, 'fn');
    obj.trigger('event!');

    equal(count, 1, 'the event was triggered');

    obj.trigger('event!');

    equal(count, 1, 'the event was not triggered again');
  });

  QUnit.test('a listener registered with one can be removed with off', function () {
    var obj = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsEvented.default, {
      F: function () {}
    }).create();
    var F = function () {};

    obj.one('event!', F);
    obj.one('event!', obj, 'F');

    equal(obj.has('event!'), true, 'has events');

    obj.off('event!', F);
    obj.off('event!', obj, 'F');

    equal(obj.has('event!'), false, 'has no more events');
  });

  QUnit.test('adding and removing listeners should be chainable', function () {
    var obj = _emberRuntimeSystemObject.default.extend(_emberRuntimeMixinsEvented.default).create();
    var F = function () {};

    var ret = obj.on('event!', F);
    equal(ret, obj, '#on returns self');

    ret = obj.off('event!', F);
    equal(ret, obj, '#off returns self');

    ret = obj.one('event!', F);
    equal(ret, obj, '#one returns self');
  });
});
enifed('ember-runtime/tests/system/object/events_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/object/events_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/object/events_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/object/extend_test', ['exports', 'ember-metal', 'ember-runtime/system/object'], function (exports, _emberMetal, _emberRuntimeSystemObject) {
  'use strict';

  QUnit.module('EmberObject.extend');

  QUnit.test('Basic extend', function () {
    var SomeClass = _emberRuntimeSystemObject.default.extend({ foo: 'BAR' });
    ok(SomeClass.isClass, 'A class has isClass of true');
    var obj = new SomeClass();
    equal(obj.foo, 'BAR');
  });

  QUnit.test('Sub-subclass', function () {
    var SomeClass = _emberRuntimeSystemObject.default.extend({ foo: 'BAR' });
    var AnotherClass = SomeClass.extend({ bar: 'FOO' });
    var obj = new AnotherClass();
    equal(obj.foo, 'BAR');
    equal(obj.bar, 'FOO');
  });

  QUnit.test('Overriding a method several layers deep', function () {
    var SomeClass = _emberRuntimeSystemObject.default.extend({
      fooCnt: 0,
      foo: function () {
        this.fooCnt++;
      },

      barCnt: 0,
      bar: function () {
        this.barCnt++;
      }
    });

    var AnotherClass = SomeClass.extend({
      barCnt: 0,
      bar: function () {
        this.barCnt++;
        this._super.apply(this, arguments);
      }
    });

    var FinalClass = AnotherClass.extend({
      fooCnt: 0,
      foo: function () {
        this.fooCnt++;
        this._super.apply(this, arguments);
      }
    });

    var obj = new FinalClass();
    obj.foo();
    obj.bar();
    equal(obj.fooCnt, 2, 'should invoke both');
    equal(obj.barCnt, 2, 'should invoke both');

    // Try overriding on create also
    obj = FinalClass.extend({
      foo: function () {
        this.fooCnt++;
        this._super.apply(this, arguments);
      }
    }).create();

    obj.foo();
    obj.bar();
    equal(obj.fooCnt, 3, 'should invoke final as well');
    equal(obj.barCnt, 2, 'should invoke both');
  });

  QUnit.test('With concatenatedProperties', function () {
    var SomeClass = _emberRuntimeSystemObject.default.extend({ things: 'foo', concatenatedProperties: ['things'] });
    var AnotherClass = SomeClass.extend({ things: 'bar' });
    var YetAnotherClass = SomeClass.extend({ things: 'baz' });
    var some = new SomeClass();
    var another = new AnotherClass();
    var yetAnother = new YetAnotherClass();
    deepEqual(some.get('things'), ['foo'], 'base class should have just its value');
    deepEqual(another.get('things'), ['foo', 'bar'], 'subclass should have base class\' and its own');
    deepEqual(yetAnother.get('things'), ['foo', 'baz'], 'subclass should have base class\' and its own');
  });

  QUnit.test('With concatenatedProperties class properties', function () {
    var SomeClass = _emberRuntimeSystemObject.default.extend();
    SomeClass.reopenClass({
      concatenatedProperties: ['things'],
      things: 'foo'
    });
    var AnotherClass = SomeClass.extend();
    AnotherClass.reopenClass({ things: 'bar' });
    var YetAnotherClass = SomeClass.extend();
    YetAnotherClass.reopenClass({ things: 'baz' });
    var some = new SomeClass();
    var another = new AnotherClass();
    var yetAnother = new YetAnotherClass();
    deepEqual(_emberMetal.get(some.constructor, 'things'), ['foo'], 'base class should have just its value');
    deepEqual(_emberMetal.get(another.constructor, 'things'), ['foo', 'bar'], 'subclass should have base class\' and its own');
    deepEqual(_emberMetal.get(yetAnother.constructor, 'things'), ['foo', 'baz'], 'subclass should have base class\' and its own');
  });
});
enifed('ember-runtime/tests/system/object/extend_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/object/extend_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/object/extend_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/object/observer_test', ['exports', 'ember-metal', 'internal-test-helpers', 'ember-runtime/system/object'], function (exports, _emberMetal, _internalTestHelpers, _emberRuntimeSystemObject) {
  'use strict';

  QUnit.module('EmberObject observer');

  _internalTestHelpers.testBoth('observer on class', function (get, set) {
    var MyClass = _emberRuntimeSystemObject.default.extend({
      count: 0,

      foo: _emberMetal.observer('bar', function () {
        set(this, 'count', get(this, 'count') + 1);
      })
    });

    var obj = new MyClass();
    equal(get(obj, 'count'), 0, 'should not invoke observer immediately');

    set(obj, 'bar', 'BAZ');
    equal(get(obj, 'count'), 1, 'should invoke observer after change');
  });

  _internalTestHelpers.testBoth('observer on subclass', function (get, set) {
    var MyClass = _emberRuntimeSystemObject.default.extend({
      count: 0,

      foo: _emberMetal.observer('bar', function () {
        set(this, 'count', get(this, 'count') + 1);
      })
    });

    var Subclass = MyClass.extend({
      foo: _emberMetal.observer('baz', function () {
        set(this, 'count', get(this, 'count') + 1);
      })
    });

    var obj = new Subclass();
    equal(get(obj, 'count'), 0, 'should not invoke observer immediately');

    set(obj, 'bar', 'BAZ');
    equal(get(obj, 'count'), 0, 'should not invoke observer after change');

    set(obj, 'baz', 'BAZ');
    equal(get(obj, 'count'), 1, 'should invoke observer after change');
  });

  _internalTestHelpers.testBoth('observer on instance', function (get, set) {
    var obj = _emberRuntimeSystemObject.default.extend({
      foo: _emberMetal.observer('bar', function () {
        set(this, 'count', get(this, 'count') + 1);
      })
    }).create({
      count: 0
    });

    equal(get(obj, 'count'), 0, 'should not invoke observer immediately');

    set(obj, 'bar', 'BAZ');
    equal(get(obj, 'count'), 1, 'should invoke observer after change');
  });

  _internalTestHelpers.testBoth('observer on instance overriding class', function (get, set) {
    var MyClass = _emberRuntimeSystemObject.default.extend({
      count: 0,

      foo: _emberMetal.observer('bar', function () {
        set(this, 'count', get(this, 'count') + 1);
      })
    });

    var obj = MyClass.extend({
      foo: _emberMetal.observer('baz', function () {
        // <-- change property we observe
        set(this, 'count', get(this, 'count') + 1);
      })
    }).create();

    equal(get(obj, 'count'), 0, 'should not invoke observer immediately');

    set(obj, 'bar', 'BAZ');
    equal(get(obj, 'count'), 0, 'should not invoke observer after change');

    set(obj, 'baz', 'BAZ');
    equal(get(obj, 'count'), 1, 'should invoke observer after change');
  });

  _internalTestHelpers.testBoth('observer should not fire after being destroyed', function (get, set) {
    var obj = _emberRuntimeSystemObject.default.extend({
      count: 0,
      foo: _emberMetal.observer('bar', function () {
        set(this, 'count', get(this, 'count') + 1);
      })
    }).create();

    equal(get(obj, 'count'), 0, 'precond - should not invoke observer immediately');

    _emberMetal.run(function () {
      return obj.destroy();
    });

    expectAssertion(function () {
      set(obj, 'bar', 'BAZ');
    }, 'calling set on destroyed object: ' + obj + '.bar = BAZ');

    equal(get(obj, 'count'), 0, 'should not invoke observer after change');
  });
  // ..........................................................
  // COMPLEX PROPERTIES
  //

  _internalTestHelpers.testBoth('chain observer on class', function (get, set) {
    var MyClass = _emberRuntimeSystemObject.default.extend({
      count: 0,

      foo: _emberMetal.observer('bar.baz', function () {
        set(this, 'count', get(this, 'count') + 1);
      })
    });

    var obj1 = MyClass.create({
      bar: { baz: 'biff' }
    });

    var obj2 = MyClass.create({
      bar: { baz: 'biff2' }
    });

    equal(get(obj1, 'count'), 0, 'should not invoke yet');
    equal(get(obj2, 'count'), 0, 'should not invoke yet');

    set(get(obj1, 'bar'), 'baz', 'BIFF1');
    equal(get(obj1, 'count'), 1, 'should invoke observer on obj1');
    equal(get(obj2, 'count'), 0, 'should not invoke yet');

    set(get(obj2, 'bar'), 'baz', 'BIFF2');
    equal(get(obj1, 'count'), 1, 'should not invoke again');
    equal(get(obj2, 'count'), 1, 'should invoke observer on obj2');
  });

  _internalTestHelpers.testBoth('chain observer on class', function (get, set) {
    var MyClass = _emberRuntimeSystemObject.default.extend({
      count: 0,

      foo: _emberMetal.observer('bar.baz', function () {
        set(this, 'count', get(this, 'count') + 1);
      })
    });

    var obj1 = MyClass.extend().create({
      bar: { baz: 'biff' }
    });

    var obj2 = MyClass.extend({
      foo: _emberMetal.observer('bar2.baz', function () {
        set(this, 'count', get(this, 'count') + 1);
      })
    }).create({
      bar: { baz: 'biff2' },
      bar2: { baz: 'biff3' }
    });

    equal(get(obj1, 'count'), 0, 'should not invoke yet');
    equal(get(obj2, 'count'), 0, 'should not invoke yet');

    set(get(obj1, 'bar'), 'baz', 'BIFF1');
    equal(get(obj1, 'count'), 1, 'should invoke observer on obj1');
    equal(get(obj2, 'count'), 0, 'should not invoke yet');

    set(get(obj2, 'bar'), 'baz', 'BIFF2');
    equal(get(obj1, 'count'), 1, 'should not invoke again');
    equal(get(obj2, 'count'), 0, 'should not invoke yet');

    set(get(obj2, 'bar2'), 'baz', 'BIFF3');
    equal(get(obj1, 'count'), 1, 'should not invoke again');
    equal(get(obj2, 'count'), 1, 'should invoke observer on obj2');
  });

  _internalTestHelpers.testBoth('chain observer on class that has a reference to an uninitialized object will finish chains that reference it', function (get, set) {
    var changed = false;

    var ChildClass = _emberRuntimeSystemObject.default.extend({
      parent: null,
      parentOneTwoDidChange: _emberMetal.observer('parent.one.two', function () {
        changed = true;
      })
    });

    var ParentClass = _emberRuntimeSystemObject.default.extend({
      one: {
        two: 'old'
      },
      init: function () {
        this.child = ChildClass.create({
          parent: this
        });
      }
    });

    var parent = new ParentClass();

    equal(changed, false, 'precond');

    parent.set('one.two', 'new');

    equal(changed, true, 'child should have been notified of change to path');

    parent.set('one', { two: 'newer' });

    equal(changed, true, 'child should have been notified of change to path');
  });
});
enifed('ember-runtime/tests/system/object/observer_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/object/observer_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/object/observer_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/object/reopenClass_test', ['exports', 'ember-metal', 'ember-runtime/system/object'], function (exports, _emberMetal, _emberRuntimeSystemObject) {
  'use strict';

  QUnit.module('system/object/reopenClass');

  QUnit.test('adds new properties to subclass', function () {
    var Subclass = _emberRuntimeSystemObject.default.extend();
    Subclass.reopenClass({
      foo: function () {
        return 'FOO';
      },
      bar: 'BAR'
    });

    equal(Subclass.foo(), 'FOO', 'Adds method');
    equal(_emberMetal.get(Subclass, 'bar'), 'BAR', 'Adds property');
  });

  QUnit.test('class properties inherited by subclasses', function () {
    var Subclass = _emberRuntimeSystemObject.default.extend();
    Subclass.reopenClass({
      foo: function () {
        return 'FOO';
      },
      bar: 'BAR'
    });

    var SubSub = Subclass.extend();

    equal(SubSub.foo(), 'FOO', 'Adds method');
    equal(_emberMetal.get(SubSub, 'bar'), 'BAR', 'Adds property');
  });
});
enifed('ember-runtime/tests/system/object/reopenClass_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/object/reopenClass_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/object/reopenClass_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/object/reopen_test', ['exports', 'ember-metal', 'ember-runtime/system/object'], function (exports, _emberMetal, _emberRuntimeSystemObject) {
  'use strict';

  QUnit.module('system/core_object/reopen');

  QUnit.test('adds new properties to subclass instance', function () {
    var Subclass = _emberRuntimeSystemObject.default.extend();
    Subclass.reopen({
      foo: function () {
        return 'FOO';
      },
      bar: 'BAR'
    });

    equal(new Subclass().foo(), 'FOO', 'Adds method');
    equal(_emberMetal.get(new Subclass(), 'bar'), 'BAR', 'Adds property');
  });

  QUnit.test('reopened properties inherited by subclasses', function () {
    var Subclass = _emberRuntimeSystemObject.default.extend();
    var SubSub = Subclass.extend();

    Subclass.reopen({
      foo: function () {
        return 'FOO';
      },
      bar: 'BAR'
    });

    equal(new SubSub().foo(), 'FOO', 'Adds method');
    equal(_emberMetal.get(new SubSub(), 'bar'), 'BAR', 'Adds property');
  });

  QUnit.test('allows reopening already instantiated classes', function () {
    var Subclass = _emberRuntimeSystemObject.default.extend();

    Subclass.create();

    Subclass.reopen({
      trololol: true
    });

    equal(Subclass.create().get('trololol'), true, 'reopen works');
  });
});
enifed('ember-runtime/tests/system/object/reopen_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/object/reopen_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/object/reopen_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/object/strict-mode-test', ['exports', 'ember-runtime/system/object'], function (exports, _emberRuntimeSystemObject) {
  'use strict';

  QUnit.module('strict mode tests');

  QUnit.test('__superWrapper does not throw errors in strict mode', function () {
    var Foo = _emberRuntimeSystemObject.default.extend({
      blah: function () {
        return 'foo';
      }
    });

    var Bar = Foo.extend({
      blah: function () {
        return 'bar';
      },

      callBlah: function () {
        var blah = this.blah;

        return blah();
      }
    });

    var bar = Bar.create();

    equal(bar.callBlah(), 'bar', 'can call local function without call/apply');
  });
});
enifed('ember-runtime/tests/system/object/strict-mode-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/object/strict-mode-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/object/strict-mode-test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/object/subclasses_test', ['exports', 'ember-metal', 'ember-runtime/system/object'], function (exports, _emberMetal, _emberRuntimeSystemObject) {
  'use strict';

  QUnit.module('system/object/subclasses');

  QUnit.test('chains should copy forward to subclasses when prototype created', function () {
    var ObjectWithChains = undefined,
        objWithChains = undefined,
        SubWithChains = undefined,
        SubSub = undefined,
        subSub = undefined;
    _emberMetal.run(function () {
      ObjectWithChains = _emberRuntimeSystemObject.default.extend({
        obj: {
          a: 'a',
          hi: 'hi'
        },
        aBinding: 'obj.a' // add chain
      });

      var deprecationMessage = /`Ember.Binding` is deprecated/;

      expectDeprecation(function () {
        // realize prototype
        objWithChains = ObjectWithChains.create();
      }, deprecationMessage);

      // should not copy chains from parent yet
      SubWithChains = ObjectWithChains.extend({
        hiBinding: 'obj.hi', // add chain
        hello: _emberMetal.computed(function () {
          return this.get('obj.hi') + ' world';
        }).property('hi'), // observe chain
        greetingBinding: 'hello'
      });

      SubSub = SubWithChains.extend();

      expectDeprecation(function () {
        // should realize prototypes and copy forward chains
        subSub = SubSub.create();
      }, deprecationMessage);
    });
    equal(subSub.get('greeting'), 'hi world');
    _emberMetal.run(function () {
      return objWithChains.set('obj.hi', 'hello');
    });
    equal(subSub.get('greeting'), 'hello world');
  });
});
enifed('ember-runtime/tests/system/object/subclasses_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/object/subclasses_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/object/subclasses_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/object/toString_test', ['exports', 'ember-utils', 'ember-environment', 'ember-runtime/system/object', 'ember-runtime/system/namespace'], function (exports, _emberUtils, _emberEnvironment, _emberRuntimeSystemObject, _emberRuntimeSystemNamespace) {
  'use strict';

  var originalLookup = _emberEnvironment.context.lookup;
  var lookup = undefined;

  QUnit.module('system/object/toString', {
    setup: function () {
      _emberEnvironment.context.lookup = lookup = {};
    },
    teardown: function () {
      _emberEnvironment.context.lookup = originalLookup;
    }
  });

  QUnit.test('NAME_KEY slot is present on Class', function () {
    ok(_emberRuntimeSystemObject.default.extend().hasOwnProperty(_emberUtils.NAME_KEY), 'Ember Class\'s have a NAME_KEY slot');
  });

  QUnit.test('toString() returns the same value if called twice', function () {
    var Foo = _emberRuntimeSystemNamespace.default.create();
    Foo.toString = function () {
      return 'Foo';
    };

    Foo.Bar = _emberRuntimeSystemObject.default.extend();

    equal(Foo.Bar.toString(), 'Foo.Bar');
    equal(Foo.Bar.toString(), 'Foo.Bar');

    var obj = Foo.Bar.create();

    equal(obj.toString(), '<Foo.Bar:' + _emberUtils.guidFor(obj) + '>');
    equal(obj.toString(), '<Foo.Bar:' + _emberUtils.guidFor(obj) + '>');

    equal(Foo.Bar.toString(), 'Foo.Bar');
  });

  QUnit.test('toString on a class returns a useful value when nested in a namespace', function () {
    var obj = undefined;

    var Foo = _emberRuntimeSystemNamespace.default.create();
    Foo.toString = function () {
      return 'Foo';
    };

    Foo.Bar = _emberRuntimeSystemObject.default.extend();
    equal(Foo.Bar.toString(), 'Foo.Bar');

    obj = Foo.Bar.create();
    equal(obj.toString(), '<Foo.Bar:' + _emberUtils.guidFor(obj) + '>');

    Foo.Baz = Foo.Bar.extend();
    equal(Foo.Baz.toString(), 'Foo.Baz');

    obj = Foo.Baz.create();
    equal(obj.toString(), '<Foo.Baz:' + _emberUtils.guidFor(obj) + '>');

    obj = Foo.Bar.create();
    equal(obj.toString(), '<Foo.Bar:' + _emberUtils.guidFor(obj) + '>');
  });

  QUnit.test('toString on a namespace finds the namespace in lookup', function () {
    var Foo = lookup.Foo = _emberRuntimeSystemNamespace.default.create();

    equal(Foo.toString(), 'Foo');
  });

  QUnit.test('toString on a namespace finds the namespace in lookup', function () {
    var Foo = lookup.Foo = _emberRuntimeSystemNamespace.default.create();
    var obj = undefined;

    Foo.Bar = _emberRuntimeSystemObject.default.extend();

    equal(Foo.Bar.toString(), 'Foo.Bar');

    obj = Foo.Bar.create();
    equal(obj.toString(), '<Foo.Bar:' + _emberUtils.guidFor(obj) + '>');
  });

  QUnit.test('toString on a namespace falls back to modulePrefix, if defined', function () {
    var Foo = _emberRuntimeSystemNamespace.default.create({ modulePrefix: 'foo' });

    equal(Foo.toString(), 'foo');
  });

  QUnit.test('toString includes toStringExtension if defined', function () {
    var Foo = _emberRuntimeSystemObject.default.extend({
      toStringExtension: function () {
        return 'fooey';
      }
    });
    var foo = Foo.create();
    var Bar = _emberRuntimeSystemObject.default.extend({});
    var bar = Bar.create();

    // simulate these classes being defined on a Namespace
    Foo[_emberUtils.NAME_KEY] = 'Foo';
    Bar[_emberUtils.NAME_KEY] = 'Bar';

    equal(bar.toString(), '<Bar:' + _emberUtils.guidFor(bar) + '>', 'does not include toStringExtension part');
    equal(foo.toString(), '<Foo:' + _emberUtils.guidFor(foo) + ':fooey>', 'Includes toStringExtension result');
  });
});
enifed('ember-runtime/tests/system/object/toString_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/object/toString_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/object/toString_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/object_proxy_test', ['exports', 'ember-metal', 'internal-test-helpers', 'ember-runtime/system/object_proxy'], function (exports, _emberMetal, _internalTestHelpers, _emberRuntimeSystemObject_proxy) {
  'use strict';

  QUnit.module('ObjectProxy');

  _internalTestHelpers.testBoth('should not proxy properties passed to create', function (get, set) {
    var Proxy = _emberRuntimeSystemObject_proxy.default.extend({
      cp: _emberMetal.computed({
        get: function (key) {
          return this._cp;
        },
        set: function (key, value) {
          this._cp = value;
          return this._cp;
        }
      })
    });
    var proxy = Proxy.create({
      prop: 'Foo',
      cp: 'Bar'
    });

    equal(get(proxy, 'prop'), 'Foo', 'should not have tried to proxy set');
    equal(proxy._cp, 'Bar', 'should use CP setter');
  });

  _internalTestHelpers.testBoth('should proxy properties to content', function (get, set) {
    var content = {
      firstName: 'Tom',
      lastName: 'Dale',
      unknownProperty: function (key) {
        return key + ' unknown';
      }
    };
    var proxy = _emberRuntimeSystemObject_proxy.default.create();

    equal(get(proxy, 'firstName'), undefined, 'get on proxy without content should return undefined');
    expectAssertion(function () {
      set(proxy, 'firstName', 'Foo');
    }, /Cannot delegate set\('firstName', Foo\) to the 'content'/i);

    set(proxy, 'content', content);

    equal(get(proxy, 'firstName'), 'Tom', 'get on proxy with content should forward to content');
    equal(get(proxy, 'lastName'), 'Dale', 'get on proxy with content should forward to content');
    equal(get(proxy, 'foo'), 'foo unknown', 'get on proxy with content should forward to content');

    set(proxy, 'lastName', 'Huda');

    equal(get(content, 'lastName'), 'Huda', 'content should have new value from set on proxy');
    equal(get(proxy, 'lastName'), 'Huda', 'proxy should have new value from set on proxy');

    set(proxy, 'content', { firstName: 'Yehuda', lastName: 'Katz' });

    equal(get(proxy, 'firstName'), 'Yehuda', 'proxy should reflect updated content');
    equal(get(proxy, 'lastName'), 'Katz', 'proxy should reflect updated content');
  });

  _internalTestHelpers.testBoth('should work with watched properties', function (get, set) {
    var content1 = { firstName: 'Tom', lastName: 'Dale' };
    var content2 = { firstName: 'Yehuda', lastName: 'Katz' };
    var count = 0;
    var last = undefined;

    var Proxy = _emberRuntimeSystemObject_proxy.default.extend({
      fullName: _emberMetal.computed(function () {
        var firstName = this.get('firstName');
        var lastName = this.get('lastName');

        if (firstName && lastName) {
          return firstName + ' ' + lastName;
        }
        return firstName || lastName;
      }).property('firstName', 'lastName')
    });

    var proxy = Proxy.create();

    _emberMetal.addObserver(proxy, 'fullName', function () {
      last = get(proxy, 'fullName');
      count++;
    });

    // proxy without content returns undefined
    equal(get(proxy, 'fullName'), undefined);

    // setting content causes all watched properties to change
    set(proxy, 'content', content1);
    // both dependent keys changed
    equal(count, 2);
    equal(last, 'Tom Dale');

    // setting property in content causes proxy property to change
    set(content1, 'lastName', 'Huda');
    equal(count, 3);
    equal(last, 'Tom Huda');

    // replacing content causes all watched properties to change
    set(proxy, 'content', content2);
    // both dependent keys changed
    equal(count, 5);
    equal(last, 'Yehuda Katz');
    // content1 is no longer watched
    ok(!_emberMetal.isWatching(content1, 'firstName'), 'not watching firstName');
    ok(!_emberMetal.isWatching(content1, 'lastName'), 'not watching lastName');

    // setting property in new content
    set(content2, 'firstName', 'Tomhuda');
    equal(last, 'Tomhuda Katz');
    equal(count, 6);

    // setting property in proxy syncs with new content
    set(proxy, 'lastName', 'Katzdale');
    equal(count, 7);
    equal(last, 'Tomhuda Katzdale');
    equal(get(content2, 'firstName'), 'Tomhuda');
    equal(get(content2, 'lastName'), 'Katzdale');
  });

  QUnit.test('set and get should work with paths', function () {
    var content = { foo: { bar: 'baz' } };
    var proxy = _emberRuntimeSystemObject_proxy.default.create({ content: content });
    var count = 0;

    proxy.set('foo.bar', 'hello');
    equal(proxy.get('foo.bar'), 'hello');
    equal(proxy.get('content.foo.bar'), 'hello');

    proxy.addObserver('foo.bar', function () {
      count++;
    });

    proxy.set('foo.bar', 'bye');

    equal(count, 1);
    equal(proxy.get('foo.bar'), 'bye');
    equal(proxy.get('content.foo.bar'), 'bye');
  });

  _internalTestHelpers.testBoth('should transition between watched and unwatched strategies', function (get, set) {
    var content = { foo: 'foo' };
    var proxy = _emberRuntimeSystemObject_proxy.default.create({ content: content });
    var count = 0;

    function observer() {
      count++;
    }

    equal(get(proxy, 'foo'), 'foo');

    set(content, 'foo', 'bar');

    equal(get(proxy, 'foo'), 'bar');

    set(proxy, 'foo', 'foo');

    equal(get(content, 'foo'), 'foo');
    equal(get(proxy, 'foo'), 'foo');

    _emberMetal.addObserver(proxy, 'foo', observer);

    equal(count, 0);
    equal(get(proxy, 'foo'), 'foo');

    set(content, 'foo', 'bar');

    equal(count, 1);
    equal(get(proxy, 'foo'), 'bar');

    set(proxy, 'foo', 'foo');

    equal(count, 2);
    equal(get(content, 'foo'), 'foo');
    equal(get(proxy, 'foo'), 'foo');

    _emberMetal.removeObserver(proxy, 'foo', observer);

    set(content, 'foo', 'bar');

    equal(get(proxy, 'foo'), 'bar');

    set(proxy, 'foo', 'foo');

    equal(get(content, 'foo'), 'foo');
    equal(get(proxy, 'foo'), 'foo');
  });

  _internalTestHelpers.testBoth('setting `undefined` to a proxied content property should override its existing value', function (get, set) {
    var proxyObject = _emberRuntimeSystemObject_proxy.default.create({
      content: {
        prop: 'emberjs'
      }
    });
    set(proxyObject, 'prop', undefined);
    equal(get(proxyObject, 'prop'), undefined, 'sets the `undefined` value to the proxied content');
  });
});
enifed('ember-runtime/tests/system/object_proxy_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/object_proxy_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/object_proxy_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/string/camelize_test', ['exports', 'ember-environment', 'ember-runtime/system/string'], function (exports, _emberEnvironment, _emberRuntimeSystemString) {
  'use strict';

  QUnit.module('EmberStringUtils.camelize');

  if (!_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
    QUnit.test('String.prototype.camelize is not modified without EXTEND_PROTOTYPES', function () {
      ok('undefined' === typeof String.prototype.camelize, 'String.prototype helper disabled');
    });
  }

  QUnit.test('camelize normal string', function () {
    deepEqual(_emberRuntimeSystemString.camelize('my favorite items'), 'myFavoriteItems');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('my favorite items'.camelize(), 'myFavoriteItems');
    }
  });

  QUnit.test('camelize capitalized string', function () {
    deepEqual(_emberRuntimeSystemString.camelize('I Love Ramen'), 'iLoveRamen');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('I Love Ramen'.camelize(), 'iLoveRamen');
    }
  });

  QUnit.test('camelize dasherized string', function () {
    deepEqual(_emberRuntimeSystemString.camelize('css-class-name'), 'cssClassName');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('css-class-name'.camelize(), 'cssClassName');
    }
  });

  QUnit.test('camelize underscored string', function () {
    deepEqual(_emberRuntimeSystemString.camelize('action_name'), 'actionName');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('action_name'.camelize(), 'actionName');
    }
  });

  QUnit.test('camelize dot notation string', function () {
    deepEqual(_emberRuntimeSystemString.camelize('action.name'), 'actionName');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('action.name'.camelize(), 'actionName');
    }
  });

  QUnit.test('does nothing with camelcased string', function () {
    deepEqual(_emberRuntimeSystemString.camelize('innerHTML'), 'innerHTML');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('innerHTML'.camelize(), 'innerHTML');
    }
  });

  QUnit.test('camelize namespaced classified string', function () {
    deepEqual(_emberRuntimeSystemString.camelize('PrivateDocs/OwnerInvoice'), 'privateDocs/ownerInvoice');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('PrivateDocs/OwnerInvoice'.camelize(), 'privateDocs/ownerInvoice');
    }
  });

  QUnit.test('camelize namespaced underscored string', function () {
    deepEqual(_emberRuntimeSystemString.camelize('private_docs/owner_invoice'), 'privateDocs/ownerInvoice');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('private_docs/owner_invoice'.camelize(), 'privateDocs/ownerInvoice');
    }
  });

  QUnit.test('camelize namespaced dasherized string', function () {
    deepEqual(_emberRuntimeSystemString.camelize('private-docs/owner-invoice'), 'privateDocs/ownerInvoice');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('private-docs/owner-invoice'.camelize(), 'privateDocs/ownerInvoice');
    }
  });
});
enifed('ember-runtime/tests/system/string/camelize_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/string/camelize_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/string/camelize_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/string/capitalize_test', ['exports', 'ember-environment', 'ember-runtime/system/string'], function (exports, _emberEnvironment, _emberRuntimeSystemString) {
  'use strict';

  QUnit.module('EmberStringUtils.capitalize');

  if (!_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
    QUnit.test('String.prototype.capitalize is not modified without EXTEND_PROTOTYPES', function () {
      ok('undefined' === typeof String.prototype.capitalize, 'String.prototype helper disabled');
    });
  }

  QUnit.test('capitalize normal string', function () {
    deepEqual(_emberRuntimeSystemString.capitalize('my favorite items'), 'My favorite items');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('my favorite items'.capitalize(), 'My favorite items');
    }
  });

  QUnit.test('capitalize dasherized string', function () {
    deepEqual(_emberRuntimeSystemString.capitalize('css-class-name'), 'Css-class-name');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('css-class-name'.capitalize(), 'Css-class-name');
    }
  });

  QUnit.test('capitalize underscored string', function () {
    deepEqual(_emberRuntimeSystemString.capitalize('action_name'), 'Action_name');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('action_name'.capitalize(), 'Action_name');
    }
  });

  QUnit.test('capitalize camelcased string', function () {
    deepEqual(_emberRuntimeSystemString.capitalize('innerHTML'), 'InnerHTML');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('innerHTML'.capitalize(), 'InnerHTML');
    }
  });

  QUnit.test('does nothing with capitalized string', function () {
    deepEqual(_emberRuntimeSystemString.capitalize('Capitalized string'), 'Capitalized string');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('Capitalized string'.capitalize(), 'Capitalized string');
    }
  });

  QUnit.test('capitalize namespaced camelized string', function () {
    deepEqual(_emberRuntimeSystemString.capitalize('privateDocs/ownerInvoice'), 'PrivateDocs/OwnerInvoice');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('privateDocs/ownerInvoice'.capitalize(), 'PrivateDocs/OwnerInvoice');
    }
  });

  QUnit.test('capitalize namespaced underscored string', function () {
    deepEqual(_emberRuntimeSystemString.capitalize('private_docs/owner_invoice'), 'Private_docs/Owner_invoice');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('private_docs/owner_invoice'.capitalize(), 'Private_docs/Owner_invoice');
    }
  });

  QUnit.test('capitalize namespaced dasherized string', function () {
    deepEqual(_emberRuntimeSystemString.capitalize('private-docs/owner-invoice'), 'Private-docs/Owner-invoice');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('private-docs/owner-invoice'.capitalize(), 'Private-docs/Owner-invoice');
    }
  });
});
enifed('ember-runtime/tests/system/string/capitalize_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/string/capitalize_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/string/capitalize_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/string/classify_test', ['exports', 'ember-environment', 'ember-runtime/system/string'], function (exports, _emberEnvironment, _emberRuntimeSystemString) {
  'use strict';

  QUnit.module('EmberStringUtils.classify');

  if (!_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
    QUnit.test('String.prototype.classify is not modified without EXTEND_PROTOTYPES', function () {
      ok('undefined' === typeof String.prototype.classify, 'String.prototype helper disabled');
    });
  }

  function test(given, expected, description) {
    QUnit.test(description, function () {
      deepEqual(_emberRuntimeSystemString.classify(given), expected);
      if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
        deepEqual(given.classify(), expected);
      }
    });
  }

  test('my favorite items', 'MyFavoriteItems', 'classify normal string');
  test('css-class-name', 'CssClassName', 'classify dasherized string');
  test('action_name', 'ActionName', 'classify underscored string');
  test('privateDocs/ownerInvoice', 'PrivateDocs/OwnerInvoice', 'classify namespaced camelized string');
  test('private_docs/owner_invoice', 'PrivateDocs/OwnerInvoice', 'classify namespaced underscored string');
  test('private-docs/owner-invoice', 'PrivateDocs/OwnerInvoice', 'classify namespaced dasherized string');
  test('-view-registry', '_ViewRegistry', 'classify prefixed dasherized string');
  test('components/-text-field', 'Components/_TextField', 'classify namespaced prefixed dasherized string');
  test('_Foo_Bar', '_FooBar', 'classify underscore-prefixed underscored string');
  test('_Foo-Bar', '_FooBar', 'classify underscore-prefixed dasherized string');
  test('_foo/_bar', '_Foo/_Bar', 'classify underscore-prefixed-namespaced underscore-prefixed string');
  test('-foo/_bar', '_Foo/_Bar', 'classify dash-prefixed-namespaced underscore-prefixed string');
  test('-foo/-bar', '_Foo/_Bar', 'classify dash-prefixed-namespaced dash-prefixed string');
  test('InnerHTML', 'InnerHTML', 'does nothing with classified string');
  test('_FooBar', '_FooBar', 'does nothing with classified prefixed string');
});
enifed('ember-runtime/tests/system/string/classify_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/string/classify_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/string/classify_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/string/dasherize_test', ['exports', 'ember-environment', 'ember-runtime/system/string'], function (exports, _emberEnvironment, _emberRuntimeSystemString) {
  'use strict';

  QUnit.module('EmberStringUtils.dasherize');

  if (!_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
    QUnit.test('String.prototype.dasherize is not modified without EXTEND_PROTOTYPES', function () {
      ok('undefined' === typeof String.prototype.dasherize, 'String.prototype helper disabled');
    });
  }

  QUnit.test('dasherize normal string', function () {
    deepEqual(_emberRuntimeSystemString.dasherize('my favorite items'), 'my-favorite-items');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('my favorite items'.dasherize(), 'my-favorite-items');
    }
  });

  QUnit.test('does nothing with dasherized string', function () {
    deepEqual(_emberRuntimeSystemString.dasherize('css-class-name'), 'css-class-name');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('css-class-name'.dasherize(), 'css-class-name');
    }
  });

  QUnit.test('dasherize underscored string', function () {
    deepEqual(_emberRuntimeSystemString.dasherize('action_name'), 'action-name');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('action_name'.dasherize(), 'action-name');
    }
  });

  QUnit.test('dasherize camelcased string', function () {
    deepEqual(_emberRuntimeSystemString.dasherize('innerHTML'), 'inner-html');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('innerHTML'.dasherize(), 'inner-html');
    }
  });

  QUnit.test('dasherize string that is the property name of Object.prototype', function () {
    deepEqual(_emberRuntimeSystemString.dasherize('toString'), 'to-string');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('toString'.dasherize(), 'to-string');
    }
  });

  QUnit.test('dasherize namespaced classified string', function () {
    deepEqual(_emberRuntimeSystemString.dasherize('PrivateDocs/OwnerInvoice'), 'private-docs/owner-invoice');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('PrivateDocs/OwnerInvoice'.dasherize(), 'private-docs/owner-invoice');
    }
  });

  QUnit.test('dasherize namespaced camelized string', function () {
    deepEqual(_emberRuntimeSystemString.dasherize('privateDocs/ownerInvoice'), 'private-docs/owner-invoice');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('privateDocs/ownerInvoice'.dasherize(), 'private-docs/owner-invoice');
    }
  });

  QUnit.test('dasherize namespaced underscored string', function () {
    deepEqual(_emberRuntimeSystemString.dasherize('private_docs/owner_invoice'), 'private-docs/owner-invoice');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('private_docs/owner_invoice'.dasherize(), 'private-docs/owner-invoice');
    }
  });
});
enifed('ember-runtime/tests/system/string/dasherize_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/string/dasherize_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/string/dasherize_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/string/decamelize_test', ['exports', 'ember-environment', 'ember-runtime/system/string'], function (exports, _emberEnvironment, _emberRuntimeSystemString) {
  'use strict';

  QUnit.module('EmberStringUtils.decamelize');

  if (!_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
    QUnit.test('String.prototype.decamelize is not modified without EXTEND_PROTOTYPES', function () {
      ok('undefined' === typeof String.prototype.decamelize, 'String.prototype helper disabled');
    });
  }

  QUnit.test('does nothing with normal string', function () {
    deepEqual(_emberRuntimeSystemString.decamelize('my favorite items'), 'my favorite items');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('my favorite items'.decamelize(), 'my favorite items');
    }
  });

  QUnit.test('does nothing with dasherized string', function () {
    deepEqual(_emberRuntimeSystemString.decamelize('css-class-name'), 'css-class-name');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('css-class-name'.decamelize(), 'css-class-name');
    }
  });

  QUnit.test('does nothing with underscored string', function () {
    deepEqual(_emberRuntimeSystemString.decamelize('action_name'), 'action_name');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('action_name'.decamelize(), 'action_name');
    }
  });

  QUnit.test('converts a camelized string into all lower case separated by underscores.', function () {
    deepEqual(_emberRuntimeSystemString.decamelize('innerHTML'), 'inner_html');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('innerHTML'.decamelize(), 'inner_html');
    }
  });

  QUnit.test('decamelizes strings with numbers', function () {
    deepEqual(_emberRuntimeSystemString.decamelize('size160Url'), 'size160_url');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('size160Url'.decamelize(), 'size160_url');
    }
  });

  QUnit.test('decamelize namespaced classified string', function () {
    deepEqual(_emberRuntimeSystemString.decamelize('PrivateDocs/OwnerInvoice'), 'private_docs/owner_invoice');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('PrivateDocs/OwnerInvoice'.decamelize(), 'private_docs/owner_invoice');
    }
  });

  QUnit.test('decamelize namespaced camelized string', function () {
    deepEqual(_emberRuntimeSystemString.decamelize('privateDocs/ownerInvoice'), 'private_docs/owner_invoice');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('privateDocs/ownerInvoice'.decamelize(), 'private_docs/owner_invoice');
    }
  });
});
enifed('ember-runtime/tests/system/string/decamelize_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/string/decamelize_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/string/decamelize_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/string/fmt_string_test', ['exports', 'ember-environment', 'ember-runtime/system/string'], function (exports, _emberEnvironment, _emberRuntimeSystemString) {
  'use strict';

  QUnit.module('EmberStringUtils.fmt');

  if (!_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
    QUnit.test('String.prototype.fmt is not modified without EXTEND_PROTOTYPES', function () {
      ok('undefined' === typeof String.prototype.fmt, 'String.prototype helper disabled');
    });
  }

  QUnit.test('\'Hello %@ %@\'.fmt(\'John\', \'Doe\') => \'Hello John Doe\'', function () {
    expectDeprecation('Ember.String.fmt is deprecated, use ES6 template strings instead.');
    equal(_emberRuntimeSystemString.fmt('Hello %@ %@', ['John', 'Doe']), 'Hello John Doe');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      equal('Hello %@ %@'.fmt('John', 'Doe'), 'Hello John Doe');
    }
  });

  QUnit.test('\'Hello %@2 %@1\'.fmt(\'John\', \'Doe\') => \'Hello Doe John\'', function () {
    expectDeprecation('Ember.String.fmt is deprecated, use ES6 template strings instead.');
    equal(_emberRuntimeSystemString.fmt('Hello %@2 %@1', ['John', 'Doe']), 'Hello Doe John');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      equal('Hello %@2 %@1'.fmt('John', 'Doe'), 'Hello Doe John');
    }
  });

  QUnit.test('\'%@08 %@07 %@06 %@05 %@04 %@03 %@02 %@01\'.fmt(\'One\', \'Two\', \'Three\', \'Four\', \'Five\', \'Six\', \'Seven\', \'Eight\') => \'Eight Seven Six Five Four Three Two One\'', function () {
    expectDeprecation('Ember.String.fmt is deprecated, use ES6 template strings instead.');
    equal(_emberRuntimeSystemString.fmt('%@08 %@07 %@06 %@05 %@04 %@03 %@02 %@01', ['One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight']), 'Eight Seven Six Five Four Three Two One');

    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      equal('%@08 %@07 %@06 %@05 %@04 %@03 %@02 %@01'.fmt('One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight'), 'Eight Seven Six Five Four Three Two One');
    }
  });

  QUnit.test('\'data: %@\'.fmt({ id: 3 }) => \'data: {id: 3}\'', function () {
    expectDeprecation('Ember.String.fmt is deprecated, use ES6 template strings instead.');
    equal(_emberRuntimeSystemString.fmt('data: %@', [{ id: 3 }]), 'data: {id: 3}');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      equal('data: %@'.fmt({ id: 3 }), 'data: {id: 3}');
    }
  });

  QUnit.test('works with argument form', function () {
    expectDeprecation('Ember.String.fmt is deprecated, use ES6 template strings instead.');
    equal(_emberRuntimeSystemString.fmt('%@', 'John'), 'John');
    equal(_emberRuntimeSystemString.fmt('%@ %@', ['John'], 'Doe'), '[John] Doe');
  });
});
enifed('ember-runtime/tests/system/string/fmt_string_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/string/fmt_string_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/string/fmt_string_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/string/loc_test', ['exports', 'ember-metal', 'ember-environment', 'ember-runtime/system/string'], function (exports, _emberMetal, _emberEnvironment, _emberRuntimeSystemString) {
  'use strict';

  var oldString = undefined;

  QUnit.module('EmberStringUtils.loc', {
    setup: function () {
      oldString = _emberMetal.default.STRINGS;
      _emberMetal.default.STRINGS = {
        '_Hello World': 'Bonjour le monde',
        '_Hello %@': 'Bonjour %@',
        '_Hello %@ %@': 'Bonjour %@ %@',
        '_Hello %@# %@#': 'Bonjour %@2 %@1'
      };
    },

    teardown: function () {
      _emberMetal.default.STRINGS = oldString;
    }
  });

  if (!_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
    QUnit.test('String.prototype.loc is not available without EXTEND_PROTOTYPES', function () {
      ok('undefined' === typeof String.prototype.loc, 'String.prototype helper disabled');
    });
  }

  QUnit.test('\'_Hello World\'.loc() => \'Bonjour le monde\'', function () {
    equal(_emberRuntimeSystemString.loc('_Hello World'), 'Bonjour le monde');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      equal('_Hello World'.loc(), 'Bonjour le monde');
    }
  });

  QUnit.test('\'_Hello %@ %@\'.loc(\'John\', \'Doe\') => \'Bonjour John Doe\'', function () {
    equal(_emberRuntimeSystemString.loc('_Hello %@ %@', ['John', 'Doe']), 'Bonjour John Doe');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      equal('_Hello %@ %@'.loc('John', 'Doe'), 'Bonjour John Doe');
    }
  });

  QUnit.test('\'_Hello %@# %@#\'.loc(\'John\', \'Doe\') => \'Bonjour Doe John\'', function () {
    equal(_emberRuntimeSystemString.loc('_Hello %@# %@#', ['John', 'Doe']), 'Bonjour Doe John');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      equal('_Hello %@# %@#'.loc('John', 'Doe'), 'Bonjour Doe John');
    }
  });

  QUnit.test('\'_Not In Strings\'.loc() => \'_Not In Strings\'', function () {
    equal(_emberRuntimeSystemString.loc('_Not In Strings'), '_Not In Strings');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      equal('_Not In Strings'.loc(), '_Not In Strings');
    }
  });

  QUnit.test('works with argument form', function () {
    equal(_emberRuntimeSystemString.loc('_Hello %@', 'John'), 'Bonjour John');
    equal(_emberRuntimeSystemString.loc('_Hello %@ %@', ['John'], 'Doe'), 'Bonjour [John] Doe');
  });
});
// ES6TODO Ember.STRINGS
enifed('ember-runtime/tests/system/string/loc_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/string/loc_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/string/loc_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/string/underscore_test', ['exports', 'ember-environment', 'ember-runtime/system/string'], function (exports, _emberEnvironment, _emberRuntimeSystemString) {
  'use strict';

  QUnit.module('EmberStringUtils.underscore');

  if (!_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
    QUnit.test('String.prototype.underscore is not available without EXTEND_PROTOTYPES', function () {
      ok('undefined' === typeof String.prototype.underscore, 'String.prototype helper disabled');
    });
  }

  QUnit.test('with normal string', function () {
    deepEqual(_emberRuntimeSystemString.underscore('my favorite items'), 'my_favorite_items');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('my favorite items'.underscore(), 'my_favorite_items');
    }
  });

  QUnit.test('with dasherized string', function () {
    deepEqual(_emberRuntimeSystemString.underscore('css-class-name'), 'css_class_name');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('css-class-name'.underscore(), 'css_class_name');
    }
  });

  QUnit.test('does nothing with underscored string', function () {
    deepEqual(_emberRuntimeSystemString.underscore('action_name'), 'action_name');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('action_name'.underscore(), 'action_name');
    }
  });

  QUnit.test('with camelcased string', function () {
    deepEqual(_emberRuntimeSystemString.underscore('innerHTML'), 'inner_html');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('innerHTML'.underscore(), 'inner_html');
    }
  });

  QUnit.test('underscore namespaced classified string', function () {
    deepEqual(_emberRuntimeSystemString.underscore('PrivateDocs/OwnerInvoice'), 'private_docs/owner_invoice');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('PrivateDocs/OwnerInvoice'.underscore(), 'private_docs/owner_invoice');
    }
  });

  QUnit.test('underscore namespaced camelized string', function () {
    deepEqual(_emberRuntimeSystemString.underscore('privateDocs/ownerInvoice'), 'private_docs/owner_invoice');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('privateDocs/ownerInvoice'.underscore(), 'private_docs/owner_invoice');
    }
  });

  QUnit.test('underscore namespaced dasherized string', function () {
    deepEqual(_emberRuntimeSystemString.underscore('private-docs/owner-invoice'), 'private_docs/owner_invoice');
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('private-docs/owner-invoice'.underscore(), 'private_docs/owner_invoice');
    }
  });
});
enifed('ember-runtime/tests/system/string/underscore_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/string/underscore_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/string/underscore_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/tests/system/string/w_test', ['exports', 'ember-environment', 'ember-runtime/system/string'], function (exports, _emberEnvironment, _emberRuntimeSystemString) {
  'use strict';

  QUnit.module('EmberStringUtils.w');

  if (!_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
    QUnit.test('String.prototype.w is not available without EXTEND_PROTOTYPES', function () {
      ok('undefined' === typeof String.prototype.w, 'String.prototype helper disabled');
    });
  }

  QUnit.test('\'one two three\'.w() => [\'one\',\'two\',\'three\']', function () {
    deepEqual(_emberRuntimeSystemString.w('one two three'), ['one', 'two', 'three']);
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('one two three'.w(), ['one', 'two', 'three']);
    }
  });

  QUnit.test('\'one    two    three\'.w() with extra spaces between words => [\'one\',\'two\',\'three\']', function () {
    deepEqual(_emberRuntimeSystemString.w('one   two  three'), ['one', 'two', 'three']);
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('one   two  three'.w(), ['one', 'two', 'three']);
    }
  });

  QUnit.test('\'one two three\'.w() with tabs', function () {
    deepEqual(_emberRuntimeSystemString.w('one\ttwo  three'), ['one', 'two', 'three']);
    if (_emberEnvironment.ENV.EXTEND_PROTOTYPES.String) {
      deepEqual('one\ttwo  three'.w(), ['one', 'two', 'three']);
    }
  });
});
enifed('ember-runtime/tests/system/string/w_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/tests/system/string/w_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/tests/system/string/w_test.js should pass ESLint\n\n');
  });
});
enifed('ember-runtime/utils.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-runtime/utils.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-runtime/utils.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/compat.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/compat.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/compat.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/index.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/index.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/index.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/plugins/assert-reserved-named-arguments.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/plugins/assert-reserved-named-arguments.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/plugins/assert-reserved-named-arguments.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/plugins/deprecate-render-model.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/plugins/deprecate-render-model.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/plugins/deprecate-render-model.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/plugins/deprecate-render.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/plugins/deprecate-render.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/plugins/deprecate-render.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/plugins/index.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/plugins/index.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/plugins/index.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/plugins/transform-action-syntax.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/plugins/transform-action-syntax.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/plugins/transform-action-syntax.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/plugins/transform-angle-bracket-components.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/plugins/transform-angle-bracket-components.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/plugins/transform-angle-bracket-components.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/plugins/transform-attrs-into-args.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/plugins/transform-attrs-into-args.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/plugins/transform-attrs-into-args.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/plugins/transform-each-in-into-each.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/plugins/transform-each-in-into-each.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/plugins/transform-each-in-into-each.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/plugins/transform-has-block-syntax.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/plugins/transform-has-block-syntax.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/plugins/transform-has-block-syntax.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/plugins/transform-inline-link-to.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/plugins/transform-inline-link-to.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/plugins/transform-inline-link-to.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/plugins/transform-input-on-to-onEvent.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/plugins/transform-input-on-to-onEvent.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/plugins/transform-input-on-to-onEvent.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/plugins/transform-input-type-syntax.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/plugins/transform-input-type-syntax.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/plugins/transform-input-type-syntax.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/plugins/transform-item-class.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/plugins/transform-item-class.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/plugins/transform-item-class.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/plugins/transform-old-binding-syntax.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/plugins/transform-old-binding-syntax.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/plugins/transform-old-binding-syntax.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/plugins/transform-old-class-binding-syntax.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/plugins/transform-old-class-binding-syntax.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/plugins/transform-old-class-binding-syntax.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/plugins/transform-quoted-bindings-into-just-bindings.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/plugins/transform-quoted-bindings-into-just-bindings.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/plugins/transform-quoted-bindings-into-just-bindings.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/plugins/transform-top-level-components.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/plugins/transform-top-level-components.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/plugins/transform-top-level-components.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/system/bootstrap.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/system/bootstrap.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/system/bootstrap.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/system/calculate-location-display.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/system/calculate-location-display.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/system/calculate-location-display.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/system/compile-options.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/system/compile-options.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/system/compile-options.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/system/compile.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/system/compile.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/system/compile.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/system/precompile.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/system/precompile.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/system/precompile.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/tests/plugins/assert-reserved-named-arguments-test', ['exports', 'ember-template-compiler/index'], function (exports, _emberTemplateCompilerIndex) {
  'use strict';

  QUnit.module('ember-template-compiler: assert-reserved-named-arguments');

  QUnit.test('Paths beginning with @ are not valid', function () {
    expect(3);

    expectAssertion(function () {
      _emberTemplateCompilerIndex.compile('{{@foo}}', {
        moduleName: 'baz/foo-bar'
      });
    }, '\'@foo\' is not a valid path. (\'baz/foo-bar\' @ L1:C2) ');

    expectAssertion(function () {
      _emberTemplateCompilerIndex.compile('{{#if @foo}}Yup{{/if}}', {
        moduleName: 'baz/foo-bar'
      });
    }, '\'@foo\' is not a valid path. (\'baz/foo-bar\' @ L1:C6) ');

    expectAssertion(function () {
      _emberTemplateCompilerIndex.compile('{{input type=(if @foo "bar" "baz")}}', {
        moduleName: 'baz/foo-bar'
      });
    }, '\'@foo\' is not a valid path. (\'baz/foo-bar\' @ L1:C17) ');
  });
});
enifed('ember-template-compiler/tests/plugins/assert-reserved-named-arguments-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/tests/plugins/assert-reserved-named-arguments-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/tests/plugins/assert-reserved-named-arguments-test.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/tests/plugins/deprecate-render-model-test', ['exports', 'ember-template-compiler/index'], function (exports, _emberTemplateCompilerIndex) {
  'use strict';

  QUnit.module('ember-template-compiler: deprecate-model-render');

  QUnit.test('Using `{{render` with model provides a deprecation', function () {
    expect(1);

    var expectedMessage = 'Please refactor `{{render "foo-bar" coolModel}}` to a component and' + ' invoke via `{{foo-bar model=coolModel}}`. (\'baz/foo-bar\' @ L1:C0) ';

    expectDeprecation(function () {
      _emberTemplateCompilerIndex.compile('{{render "foo-bar" coolModel}}', {
        moduleName: 'baz/foo-bar'
      });
    }, expectedMessage);
  });
});
enifed('ember-template-compiler/tests/plugins/deprecate-render-model-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/tests/plugins/deprecate-render-model-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/tests/plugins/deprecate-render-model-test.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/tests/plugins/deprecate-render-test', ['exports', 'ember-template-compiler/index'], function (exports, _emberTemplateCompilerIndex) {
  'use strict';

  QUnit.module('ember-template-compiler: deprecate-render');

  QUnit.test('Using `{{render` without a model provides a deprecation', function () {
    expect(1);

    var expectedMessage = 'Please refactor `{{render "foo-bar"}}` to a component and' + ' invoke via `{{foo-bar}}`. (\'baz/foo-bar\' @ L1:C0) ';

    expectDeprecation(function () {
      _emberTemplateCompilerIndex.compile('{{render "foo-bar"}}', {
        moduleName: 'baz/foo-bar'
      });
    }, expectedMessage);
  });
});
enifed('ember-template-compiler/tests/plugins/deprecate-render-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/tests/plugins/deprecate-render-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/tests/plugins/deprecate-render-test.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/tests/plugins/transform-inline-link-to-test', ['exports', 'ember-template-compiler/index'], function (exports, _emberTemplateCompilerIndex) {
  'use strict';

  QUnit.module('ember-template-compiler: assert-no-view-and-controller-paths without legacy view support');

  QUnit.test('Can transform an inline {{link-to}} without error', function () {
    expect(0);

    _emberTemplateCompilerIndex.compile('{{link-to \'foo\' \'index\'}}', {
      moduleName: 'foo/bar/baz'
    });
  });
});
enifed('ember-template-compiler/tests/plugins/transform-inline-link-to-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/tests/plugins/transform-inline-link-to-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/tests/plugins/transform-inline-link-to-test.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/tests/plugins/transform-input-on-test', ['exports', 'ember-template-compiler/index'], function (exports, _emberTemplateCompilerIndex) {
  'use strict';

  QUnit.module('ember-template-compiler: transform-input-on');

  QUnit.test('Using `action` without `on` provides a deprecation', function () {
    expect(1);

    expectDeprecation(function () {
      _emberTemplateCompilerIndex.compile('{{input action="foo"}}', {
        moduleName: 'foo/bar/baz'
      });
    }, 'Using \'{{input action="foo"}}\' (\'foo/bar/baz\' @ L1:C0) is deprecated. Please use \'{{input enter="foo"}}\' instead.');
  });

  QUnit.test('Using `action` with `on` provides a deprecation', function () {
    expect(1);

    expectDeprecation(function () {
      _emberTemplateCompilerIndex.compile('{{input on="focus-in" action="foo"}}', {
        moduleName: 'foo/bar/baz'
      });
    }, 'Using \'{{input on="focus-in" action="foo"}}\' (\'foo/bar/baz\' @ L1:C0) is deprecated. Please use \'{{input focus-in="foo"}}\' instead.');
  });

  QUnit.test('Using `on=\'keyPress\'` does not clobber `keyPress`', function () {
    expect(1);

    expectDeprecation(function () {
      _emberTemplateCompilerIndex.compile('{{input on="keyPress" action="foo"}}', {
        moduleName: 'foo/bar/baz'
      });
    }, 'Using \'{{input on="keyPress" action="foo"}}\' (\'foo/bar/baz\' @ L1:C0) is deprecated. Please use \'{{input key-press="foo"}}\' instead.');
  });

  QUnit.test('Using `on=\'foo\'` without `action=\'asdf\'` raises specific deprecation', function () {
    expect(1);

    expectDeprecation(function () {
      _emberTemplateCompilerIndex.compile('{{input on="asdf"}}', {
        moduleName: 'foo/bar/baz'
      });
    }, 'Using \'{{input on="asdf" ...}}\' without specifying an action (\'foo/bar/baz\' @ L1:C0) will do nothing.');
  });
});
enifed('ember-template-compiler/tests/plugins/transform-input-on-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/tests/plugins/transform-input-on-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/tests/plugins/transform-input-on-test.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/tests/plugins/transform-input-type-syntax-test', ['exports', 'ember-template-compiler/index'], function (exports, _emberTemplateCompilerIndex) {
  'use strict';

  QUnit.module('ember-template-compiler: input type syntax');

  QUnit.test('Can compile an {{input}} helper that has a sub-expression value as its type', function () {
    expect(0);

    _emberTemplateCompilerIndex.compile('{{input type=(if true \'password\' \'text\')}}');
  });

  QUnit.test('Can compile an {{input}} helper with a string literal type', function () {
    expect(0);

    _emberTemplateCompilerIndex.compile('{{input type=\'text\'}}');
  });

  QUnit.test('Can compile an {{input}} helper with a type stored in a var', function () {
    expect(0);

    _emberTemplateCompilerIndex.compile('{{input type=_type}}');
  });
});
enifed('ember-template-compiler/tests/plugins/transform-input-type-syntax-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/tests/plugins/transform-input-type-syntax-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/tests/plugins/transform-input-type-syntax-test.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/tests/system/bootstrap-test', ['exports', 'ember-metal', 'ember-views', 'ember-glimmer', 'ember-template-compiler/system/bootstrap', 'internal-test-helpers'], function (exports, _emberMetal, _emberViews, _emberGlimmer, _emberTemplateCompilerSystemBootstrap, _internalTestHelpers) {
  'use strict';

  var trim = _emberViews.jQuery.trim;

  var component = undefined,
      fixture = undefined;

  function checkTemplate(templateName) {
    _emberMetal.run(function () {
      return _emberTemplateCompilerSystemBootstrap.default({ context: fixture, hasTemplate: _emberGlimmer.hasTemplate, setTemplate: _emberGlimmer.setTemplate });
    });

    var template = _emberGlimmer.getTemplate(templateName);

    ok(template, 'template is available on Ember.TEMPLATES');
    equal(_emberViews.jQuery('#qunit-fixture script').length, 0, 'script removed');

    var owner = _internalTestHelpers.buildOwner();
    owner.register('template:-top-level', template);
    owner.register('component:-top-level', _emberGlimmer.Component.extend({
      layoutName: '-top-level',
      firstName: 'Tobias',
      drug: 'teamocil'
    }));

    component = owner.lookup('component:-top-level');
    _internalTestHelpers.runAppend(component);

    equal(_emberViews.jQuery('#qunit-fixture').text().trim(), 'Tobias takes teamocil', 'template works');
    _internalTestHelpers.runDestroy(component);
  }

  QUnit.module('ember-templates: bootstrap', {
    setup: function () {
      fixture = document.getElementById('qunit-fixture');
    },
    teardown: function () {
      _emberGlimmer.setTemplates({});
      _internalTestHelpers.runDestroy(component);
    }
  });

  QUnit.test('template with data-template-name should add a new template to Ember.TEMPLATES', function () {
    _emberViews.jQuery('#qunit-fixture').html('<script type="text/x-handlebars" data-template-name="funkyTemplate">{{firstName}} takes {{drug}}</script>');

    checkTemplate('funkyTemplate');
  });

  QUnit.test('template with id instead of data-template-name should add a new template to Ember.TEMPLATES', function () {
    _emberViews.jQuery('#qunit-fixture').html('<script type="text/x-handlebars" id="funkyTemplate" >{{firstName}} takes {{drug}}</script>');

    checkTemplate('funkyTemplate');
  });

  QUnit.test('template without data-template-name or id should default to application', function () {
    _emberViews.jQuery('#qunit-fixture').html('<script type="text/x-handlebars">{{firstName}} takes {{drug}}</script>');

    checkTemplate('application');
  });

  if (typeof Handlebars === 'object') {
    QUnit.test('template with type text/x-raw-handlebars should be parsed', function () {
      _emberViews.jQuery('#qunit-fixture').html('<script type="text/x-raw-handlebars" data-template-name="funkyTemplate">{{name}}</script>');

      _emberMetal.run(function () {
        return _emberTemplateCompilerSystemBootstrap.default({ context: fixture, hasTemplate: _emberGlimmer.hasTemplate, setTemplate: _emberGlimmer.setTemplate });
      });

      var template = _emberGlimmer.getTemplate('funkyTemplate');

      ok(template, 'template with name funkyTemplate available');

      // This won't even work with Ember templates
      equal(trim(template({ name: 'Tobias' })), 'Tobias');
    });
  }

  QUnit.test('duplicated default application templates should throw exception', function () {
    _emberViews.jQuery('#qunit-fixture').html('<script type="text/x-handlebars">first</script><script type="text/x-handlebars">second</script>');

    throws(function () {
      return _emberTemplateCompilerSystemBootstrap.default({ context: fixture, hasTemplate: _emberGlimmer.hasTemplate, setTemplate: _emberGlimmer.setTemplate });
    }, /Template named "[^"]+" already exists\./, 'duplicate templates should not be allowed');
  });

  QUnit.test('default application template and id application template present should throw exception', function () {
    _emberViews.jQuery('#qunit-fixture').html('<script type="text/x-handlebars">first</script><script type="text/x-handlebars" id="application">second</script>');

    throws(function () {
      return _emberTemplateCompilerSystemBootstrap.default({ context: fixture, hasTemplate: _emberGlimmer.hasTemplate, setTemplate: _emberGlimmer.setTemplate });
    }, /Template named "[^"]+" already exists\./, 'duplicate templates should not be allowed');
  });

  QUnit.test('default application template and data-template-name application template present should throw exception', function () {
    _emberViews.jQuery('#qunit-fixture').html('<script type="text/x-handlebars">first</script><script type="text/x-handlebars" data-template-name="application">second</script>');

    throws(function () {
      return _emberTemplateCompilerSystemBootstrap.default({ context: fixture, hasTemplate: _emberGlimmer.hasTemplate, setTemplate: _emberGlimmer.setTemplate });
    }, /Template named "[^"]+" already exists\./, 'duplicate templates should not be allowed');
  });

  QUnit.test('duplicated template id should throw exception', function () {
    _emberViews.jQuery('#qunit-fixture').html('<script type="text/x-handlebars" id="funkyTemplate">first</script><script type="text/x-handlebars" id="funkyTemplate">second</script>');

    throws(function () {
      return _emberTemplateCompilerSystemBootstrap.default({ context: fixture, hasTemplate: _emberGlimmer.hasTemplate, setTemplate: _emberGlimmer.setTemplate });
    }, /Template named "[^"]+" already exists\./, 'duplicate templates should not be allowed');
  });

  QUnit.test('duplicated template data-template-name should throw exception', function () {
    _emberViews.jQuery('#qunit-fixture').html('<script type="text/x-handlebars" data-template-name="funkyTemplate">first</script><script type="text/x-handlebars" data-template-name="funkyTemplate">second</script>');

    throws(function () {
      return _emberTemplateCompilerSystemBootstrap.default({ context: fixture, hasTemplate: _emberGlimmer.hasTemplate, setTemplate: _emberGlimmer.setTemplate });
    }, /Template named "[^"]+" already exists\./, 'duplicate templates should not be allowed');
  });
});
enifed('ember-template-compiler/tests/system/bootstrap-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/tests/system/bootstrap-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/tests/system/bootstrap-test.js should pass ESLint\n\n');
  });
});
enifed('ember-template-compiler/tests/system/compile_options_test', ['exports', 'ember-template-compiler/index'], function (exports, _emberTemplateCompilerIndex) {
  'use strict';

  QUnit.module('ember-template-compiler: default compile options');

  QUnit.test('default options are a new copy', function () {
    notEqual(_emberTemplateCompilerIndex.compileOptions(), _emberTemplateCompilerIndex.compileOptions());
  });

  QUnit.test('has default AST plugins', function (assert) {
    assert.expect(_emberTemplateCompilerIndex.defaultPlugins.length);

    var plugins = _emberTemplateCompilerIndex.compileOptions().plugins.ast;

    for (var i = 0; i < _emberTemplateCompilerIndex.defaultPlugins.length; i++) {
      var plugin = _emberTemplateCompilerIndex.defaultPlugins[i];
      assert.ok(plugins.indexOf(plugin) > -1, 'includes ' + plugin);
    }
  });
});
enifed('ember-template-compiler/tests/system/compile_options_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-template-compiler/tests/system/compile_options_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-template-compiler/tests/system/compile_options_test.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/adapters/adapter.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/adapters/adapter.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/adapters/adapter.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/adapters/qunit.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/adapters/qunit.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/adapters/qunit.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/events.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/events.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/events.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/ext/application.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/ext/application.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/ext/application.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/ext/rsvp.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/ext/rsvp.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/ext/rsvp.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/helpers.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/helpers.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/helpers.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/helpers/and_then.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/helpers/and_then.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/helpers/and_then.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/helpers/click.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/helpers/click.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/helpers/click.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/helpers/current_path.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/helpers/current_path.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/helpers/current_path.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/helpers/current_route_name.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/helpers/current_route_name.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/helpers/current_route_name.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/helpers/current_url.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/helpers/current_url.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/helpers/current_url.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/helpers/fill_in.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/helpers/fill_in.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/helpers/fill_in.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/helpers/find.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/helpers/find.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/helpers/find.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/helpers/find_with_assert.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/helpers/find_with_assert.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/helpers/find_with_assert.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/helpers/key_event.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/helpers/key_event.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/helpers/key_event.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/helpers/pause_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/helpers/pause_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/helpers/pause_test.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/helpers/trigger_event.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/helpers/trigger_event.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/helpers/trigger_event.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/helpers/visit.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/helpers/visit.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/helpers/visit.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/helpers/wait.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/helpers/wait.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/helpers/wait.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/index.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/index.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/index.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/initializers.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/initializers.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/initializers.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/setup_for_testing.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/setup_for_testing.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/setup_for_testing.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/support.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/support.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/support.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/test.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/test/adapter.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/test/adapter.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/test/adapter.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/test/helpers.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/test/helpers.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/test/helpers.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/test/on_inject_helpers.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/test/on_inject_helpers.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/test/on_inject_helpers.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/test/pending_requests.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/test/pending_requests.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/test/pending_requests.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/test/promise.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/test/promise.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/test/promise.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/test/run.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/test/run.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/test/run.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/test/waiters.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/test/waiters.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/test/waiters.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/tests/acceptance_test', ['exports', 'ember-metal', 'ember-views', 'ember-testing/test', 'ember-testing/adapters/qunit', 'ember-testing/initializers', 'ember-application', 'ember-routing', 'ember-template-compiler', 'ember-runtime', 'ember-glimmer'], function (exports, _emberMetal, _emberViews, _emberTestingTest, _emberTestingAdaptersQunit, _emberTestingInitializers, _emberApplication, _emberRouting, _emberTemplateCompiler, _emberRuntime, _emberGlimmer) {
  'use strict';

  //ES6TODO: we need {{link-to}}  and {{outlet}} to exist here

  var App, find, click, fillIn, currentRoute, currentURL, visit, originalAdapter, andThen, indexHitCount;

  QUnit.module('ember-testing Acceptance', {
    setup: function () {
      _emberViews.jQuery('<style>#ember-testing-container { position: absolute; background: white; bottom: 0; right: 0; width: 640px; height: 384px; overflow: auto; z-index: 9999; border: 1px solid #ccc; } #ember-testing { zoom: 50%; }</style>').appendTo('head');
      _emberViews.jQuery('<div id="ember-testing-container"><div id="ember-testing"></div></div>').appendTo('body');

      originalAdapter = _emberTestingTest.default.adapter;

      _emberMetal.run(function () {
        indexHitCount = 0;

        App = _emberApplication.Application.create({
          rootElement: '#ember-testing'
        });

        App.Router.map(function () {
          this.route('posts');
          this.route('comments');

          this.route('abort_transition');

          this.route('redirect');
        });

        App.IndexRoute = _emberRouting.Route.extend({
          model: function () {
            indexHitCount += 1;
          }
        });

        App.PostsRoute = _emberRouting.Route.extend({
          renderTemplate: function () {
            currentRoute = 'posts';
            this._super.apply(this, arguments);
          }
        });

        _emberGlimmer.setTemplate('posts', _emberTemplateCompiler.compile('<div class="posts-view"><a class="dummy-link"></a><div id="comments-link">{{#link-to \'comments\'}}Comments{{/link-to}}</div></div>'));

        App.CommentsRoute = _emberRouting.Route.extend({
          renderTemplate: function () {
            currentRoute = 'comments';
            this._super.apply(this, arguments);
          }
        });

        _emberGlimmer.setTemplate('comments', _emberTemplateCompiler.compile('<div>{{input type="text"}}</div>'));

        App.AbortTransitionRoute = _emberRouting.Route.extend({
          beforeModel: function (transition) {
            transition.abort();
          }
        });

        App.RedirectRoute = _emberRouting.Route.extend({
          beforeModel: function () {
            this.transitionTo('comments');
          }
        });

        App.setupForTesting();
      });

      _emberTestingTest.default.registerAsyncHelper('slowHelper', function () {
        return new _emberRuntime.RSVP.Promise(function (resolve) {
          setTimeout(resolve, 10);
        });
      });

      App.injectTestHelpers();

      find = window.find;
      click = window.click;
      fillIn = window.fillIn;
      visit = window.visit;
      andThen = window.andThen;
      currentURL = window.currentURL;
    },

    teardown: function () {
      _emberTestingTest.default.unregisterHelper('slowHelper');
      _emberGlimmer.setTemplates({});
      _emberViews.jQuery('#ember-testing-container, #ember-testing').remove();
      _emberMetal.run(App, App.destroy);
      App = null;
      _emberTestingTest.default.adapter = originalAdapter;
      indexHitCount = 0;
    }
  });

  QUnit.test('helpers can be chained with then', function () {
    expect(6);

    currentRoute = 'index';

    visit('/posts').then(function () {
      equal(currentRoute, 'posts', 'Successfully visited posts route');
      equal(currentURL(), '/posts', 'posts URL is correct');
      return click('a:contains("Comments")');
    }).then(function () {
      equal(currentRoute, 'comments', 'visit chained with click');
      return fillIn('.ember-text-field', 'yeah');
    }).then(function () {
      equal(_emberViews.jQuery('.ember-text-field').val(), 'yeah', 'chained with fillIn');
      return fillIn('.ember-text-field', '#ember-testing-container', 'context working');
    }).then(function () {
      equal(_emberViews.jQuery('.ember-text-field').val(), 'context working', 'chained with fillIn');
      return click('.does-not-exist');
    }).then(null, function (e) {
      equal(e.message, 'Element .does-not-exist not found.', 'Non-existent click exception caught');
    });
  });

  // Keep this for backwards compatibility

  QUnit.test('helpers can be chained to each other', function () {
    expect(7);

    currentRoute = 'index';

    visit('/posts').click('a:first', '#comments-link').fillIn('.ember-text-field', 'hello').then(function () {
      equal(currentRoute, 'comments', 'Successfully visited comments route');
      equal(currentURL(), '/comments', 'Comments URL is correct');
      equal(_emberViews.jQuery('.ember-text-field').val(), 'hello', 'Fillin successfully works');
      find('.ember-text-field').one('keypress', function (e) {
        equal(e.keyCode, 13, 'keyevent chained with correct keyCode.');
        equal(e.which, 13, 'keyevent chained with correct which.');
      });
    }).keyEvent('.ember-text-field', 'keypress', 13).visit('/posts').then(function () {
      equal(currentRoute, 'posts', 'Thens can also be chained to helpers');
      equal(currentURL(), '/posts', 'URL is set correct on chained helpers');
    });
  });

  QUnit.test('helpers don\'t need to be chained', function () {
    expect(5);

    currentRoute = 'index';

    visit('/posts');

    click('a:first', '#comments-link');

    fillIn('.ember-text-field', 'hello');

    andThen(function () {
      equal(currentRoute, 'comments', 'Successfully visited comments route');
      equal(currentURL(), '/comments', 'Comments URL is correct');
      equal(find('.ember-text-field').val(), 'hello', 'Fillin successfully works');
    });

    visit('/posts');

    andThen(function () {
      equal(currentRoute, 'posts');
      equal(currentURL(), '/posts');
    });
  });

  QUnit.test('Nested async helpers', function () {
    expect(5);

    currentRoute = 'index';

    visit('/posts');

    andThen(function () {
      click('a:first', '#comments-link');

      fillIn('.ember-text-field', 'hello');
    });

    andThen(function () {
      equal(currentRoute, 'comments', 'Successfully visited comments route');
      equal(currentURL(), '/comments', 'Comments URL is correct');
      equal(find('.ember-text-field').val(), 'hello', 'Fillin successfully works');
    });

    visit('/posts');

    andThen(function () {
      equal(currentRoute, 'posts');
      equal(currentURL(), '/posts');
    });
  });

  QUnit.test('Multiple nested async helpers', function () {
    expect(3);

    visit('/posts');

    andThen(function () {
      click('a:first', '#comments-link');

      fillIn('.ember-text-field', 'hello');
      fillIn('.ember-text-field', 'goodbye');
    });

    andThen(function () {
      equal(find('.ember-text-field').val(), 'goodbye', 'Fillin successfully works');
      equal(currentRoute, 'comments', 'Successfully visited comments route');
      equal(currentURL(), '/comments', 'Comments URL is correct');
    });
  });

  QUnit.test('Helpers nested in thens', function () {
    expect(5);

    currentRoute = 'index';

    visit('/posts').then(function () {
      click('a:first', '#comments-link');
    });

    andThen(function () {
      fillIn('.ember-text-field', 'hello');
    });

    andThen(function () {
      equal(currentRoute, 'comments', 'Successfully visited comments route');
      equal(currentURL(), '/comments', 'Comments URL is correct');
      equal(find('.ember-text-field').val(), 'hello', 'Fillin successfully works');
    });

    visit('/posts');

    andThen(function () {
      equal(currentRoute, 'posts');
      equal(currentURL(), '/posts', 'Posts URL is correct');
    });
  });

  QUnit.test('Aborted transitions are not logged via Ember.Test.adapter#exception', function () {
    expect(0);

    _emberTestingTest.default.adapter = _emberTestingAdaptersQunit.default.create({
      exception: function (error) {
        ok(false, 'aborted transitions are not logged');
      }
    });

    visit('/abort_transition');
  });

  QUnit.test('Unhandled exceptions are logged via Ember.Test.adapter#exception', function () {
    expect(2);

    var asyncHandled;
    _emberTestingTest.default.adapter = _emberTestingAdaptersQunit.default.create({
      exception: function (error) {
        equal(error.message, 'Element .does-not-exist not found.', 'Exception successfully caught and passed to Ember.Test.adapter.exception');
        asyncHandled['catch'](function () {}); // handle the rejection so it doesn't leak later.
      }
    });

    visit('/posts');

    click('.invalid-element').then(null, function (error) {
      equal(error.message, 'Element .invalid-element not found.', 'Exception successfully handled in the rejection handler');
    });

    asyncHandled = click('.does-not-exist');
  });

  QUnit.test('Unhandled exceptions in `andThen` are logged via Ember.Test.adapter#exception', function () {
    expect(1);

    _emberTestingTest.default.adapter = _emberTestingAdaptersQunit.default.create({
      exception: function (error) {
        equal(error.message, 'Catch me', 'Exception successfully caught and passed to Ember.Test.adapter.exception');
      }
    });

    visit('/posts');

    andThen(function () {
      throw new Error('Catch me');
    });
  });

  QUnit.test('should not start routing on the root URL when visiting another', function () {
    expect(4);

    visit('/posts');

    andThen(function () {
      ok(find('#comments-link'), 'found comments-link');
      equal(currentRoute, 'posts', 'Successfully visited posts route');
      equal(currentURL(), '/posts', 'Posts URL is correct');
      equal(indexHitCount, 0, 'should not hit index route when visiting another route');
    });
  });

  QUnit.test('only enters the index route once when visiting /', function () {
    expect(1);

    visit('/');

    andThen(function () {
      equal(indexHitCount, 1, 'should hit index once when visiting /');
    });
  });

  QUnit.test('test must not finish while asyncHelpers are pending', function () {
    expect(2);

    var async = 0;
    var innerRan = false;

    _emberTestingTest.default.adapter = _emberTestingAdaptersQunit.default.extend({
      asyncStart: function () {
        async++;
        this._super();
      },
      asyncEnd: function () {
        async--;
        this._super();
      }
    }).create();

    App.testHelpers.slowHelper();
    andThen(function () {
      innerRan = true;
    });

    equal(innerRan, false, 'should not have run yet');
    ok(async > 0, 'should have told the adapter to pause');

    if (async === 0) {
      // If we failed the test, prevent zalgo from escaping and breaking
      // our other tests.
      _emberTestingTest.default.adapter.asyncStart();
      _emberTestingTest.default.resolve().then(function () {
        _emberTestingTest.default.adapter.asyncEnd();
      });
    }
  });

  QUnit.test('visiting a URL that causes another transition should yield the correct URL', function () {
    expect(1);

    visit('/redirect');

    andThen(function () {
      equal(currentURL(), '/comments', 'Redirected to Comments URL');
    });
  });

  QUnit.test('visiting a URL and then visiting a second URL with a transition should yield the correct URL', function () {
    expect(2);

    visit('/posts');

    andThen(function () {
      equal(currentURL(), '/posts', 'First visited URL is correct');
    });

    visit('/redirect');

    andThen(function () {
      equal(currentURL(), '/comments', 'Redirected to Comments URL');
    });
  });

  QUnit.module('ember-testing Acceptance – teardown');

  QUnit.test('that the setup/teardown happens correct', function () {
    expect(2);

    _emberViews.jQuery('<style>#ember-testing-container { position: absolute; background: white; bottom: 0; right: 0; width: 640px; height: 384px; overflow: auto; z-index: 9999; border: 1px solid #ccc; } #ember-testing { zoom: 50%; }</style>').appendTo('head');
    _emberViews.jQuery('<div id="ember-testing-container"><div id="ember-testing"></div></div>').appendTo('body');

    _emberMetal.run(function () {
      indexHitCount = 0;
      App = _emberApplication.Application.create({
        rootElement: '#ember-testing'
      });
    });
    App.injectTestHelpers();

    _emberViews.jQuery('#ember-testing-container, #ember-testing').remove();
    ok(typeof _emberTestingTest.default.Promise.prototype.click === 'function');
    _emberMetal.run(App, App.destroy);
    equal(_emberTestingTest.default.Promise.prototype.click, undefined);
    App = null;
    _emberTestingTest.default.adapter = originalAdapter;
    indexHitCount = 0;
  });
});
// ensure the initializer is setup
enifed('ember-testing/tests/acceptance_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/tests/acceptance_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/tests/acceptance_test.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/tests/adapters/adapter_test', ['exports', 'ember-metal', 'ember-testing/adapters/adapter'], function (exports, _emberMetal, _emberTestingAdaptersAdapter) {
  'use strict';

  var adapter;

  QUnit.module('ember-testing Adapter', {
    setup: function () {
      adapter = new _emberTestingAdaptersAdapter.default();
    },
    teardown: function () {
      _emberMetal.run(adapter, adapter.destroy);
    }
  });

  // Can't test these this way anymore since we have nothing to compare to
  // test("asyncStart is a noop", function() {
  //   equal(adapter.asyncStart, K);
  // });

  // test("asyncEnd is a noop", function() {
  //   equal(adapter.asyncEnd, K);
  // });

  QUnit.test('exception throws', function () {
    var error = 'Hai';
    var thrown;

    try {
      adapter.exception(error);
    } catch (e) {
      thrown = e;
    }
    equal(thrown, error);
  });
});
enifed('ember-testing/tests/adapters/adapter_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/tests/adapters/adapter_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/tests/adapters/adapter_test.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/tests/adapters/qunit_test', ['exports', 'ember-metal', 'ember-testing/adapters/qunit'], function (exports, _emberMetal, _emberTestingAdaptersQunit) {
  'use strict';

  var adapter;

  QUnit.module('ember-testing QUnitAdapter', {
    setup: function () {
      adapter = new _emberTestingAdaptersQunit.default();
    },
    teardown: function () {
      _emberMetal.run(adapter, adapter.destroy);
    }
  });

  QUnit.test('asyncStart calls stop', function () {
    var originalStop = QUnit.stop;
    try {
      QUnit.stop = function () {
        ok(true, 'stop called');
      };
      adapter.asyncStart();
    } finally {
      QUnit.stop = originalStop;
    }
  });

  QUnit.test('asyncEnd calls start', function () {
    var originalStart = QUnit.start;
    try {
      QUnit.start = function () {
        ok(true, 'start called');
      };
      adapter.asyncEnd();
    } finally {
      QUnit.start = originalStart;
    }
  });

  QUnit.test('exception causes a failing assertion', function () {
    var error = { err: 'hai' };
    var originalOk = window.ok;
    try {
      window.ok = function (val, msg) {
        originalOk(!val, 'ok is called with false');
        originalOk(msg, '{err: "hai"}');
      };
      adapter.exception(error);
    } finally {
      window.ok = originalOk;
    }
  });
});
enifed('ember-testing/tests/adapters/qunit_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/tests/adapters/qunit_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/tests/adapters/qunit_test.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/tests/adapters_test', ['exports', 'ember-metal', 'ember-testing/test', 'ember-testing/adapters/adapter', 'ember-testing/adapters/qunit', 'ember-application'], function (exports, _emberMetal, _emberTestingTest, _emberTestingAdaptersAdapter, _emberTestingAdaptersQunit, _emberApplication) {
  'use strict';

  var App, originalAdapter, originalQUnit;

  QUnit.module('ember-testing Adapters', {
    setup: function () {
      originalAdapter = _emberTestingTest.default.adapter;
      originalQUnit = window.QUnit;
    },
    teardown: function () {
      _emberMetal.run(App, App.destroy);
      App.removeTestHelpers();
      App = null;

      _emberTestingTest.default.adapter = originalAdapter;
      window.QUnit = originalQUnit;
    }
  });

  QUnit.test('Setting a test adapter manually', function () {
    expect(1);
    var CustomAdapter;

    CustomAdapter = _emberTestingAdaptersAdapter.default.extend({
      asyncStart: function () {
        ok(true, 'Correct adapter was used');
      }
    });

    _emberMetal.run(function () {
      App = _emberApplication.Application.create();
      _emberTestingTest.default.adapter = CustomAdapter.create();
      App.setupForTesting();
    });

    _emberTestingTest.default.adapter.asyncStart();
  });

  QUnit.test('QUnitAdapter is used by default (if QUnit is available)', function () {
    expect(1);

    _emberTestingTest.default.adapter = null;

    _emberMetal.run(function () {
      App = _emberApplication.Application.create();
      App.setupForTesting();
    });

    ok(_emberTestingTest.default.adapter instanceof _emberTestingAdaptersQunit.default);
  });

  QUnit.test('Adapter is used by default (if QUnit is not available)', function () {
    expect(2);

    delete window.QUnit;

    _emberTestingTest.default.adapter = null;

    _emberMetal.run(function () {
      App = _emberApplication.Application.create();
      App.setupForTesting();
    });

    ok(_emberTestingTest.default.adapter instanceof _emberTestingAdaptersAdapter.default);
    ok(!(_emberTestingTest.default.adapter instanceof _emberTestingAdaptersQunit.default));
  });
});
enifed('ember-testing/tests/adapters_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/tests/adapters_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/tests/adapters_test.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/tests/ext/rsvp_test', ['exports', 'ember-testing/ext/rsvp', 'ember-testing/test/adapter', 'ember-metal'], function (exports, _emberTestingExtRsvp, _emberTestingTestAdapter, _emberMetal) {
  'use strict';

  var originalTestAdapter = _emberTestingTestAdapter.getAdapter();
  var originalTestingFlag = _emberMetal.isTesting();

  var asyncStarted = 0;
  var asyncEnded = 0;

  QUnit.module('ember-testing RSVP', {
    setup: function () {
      _emberMetal.setTesting(true);
      _emberTestingTestAdapter.setAdapter({
        asyncStart: function () {
          asyncStarted++;
          QUnit.stop();
        },
        asyncEnd: function () {
          asyncEnded++;
          QUnit.start();
        }
      });
    },
    teardown: function () {
      asyncStarted = 0;
      asyncEnded = 0;
      _emberTestingTestAdapter.setAdapter(originalTestAdapter);
      _emberMetal.setTesting(originalTestingFlag);
    }
  });

  QUnit.test('given `Ember.testing = true`, correctly informs the test suite about async steps', function () {
    expect(19);

    ok(!_emberMetal.run.currentRunLoop, 'expect no run-loop');

    _emberMetal.setTesting(true);

    equal(asyncStarted, 0);
    equal(asyncEnded, 0);

    var user = _emberTestingExtRsvp.default.Promise.resolve({
      name: 'tomster'
    });

    equal(asyncStarted, 0);
    equal(asyncEnded, 0);

    user.then(function (user) {
      equal(asyncStarted, 1);
      equal(asyncEnded, 1);

      equal(user.name, 'tomster');

      return _emberTestingExtRsvp.default.Promise.resolve(1).then(function () {
        equal(asyncStarted, 1);
        equal(asyncEnded, 1);
      });
    }).then(function () {
      equal(asyncStarted, 1);
      equal(asyncEnded, 1);

      return new _emberTestingExtRsvp.default.Promise(function (resolve) {
        QUnit.stop(); // raw async, we must inform the test framework manually
        setTimeout(function () {
          QUnit.start(); // raw async, we must inform the test framework manually

          equal(asyncStarted, 1);
          equal(asyncEnded, 1);

          resolve({
            name: 'async tomster'
          });

          equal(asyncStarted, 2);
          equal(asyncEnded, 1);
        }, 0);
      });
    }).then(function (user) {
      equal(user.name, 'async tomster');
      equal(asyncStarted, 2);
      equal(asyncEnded, 2);
    });
  });
});
enifed('ember-testing/tests/ext/rsvp_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/tests/ext/rsvp_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/tests/ext/rsvp_test.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/tests/helper_registration_test', ['exports', 'ember-metal', 'ember-testing/test', 'ember-application'], function (exports, _emberMetal, _emberTestingTest, _emberApplication) {
  'use strict';

  var App, appBooted, helperContainer;

  function registerHelper() {
    _emberTestingTest.default.registerHelper('boot', function (app) {
      _emberMetal.run(app, app.advanceReadiness);
      appBooted = true;
      return app.testHelpers.wait();
    });
  }

  function unregisterHelper() {
    _emberTestingTest.default.unregisterHelper('boot');
  }

  var originalAdapter = _emberTestingTest.default.adapter;

  function setupApp() {
    appBooted = false;
    helperContainer = {};

    _emberMetal.run(function () {
      App = _emberApplication.Application.create();
      App.setupForTesting();
      App.injectTestHelpers(helperContainer);
    });
  }

  function destroyApp() {
    if (App) {
      _emberMetal.run(App, 'destroy');
      App = null;
    }
  }

  QUnit.module('Test - registerHelper/unregisterHelper', {
    teardown: function () {
      _emberTestingTest.default.adapter = originalAdapter;
      destroyApp();
    }
  });

  QUnit.test('Helper gets registered', function () {
    expect(2);

    registerHelper();
    setupApp();

    ok(App.testHelpers.boot);
    ok(helperContainer.boot);
  });

  QUnit.test('Helper is ran when called', function (assert) {
    var done = assert.async();
    assert.expect(1);

    registerHelper();
    setupApp();

    App.testHelpers.boot().then(function () {
      assert.ok(appBooted);
    }).finally(done);
  });

  QUnit.test('Helper can be unregistered', function () {
    expect(4);

    registerHelper();
    setupApp();

    ok(App.testHelpers.boot);
    ok(helperContainer.boot);

    unregisterHelper();

    setupApp();

    ok(!App.testHelpers.boot, 'once unregistered the helper is not added to App.testHelpers');
    ok(!helperContainer.boot, 'once unregistered the helper is not added to the helperContainer');
  });
});
enifed('ember-testing/tests/helper_registration_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/tests/helper_registration_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/tests/helper_registration_test.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/tests/helpers_test', ['exports', 'ember-routing', 'ember-runtime', 'ember-metal', 'ember-views', 'ember-glimmer', 'ember-testing/test', 'ember-testing/helpers', 'ember-testing/initializers', 'ember-testing/setup_for_testing', 'ember-application', 'ember-template-compiler', 'ember-testing/test/pending_requests', 'ember-testing/test/adapter', 'ember-testing/test/waiters'], function (exports, _emberRouting, _emberRuntime, _emberMetal, _emberViews, _emberGlimmer, _emberTestingTest, _emberTestingHelpers, _emberTestingInitializers, _emberTestingSetup_for_testing, _emberApplication, _emberTemplateCompiler, _emberTestingTestPending_requests, _emberTestingTestAdapter, _emberTestingTestWaiters) {
  'use strict';

  var App;
  var originalAdapter = _emberTestingTestAdapter.getAdapter();

  function cleanup() {
    // Teardown setupForTesting

    _emberTestingTestAdapter.setAdapter(originalAdapter);
    _emberMetal.run(function () {
      _emberViews.jQuery(document).off('ajaxSend');
      _emberViews.jQuery(document).off('ajaxComplete');
    });
    _emberTestingTestPending_requests.clearPendingRequests();
    // Test.waiters = null;

    // Other cleanup

    if (App) {
      _emberMetal.run(App, App.destroy);
      App.removeTestHelpers();
      App = null;
    }

    _emberGlimmer.setTemplates({});
  }

  function assertHelpers(application, helperContainer, expected) {
    if (!helperContainer) {
      helperContainer = window;
    }
    if (expected === undefined) {
      expected = true;
    }

    function checkHelperPresent(helper, expected) {
      var presentInHelperContainer = !!helperContainer[helper];
      var presentInTestHelpers = !!application.testHelpers[helper];

      ok(presentInHelperContainer === expected, 'Expected \'' + helper + '\' to be present in the helper container (defaults to window).');
      ok(presentInTestHelpers === expected, 'Expected \'' + helper + '\' to be present in App.testHelpers.');
    }

    checkHelperPresent('visit', expected);
    checkHelperPresent('click', expected);
    checkHelperPresent('keyEvent', expected);
    checkHelperPresent('fillIn', expected);
    checkHelperPresent('wait', expected);
    checkHelperPresent('triggerEvent', expected);
  }

  function assertNoHelpers(application, helperContainer) {
    assertHelpers(application, helperContainer, false);
  }

  function currentRouteName(app) {
    return app.testHelpers.currentRouteName();
  }

  function currentPath(app) {
    return app.testHelpers.currentPath();
  }

  function currentURL(app) {
    return app.testHelpers.currentURL();
  }

  function setupApp() {
    _emberMetal.run(function () {
      App = _emberApplication.Application.create();
      App.setupForTesting();

      App.injectTestHelpers();
    });
  }

  QUnit.module('ember-testing: Helper setup', {
    setup: function () {
      cleanup();
    },
    teardown: function () {
      cleanup();
    }
  });

  function registerHelper() {
    _emberTestingTest.default.registerHelper('LeakyMcLeakLeak', function (app) {});
  }

  QUnit.test('Ember.Application#injectTestHelpers/#removeTestHelpers', function () {
    App = _emberMetal.run(_emberApplication.Application, _emberApplication.Application.create);
    assertNoHelpers(App);

    registerHelper();

    App.injectTestHelpers();
    assertHelpers(App);
    ok(_emberTestingTest.default.Promise.prototype.LeakyMcLeakLeak, 'helper in question SHOULD be present');

    App.removeTestHelpers();
    assertNoHelpers(App);

    equal(_emberTestingTest.default.Promise.prototype.LeakyMcLeakLeak, undefined, 'should NOT leak test promise extensions');
  });

  QUnit.test('Ember.Application#setupForTesting', function () {
    _emberMetal.run(function () {
      App = _emberApplication.Application.create();
      App.setupForTesting();
    });

    equal(App.__container__.lookup('router:main').location, 'none');
  });

  QUnit.test('Ember.Application.setupForTesting sets the application to `testing`.', function () {
    _emberMetal.run(function () {
      App = _emberApplication.Application.create();
      App.setupForTesting();
    });

    equal(App.testing, true, 'Application instance is set to testing.');
  });

  QUnit.test('Ember.Application.setupForTesting leaves the system in a deferred state.', function () {
    _emberMetal.run(function () {
      App = _emberApplication.Application.create();
      App.setupForTesting();
    });

    equal(App._readinessDeferrals, 1, 'App is in deferred state after setupForTesting.');
  });

  QUnit.test('App.reset() after Application.setupForTesting leaves the system in a deferred state.', function () {
    _emberMetal.run(function () {
      App = _emberApplication.Application.create();
      App.setupForTesting();
    });

    equal(App._readinessDeferrals, 1, 'App is in deferred state after setupForTesting.');

    App.reset();
    equal(App._readinessDeferrals, 1, 'App is in deferred state after setupForTesting.');
  });

  QUnit.test('Ember.Application#setupForTesting attaches ajax listeners', function () {
    var documentEvents;

    documentEvents = _emberViews.jQuery._data(document, 'events');

    if (!documentEvents) {
      documentEvents = {};
    }

    ok(documentEvents['ajaxSend'] === undefined, 'there are no ajaxSend listers setup prior to calling injectTestHelpers');
    ok(documentEvents['ajaxComplete'] === undefined, 'there are no ajaxComplete listers setup prior to calling injectTestHelpers');

    _emberMetal.run(function () {
      _emberTestingSetup_for_testing.default();
    });

    documentEvents = _emberViews.jQuery._data(document, 'events');

    equal(documentEvents['ajaxSend'].length, 1, 'calling injectTestHelpers registers an ajaxSend handler');
    equal(documentEvents['ajaxComplete'].length, 1, 'calling injectTestHelpers registers an ajaxComplete handler');
  });

  QUnit.test('Ember.Application#setupForTesting attaches ajax listeners only once', function () {
    var documentEvents;

    documentEvents = _emberViews.jQuery._data(document, 'events');

    if (!documentEvents) {
      documentEvents = {};
    }

    ok(documentEvents['ajaxSend'] === undefined, 'there are no ajaxSend listeners setup prior to calling injectTestHelpers');
    ok(documentEvents['ajaxComplete'] === undefined, 'there are no ajaxComplete listeners setup prior to calling injectTestHelpers');

    _emberMetal.run(function () {
      _emberTestingSetup_for_testing.default();
    });
    _emberMetal.run(function () {
      _emberTestingSetup_for_testing.default();
    });

    documentEvents = _emberViews.jQuery._data(document, 'events');

    equal(documentEvents['ajaxSend'].length, 1, 'calling injectTestHelpers registers an ajaxSend handler');
    equal(documentEvents['ajaxComplete'].length, 1, 'calling injectTestHelpers registers an ajaxComplete handler');
  });

  QUnit.test('Ember.Application#injectTestHelpers calls callbacks registered with onInjectHelpers', function () {
    var injected = 0;

    _emberTestingTest.default.onInjectHelpers(function () {
      injected++;
    });

    _emberMetal.run(function () {
      App = _emberApplication.Application.create();
      App.setupForTesting();
    });

    equal(injected, 0, 'onInjectHelpers are not called before injectTestHelpers');

    App.injectTestHelpers();

    equal(injected, 1, 'onInjectHelpers are called after injectTestHelpers');
  });

  QUnit.test('Ember.Application#injectTestHelpers adds helpers to provided object.', function () {
    var helpers = {};

    _emberMetal.run(function () {
      App = _emberApplication.Application.create();
      App.setupForTesting();
    });

    App.injectTestHelpers(helpers);
    assertHelpers(App, helpers);

    App.removeTestHelpers();
    assertNoHelpers(App, helpers);
  });

  QUnit.test('Ember.Application#removeTestHelpers resets the helperContainer\'s original values', function () {
    var helpers = { visit: 'snazzleflabber' };

    _emberMetal.run(function () {
      App = _emberApplication.Application.create();
      App.setupForTesting();
    });

    App.injectTestHelpers(helpers);

    ok(helpers.visit !== 'snazzleflabber', 'helper added to container');
    App.removeTestHelpers();

    ok(helpers.visit === 'snazzleflabber', 'original value added back to container');
  });

  QUnit.module('ember-testing: Helper methods', {
    setup: function () {
      setupApp();
    },
    teardown: function () {
      cleanup();
    }
  });

  QUnit.test('`wait` respects registerWaiters', function (assert) {
    assert.expect(3);

    var done = assert.async();

    var counter = 0;
    function waiter() {
      return ++counter > 2;
    }

    var other = 0;
    function otherWaiter() {
      return ++other > 2;
    }

    _emberMetal.run(App, App.advanceReadiness);
    _emberTestingTestWaiters.registerWaiter(waiter);
    _emberTestingTestWaiters.registerWaiter(otherWaiter);

    App.testHelpers.wait().then(function () {
      equal(waiter(), true, 'should not resolve until our waiter is ready');
      _emberTestingTestWaiters.unregisterWaiter(waiter);
      counter = 0;
      return App.testHelpers.wait();
    }).then(function () {
      equal(counter, 0, 'unregistered waiter was not checked');
      equal(otherWaiter(), true, 'other waiter is still registered');
    }).finally(function () {
      _emberTestingTestWaiters.unregisterWaiter(otherWaiter);
      done();
    });
  });

  QUnit.test('`visit` advances readiness.', function () {
    expect(2);

    equal(App._readinessDeferrals, 1, 'App is in deferred state after setupForTesting.');

    return App.testHelpers.visit('/').then(function () {
      equal(App._readinessDeferrals, 0, 'App\'s readiness was advanced by visit.');
    });
  });

  QUnit.test('`wait` helper can be passed a resolution value', function () {
    expect(4);

    var promise, wait;

    promise = new _emberRuntime.RSVP.Promise(function (resolve) {
      _emberMetal.run(null, resolve, 'promise');
    });

    _emberMetal.run(App, App.advanceReadiness);

    wait = App.testHelpers.wait;

    return wait('text').then(function (val) {
      equal(val, 'text', 'can resolve to a string');
      return wait(1);
    }).then(function (val) {
      equal(val, 1, 'can resolve to an integer');
      return wait({ age: 10 });
    }).then(function (val) {
      deepEqual(val, { age: 10 }, 'can resolve to an object');
      return wait(promise);
    }).then(function (val) {
      equal(val, 'promise', 'can resolve to a promise resolution value');
    });
  });

  QUnit.test('`click` triggers appropriate events in order', function () {
    expect(5);

    var click, wait, events;

    App.IndexWrapperComponent = _emberGlimmer.Component.extend({
      classNames: 'index-wrapper',

      didInsertElement: function () {
        this.$().on('mousedown focusin mouseup click', function (e) {
          events.push(e.type);
        });
      }
    });

    App.XCheckboxComponent = _emberGlimmer.Component.extend({
      tagName: 'input',
      attributeBindings: ['type'],
      type: 'checkbox',
      click: function () {
        events.push('click:' + this.get('checked'));
      },
      change: function () {
        events.push('change:' + this.get('checked'));
      }
    });

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#index-wrapper}}{{input type="text"}} {{x-checkbox type="checkbox"}} {{textarea}} <div contenteditable="true"> </div>{{/index-wrapper}}'));

    _emberMetal.run(App, App.advanceReadiness);

    click = App.testHelpers.click;
    wait = App.testHelpers.wait;

    return wait().then(function () {
      events = [];
      return click('.index-wrapper');
    }).then(function () {
      deepEqual(events, ['mousedown', 'mouseup', 'click'], 'fires events in order');
    }).then(function () {
      events = [];
      return click('.index-wrapper input[type=text]');
    }).then(function () {
      deepEqual(events, ['mousedown', 'focusin', 'mouseup', 'click'], 'fires focus events on inputs');
    }).then(function () {
      events = [];
      return click('.index-wrapper textarea');
    }).then(function () {
      deepEqual(events, ['mousedown', 'focusin', 'mouseup', 'click'], 'fires focus events on textareas');
    }).then(function () {
      events = [];
      return click('.index-wrapper div');
    }).then(function () {
      deepEqual(events, ['mousedown', 'focusin', 'mouseup', 'click'], 'fires focus events on contenteditable');
    }).then(function () {
      events = [];
      return click('.index-wrapper input[type=checkbox]');
    }).then(function () {
      // i.e. mousedown, mouseup, change:true, click, click:true
      // Firefox differs so we can't assert the exact ordering here.
      // See https://bugzilla.mozilla.org/show_bug.cgi?id=843554.
      equal(events.length, 5, 'fires click and change on checkboxes');
    });
  });

  QUnit.test('`click` triggers native events with simulated X/Y coordinates', function () {
    expect(15);

    var click, wait, events;

    App.IndexWrapperComponent = _emberGlimmer.Component.extend({
      classNames: 'index-wrapper',

      didInsertElement: function () {
        var pushEvent = function (e) {
          return events.push(e);
        };
        this.element.addEventListener('mousedown', pushEvent);
        this.element.addEventListener('mouseup', pushEvent);
        this.element.addEventListener('click', pushEvent);
      }
    });

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#index-wrapper}}some text{{/index-wrapper}}'));

    _emberMetal.run(App, App.advanceReadiness);

    click = App.testHelpers.click;
    wait = App.testHelpers.wait;

    return wait().then(function () {
      events = [];
      return click('.index-wrapper');
    }).then(function () {
      events.forEach(function (e) {
        ok(e instanceof window.Event, 'The event is an instance of MouseEvent');
        ok(typeof e.screenX === 'number' && e.screenX > 0, 'screenX is correct');
        ok(typeof e.screenY === 'number' && e.screenY > 0, 'screenY is correct');
        ok(typeof e.clientX === 'number' && e.clientX > 0, 'clientX is correct');
        ok(typeof e.clientY === 'number' && e.clientY > 0, 'clientY is correct');
      });
    });
  });

  QUnit.test('`triggerEvent` with mouseenter triggers native events with simulated X/Y coordinates', function () {
    expect(5);

    var triggerEvent, wait, evt;

    App.IndexWrapperComponent = _emberGlimmer.Component.extend({
      classNames: 'index-wrapper',

      didInsertElement: function () {
        this.element.addEventListener('mouseenter', function (e) {
          return evt = e;
        });
      }
    });

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#index-wrapper}}some text{{/index-wrapper}}'));

    _emberMetal.run(App, App.advanceReadiness);

    triggerEvent = App.testHelpers.triggerEvent;
    wait = App.testHelpers.wait;

    return wait().then(function () {
      return triggerEvent('.index-wrapper', 'mouseenter');
    }).then(function () {
      ok(evt instanceof window.Event, 'The event is an instance of MouseEvent');
      ok(typeof evt.screenX === 'number' && evt.screenX > 0, 'screenX is correct');
      ok(typeof evt.screenY === 'number' && evt.screenY > 0, 'screenY is correct');
      ok(typeof evt.clientX === 'number' && evt.clientX > 0, 'clientX is correct');
      ok(typeof evt.clientY === 'number' && evt.clientY > 0, 'clientY is correct');
    });
  });

  QUnit.test('`wait` waits for outstanding timers', function () {
    expect(1);

    var wait_done = false;

    _emberMetal.run(App, App.advanceReadiness);

    _emberMetal.run.later(this, function () {
      wait_done = true;
    }, 500);

    return App.testHelpers.wait().then(function () {
      equal(wait_done, true, 'should wait for the timer to be fired.');
    });
  });

  QUnit.test('`wait` respects registerWaiters with optional context', function () {
    expect(3);

    var obj = {
      counter: 0,
      ready: function () {
        return ++this.counter > 2;
      }
    };

    var other = 0;
    function otherWaiter() {
      return ++other > 2;
    }

    _emberMetal.run(App, App.advanceReadiness);
    _emberTestingTestWaiters.registerWaiter(obj, obj.ready);
    _emberTestingTestWaiters.registerWaiter(otherWaiter);

    return App.testHelpers.wait().then(function () {
      equal(obj.ready(), true, 'should not resolve until our waiter is ready');
      _emberTestingTestWaiters.unregisterWaiter(obj, obj.ready);
      obj.counter = 0;
      return App.testHelpers.wait();
    }).then(function () {
      equal(obj.counter, 0, 'the unregistered waiter should still be at 0');
      equal(otherWaiter(), true, 'other waiter should still be registered');
    }).finally(function () {
      _emberTestingTestWaiters.unregisterWaiter(otherWaiter);
    });
  });

  QUnit.test('`wait` does not error if routing has not begun', function () {
    expect(1);

    return App.testHelpers.wait().then(function () {
      ok(true, 'should not error without `visit`');
    });
  });

  QUnit.test('`triggerEvent accepts an optional options hash without context', function () {
    expect(3);

    var triggerEvent, wait, event;

    App.IndexWrapperComponent = _emberGlimmer.Component.extend({
      didInsertElement: function () {
        this.$('.input').on('keydown change', function (e) {
          event = e;
        });
      }
    });

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{index-wrapper}}'));
    _emberGlimmer.setTemplate('components/index-wrapper', _emberTemplateCompiler.compile('{{input type="text" id="scope" class="input"}}'));

    _emberMetal.run(App, App.advanceReadiness);

    triggerEvent = App.testHelpers.triggerEvent;
    wait = App.testHelpers.wait;

    return wait().then(function () {
      return triggerEvent('.input', 'keydown', { keyCode: 13 });
    }).then(function () {
      equal(event.keyCode, 13, 'options were passed');
      equal(event.type, 'keydown', 'correct event was triggered');
      equal(event.target.getAttribute('id'), 'scope', 'triggered on the correct element');
    });
  });

  QUnit.test('`triggerEvent can limit searching for a selector to a scope', function () {
    expect(2);

    var triggerEvent, wait, event;

    App.IndexWrapperComponent = _emberGlimmer.Component.extend({

      didInsertElement: function () {
        this.$('.input').on('blur change', function (e) {
          event = e;
        });
      }
    });

    _emberGlimmer.setTemplate('components/index-wrapper', _emberTemplateCompiler.compile('{{input type="text" id="outside-scope" class="input"}}<div id="limited">{{input type="text" id="inside-scope" class="input"}}</div>'));
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{index-wrapper}}'));

    _emberMetal.run(App, App.advanceReadiness);

    triggerEvent = App.testHelpers.triggerEvent;
    wait = App.testHelpers.wait;

    return wait().then(function () {
      return triggerEvent('.input', '#limited', 'blur');
    }).then(function () {
      equal(event.type, 'blur', 'correct event was triggered');
      equal(event.target.getAttribute('id'), 'inside-scope', 'triggered on the correct element');
    });
  });

  QUnit.test('`triggerEvent` can be used to trigger arbitrary events', function () {
    expect(2);

    var triggerEvent, wait, event;

    App.IndexWrapperComponent = _emberGlimmer.Component.extend({
      didInsertElement: function () {
        this.$('#foo').on('blur change', function (e) {
          event = e;
        });
      }
    });

    _emberGlimmer.setTemplate('components/index-wrapper', _emberTemplateCompiler.compile('{{input type="text" id="foo"}}'));
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{index-wrapper}}'));

    _emberMetal.run(App, App.advanceReadiness);

    triggerEvent = App.testHelpers.triggerEvent;
    wait = App.testHelpers.wait;

    return wait().then(function () {
      return triggerEvent('#foo', 'blur');
    }).then(function () {
      equal(event.type, 'blur', 'correct event was triggered');
      equal(event.target.getAttribute('id'), 'foo', 'triggered on the correct element');
    });
  });

  QUnit.test('`fillIn` takes context into consideration', function () {
    expect(2);
    var fillIn, find, visit, andThen;

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<div id="parent">{{input type="text" id="first" class="current"}}</div>{{input type="text" id="second" class="current"}}'));

    _emberMetal.run(App, App.advanceReadiness);

    fillIn = App.testHelpers.fillIn;
    find = App.testHelpers.find;
    visit = App.testHelpers.visit;
    andThen = App.testHelpers.andThen;

    visit('/');
    fillIn('.current', '#parent', 'current value');

    return andThen(function () {
      equal(find('#first').val(), 'current value');
      equal(find('#second').val(), '');
    });
  });

  QUnit.test('`fillIn` focuses on the element', function () {
    expect(2);
    var fillIn, find, visit, andThen, wait;

    App.ApplicationRoute = _emberRouting.Route.extend({
      actions: {
        wasFocused: function () {
          ok(true, 'focusIn event was triggered');
        }
      }
    });

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<div id="parent">{{input type="text" id="first" focus-in="wasFocused"}}</div>'));

    _emberMetal.run(App, App.advanceReadiness);

    fillIn = App.testHelpers.fillIn;
    find = App.testHelpers.find;
    visit = App.testHelpers.visit;
    andThen = App.testHelpers.andThen;
    wait = App.testHelpers.wait;

    visit('/');
    fillIn('#first', 'current value');
    andThen(function () {
      equal(find('#first').val(), 'current value');
    });

    return wait();
  });

  QUnit.test('`fillIn` fires `input` and `change` events in the proper order', function () {
    expect(1);

    var fillIn, visit, andThen, wait;
    var events = [];
    App.IndexController = _emberRuntime.Controller.extend({
      actions: {
        oninputHandler: function (e) {
          events.push(e.type);
        },
        onchangeHandler: function (e) {
          events.push(e.type);
        }
      }
    });

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<input type="text" id="first" oninput={{action "oninputHandler"}} onchange={{action "onchangeHandler"}}>'));

    _emberMetal.run(App, App.advanceReadiness);

    fillIn = App.testHelpers.fillIn;
    visit = App.testHelpers.visit;
    andThen = App.testHelpers.andThen;
    wait = App.testHelpers.wait;

    visit('/');
    fillIn('#first', 'current value');
    andThen(function () {
      deepEqual(events, ['input', 'change'], '`input` and `change` events are fired in the proper order');
    });

    return wait();
  });

  QUnit.test('`fillIn` only sets the value in the first matched element', function () {
    var fillIn = undefined,
        find = undefined,
        visit = undefined,
        andThen = undefined,
        wait = undefined;

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<input type="text" id="first" class="in-test"><input type="text" id="second" class="in-test">'));
    _emberMetal.run(App, App.advanceReadiness);

    fillIn = App.testHelpers.fillIn;
    find = App.testHelpers.find;
    visit = App.testHelpers.visit;
    andThen = App.testHelpers.andThen;
    wait = App.testHelpers.wait;

    visit('/');
    fillIn('input.in-test', 'new value');
    andThen(function () {
      equal(find('#first').val(), 'new value');
      equal(find('#second').val(), '');
    });

    return wait();
  });

  QUnit.test('`triggerEvent accepts an optional options hash and context', function () {
    expect(3);

    var triggerEvent, wait, event;

    App.IndexWrapperComponent = _emberGlimmer.Component.extend({
      didInsertElement: function () {
        this.$('.input').on('keydown change', function (e) {
          event = e;
        });
      }
    });

    _emberGlimmer.setTemplate('components/index-wrapper', _emberTemplateCompiler.compile('{{input type="text" id="outside-scope" class="input"}}<div id="limited">{{input type="text" id="inside-scope" class="input"}}</div>'));
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{index-wrapper}}'));

    _emberMetal.run(App, App.advanceReadiness);

    triggerEvent = App.testHelpers.triggerEvent;
    wait = App.testHelpers.wait;

    return wait().then(function () {
      return triggerEvent('.input', '#limited', 'keydown', { keyCode: 13 });
    }).then(function () {
      equal(event.keyCode, 13, 'options were passed');
      equal(event.type, 'keydown', 'correct event was triggered');
      equal(event.target.getAttribute('id'), 'inside-scope', 'triggered on the correct element');
    });
  });

  QUnit.module('ember-testing debugging helpers', {
    setup: function () {
      setupApp();

      _emberMetal.run(function () {
        App.Router = _emberRouting.Router.extend({
          location: 'none'
        });
      });

      _emberMetal.run(App, 'advanceReadiness');
    },

    teardown: function () {
      cleanup();
    }
  });

  QUnit.test('pauseTest pauses', function () {
    expect(1);

    function fakeAdapterAsyncStart() {
      ok(true, 'Async start should be called after waiting for other helpers');
    }

    App.testHelpers.andThen(function () {
      _emberTestingTest.default.adapter.asyncStart = fakeAdapterAsyncStart;
    });

    App.testHelpers.pauseTest();
  });

  if (_emberMetal.isFeatureEnabled('ember-testing-resume-test')) {
    QUnit.test('resumeTest resumes paused tests', function () {
      expect(1);

      var pausePromise = App.testHelpers.pauseTest();
      setTimeout(function () {
        return App.testHelpers.resumeTest();
      }, 0);

      return pausePromise.then(function () {
        return ok(true, 'pauseTest promise was resolved');
      });
    });

    QUnit.test('resumeTest throws if nothing to resume', function () {
      expect(1);

      throws(function () {
        return App.testHelpers.resumeTest();
      }, /Testing has not been paused. There is nothing to resume./);
    });
  }

  QUnit.module('ember-testing routing helpers', {
    setup: function () {
      _emberMetal.run(function () {
        App = _emberApplication.Application.create();
        App.setupForTesting();

        App.injectTestHelpers();

        App.Router = _emberRouting.Router.extend({
          location: 'none'
        });

        App.Router.map(function () {
          this.route('posts', { resetNamespace: true }, function () {
            this.route('new');
          });
        });
      });

      _emberMetal.run(App, 'advanceReadiness');
    },

    teardown: function () {
      cleanup();
    }
  });

  QUnit.test('currentRouteName for \'/\'', function () {
    expect(3);

    return App.testHelpers.visit('/').then(function () {
      equal(App.testHelpers.currentRouteName(), 'index', 'should equal \'index\'.');
      equal(App.testHelpers.currentPath(), 'index', 'should equal \'index\'.');
      equal(App.testHelpers.currentURL(), '/', 'should equal \'/\'.');
    });
  });

  QUnit.test('currentRouteName for \'/posts\'', function () {
    expect(3);

    return App.testHelpers.visit('/posts').then(function () {
      equal(App.testHelpers.currentRouteName(), 'posts.index', 'should equal \'posts.index\'.');
      equal(App.testHelpers.currentPath(), 'posts.index', 'should equal \'posts.index\'.');
      equal(App.testHelpers.currentURL(), '/posts', 'should equal \'/posts\'.');
    });
  });

  QUnit.test('currentRouteName for \'/posts/new\'', function () {
    expect(3);

    return App.testHelpers.visit('/posts/new').then(function () {
      equal(App.testHelpers.currentRouteName(), 'posts.new', 'should equal \'posts.new\'.');
      equal(App.testHelpers.currentPath(), 'posts.new', 'should equal \'posts.new\'.');
      equal(App.testHelpers.currentURL(), '/posts/new', 'should equal \'/posts/new\'.');
    });
  });

  QUnit.module('ember-testing pendingRequests', {
    setup: function () {
      setupApp();
    },

    teardown: function () {
      cleanup();
    }
  });

  QUnit.test('pendingRequests is maintained for ajaxSend and ajaxComplete events', function () {
    equal(_emberTestingTestPending_requests.pendingRequests(), 0);
    var xhr = { some: 'xhr' };
    _emberViews.jQuery(document).trigger('ajaxSend', xhr);
    equal(_emberTestingTestPending_requests.pendingRequests(), 1, 'Ember.Test.pendingRequests was incremented');
    _emberViews.jQuery(document).trigger('ajaxComplete', xhr);
    equal(_emberTestingTestPending_requests.pendingRequests(), 0, 'Ember.Test.pendingRequests was decremented');
  });

  QUnit.test('pendingRequests is ignores ajaxComplete events from past setupForTesting calls', function () {
    equal(_emberTestingTestPending_requests.pendingRequests(), 0);
    var xhr = { some: 'xhr' };
    _emberViews.jQuery(document).trigger('ajaxSend', xhr);
    equal(_emberTestingTestPending_requests.pendingRequests(), 1, 'Ember.Test.pendingRequests was incremented');

    _emberMetal.run(function () {
      _emberTestingSetup_for_testing.default();
    });
    equal(_emberTestingTestPending_requests.pendingRequests(), 0, 'Ember.Test.pendingRequests was reset');

    var altXhr = { some: 'more xhr' };
    _emberViews.jQuery(document).trigger('ajaxSend', altXhr);
    equal(_emberTestingTestPending_requests.pendingRequests(), 1, 'Ember.Test.pendingRequests was incremented');
    _emberViews.jQuery(document).trigger('ajaxComplete', xhr);
    equal(_emberTestingTestPending_requests.pendingRequests(), 1, 'Ember.Test.pendingRequests is not impressed with your unexpected complete');
  });

  QUnit.test('pendingRequests is reset by setupForTesting', function () {
    _emberTestingTestPending_requests.incrementPendingRequests();
    _emberMetal.run(function () {
      _emberTestingSetup_for_testing.default();
    });
    equal(_emberTestingTestPending_requests.pendingRequests(), 0, 'pendingRequests is reset');
  });

  QUnit.module('ember-testing async router', {
    setup: function () {
      cleanup();

      _emberMetal.run(function () {
        App = _emberApplication.Application.create();
        App.Router = _emberRouting.Router.extend({
          location: 'none'
        });

        App.Router.map(function () {
          this.route('user', { resetNamespace: true }, function () {
            this.route('profile');
            this.route('edit');
          });
        });

        App.UserRoute = _emberRouting.Route.extend({
          model: function () {
            return resolveLater();
          }
        });

        App.UserProfileRoute = _emberRouting.Route.extend({
          beforeModel: function () {
            var self = this;
            return resolveLater().then(function () {
              self.transitionTo('user.edit');
            });
          }
        });

        // Emulates a long-running unscheduled async operation.
        function resolveLater() {
          var promise;

          _emberMetal.run(function () {
            promise = new _emberRuntime.RSVP.Promise(function (resolve) {
              // The wait() helper has a 10ms tick. We should resolve() after at least one tick
              // to test whether wait() held off while the async router was still loading. 20ms
              // should be enough.
              setTimeout(function () {
                _emberMetal.run(function () {
                  resolve(_emberRuntime.Object.create({ firstName: 'Tom' }));
                });
              }, 20);
            });
          });

          return promise;
        }

        App.setupForTesting();
      });

      App.injectTestHelpers();
      _emberMetal.run(App, 'advanceReadiness');
    },

    teardown: function () {
      cleanup();
    }
  });

  QUnit.test('currentRouteName for \'/user\'', function () {
    expect(4);

    return App.testHelpers.visit('/user').then(function () {
      equal(currentRouteName(App), 'user.index', 'should equal \'user.index\'.');
      equal(currentPath(App), 'user.index', 'should equal \'user.index\'.');
      equal(currentURL(App), '/user', 'should equal \'/user\'.');
      equal(App.__container__.lookup('route:user').get('controller.model.firstName'), 'Tom', 'should equal \'Tom\'.');
    });
  });

  QUnit.test('currentRouteName for \'/user/profile\'', function () {
    expect(4);

    return App.testHelpers.visit('/user/profile').then(function () {
      equal(currentRouteName(App), 'user.edit', 'should equal \'user.edit\'.');
      equal(currentPath(App), 'user.edit', 'should equal \'user.edit\'.');
      equal(currentURL(App), '/user/edit', 'should equal \'/user/edit\'.');
      equal(App.__container__.lookup('route:user').get('controller.model.firstName'), 'Tom', 'should equal \'Tom\'.');
    });
  });

  var originalVisitHelper, originalFindHelper, originalWaitHelper;

  QUnit.module('can override built-in helpers', {
    setup: function () {
      originalVisitHelper = _emberTestingTest.default._helpers.visit;
      originalFindHelper = _emberTestingTest.default._helpers.find;
      originalWaitHelper = _emberTestingTest.default._helpers.wait;

      _emberViews.jQuery('<style>#ember-testing-container { position: absolute; background: white; bottom: 0; right: 0; width: 640px; height: 384px; overflow: auto; z-index: 9999; border: 1px solid #ccc; } #ember-testing { zoom: 50%; }</style>').appendTo('head');
      _emberViews.jQuery('<div id="ember-testing-container"><div id="ember-testing"></div></div>').appendTo('body');
      _emberMetal.run(function () {
        App = _emberApplication.Application.create({
          rootElement: '#ember-testing'
        });

        App.setupForTesting();
      });
    },

    teardown: function () {
      cleanup();

      _emberTestingTest.default._helpers.visit = originalVisitHelper;
      _emberTestingTest.default._helpers.find = originalFindHelper;
      _emberTestingTest.default._helpers.wait = originalWaitHelper;
    }
  });

  QUnit.test('can override visit helper', function () {
    expect(1);

    _emberTestingTest.default.registerHelper('visit', function () {
      ok(true, 'custom visit helper was called');
    });

    App.injectTestHelpers();

    return App.testHelpers.visit();
  });

  QUnit.test('can override find helper', function () {
    expect(1);

    _emberTestingTest.default.registerHelper('find', function () {
      ok(true, 'custom find helper was called');

      return ['not empty array'];
    });

    App.injectTestHelpers();

    return App.testHelpers.findWithAssert('.who-cares');
  });
});
// ensure that the helpers are loaded
// ensure the initializer is setup
enifed('ember-testing/tests/helpers_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/tests/helpers_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/tests/helpers_test.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/tests/integration_test', ['exports', 'ember-metal', 'ember-runtime', 'ember-views', 'ember-testing/test', 'ember-routing', 'ember-application', 'ember-template-compiler', 'ember-glimmer'], function (exports, _emberMetal, _emberRuntime, _emberViews, _emberTestingTest, _emberRouting, _emberApplication, _emberTemplateCompiler, _emberGlimmer) {
  'use strict';

  var App, find, visit;
  var originalAdapter = _emberTestingTest.default.adapter;

  QUnit.module('ember-testing Integration', {
    setup: function () {
      _emberViews.jQuery('<div id="ember-testing-container"><div id="ember-testing"></div></div>').appendTo('body');
      _emberMetal.run(function () {
        _emberGlimmer.setTemplate('people', _emberTemplateCompiler.compile('<div>{{#each model as |person|}}<div class="name">{{person.firstName}}</div>{{/each}}</div>'));
        _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{outlet}}'));

        App = _emberApplication.Application.create({
          rootElement: '#ember-testing'
        });

        App.Router.map(function () {
          this.route('people', { path: '/' });
        });

        App.PeopleRoute = _emberRouting.Route.extend({
          model: function () {
            return App.Person.find();
          }
        });

        App.PeopleController = _emberRuntime.Controller.extend({});

        App.Person = _emberRuntime.Object.extend({
          firstName: ''
        });

        App.Person.reopenClass({
          find: function () {
            return _emberRuntime.A();
          }
        });

        App.setupForTesting();
      });

      _emberMetal.run(function () {
        App.reset();
      });

      App.injectTestHelpers();

      find = window.find;
      visit = window.visit;
    },

    teardown: function () {
      App.removeTestHelpers();
      _emberGlimmer.setTemplates({});
      _emberViews.jQuery('#ember-testing-container, #ember-testing').remove();
      _emberMetal.run(App, App.destroy);
      App = null;
      _emberTestingTest.default.adapter = originalAdapter;
    }
  });

  QUnit.test('template is bound to empty array of people', function () {
    App.Person.find = function () {
      return _emberRuntime.A();
    };
    _emberMetal.run(App, 'advanceReadiness');
    visit('/').then(function () {
      var rows = find('.name').length;
      equal(rows, 0, 'successfully stubbed an empty array of people');
    });
  });

  QUnit.test('template is bound to array of 2 people', function () {
    App.Person.find = function () {
      var people = _emberRuntime.A();
      var first = App.Person.create({ firstName: 'x' });
      var last = App.Person.create({ firstName: 'y' });
      _emberMetal.run(people, people.pushObject, first);
      _emberMetal.run(people, people.pushObject, last);
      return people;
    };
    _emberMetal.run(App, 'advanceReadiness');
    visit('/').then(function () {
      var rows = find('.name').length;
      equal(rows, 2, 'successfully stubbed a non empty array of people');
    });
  });

  QUnit.test('template is again bound to empty array of people', function () {
    App.Person.find = function () {
      return _emberRuntime.A();
    };
    _emberMetal.run(App, 'advanceReadiness');
    visit('/').then(function () {
      var rows = find('.name').length;
      equal(rows, 0, 'successfully stubbed another empty array of people');
    });
  });

  QUnit.test('`visit` can be called without advancedReadiness.', function () {
    App.Person.find = function () {
      return _emberRuntime.A();
    };

    visit('/').then(function () {
      var rows = find('.name').length;
      equal(rows, 0, 'stubbed an empty array of people without calling advancedReadiness.');
    });
  });
});
enifed('ember-testing/tests/integration_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/tests/integration_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/tests/integration_test.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/tests/reexports_test', ['exports', 'ember', 'internal-test-helpers'], function (exports, _ember, _internalTestHelpers) {
  'use strict';

  QUnit.module('ember-testing reexports');

  [
  // ember-testing
  ['Test', 'ember-testing'], ['Test.Adapter', 'ember-testing', 'Adapter'], ['Test.QUnitAdapter', 'ember-testing', 'QUnitAdapter'], ['setupForTesting', 'ember-testing']].forEach(function (reexport) {
    var path = reexport[0];
    var moduleId = reexport[1];
    var exportName = reexport[2];

    // default path === exportName if none present
    if (!exportName) {
      exportName = path;
    }

    QUnit.test('Ember.' + path + ' exports correctly', function (assert) {
      _internalTestHelpers.confirmExport(_ember.default, assert, path, moduleId, exportName);
    });
  });
});
enifed('ember-testing/tests/reexports_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/tests/reexports_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/tests/reexports_test.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/tests/simple_setup', ['exports', 'ember-metal', 'ember-views'], function (exports, _emberMetal, _emberViews) {
  'use strict';

  var App;

  QUnit.module('Simple Testing Setup', {
    teardown: function () {
      if (App) {
        App.removeTestHelpers();
        _emberViews.jQuery('#ember-testing-container, #ember-testing').remove();
        _emberMetal.run(App, 'destroy');
        App = null;
      }
    }
  });
});
enifed('ember-testing/tests/simple_setup.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/tests/simple_setup.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/tests/simple_setup.js should pass ESLint\n\n');
  });
});
enifed('ember-testing/tests/test/waiters-test', ['exports', 'ember-testing/test/waiters'], function (exports, _emberTestingTestWaiters) {
  'use strict';

  var Waiters = (function () {
    function Waiters() {
      this._waiters = [];
    }

    Waiters.prototype.add = function add() {
      this._waiters.push([].concat(babelHelpers.slice.call(arguments)));
    };

    Waiters.prototype.register = function register() {
      this.forEach(function () {
        _emberTestingTestWaiters.registerWaiter.apply(undefined, arguments);
      });
    };

    Waiters.prototype.unregister = function unregister() {
      this.forEach(function () {
        _emberTestingTestWaiters.unregisterWaiter.apply(undefined, arguments);
      });
    };

    Waiters.prototype.forEach = function forEach(callback) {
      for (var i = 0; i < this._waiters.length; i++) {
        var args = this._waiters[i];

        callback.apply(undefined, args);
      }
    };

    Waiters.prototype.check = function check() {
      this.register();
      var result = _emberTestingTestWaiters.checkWaiters();
      this.unregister();

      return result;
    };

    return Waiters;
  })();

  QUnit.module('ember-testing: waiters', {
    setup: function () {
      this.waiters = new Waiters();
    },

    teardown: function () {
      this.waiters.unregister();
    }
  });

  QUnit.test('registering a waiter', function (assert) {
    assert.expect(2);

    var obj = { foo: true };

    this.waiters.add(obj, function () {
      assert.ok(this.foo, 'has proper `this` context');
      return true;
    });

    this.waiters.add(function () {
      assert.ok(true, 'is called');
      return true;
    });

    this.waiters.check();
  });

  QUnit.test('unregistering a waiter', function (assert) {
    assert.expect(2);

    var obj = { foo: true };

    this.waiters.add(obj, function () {
      assert.ok(true, 'precond - waiter with context is registered');
      return true;
    });

    this.waiters.add(function () {
      assert.ok(true, 'precond - waiter without context is registered');
      return true;
    });

    this.waiters.check();
    this.waiters.unregister();

    _emberTestingTestWaiters.checkWaiters();
  });

  QUnit.test('checkWaiters returns false if all waiters return true', function (assert) {
    assert.expect(3);

    this.waiters.add(function () {
      assert.ok(true, 'precond - waiter is registered');

      return true;
    });

    this.waiters.add(function () {
      assert.ok(true, 'precond - waiter is registered');

      return true;
    });

    assert.notOk(this.waiters.check(), 'checkWaiters returns true if all waiters return true');
  });

  QUnit.test('checkWaiters returns true if any waiters return false', function (assert) {
    assert.expect(3);

    this.waiters.add(function () {
      assert.ok(true, 'precond - waiter is registered');

      return true;
    });

    this.waiters.add(function () {
      assert.ok(true, 'precond - waiter is registered');

      return false;
    });

    assert.ok(this.waiters.check(), 'checkWaiters returns false if any waiters return false');
  });

  QUnit.test('checkWaiters short circuits after first falsey waiter', function (assert) {
    assert.expect(2);

    this.waiters.add(function () {
      assert.ok(true, 'precond - waiter is registered');

      return false;
    });

    this.waiters.add(function () {
      assert.notOk(true, 'waiter should not be called');
    });

    assert.ok(this.waiters.check(), 'checkWaiters returns false if any waiters return false');
  });

  QUnit.test('generateDeprecatedWaitersArray provides deprecated access to waiters array', function (assert) {
    var waiter1 = function () {};
    var waiter2 = function () {};

    this.waiters.add(waiter1);
    this.waiters.add(waiter2);

    this.waiters.register();

    var waiters = undefined;
    expectDeprecation(function () {
      waiters = _emberTestingTestWaiters.generateDeprecatedWaitersArray();
    }, /Usage of `Ember.Test.waiters` is deprecated/);

    assert.deepEqual(waiters, [[null, waiter1], [null, waiter2]]);
  });
});
enifed('ember-testing/tests/test/waiters-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-testing/tests/test/waiters-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-testing/tests/test/waiters-test.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/apply-str.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/apply-str.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/apply-str.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/assign.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/assign.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/assign.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/dictionary.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/dictionary.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/dictionary.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/empty-object.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/empty-object.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/empty-object.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/guid.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/guid.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/guid.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/index.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/index.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/index.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/inspect.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/inspect.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/inspect.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/intern.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/intern.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/intern.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/invoke.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/invoke.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/invoke.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/lookup-descriptor.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/lookup-descriptor.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/lookup-descriptor.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/make-array.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/make-array.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/make-array.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/name.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/name.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/name.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/owner.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/owner.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/owner.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/proxy-utils.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/proxy-utils.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/proxy-utils.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/super.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/super.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/super.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/symbol.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/symbol.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/symbol.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/tests/assign_test', ['exports', 'ember-utils/assign'], function (exports, _emberUtilsAssign) {
  'use strict';

  QUnit.module('Ember.assign');

  QUnit.test('Ember.assign', function () {
    var a = { a: 1 };
    var b = { b: 2 };
    var c = { c: 3 };
    var a2 = { a: 4 };

    _emberUtilsAssign.default(a, b, c, a2);

    deepEqual(a, { a: 4, b: 2, c: 3 });
    deepEqual(b, { b: 2 });
    deepEqual(c, { c: 3 });
    deepEqual(a2, { a: 4 });
  });
});
enifed('ember-utils/tests/assign_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/tests/assign_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/tests/assign_test.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/tests/can_invoke_test', ['exports', 'ember-utils/index'], function (exports, _emberUtilsIndex) {
  'use strict';

  var obj = undefined;

  QUnit.module('Ember.canInvoke', {
    setup: function () {
      obj = {
        foobar: 'foobar',
        aMethodThatExists: function () {}
      };
    },

    teardown: function () {
      obj = undefined;
    }
  });

  QUnit.test('should return false if the object doesn\'t exist', function () {
    equal(_emberUtilsIndex.canInvoke(undefined, 'aMethodThatDoesNotExist'), false);
  });

  QUnit.test('should return true if the method exists on the object', function () {
    equal(_emberUtilsIndex.canInvoke(obj, 'aMethodThatExists'), true);
  });

  QUnit.test('should return false if the method doesn\'t exist on the object', function () {
    equal(_emberUtilsIndex.canInvoke(obj, 'aMethodThatDoesNotExist'), false);
  });

  QUnit.test('should return false if the property exists on the object but is a non-function', function () {
    equal(_emberUtilsIndex.canInvoke(obj, 'foobar'), false);
  });
});
enifed('ember-utils/tests/can_invoke_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/tests/can_invoke_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/tests/can_invoke_test.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/tests/checkHasSuper_test', ['exports', 'ember-environment', 'ember-utils/index'], function (exports, _emberEnvironment, _emberUtilsIndex) {
  'use strict';

  QUnit.module('checkHasSuper');

  // Only run this test on browsers that we are certain should have function
  // source available.  This allows the test suite to continue to pass on other
  // platforms that correctly (for them) fall back to the "always wrap" code.
  if (_emberEnvironment.environment.isPhantom || _emberEnvironment.environment.isChrome || _emberEnvironment.environment.isFirefox) {
    QUnit.test('does not super wrap needlessly [GH #12462]', function (assert) {
      assert.notOk(_emberUtilsIndex.checkHasSuper(function () {}), 'empty function does not have super');
    });
  }
});
enifed('ember-utils/tests/checkHasSuper_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/tests/checkHasSuper_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/tests/checkHasSuper_test.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/tests/generate_guid_test', ['exports', 'ember-utils/index'], function (exports, _emberUtilsIndex) {
  'use strict';

  QUnit.module('Ember.generateGuid');

  QUnit.test('Prefix', function () {
    var a = {};

    ok(_emberUtilsIndex.generateGuid(a, 'tyrell').indexOf('tyrell') > -1, 'guid can be prefixed');
  });
});
enifed('ember-utils/tests/generate_guid_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/tests/generate_guid_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/tests/generate_guid_test.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/tests/guid_for_test', ['exports', 'ember-utils/index'], function (exports, _emberUtilsIndex) {
  'use strict';

  QUnit.module('guidFor');

  function sameGuid(a, b, message) {
    equal(_emberUtilsIndex.guidFor(a), _emberUtilsIndex.guidFor(b), message);
  }

  function diffGuid(a, b, message) {
    ok(_emberUtilsIndex.guidFor(a) !== _emberUtilsIndex.guidFor(b), message);
  }

  function nanGuid(obj) {
    var type = typeof obj;
    ok(isNaN(parseInt(_emberUtilsIndex.guidFor(obj), 0)), 'guids for ' + type + 'don\'t parse to numbers');
  }

  QUnit.test('Object', function () {
    var a = {};
    var b = {};

    sameGuid(a, a, 'same object always yields same guid');
    diffGuid(a, b, 'different objects yield different guids');
    nanGuid(a);
  });

  QUnit.test('strings', function () {
    var a = 'string A';
    var aprime = 'string A';
    var b = 'String B';

    sameGuid(a, a, 'same string always yields same guid');
    sameGuid(a, aprime, 'identical strings always yield the same guid');
    diffGuid(a, b, 'different strings yield different guids');
    nanGuid(a);
  });

  QUnit.test('numbers', function () {
    var a = 23;
    var aprime = 23;
    var b = 34;

    sameGuid(a, a, 'same numbers always yields same guid');
    sameGuid(a, aprime, 'identical numbers always yield the same guid');
    diffGuid(a, b, 'different numbers yield different guids');
    nanGuid(a);
  });

  QUnit.test('numbers', function () {
    var a = true;
    var aprime = true;
    var b = false;

    sameGuid(a, a, 'same booleans always yields same guid');
    sameGuid(a, aprime, 'identical booleans always yield the same guid');
    diffGuid(a, b, 'different boolean yield different guids');
    nanGuid(a);
    nanGuid(b);
  });

  QUnit.test('null and undefined', function () {
    var a = null;
    var aprime = null;
    var b = undefined;

    sameGuid(a, a, 'null always returns the same guid');
    sameGuid(b, b, 'undefined always returns the same guid');
    sameGuid(a, aprime, 'different nulls return the same guid');
    diffGuid(a, b, 'null and undefined return different guids');
    nanGuid(a);
    nanGuid(b);
  });

  QUnit.test('arrays', function () {
    var a = ['a', 'b', 'c'];
    var aprime = ['a', 'b', 'c'];
    var b = ['1', '2', '3'];

    sameGuid(a, a, 'same instance always yields same guid');
    diffGuid(a, aprime, 'identical arrays always yield the same guid');
    diffGuid(a, b, 'different arrays yield different guids');
    nanGuid(a);
  });
});
enifed('ember-utils/tests/guid_for_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/tests/guid_for_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/tests/guid_for_test.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/tests/inspect_test', ['exports', 'ember-utils/index'], function (exports, _emberUtilsIndex) {
  'use strict';

  // Symbol is not defined on pre-ES2015 runtimes, so this let's us safely test
  // for it's existence (where a simple `if (Symbol)` would ReferenceError)
  var HAS_NATIVE_SYMBOL = typeof Symbol === 'function';

  QUnit.module('Ember.inspect');

  QUnit.test('strings', function () {
    equal(_emberUtilsIndex.inspect('foo'), 'foo');
  });

  QUnit.test('numbers', function () {
    equal(_emberUtilsIndex.inspect(2.6), '2.6');
  });

  QUnit.test('null', function () {
    equal(_emberUtilsIndex.inspect(null), 'null');
  });

  QUnit.test('undefined', function () {
    equal(_emberUtilsIndex.inspect(undefined), 'undefined');
  });

  QUnit.test('true', function () {
    equal(_emberUtilsIndex.inspect(true), 'true');
  });

  QUnit.test('false', function () {
    equal(_emberUtilsIndex.inspect(false), 'false');
  });

  QUnit.test('object', function () {
    equal(_emberUtilsIndex.inspect({}), '{}');
    equal(_emberUtilsIndex.inspect({ foo: 'bar' }), '{foo: bar}');
    equal(_emberUtilsIndex.inspect({ foo: function () {
        return this;
      } }), '{foo: function() { ... }}');
  });

  QUnit.test('objects without a prototype', function () {
    var prototypelessObj = Object.create(null);
    equal(_emberUtilsIndex.inspect({ foo: prototypelessObj }), '{foo: [object Object]}');
  });

  QUnit.test('array', function () {
    equal(_emberUtilsIndex.inspect([1, 2, 3]), '[1,2,3]');
  });

  QUnit.test('regexp', function () {
    equal(_emberUtilsIndex.inspect(/regexp/), '/regexp/');
  });

  QUnit.test('date', function () {
    var inspected = _emberUtilsIndex.inspect(new Date('Sat Apr 30 2011 13:24:11'));
    ok(inspected.match(/Sat Apr 30/), 'The inspected date has its date');
    ok(inspected.match(/2011/), 'The inspected date has its year');
    ok(inspected.match(/13:24:11/), 'The inspected date has its time');
  });

  QUnit.test('inspect outputs the toString() representation of Symbols', function () {
    if (HAS_NATIVE_SYMBOL) {
      var symbol = Symbol('test');
      equal(_emberUtilsIndex.inspect(symbol), 'Symbol(test)');
    } else {
      expect(0);
    }
  });
});
enifed('ember-utils/tests/inspect_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/tests/inspect_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/tests/inspect_test.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/tests/make_array_test', ['exports', 'ember-utils/make-array'], function (exports, _emberUtilsMakeArray) {
  'use strict';

  QUnit.module('Ember.makeArray');

  QUnit.test('undefined', function () {
    deepEqual(_emberUtilsMakeArray.default(), []);
    deepEqual(_emberUtilsMakeArray.default(undefined), []);
  });

  QUnit.test('null', function () {
    deepEqual(_emberUtilsMakeArray.default(null), []);
  });

  QUnit.test('string', function () {
    deepEqual(_emberUtilsMakeArray.default('lindsay'), ['lindsay']);
  });

  QUnit.test('number', function () {
    deepEqual(_emberUtilsMakeArray.default(0), [0]);
    deepEqual(_emberUtilsMakeArray.default(1), [1]);
  });

  QUnit.test('array', function () {
    deepEqual(_emberUtilsMakeArray.default([1, 2, 42]), [1, 2, 42]);
  });

  QUnit.test('true', function () {
    deepEqual(_emberUtilsMakeArray.default(true), [true]);
  });

  QUnit.test('false', function () {
    deepEqual(_emberUtilsMakeArray.default(false), [false]);
  });

  QUnit.test('object', function () {
    deepEqual(_emberUtilsMakeArray.default({}), [{}]);
  });
});
enifed('ember-utils/tests/make_array_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/tests/make_array_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/tests/make_array_test.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/tests/to-string-test', ['exports', 'ember-utils/index'], function (exports, _emberUtilsIndex) {
  'use strict';

  QUnit.module('ember-utils toString');

  QUnit.test('toString uses an object\'s toString method when available', function () {
    var obj = {
      toString: function () {
        return 'bob';
      }
    };

    strictEqual(_emberUtilsIndex.toString(obj), 'bob');
  });

  QUnit.test('toString falls back to Object.prototype.toString', function () {
    var obj = Object.create(null);

    strictEqual(_emberUtilsIndex.toString(obj), ({}).toString());
  });
});
enifed('ember-utils/tests/to-string-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/tests/to-string-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/tests/to-string-test.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/tests/try_invoke_test', ['exports', 'ember-utils/index'], function (exports, _emberUtilsIndex) {
  'use strict';

  var obj = undefined;

  QUnit.module('Ember.tryInvoke', {
    setup: function () {
      obj = {
        aMethodThatExists: function () {
          return true;
        },
        aMethodThatTakesArguments: function (arg1, arg2) {
          return arg1 === arg2;
        }
      };
    },

    teardown: function () {
      obj = undefined;
    }
  });

  QUnit.test('should return undefined when the object doesn\'t exist', function () {
    equal(_emberUtilsIndex.tryInvoke(undefined, 'aMethodThatDoesNotExist'), undefined);
  });

  QUnit.test('should return undefined when asked to perform a method that doesn\'t exist on the object', function () {
    equal(_emberUtilsIndex.tryInvoke(obj, 'aMethodThatDoesNotExist'), undefined);
  });

  QUnit.test('should return what the method returns when asked to perform a method that exists on the object', function () {
    equal(_emberUtilsIndex.tryInvoke(obj, 'aMethodThatExists'), true);
  });

  QUnit.test('should return what the method returns when asked to perform a method that takes arguments and exists on the object', function () {
    equal(_emberUtilsIndex.tryInvoke(obj, 'aMethodThatTakesArguments', [true, true]), true);
  });
});
enifed('ember-utils/tests/try_invoke_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/tests/try_invoke_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/tests/try_invoke_test.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/to-string.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/to-string.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/to-string.js should pass ESLint\n\n');
  });
});
enifed('ember-utils/weak-map-utils.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-utils/weak-map-utils.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-utils/weak-map-utils.js should pass ESLint\n\n');
  });
});
enifed('ember-views/compat/attrs.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/compat/attrs.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/compat/attrs.js should pass ESLint\n\n');
  });
});
enifed('ember-views/compat/fallback-view-registry.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/compat/fallback-view-registry.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/compat/fallback-view-registry.js should pass ESLint\n\n');
  });
});
enifed('ember-views/component_lookup.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/component_lookup.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/component_lookup.js should pass ESLint\n\n');
  });
});
enifed('ember-views/index.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/index.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/index.js should pass ESLint\n\n');
  });
});
enifed('ember-views/mixins/action_support.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/mixins/action_support.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/mixins/action_support.js should pass ESLint\n\n');
  });
});
enifed('ember-views/mixins/child_views_support.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/mixins/child_views_support.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/mixins/child_views_support.js should pass ESLint\n\n');
  });
});
enifed('ember-views/mixins/class_names_support.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/mixins/class_names_support.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/mixins/class_names_support.js should pass ESLint\n\n');
  });
});
enifed('ember-views/mixins/text_support.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/mixins/text_support.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/mixins/text_support.js should pass ESLint\n\n');
  });
});
enifed('ember-views/mixins/view_state_support.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/mixins/view_state_support.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/mixins/view_state_support.js should pass ESLint\n\n');
  });
});
enifed('ember-views/mixins/view_support.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/mixins/view_support.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/mixins/view_support.js should pass ESLint\n\n');
  });
});
enifed('ember-views/system/action_manager.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/system/action_manager.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/system/action_manager.js should pass ESLint\n\n');
  });
});
enifed('ember-views/system/event_dispatcher.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/system/event_dispatcher.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/system/event_dispatcher.js should pass ESLint\n\n');
  });
});
enifed('ember-views/system/ext.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/system/ext.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/system/ext.js should pass ESLint\n\n');
  });
});
enifed('ember-views/system/jquery.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/system/jquery.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/system/jquery.js should pass ESLint\n\n');
  });
});
enifed('ember-views/system/lookup_partial.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/system/lookup_partial.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/system/lookup_partial.js should pass ESLint\n\n');
  });
});
enifed('ember-views/system/utils.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/system/utils.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/system/utils.js should pass ESLint\n\n');
  });
});
enifed('ember-views/utils/lookup-component.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/utils/lookup-component.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/utils/lookup-component.js should pass ESLint\n\n');
  });
});
enifed('ember-views/views/core_view.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/views/core_view.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/views/core_view.js should pass ESLint\n\n');
  });
});
enifed('ember-views/views/states.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/views/states.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/views/states.js should pass ESLint\n\n');
  });
});
enifed('ember-views/views/states/default.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/views/states/default.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/views/states/default.js should pass ESLint\n\n');
  });
});
enifed('ember-views/views/states/destroying.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/views/states/destroying.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/views/states/destroying.js should pass ESLint\n\n');
  });
});
enifed('ember-views/views/states/has_element.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/views/states/has_element.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/views/states/has_element.js should pass ESLint\n\n');
  });
});
enifed('ember-views/views/states/in_dom.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/views/states/in_dom.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/views/states/in_dom.js should pass ESLint\n\n');
  });
});
enifed('ember-views/views/states/pre_render.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/views/states/pre_render.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/views/states/pre_render.js should pass ESLint\n\n');
  });
});
enifed('ember-views/views/view.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember-views/views/view.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember-views/views/view.js should pass ESLint\n\n');
  });
});
enifed('ember/index.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/index.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/index.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/application_lifecycle_test', ['exports', 'ember-application', 'ember-routing', 'ember-metal', 'ember-glimmer', 'ember-views', 'ember-template-compiler'], function (exports, _emberApplication, _emberRouting, _emberMetal, _emberGlimmer, _emberViews, _emberTemplateCompiler) {
  'use strict';

  var App = undefined,
      TEMPLATES = undefined,
      appInstance = undefined,
      router = undefined;

  function setupApp(klass) {
    _emberMetal.run(function () {
      App = klass.create({
        rootElement: '#qunit-fixture'
      });

      App.Router = App.Router.extend({
        location: 'none'
      });

      App.deferReadiness();

      appInstance = App.__deprecatedInstance__;
    });
  }

  QUnit.module('Application Lifecycle', {
    setup: function () {
      TEMPLATES = _emberGlimmer.getTemplates();
      setupApp(_emberApplication.Application.extend());
    },

    teardown: function () {
      router = null;
      _emberMetal.run(App, 'destroy');
      _emberGlimmer.setTemplates({});
    }
  });

  function handleURL(path) {
    router = appInstance.lookup('router:main');
    return _emberMetal.run(function () {
      return router.handleURL(path).then(function (value) {
        ok(true, 'url: `' + path + '` was handled');
        return value;
      }, function (reason) {
        ok(false, reason);
        throw reason;
      });
    });
  }

  QUnit.test('Resetting the application allows controller properties to be set when a route deactivates', function () {
    App.Router.map(function () {
      this.route('home', { path: '/' });
    });

    App.HomeRoute = _emberRouting.Route.extend({
      setupController: function () {
        this.controllerFor('home').set('selectedMenuItem', 'home');
      },
      deactivate: function () {
        this.controllerFor('home').set('selectedMenuItem', null);
      }
    });
    App.ApplicationRoute = _emberRouting.Route.extend({
      setupController: function () {
        this.controllerFor('application').set('selectedMenuItem', 'home');
      },
      deactivate: function () {
        this.controllerFor('application').set('selectedMenuItem', null);
      }
    });

    appInstance.lookup('router:main');

    _emberMetal.run(App, 'advanceReadiness');

    handleURL('/');

    equal(_emberRouting.controllerFor(appInstance, 'home').get('selectedMenuItem'), 'home');
    equal(_emberRouting.controllerFor(appInstance, 'application').get('selectedMenuItem'), 'home');

    App.reset();

    equal(_emberRouting.controllerFor(appInstance, 'home').get('selectedMenuItem'), null);
    equal(_emberRouting.controllerFor(appInstance, 'application').get('selectedMenuItem'), null);
  });

  QUnit.test('Destroying the application resets the router before the appInstance is destroyed', function () {
    App.Router.map(function () {
      this.route('home', { path: '/' });
    });

    App.HomeRoute = _emberRouting.Route.extend({
      setupController: function () {
        this.controllerFor('home').set('selectedMenuItem', 'home');
      },
      deactivate: function () {
        this.controllerFor('home').set('selectedMenuItem', null);
      }
    });
    App.ApplicationRoute = _emberRouting.Route.extend({
      setupController: function () {
        this.controllerFor('application').set('selectedMenuItem', 'home');
      },
      deactivate: function () {
        this.controllerFor('application').set('selectedMenuItem', null);
      }
    });

    appInstance.lookup('router:main');

    _emberMetal.run(App, 'advanceReadiness');

    handleURL('/');

    equal(_emberRouting.controllerFor(appInstance, 'home').get('selectedMenuItem'), 'home');
    equal(_emberRouting.controllerFor(appInstance, 'application').get('selectedMenuItem'), 'home');

    _emberMetal.run(App, 'destroy');

    equal(_emberRouting.controllerFor(appInstance, 'home').get('selectedMenuItem'), null);
    equal(_emberRouting.controllerFor(appInstance, 'application').get('selectedMenuItem'), null);
  });

  QUnit.test('Destroying a route after the router does create an undestroyed `toplevelView`', function () {
    App.Router.map(function () {
      this.route('home', { path: '/' });
    });

    _emberGlimmer.setTemplates({
      index: _emberTemplateCompiler.compile('Index!'),
      application: _emberTemplateCompiler.compile('Application! {{outlet}}')
    });

    App.IndexRoute = _emberRouting.Route.extend();
    _emberMetal.run(App, 'advanceReadiness');

    handleURL('/');

    var router = appInstance.lookup('router:main');
    var route = appInstance.lookup('route:index');

    _emberMetal.run(router, 'destroy');
    equal(router._toplevelView, null, 'the toplevelView was cleared');

    _emberMetal.run(route, 'destroy');
    equal(router._toplevelView, null, 'the toplevelView was not reinitialized');

    _emberMetal.run(App, 'destroy');
    equal(router._toplevelView, null, 'the toplevelView was not reinitialized');
  });

  QUnit.test('initializers can augment an applications customEvents hash', function (assert) {
    assert.expect(1);

    _emberMetal.run(App, 'destroy');

    var ApplicationSubclass = _emberApplication.Application.extend();

    ApplicationSubclass.initializer({
      name: 'customize-things',
      initialize: function (application) {
        application.customEvents = {
          wowza: 'wowza'
        };
      }
    });

    setupApp(ApplicationSubclass);

    App.FooBarComponent = _emberGlimmer.Component.extend({
      wowza: function () {
        assert.ok(true, 'fired the event!');
      }
    });

    TEMPLATES['application'] = _emberTemplateCompiler.compile('{{foo-bar}}');
    TEMPLATES['components/foo-bar'] = _emberTemplateCompiler.compile('<div id=\'wowza-thingy\'></div>');

    _emberMetal.run(App, 'advanceReadiness');

    _emberMetal.run(function () {
      return _emberViews.jQuery('#wowza-thingy').trigger('wowza');
    });
  });

  QUnit.test('instanceInitializers can augment an the customEvents hash', function (assert) {
    assert.expect(1);

    _emberMetal.run(App, 'destroy');

    var ApplicationSubclass = _emberApplication.Application.extend();

    ApplicationSubclass.instanceInitializer({
      name: 'customize-things',
      initialize: function (application) {
        application.customEvents = {
          herky: 'jerky'
        };
      }
    });

    setupApp(ApplicationSubclass);

    App.FooBarComponent = _emberGlimmer.Component.extend({
      jerky: function () {
        assert.ok(true, 'fired the event!');
      }
    });

    TEMPLATES['application'] = _emberTemplateCompiler.compile('{{foo-bar}}');
    TEMPLATES['components/foo-bar'] = _emberTemplateCompiler.compile('<div id=\'herky-thingy\'></div>');

    _emberMetal.run(App, 'advanceReadiness');

    _emberMetal.run(function () {
      return _emberViews.jQuery('#herky-thingy').trigger('herky');
    });
  });
});
enifed('ember/tests/application_lifecycle_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/application_lifecycle_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/application_lifecycle_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/component_registration_test', ['exports', 'ember-runtime', 'ember-metal', 'ember-application', 'ember-routing', 'ember-template-compiler', 'ember-glimmer', 'ember-views'], function (exports, _emberRuntime, _emberMetal, _emberApplication, _emberRouting, _emberTemplateCompiler, _emberGlimmer, _emberViews) {
  'use strict';

  var App = undefined,
      appInstance = undefined;

  function prepare() {
    _emberGlimmer.setTemplate('components/expand-it', _emberTemplateCompiler.compile('<p>hello {{yield}}</p>'));
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('Hello world {{#expand-it}}world{{/expand-it}}'));
  }

  function cleanup() {
    _emberMetal.run(function () {
      try {
        if (App) {
          App.destroy();
        }
        App = appInstance = null;
      } finally {
        _emberGlimmer.setTemplates({});
      }
    });
  }

  QUnit.module('Application Lifecycle - Component Registration', {
    setup: prepare,
    teardown: cleanup
  });

  function boot(callback) {
    var startURL = arguments.length <= 1 || arguments[1] === undefined ? '/' : arguments[1];

    _emberMetal.run(function () {
      App = _emberApplication.Application.create({
        name: 'App',
        rootElement: '#qunit-fixture'
      });

      App.deferReadiness();

      App.Router = _emberRouting.Router.extend({
        location: 'none'
      });

      appInstance = App.__deprecatedInstance__;

      if (callback) {
        callback();
      }
    });

    var router = appInstance.lookup('router:main');

    _emberMetal.run(App, 'advanceReadiness');
    _emberMetal.run(function () {
      return router.handleURL(startURL);
    });
  }

  QUnit.test('The helper becomes the body of the component', function () {
    boot();
    equal(_emberViews.jQuery('div.ember-view > div.ember-view', '#qunit-fixture').text(), 'hello world', 'The component is composed correctly');
  });

  QUnit.test('If a component is registered, it is used', function () {
    boot(function () {
      appInstance.register('component:expand-it', _emberGlimmer.Component.extend({
        classNames: 'testing123'
      }));
    });

    equal(_emberViews.jQuery('div.testing123', '#qunit-fixture').text(), 'hello world', 'The component is composed correctly');
  });

  QUnit.test('Late-registered components can be rendered with custom `layout` property', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div id=\'wrapper\'>there goes {{my-hero}}</div>'));

    boot(function () {
      appInstance.register('component:my-hero', _emberGlimmer.Component.extend({
        classNames: 'testing123',
        layout: _emberTemplateCompiler.compile('watch him as he GOES')
      }));
    });

    equal(_emberViews.jQuery('#wrapper').text(), 'there goes watch him as he GOES', 'The component is composed correctly');
  });

  QUnit.test('Late-registered components can be rendered with template registered on the container', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div id=\'wrapper\'>hello world {{sally-rutherford}}-{{#sally-rutherford}}!!!{{/sally-rutherford}}</div>'));

    boot(function () {
      appInstance.register('template:components/sally-rutherford', _emberTemplateCompiler.compile('funkytowny{{yield}}'));
      appInstance.register('component:sally-rutherford', _emberGlimmer.Component);
    });

    equal(_emberViews.jQuery('#wrapper').text(), 'hello world funkytowny-funkytowny!!!', 'The component is composed correctly');
  });

  QUnit.test('Late-registered components can be rendered with ONLY the template registered on the container', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div id=\'wrapper\'>hello world {{borf-snorlax}}-{{#borf-snorlax}}!!!{{/borf-snorlax}}</div>'));

    boot(function () {
      appInstance.register('template:components/borf-snorlax', _emberTemplateCompiler.compile('goodfreakingTIMES{{yield}}'));
    });

    equal(_emberViews.jQuery('#wrapper').text(), 'hello world goodfreakingTIMES-goodfreakingTIMES!!!', 'The component is composed correctly');
  });

  QUnit.test('Assigning layoutName to a component should setup the template as a layout', function () {
    expect(1);

    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div id=\'wrapper\'>{{#my-component}}{{text}}{{/my-component}}</div>'));
    _emberGlimmer.setTemplate('foo-bar-baz', _emberTemplateCompiler.compile('{{text}}-{{yield}}'));

    boot(function () {
      appInstance.register('controller:application', _emberRuntime.Controller.extend({
        'text': 'outer'
      }));

      appInstance.register('component:my-component', _emberGlimmer.Component.extend({
        text: 'inner',
        layoutName: 'foo-bar-baz'
      }));
    });

    equal(_emberViews.jQuery('#wrapper').text(), 'inner-outer', 'The component is composed correctly');
  });

  QUnit.test('Assigning layoutName and layout to a component should use the `layout` value', function () {
    expect(1);

    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div id=\'wrapper\'>{{#my-component}}{{text}}{{/my-component}}</div>'));
    _emberGlimmer.setTemplate('foo-bar-baz', _emberTemplateCompiler.compile('No way!'));

    boot(function () {
      appInstance.register('controller:application', _emberRuntime.Controller.extend({
        'text': 'outer'
      }));

      appInstance.register('component:my-component', _emberGlimmer.Component.extend({
        text: 'inner',
        layoutName: 'foo-bar-baz',
        layout: _emberTemplateCompiler.compile('{{text}}-{{yield}}')
      }));
    });

    equal(_emberViews.jQuery('#wrapper').text(), 'inner-outer', 'The component is composed correctly');
  });

  QUnit.test('Assigning defaultLayout to a component should set it up as a layout if no layout was found [DEPRECATED]', function () {
    expect(2);

    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div id=\'wrapper\'>{{#my-component}}{{text}}{{/my-component}}</div>'));

    expectDeprecation(function () {
      boot(function () {
        appInstance.register('controller:application', _emberRuntime.Controller.extend({
          'text': 'outer'
        }));

        appInstance.register('component:my-component', _emberGlimmer.Component.extend({
          text: 'inner',
          defaultLayout: _emberTemplateCompiler.compile('{{text}}-{{yield}}')
        }));
      });
    }, /Specifying `defaultLayout` to .+ is deprecated\./);

    equal(_emberViews.jQuery('#wrapper').text(), 'inner-outer', 'The component is composed correctly');
  });

  QUnit.test('Assigning defaultLayout to a component should set it up as a layout if layout was found [DEPRECATED]', function () {
    expect(2);

    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div id=\'wrapper\'>{{#my-component}}{{text}}{{/my-component}}</div>'));
    _emberGlimmer.setTemplate('components/my-component', _emberTemplateCompiler.compile('{{text}}-{{yield}}'));

    expectDeprecation(function () {
      boot(function () {
        appInstance.register('controller:application', _emberRuntime.Controller.extend({
          'text': 'outer'
        }));

        appInstance.register('component:my-component', _emberGlimmer.Component.extend({
          text: 'inner',
          defaultLayout: _emberTemplateCompiler.compile('should not see this!')
        }));
      });
    }, /Specifying `defaultLayout` to .+ is deprecated\./);

    equal(_emberViews.jQuery('#wrapper').text(), 'inner-outer', 'The component is composed correctly');
  });

  QUnit.test('Using name of component that does not exist', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div id=\'wrapper\'>{{#no-good}} {{/no-good}}</div>'));

    expectAssertion(function () {
      return boot();
    }, /.* named "no-good" .*/);
  });

  QUnit.module('Application Lifecycle - Component Context', {
    setup: prepare,
    teardown: cleanup
  });

  QUnit.test('Components with a block should have the proper content when a template is provided', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div id=\'wrapper\'>{{#my-component}}{{text}}{{/my-component}}</div>'));
    _emberGlimmer.setTemplate('components/my-component', _emberTemplateCompiler.compile('{{text}}-{{yield}}'));

    boot(function () {
      appInstance.register('controller:application', _emberRuntime.Controller.extend({
        'text': 'outer'
      }));

      appInstance.register('component:my-component', _emberGlimmer.Component.extend({
        text: 'inner'
      }));
    });

    equal(_emberViews.jQuery('#wrapper').text(), 'inner-outer', 'The component is composed correctly');
  });

  QUnit.test('Components with a block should yield the proper content without a template provided', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div id=\'wrapper\'>{{#my-component}}{{text}}{{/my-component}}</div>'));

    boot(function () {
      appInstance.register('controller:application', _emberRuntime.Controller.extend({
        'text': 'outer'
      }));

      appInstance.register('component:my-component', _emberGlimmer.Component.extend({
        text: 'inner'
      }));
    });

    equal(_emberViews.jQuery('#wrapper').text(), 'outer', 'The component is composed correctly');
  });

  QUnit.test('Components without a block should have the proper content when a template is provided', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div id=\'wrapper\'>{{my-component}}</div>'));
    _emberGlimmer.setTemplate('components/my-component', _emberTemplateCompiler.compile('{{text}}'));

    boot(function () {
      appInstance.register('controller:application', _emberRuntime.Controller.extend({
        'text': 'outer'
      }));

      appInstance.register('component:my-component', _emberGlimmer.Component.extend({
        text: 'inner'
      }));
    });

    equal(_emberViews.jQuery('#wrapper').text(), 'inner', 'The component is composed correctly');
  });

  QUnit.test('Components without a block should have the proper content', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div id=\'wrapper\'>{{my-component}}</div>'));

    boot(function () {
      appInstance.register('controller:application', _emberRuntime.Controller.extend({
        'text': 'outer'
      }));

      appInstance.register('component:my-component', _emberGlimmer.Component.extend({
        didInsertElement: function () {
          this.$().html('Some text inserted by jQuery');
        }
      }));
    });

    equal(_emberViews.jQuery('#wrapper').text(), 'Some text inserted by jQuery', 'The component is composed correctly');
  });

  // The test following this one is the non-deprecated version
  QUnit.test('properties of a component without a template should not collide with internal structures [DEPRECATED]', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div id=\'wrapper\'>{{my-component data=foo}}</div>'));

    boot(function () {
      appInstance.register('controller:application', _emberRuntime.Controller.extend({
        'text': 'outer',
        'foo': 'Some text inserted by jQuery'
      }));

      appInstance.register('component:my-component', _emberGlimmer.Component.extend({
        didInsertElement: function () {
          this.$().html(this.get('data'));
        }
      }));
    });

    equal(_emberViews.jQuery('#wrapper').text(), 'Some text inserted by jQuery', 'The component is composed correctly');
  });

  QUnit.test('attrs property of a component without a template should not collide with internal structures', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div id=\'wrapper\'>{{my-component attrs=foo}}</div>'));

    boot(function () {
      appInstance.register('controller:application', _emberRuntime.Controller.extend({
        'text': 'outer',
        'foo': 'Some text inserted by jQuery'
      }));

      appInstance.register('component:my-component', _emberGlimmer.Component.extend({
        didInsertElement: function () {
          // FIXME: I'm unsure if this is even the right way to access attrs
          this.$().html(this.get('attrs.attrs.value'));
        }
      }));
    });

    equal(_emberViews.jQuery('#wrapper').text(), 'Some text inserted by jQuery', 'The component is composed correctly');
  });

  QUnit.test('Components trigger actions in the parents context when called from within a block', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div id=\'wrapper\'>{{#my-component}}<a href=\'#\' id=\'fizzbuzz\' {{action \'fizzbuzz\'}}>Fizzbuzz</a>{{/my-component}}</div>'));

    boot(function () {
      appInstance.register('controller:application', _emberRuntime.Controller.extend({
        actions: {
          fizzbuzz: function () {
            ok(true, 'action triggered on parent');
          }
        }
      }));

      appInstance.register('component:my-component', _emberGlimmer.Component.extend());
    });

    _emberMetal.run(function () {
      _emberViews.jQuery('#fizzbuzz', '#wrapper').click();
    });
  });

  QUnit.test('Components trigger actions in the components context when called from within its template', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div id=\'wrapper\'>{{#my-component}}{{text}}{{/my-component}}</div>'));
    _emberGlimmer.setTemplate('components/my-component', _emberTemplateCompiler.compile('<a href=\'#\' id=\'fizzbuzz\' {{action \'fizzbuzz\'}}>Fizzbuzz</a>'));

    boot(function () {
      appInstance.register('controller:application', _emberRuntime.Controller.extend({
        actions: {
          fizzbuzz: function () {
            ok(false, 'action triggered on the wrong context');
          }
        }
      }));

      appInstance.register('component:my-component', _emberGlimmer.Component.extend({
        actions: {
          fizzbuzz: function () {
            ok(true, 'action triggered on component');
          }
        }
      }));
    });

    _emberViews.jQuery('#fizzbuzz', '#wrapper').click();
  });
});
enifed('ember/tests/component_registration_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/component_registration_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/component_registration_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/controller_test', ['exports', 'ember-runtime', 'ember-routing', 'ember-metal', 'ember-template-compiler', 'ember-application', 'ember-glimmer', 'ember-views'], function (exports, _emberRuntime, _emberRouting, _emberMetal, _emberTemplateCompiler, _emberApplication, _emberGlimmer, _emberViews) {
  'use strict';

  /*
   In Ember 1.x, controllers subtly affect things like template scope
   and action targets in exciting and often inscrutable ways. This test
   file contains integration tests that verify the correct behavior of
   the many parts of the system that change and rely upon controller scope,
   from the runtime up to the templating layer.
  */

  var App = undefined,
      $fixture = undefined;

  QUnit.module('Template scoping examples', {
    setup: function () {
      _emberMetal.run(function () {
        App = _emberApplication.Application.create({
          name: 'App',
          rootElement: '#qunit-fixture'
        });
        App.deferReadiness();

        App.Router.reopen({
          location: 'none'
        });

        App.LoadingRoute = _emberRouting.Route.extend();
      });

      $fixture = _emberViews.jQuery('#qunit-fixture');
    },

    teardown: function () {
      _emberMetal.run(function () {
        return App.destroy();
      });

      App = null;

      _emberGlimmer.setTemplates({});
    }
  });

  QUnit.test('Actions inside an outlet go to the associated controller', function () {
    expect(1);

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{component-with-action action=\'componentAction\'}}'));

    App.IndexController = _emberRuntime.Controller.extend({
      actions: {
        componentAction: function () {
          ok(true, 'received the click');
        }
      }
    });

    App.ComponentWithActionComponent = _emberGlimmer.Component.extend({
      classNames: ['component-with-action'],
      click: function () {
        this.sendAction();
      }
    });

    bootApp();

    $fixture.find('.component-with-action').click();
  });

  function bootApp() {
    _emberMetal.run(App, 'advanceReadiness');
  }
});
enifed('ember/tests/controller_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/controller_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/controller_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/global-api-test', ['exports', 'ember-metal', 'ember-runtime'], function (exports, _emberMetal, _emberRuntime) {
  'use strict';

  QUnit.module('Global API Tests');

  function confirmExport(property, internal) {
    QUnit.test('confirm ' + property + ' is exported', function () {
      var theExport = _emberMetal.get(window, property);
      ok(theExport + ' is exported');
      if (internal !== undefined) {
        equal(theExport, internal, theExport + ' is exported properly');
      }
    });
  }

  confirmExport('Ember.DefaultResolver');
  confirmExport('Ember.generateController');
  confirmExport('Ember.Helper');
  confirmExport('Ember.Helper.helper');
  confirmExport('Ember.isArray', _emberRuntime.isArray);
});
enifed('ember/tests/global-api-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/global-api-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/global-api-test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/helpers/helper_registration_test', ['exports', 'ember-runtime', 'ember-metal', 'ember-template-compiler', 'ember-glimmer', 'ember-application', 'ember-routing', 'ember-views'], function (exports, _emberRuntime, _emberMetal, _emberTemplateCompiler, _emberGlimmer, _emberApplication, _emberRouting, _emberViews) {
  'use strict';

  var App = undefined,
      appInstance = undefined;

  QUnit.module('Application Lifecycle - Helper Registration', {
    teardown: function () {
      _emberMetal.run(function () {
        if (App) {
          App.destroy();
        }

        App = appInstance = null;
        _emberGlimmer.setTemplates({});
      });
    }
  });

  function boot(callback) {
    _emberMetal.run(function () {
      App = _emberApplication.Application.create({
        name: 'App',
        rootElement: '#qunit-fixture'
      });

      App.deferReadiness();

      App.Router = _emberRouting.Router.extend({
        location: 'none'
      });

      // We shouldn't be testing this
      appInstance = App.__deprecatedInstance__;

      if (callback) {
        callback();
      }
    });

    var router = appInstance.lookup('router:main');

    _emberMetal.run(App, 'advanceReadiness');
    _emberMetal.run(function () {
      return router.handleURL('/');
    });
  }

  QUnit.test('Unbound dashed helpers registered on the container can be late-invoked', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div id=\'wrapper\'>{{x-borf}} {{x-borf \'YES\'}}</div>'));
    var myHelper = _emberGlimmer.helper(function (params) {
      return params[0] || 'BORF';
    });

    boot(function () {
      App.register('helper:x-borf', myHelper);
    });

    equal(_emberViews.jQuery('#wrapper').text(), 'BORF YES', 'The helper was invoked from the container');
  });

  QUnit.test('Bound helpers registered on the container can be late-invoked', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div id=\'wrapper\'>{{x-reverse}} {{x-reverse foo}}</div>'));

    boot(function () {
      appInstance.register('controller:application', _emberRuntime.Controller.extend({
        foo: 'alex'
      }));

      appInstance.register('helper:x-reverse', _emberGlimmer.helper(function (_ref) {
        var value = _ref[0];

        return value ? value.split('').reverse().join('') : '--';
      }));
    });

    equal(_emberViews.jQuery('#wrapper').text(), '-- xela', 'The bound helper was invoked from the container');
  });

  QUnit.test('Undashed helpers registered on the container can be invoked', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div id=\'wrapper\'>{{omg}}|{{yorp \'boo\'}}|{{yorp \'ya\'}}</div>'));

    boot(function () {
      appInstance.register('helper:omg', _emberGlimmer.helper(function () {
        return 'OMG';
      }));

      appInstance.register('helper:yorp', _emberGlimmer.helper(function (_ref2) {
        var value = _ref2[0];
        return value;
      }));
    });

    equal(_emberViews.jQuery('#wrapper').text(), 'OMG|boo|ya', 'The helper was invoked from the container');
  });

  QUnit.test('Helpers can receive injections', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div id=\'wrapper\'>{{full-name}}</div>'));

    var serviceCalled = false;
    boot(function () {
      appInstance.register('service:name-builder', _emberRuntime.Service.extend({
        build: function () {
          serviceCalled = true;
        }
      }));
      appInstance.register('helper:full-name', _emberGlimmer.Helper.extend({
        nameBuilder: _emberRuntime.inject.service('name-builder'),
        compute: function () {
          this.get('nameBuilder').build();
        }
      }));
    });

    ok(serviceCalled, 'service was injected, method called');
  });
});
enifed('ember/tests/helpers/helper_registration_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/helpers/helper_registration_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/helpers/helper_registration_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/helpers/link_to_test', ['exports', 'ember-console', 'ember-runtime', 'ember-metal', 'ember-routing', 'ember-application', 'ember-views', 'ember-template-compiler', 'ember-glimmer'], function (exports, _emberConsole, _emberRuntime, _emberMetal, _emberRouting, _emberApplication, _emberViews, _emberTemplateCompiler, _emberGlimmer) {
  'use strict';

  var Router = undefined,
      App = undefined,
      router = undefined,
      appInstance = undefined;

  function bootApplication() {
    router = appInstance.lookup('router:main');
    _emberMetal.run(App, 'advanceReadiness');
  }

  // IE includes the host name
  function normalizeUrl(url) {
    return url.replace(/https?:\/\/[^\/]+/, '');
  }

  function shouldNotBeActive(selector) {
    checkActive(selector, false);
  }

  function shouldBeActive(selector) {
    checkActive(selector, true);
  }

  function checkActive(selector, active) {
    var classList = _emberViews.jQuery(selector, '#qunit-fixture')[0].className;
    equal(classList.indexOf('active') > -1, active, selector + ' active should be ' + active.toString());
  }

  var updateCount = undefined,
      replaceCount = undefined;

  function sharedSetup() {
    App = _emberApplication.Application.create({
      name: 'App',
      rootElement: '#qunit-fixture'
    });

    App.deferReadiness();

    updateCount = replaceCount = 0;
    App.Router.reopen({
      location: _emberRouting.NoneLocation.create({
        setURL: function (path) {
          updateCount++;
          _emberMetal.set(this, 'path', path);
        },

        replaceURL: function (path) {
          replaceCount++;
          _emberMetal.set(this, 'path', path);
        }
      })
    });

    Router = App.Router;
    appInstance = App.__deprecatedInstance__;
  }

  function sharedTeardown() {
    _emberMetal.run(function () {
      return App.destroy();
    });
    _emberGlimmer.setTemplates({});
    _emberMetal.instrumentationReset();
  }

  QUnit.module('The {{link-to}} helper', {
    setup: function () {
      _emberMetal.run(function () {
        sharedSetup();

        _emberGlimmer.setTemplate('app', _emberTemplateCompiler.compile('{{outlet}}'));
        _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<h3>Home</h3>{{#link-to \'about\' id=\'about-link\'}}About{{/link-to}}{{#link-to \'index\' id=\'self-link\'}}Self{{/link-to}}'));
        _emberGlimmer.setTemplate('about', _emberTemplateCompiler.compile('<h3>About</h3>{{#link-to \'index\' id=\'home-link\'}}Home{{/link-to}}{{#link-to \'about\' id=\'self-link\'}}Self{{/link-to}}'));
        _emberGlimmer.setTemplate('item', _emberTemplateCompiler.compile('<h3>Item</h3><p>{{model.name}}</p>{{#link-to \'index\' id=\'home-link\'}}Home{{/link-to}}'));

        appInstance.unregister('router:main');
        appInstance.register('router:main', Router);
      });
    },

    teardown: sharedTeardown
  });

  QUnit.test('The {{link-to}} helper moves into the named route', function () {
    Router.map(function (match) {
      this.route('about');
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    equal(_emberViews.jQuery('h3:contains(Home)', '#qunit-fixture').length, 1, 'The home template was rendered');
    equal(_emberViews.jQuery('#self-link.active', '#qunit-fixture').length, 1, 'The self-link was rendered with active class');
    equal(_emberViews.jQuery('#about-link:not(.active)', '#qunit-fixture').length, 1, 'The other link was rendered without active class');

    _emberMetal.run(function () {
      return _emberViews.jQuery('#about-link', '#qunit-fixture').click();
    });

    equal(_emberViews.jQuery('h3:contains(About)', '#qunit-fixture').length, 1, 'The about template was rendered');
    equal(_emberViews.jQuery('#self-link.active', '#qunit-fixture').length, 1, 'The self-link was rendered with active class');
    equal(_emberViews.jQuery('#home-link:not(.active)', '#qunit-fixture').length, 1, 'The other link was rendered without active class');
  });

  if (_emberMetal.isFeatureEnabled('ember-improved-instrumentation')) {
    QUnit.test('The {{link-to}} helper fires an interaction event', function (assert) {
      assert.expect(2);
      Router.map(function (match) {
        this.route('about');
      });

      bootApplication();

      _emberMetal.run(function () {
        return router.handleURL('/');
      });

      _emberMetal.instrumentationSubscribe('interaction.link-to', {
        before: function () {
          assert.ok(true, 'instrumentation subscriber was called');
        },
        after: function () {
          assert.ok(true, 'instrumentation subscriber was called');
        }
      });

      _emberViews.jQuery('#about-link', '#qunit-fixture').click();
    });

    QUnit.test('The {{link-to}} helper interaction event includes the route name', function (assert) {
      assert.expect(2);
      Router.map(function (match) {
        this.route('about');
      });

      bootApplication();

      _emberMetal.run(function () {
        return router.handleURL('/');
      });

      _emberMetal.instrumentationSubscribe('interaction.link-to', {
        before: function (name, timestamp, _ref) {
          var routeName = _ref.routeName;

          assert.equal(routeName, 'about', 'instrumentation subscriber was passed route name');
        },
        after: function (name, timestamp, _ref2) {
          var routeName = _ref2.routeName;

          assert.equal(routeName, 'about', 'instrumentation subscriber was passed route name');
        }
      });

      _emberViews.jQuery('#about-link', '#qunit-fixture').click();
    });

    QUnit.test('The {{link-to}} helper interaction event includes the transition in the after hook', function (assert) {
      assert.expect(1);
      Router.map(function (match) {
        this.route('about');
      });

      bootApplication();

      _emberMetal.run(function () {
        return router.handleURL('/');
      });

      _emberMetal.instrumentationSubscribe('interaction.link-to', {
        before: function () {},
        after: function (name, timestamp, _ref3) {
          var transition = _ref3.transition;

          assert.equal(transition.targetName, 'about', 'instrumentation subscriber was passed route name');
        }
      });

      _emberViews.jQuery('#about-link', '#qunit-fixture').click();
    });
  }

  QUnit.test('The {{link-to}} helper supports URL replacement', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<h3>Home</h3>{{#link-to \'about\' id=\'about-link\' replace=true}}About{{/link-to}}'));

    Router.map(function () {
      this.route('about');
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    equal(updateCount, 0, 'precond: setURL has not been called');
    equal(replaceCount, 0, 'precond: replaceURL has not been called');

    _emberMetal.run(function () {
      return _emberViews.jQuery('#about-link', '#qunit-fixture').click();
    });

    equal(updateCount, 0, 'setURL should not be called');
    equal(replaceCount, 1, 'replaceURL should be called once');
  });

  QUnit.test('The {{link-to}} helper supports URL replacement via replace=boundTruthyThing', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<h3>Home</h3>{{#link-to \'about\' id=\'about-link\' replace=boundTruthyThing}}About{{/link-to}}'));

    App.IndexController = _emberRuntime.Controller.extend({
      boundTruthyThing: true
    });

    Router.map(function () {
      this.route('about');
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    equal(updateCount, 0, 'precond: setURL has not been called');
    equal(replaceCount, 0, 'precond: replaceURL has not been called');

    _emberMetal.run(function () {
      return _emberViews.jQuery('#about-link', '#qunit-fixture').click();
    });

    equal(updateCount, 0, 'setURL should not be called');
    equal(replaceCount, 1, 'replaceURL should be called once');
  });

  QUnit.test('The {{link-to}} helper supports setting replace=boundFalseyThing', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<h3>Home</h3>{{#link-to \'about\' id=\'about-link\' replace=boundFalseyThing}}About{{/link-to}}'));

    App.IndexController = _emberRuntime.Controller.extend({
      boundFalseyThing: false
    });

    Router.map(function () {
      this.route('about');
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    equal(updateCount, 0, 'precond: setURL has not been called');
    equal(replaceCount, 0, 'precond: replaceURL has not been called');

    _emberMetal.run(function () {
      return _emberViews.jQuery('#about-link', '#qunit-fixture').click();
    });

    equal(updateCount, 1, 'setURL should be called');
    equal(replaceCount, 0, 'replaceURL should not be called');
  });

  // jscs:disable

  QUnit.test("the {{link-to}} helper doesn't add an href when the tagName isn't 'a'", function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#link-to \'about\' id=\'about-link\' tagName=\'div\'}}About{{/link-to}}'));

    Router.map(function () {
      this.route('about');
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    equal(_emberViews.jQuery('#about-link').attr('href'), undefined, 'there is no href attribute');
  });

  QUnit.test("the {{link-to}} applies a 'disabled' class when disabled", function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('\n    {{#link-to "about" id="about-link-static" disabledWhen="shouldDisable"}}About{{/link-to}}\n    {{#link-to "about" id="about-link-dynamic" disabledWhen=dynamicDisabledWhen}}About{{/link-to}}\n  '));

    App.IndexController = _emberRuntime.Controller.extend({
      shouldDisable: true,
      dynamicDisabledWhen: 'shouldDisable'
    });

    Router.map(function () {
      this.route('about');
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    equal(_emberViews.jQuery('#about-link-static.disabled', '#qunit-fixture').length, 1, 'The static link is disabled when its disabledWhen is true');
    equal(_emberViews.jQuery('#about-link-dynamic.disabled', '#qunit-fixture').length, 1, 'The dynamic link is disabled when its disabledWhen is true');

    _emberMetal.run(function () {
      return _emberMetal.set(appInstance.lookup('controller:index'), 'dynamicDisabledWhen', false);
    });

    equal(_emberViews.jQuery('#about-link-dynamic.disabled', '#qunit-fixture').length, 0, 'The dynamic link is re-enabled when its disabledWhen becomes false');
  });

  QUnit.test("the {{link-to}} doesn't apply a 'disabled' class if disabledWhen is not provided", function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#link-to "about" id="about-link"}}About{{/link-to}}'));

    Router.map(function () {
      this.route('about');
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    ok(!_emberViews.jQuery('#about-link', '#qunit-fixture').hasClass('disabled'), 'The link is not disabled if disabledWhen not provided');
  });

  QUnit.test('the {{link-to}} helper supports a custom disabledClass', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#link-to "about" id="about-link" disabledWhen=true disabledClass="do-not-want"}}About{{/link-to}}'));

    Router.map(function () {
      this.route('about');
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    equal(_emberViews.jQuery('#about-link.do-not-want', '#qunit-fixture').length, 1, 'The link can apply a custom disabled class');
  });

  QUnit.test('the {{link-to}} helper supports a custom disabledClass set via bound param', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#link-to "about" id="about-link" disabledWhen=true disabledClass=disabledClass}}About{{/link-to}}'));

    Router.map(function () {
      this.route('about');
    });

    App.IndexController = _emberRuntime.Controller.extend({
      disabledClass: 'do-not-want'
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    equal(_emberViews.jQuery('#about-link.do-not-want', '#qunit-fixture').length, 1, 'The link can apply a custom disabled class via bound param');
  });

  QUnit.test('the {{link-to}} helper does not respond to clicks when disabled', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#link-to "about" id="about-link" disabledWhen=true}}About{{/link-to}}'));

    Router.map(function () {
      this.route('about');
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    _emberMetal.run(function () {
      return _emberViews.jQuery('#about-link', '#qunit-fixture').click();
    });

    equal(_emberViews.jQuery('h3:contains(About)', '#qunit-fixture').length, 0, 'Transitioning did not occur');
  });

  QUnit.test('the {{link-to}} helper responds to clicks according to its disabledWhen bound param', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#link-to "about" id="about-link" disabledWhen=disabledWhen}}About{{/link-to}}'));

    Router.map(function () {
      this.route('about');
    });

    App.IndexController = _emberRuntime.Controller.extend({
      disabledWhen: true
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    _emberMetal.run(function () {
      return _emberViews.jQuery('#about-link', '#qunit-fixture').click();
    });

    equal(_emberViews.jQuery('h3:contains(About)', '#qunit-fixture').length, 0, 'Transitioning did not occur');

    _emberMetal.run(function () {
      return _emberMetal.set(appInstance.lookup('controller:index'), 'disabledWhen', false);
    });
    _emberMetal.run(function () {
      return _emberViews.jQuery('#about-link', '#qunit-fixture').click();
    });

    equal(_emberViews.jQuery('h3:contains(About)', '#qunit-fixture').length, 1, 'Transitioning did occur when disabledWhen became false');
  });

  QUnit.test('The {{link-to}} helper supports a custom activeClass', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile("<h3>Home</h3>{{#link-to 'about' id='about-link'}}About{{/link-to}}{{#link-to 'index' id='self-link' activeClass='zomg-active'}}Self{{/link-to}}"));

    Router.map(function () {
      this.route('about');
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    equal(_emberViews.jQuery('h3:contains(Home)', '#qunit-fixture').length, 1, 'The home template was rendered');
    equal(_emberViews.jQuery('#self-link.zomg-active', '#qunit-fixture').length, 1, 'The self-link was rendered with active class');
    equal(_emberViews.jQuery('#about-link:not(.active)', '#qunit-fixture').length, 1, 'The other link was rendered without active class');
  });

  QUnit.test('The {{link-to}} helper supports a custom activeClass from a bound param', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<h3>Home</h3>{{#link-to \'about\' id=\'about-link\'}}About{{/link-to}}{{#link-to \'index\' id=\'self-link\' activeClass=activeClass}}Self{{/link-to}}'));

    Router.map(function () {
      this.route('about');
    });

    App.IndexController = _emberRuntime.Controller.extend({
      activeClass: 'zomg-active'
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    equal(_emberViews.jQuery('h3:contains(Home)', '#qunit-fixture').length, 1, 'The home template was rendered');
    equal(_emberViews.jQuery('#self-link.zomg-active', '#qunit-fixture').length, 1, 'The self-link was rendered with active class');
    equal(_emberViews.jQuery('#about-link:not(.active)', '#qunit-fixture').length, 1, 'The other link was rendered without active class');
  });

  QUnit.test("The {{link-to}} helper supports 'classNameBindings' with custom values [GH #11699]", function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<h3>Home</h3>{{#link-to \'about\' id=\'about-link\' classNameBindings=\'foo:foo-is-true:foo-is-false\'}}About{{/link-to}}'));

    Router.map(function () {
      this.route('about');
    });

    App.IndexController = _emberRuntime.Controller.extend({
      foo: false
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    equal(_emberViews.jQuery('#about-link.foo-is-false', '#qunit-fixture').length, 1, 'The about-link was rendered with the falsy class');

    var controller = appInstance.lookup('controller:index');

    _emberMetal.run(function () {
      return controller.set('foo', true);
    });

    equal(_emberViews.jQuery('#about-link.foo-is-true', '#qunit-fixture').length, 1, 'The about-link was rendered with the truthy class after toggling the property');
  });

  QUnit.test('The {{link-to}} helper supports leaving off .index for nested routes', function () {
    Router.map(function () {
      this.route('about', function () {
        this.route('item');
      });
    });

    _emberGlimmer.setTemplate('about', _emberTemplateCompiler.compile('<h1>About</h1>{{outlet}}'));
    _emberGlimmer.setTemplate('about/index', _emberTemplateCompiler.compile("<div id='index'>Index</div>"));
    _emberGlimmer.setTemplate('about/item', _emberTemplateCompiler.compile("<div id='item'>{{#link-to 'about'}}About{{/link-to}}</div>"));

    bootApplication();

    _emberMetal.run(router, 'handleURL', '/about/item');

    equal(normalizeUrl(_emberViews.jQuery('#item a', '#qunit-fixture').attr('href')), '/about');
  });

  QUnit.test('The {{link-to}} helper supports currentWhen (DEPRECATED)', function () {
    expectDeprecation('Usage of `currentWhen` is deprecated, use `current-when` instead.');

    Router.map(function (match) {
      this.route('index', { path: '/' }, function () {
        this.route('about');
      });

      this.route('item');
    });

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<h3>Home</h3>{{outlet}}'));
    _emberGlimmer.setTemplate('index/about', _emberTemplateCompiler.compile("{{#link-to 'item' id='other-link' currentWhen='index'}}ITEM{{/link-to}}"));

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/about');
    });

    equal(_emberViews.jQuery('#other-link.active', '#qunit-fixture').length, 1, 'The link is active since current-when is a parent route');
  });

  QUnit.test('The {{link-to}} helper supports custom, nested, current-when', function () {
    Router.map(function (match) {
      this.route('index', { path: '/' }, function () {
        this.route('about');
      });

      this.route('item');
    });

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<h3>Home</h3>{{outlet}}'));
    _emberGlimmer.setTemplate('index/about', _emberTemplateCompiler.compile("{{#link-to 'item' id='other-link' current-when='index'}}ITEM{{/link-to}}"));

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/about');
    });

    equal(_emberViews.jQuery('#other-link.active', '#qunit-fixture').length, 1, 'The link is active since current-when is a parent route');
  });

  QUnit.test('The {{link-to}} helper does not disregard current-when when it is given explicitly for a route', function () {
    Router.map(function (match) {
      this.route('index', { path: '/' }, function () {
        this.route('about');
      });

      this.route('items', function () {
        this.route('item');
      });
    });

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<h3>Home</h3>{{outlet}}'));
    _emberGlimmer.setTemplate('index/about', _emberTemplateCompiler.compile("{{#link-to 'items' id='other-link' current-when='index'}}ITEM{{/link-to}}"));

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/about');
    });

    equal(_emberViews.jQuery('#other-link.active', '#qunit-fixture').length, 1, 'The link is active when current-when is given for explicitly for a route');
  });

  QUnit.test('The {{link-to}} helper does not disregard current-when when it is set via a bound param', function () {
    Router.map(function (match) {
      this.route('index', { path: '/' }, function () {
        this.route('about');
      });

      this.route('items', function () {
        this.route('item');
      });
    });

    App.IndexAboutController = _emberRuntime.Controller.extend({
      currentWhen: 'index'
    });

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<h3>Home</h3>{{outlet}}'));
    _emberGlimmer.setTemplate('index/about', _emberTemplateCompiler.compile("{{#link-to 'items' id='other-link' current-when=currentWhen}}ITEM{{/link-to}}"));

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/about');
    });

    equal(_emberViews.jQuery('#other-link.active', '#qunit-fixture').length, 1, 'The link is active when current-when is given for explicitly for a route');
  });

  QUnit.test('The {{link-to}} helper supports multiple current-when routes', function () {
    Router.map(function (match) {
      this.route('index', { path: '/' }, function () {
        this.route('about');
      });
      this.route('item');
      this.route('foo');
    });

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<h3>Home</h3>{{outlet}}'));
    _emberGlimmer.setTemplate('index/about', _emberTemplateCompiler.compile("{{#link-to 'item' id='link1' current-when='item index'}}ITEM{{/link-to}}"));
    _emberGlimmer.setTemplate('item', _emberTemplateCompiler.compile("{{#link-to 'item' id='link2' current-when='item index'}}ITEM{{/link-to}}"));
    _emberGlimmer.setTemplate('foo', _emberTemplateCompiler.compile("{{#link-to 'item' id='link3' current-when='item index'}}ITEM{{/link-to}}"));

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/about');
    });

    equal(_emberViews.jQuery('#link1.active', '#qunit-fixture').length, 1, 'The link is active since current-when contains the parent route');

    _emberMetal.run(function () {
      return router.handleURL('/item');
    });

    equal(_emberViews.jQuery('#link2.active', '#qunit-fixture').length, 1, 'The link is active since you are on the active route');

    _emberMetal.run(function () {
      return router.handleURL('/foo');
    });

    equal(_emberViews.jQuery('#link3.active', '#qunit-fixture').length, 0, 'The link is not active since current-when does not contain the active route');
  });

  QUnit.test('The {{link-to}} helper defaults to bubbling', function () {
    _emberGlimmer.setTemplate('about', _emberTemplateCompiler.compile("<div {{action 'hide'}}>{{#link-to 'about.contact' id='about-contact'}}About{{/link-to}}</div>{{outlet}}"));
    _emberGlimmer.setTemplate('about/contact', _emberTemplateCompiler.compile("<h1 id='contact'>Contact</h1>"));

    Router.map(function () {
      this.route('about', function () {
        this.route('contact');
      });
    });

    var hidden = 0;

    App.AboutRoute = _emberRouting.Route.extend({
      actions: {
        hide: function () {
          hidden++;
        }
      }
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/about');
    });

    _emberMetal.run(function () {
      return _emberViews.jQuery('#about-contact', '#qunit-fixture').click();
    });

    equal(_emberViews.jQuery('#contact', '#qunit-fixture').text(), 'Contact', 'precond - the link worked');

    equal(hidden, 1, 'The link bubbles');
  });

  QUnit.test('The {{link-to}} helper supports bubbles=false', function () {
    _emberGlimmer.setTemplate('about', _emberTemplateCompiler.compile("<div {{action 'hide'}}>{{#link-to 'about.contact' id='about-contact' bubbles=false}}About{{/link-to}}</div>{{outlet}}"));
    _emberGlimmer.setTemplate('about/contact', _emberTemplateCompiler.compile("<h1 id='contact'>Contact</h1>"));

    Router.map(function () {
      this.route('about', function () {
        this.route('contact');
      });
    });

    var hidden = 0;

    App.AboutRoute = _emberRouting.Route.extend({
      actions: {
        hide: function () {
          hidden++;
        }
      }
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/about');
    });

    _emberMetal.run(function () {
      return _emberViews.jQuery('#about-contact', '#qunit-fixture').click();
    });

    equal(_emberViews.jQuery('#contact', '#qunit-fixture').text(), 'Contact', 'precond - the link worked');

    equal(hidden, 0, "The link didn't bubble");
  });

  QUnit.test('The {{link-to}} helper supports bubbles=boundFalseyThing', function () {
    _emberGlimmer.setTemplate('about', _emberTemplateCompiler.compile("<div {{action 'hide'}}>{{#link-to 'about.contact' id='about-contact' bubbles=boundFalseyThing}}About{{/link-to}}</div>{{outlet}}"));
    _emberGlimmer.setTemplate('about/contact', _emberTemplateCompiler.compile("<h1 id='contact'>Contact</h1>"));

    App.AboutController = _emberRuntime.Controller.extend({
      boundFalseyThing: false
    });

    Router.map(function () {
      this.route('about', function () {
        this.route('contact');
      });
    });

    var hidden = 0;

    App.AboutRoute = _emberRouting.Route.extend({
      actions: {
        hide: function () {
          hidden++;
        }
      }
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/about');
    });
    _emberMetal.run(function () {
      return _emberViews.jQuery('#about-contact', '#qunit-fixture').click();
    });

    equal(_emberViews.jQuery('#contact', '#qunit-fixture').text(), 'Contact', 'precond - the link worked');

    equal(hidden, 0, "The link didn't bubble");
  });

  QUnit.test('The {{link-to}} helper moves into the named route with context', function () {
    Router.map(function (match) {
      this.route('about');
      this.route('item', { path: '/item/:id' });
    });

    _emberGlimmer.setTemplate('about', _emberTemplateCompiler.compile("<h3>List</h3><ul>{{#each model as |person|}}<li>{{#link-to 'item' person}}{{person.name}}{{/link-to}}</li>{{/each}}</ul>{{#link-to 'index' id='home-link'}}Home{{/link-to}}"));

    App.AboutRoute = _emberRouting.Route.extend({
      model: function () {
        return _emberRuntime.A([{ id: 'yehuda', name: 'Yehuda Katz' }, { id: 'tom', name: 'Tom Dale' }, { id: 'erik', name: 'Erik Brynroflsson' }]);
      }
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/about');
    });

    equal(_emberViews.jQuery('h3:contains(List)', '#qunit-fixture').length, 1, 'The home template was rendered');
    equal(normalizeUrl(_emberViews.jQuery('#home-link').attr('href')), '/', 'The home link points back at /');

    _emberMetal.run(function () {
      return _emberViews.jQuery('li a:contains(Yehuda)', '#qunit-fixture').click();
    });

    equal(_emberViews.jQuery('h3:contains(Item)', '#qunit-fixture').length, 1, 'The item template was rendered');
    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), 'Yehuda Katz', 'The name is correct');

    _emberMetal.run(function () {
      return _emberViews.jQuery('#home-link').click();
    });
    _emberMetal.run(function () {
      return _emberViews.jQuery('#about-link').click();
    });

    equal(normalizeUrl(_emberViews.jQuery('li a:contains(Yehuda)').attr('href')), '/item/yehuda');
    equal(normalizeUrl(_emberViews.jQuery('li a:contains(Tom)').attr('href')), '/item/tom');
    equal(normalizeUrl(_emberViews.jQuery('li a:contains(Erik)').attr('href')), '/item/erik');

    _emberMetal.run(function () {
      return _emberViews.jQuery('li a:contains(Erik)', '#qunit-fixture').click();
    });

    equal(_emberViews.jQuery('h3:contains(Item)', '#qunit-fixture').length, 1, 'The item template was rendered');
    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), 'Erik Brynroflsson', 'The name is correct');
  });

  QUnit.test('The {{link-to}} helper binds some anchor html tag common attributes', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile("<h3>Home</h3>{{#link-to 'index' id='self-link' title='title-attr' rel='rel-attr' tabindex='-1'}}Self{{/link-to}}"));
    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    var link = _emberViews.jQuery('#self-link', '#qunit-fixture');
    equal(link.attr('title'), 'title-attr', 'The self-link contains title attribute');
    equal(link.attr('rel'), 'rel-attr', 'The self-link contains rel attribute');
    equal(link.attr('tabindex'), '-1', 'The self-link contains tabindex attribute');
  });

  QUnit.test('The {{link-to}} helper supports `target` attribute', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile("<h3>Home</h3>{{#link-to 'index' id='self-link' target='_blank'}}Self{{/link-to}}"));
    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    var link = _emberViews.jQuery('#self-link', '#qunit-fixture');
    equal(link.attr('target'), '_blank', 'The self-link contains `target` attribute');
  });

  QUnit.test('The {{link-to}} helper supports `target` attribute specified as a bound param', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile("<h3>Home</h3>{{#link-to 'index' id='self-link' target=boundLinkTarget}}Self{{/link-to}}"));

    App.IndexController = _emberRuntime.Controller.extend({
      boundLinkTarget: '_blank'
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    var link = _emberViews.jQuery('#self-link', '#qunit-fixture');
    equal(link.attr('target'), '_blank', 'The self-link contains `target` attribute');
  });

  QUnit.test('The {{link-to}} helper does not call preventDefault if `target` attribute is provided', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile("<h3>Home</h3>{{#link-to 'index' id='self-link' target='_blank'}}Self{{/link-to}}"));
    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    var event = _emberViews.jQuery.Event('click');
    _emberViews.jQuery('#self-link', '#qunit-fixture').trigger(event);

    equal(event.isDefaultPrevented(), false, 'should not preventDefault when target attribute is specified');
  });

  QUnit.test('The {{link-to}} helper should preventDefault when `target = _self`', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile("<h3>Home</h3>{{#link-to 'index' id='self-link' target='_self'}}Self{{/link-to}}"));
    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    var event = _emberViews.jQuery.Event('click');
    _emberViews.jQuery('#self-link', '#qunit-fixture').trigger(event);

    equal(event.isDefaultPrevented(), true, 'should preventDefault when target attribute is `_self`');
  });

  QUnit.test('The {{link-to}} helper should not transition if target is not equal to _self or empty', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile("{{#link-to 'about' id='about-link' replace=true target='_blank'}}About{{/link-to}}"));

    Router.map(function () {
      this.route('about');
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });
    _emberMetal.run(function () {
      return _emberViews.jQuery('#about-link', '#qunit-fixture').click();
    });

    notEqual(appInstance.lookup('controller:application').get('currentRouteName'), 'about', 'link-to should not transition if target is not equal to _self or empty');
  });

  QUnit.test('The {{link-to}} helper accepts string/numeric arguments', function () {
    Router.map(function () {
      this.route('filter', { path: '/filters/:filter' });
      this.route('post', { path: '/post/:post_id' });
      this.route('repo', { path: '/repo/:owner/:name' });
    });

    App.FilterController = _emberRuntime.Controller.extend({
      filter: 'unpopular',
      repo: _emberRuntime.Object.create({ owner: 'ember', name: 'ember.js' }),
      post_id: 123
    });
    _emberGlimmer.setTemplate('filter', _emberTemplateCompiler.compile('<p>{{filter}}</p>{{#link-to "filter" "unpopular" id="link"}}Unpopular{{/link-to}}{{#link-to "filter" filter id="path-link"}}Unpopular{{/link-to}}{{#link-to "post" post_id id="post-path-link"}}Post{{/link-to}}{{#link-to "post" 123 id="post-number-link"}}Post{{/link-to}}{{#link-to "repo" repo id="repo-object-link"}}Repo{{/link-to}}'));

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile(' '));

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/filters/popular');
    });

    equal(normalizeUrl(_emberViews.jQuery('#link', '#qunit-fixture').attr('href')), '/filters/unpopular');
    equal(normalizeUrl(_emberViews.jQuery('#path-link', '#qunit-fixture').attr('href')), '/filters/unpopular');
    equal(normalizeUrl(_emberViews.jQuery('#post-path-link', '#qunit-fixture').attr('href')), '/post/123');
    equal(normalizeUrl(_emberViews.jQuery('#post-number-link', '#qunit-fixture').attr('href')), '/post/123');
    equal(normalizeUrl(_emberViews.jQuery('#repo-object-link', '#qunit-fixture').attr('href')), '/repo/ember/ember.js');
  });

  QUnit.test("Issue 4201 - Shorthand for route.index shouldn't throw errors about context arguments", function () {
    expect(2);
    Router.map(function () {
      this.route('lobby', function () {
        this.route('index', { path: ':lobby_id' });
        this.route('list');
      });
    });

    App.LobbyIndexRoute = _emberRouting.Route.extend({
      model: function (params) {
        equal(params.lobby_id, 'foobar');
        return params.lobby_id;
      }
    });

    _emberGlimmer.setTemplate('lobby/index', _emberTemplateCompiler.compile("{{#link-to 'lobby' 'foobar' id='lobby-link'}}Lobby{{/link-to}}"));
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile(''));
    _emberGlimmer.setTemplate('lobby/list', _emberTemplateCompiler.compile("{{#link-to 'lobby' 'foobar' id='lobby-link'}}Lobby{{/link-to}}"));
    bootApplication();
    _emberMetal.run(router, 'handleURL', '/lobby/list');
    _emberMetal.run(_emberViews.jQuery('#lobby-link'), 'click');
    shouldBeActive('#lobby-link');
  });

  QUnit.test('Quoteless route param performs property lookup', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile("{{#link-to 'index' id='string-link'}}string{{/link-to}}{{#link-to foo id='path-link'}}path{{/link-to}}"));

    function assertEquality(href) {
      equal(normalizeUrl(_emberViews.jQuery('#string-link', '#qunit-fixture').attr('href')), '/');
      equal(normalizeUrl(_emberViews.jQuery('#path-link', '#qunit-fixture').attr('href')), href);
    }

    App.IndexController = _emberRuntime.Controller.extend({
      foo: 'index'
    });

    App.Router.map(function () {
      this.route('about');
    });

    bootApplication();

    _emberMetal.run(router, 'handleURL', '/');

    assertEquality('/');

    var controller = appInstance.lookup('controller:index');
    _emberMetal.run(function () {
      return controller.set('foo', 'about');
    });

    assertEquality('/about');
  });

  QUnit.test('link-to with null/undefined dynamic parameters are put in a loading state', function () {
    expect(19);

    var oldWarn = _emberConsole.default.warn;
    var warnCalled = false;
    _emberConsole.default.warn = function () {
      warnCalled = true;
    };
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile("{{#link-to destinationRoute routeContext loadingClass='i-am-loading' id='context-link'}}string{{/link-to}}{{#link-to secondRoute loadingClass=loadingClass id='static-link'}}string{{/link-to}}"));

    var thing = _emberRuntime.Object.create({ id: 123 });

    App.IndexController = _emberRuntime.Controller.extend({
      destinationRoute: null,
      routeContext: null,
      loadingClass: 'i-am-loading'
    });

    App.AboutRoute = _emberRouting.Route.extend({
      activate: function () {
        ok(true, 'About was entered');
      }
    });

    App.Router.map(function () {
      this.route('thing', { path: '/thing/:thing_id' });
      this.route('about');
    });

    bootApplication();

    _emberMetal.run(router, 'handleURL', '/');

    function assertLinkStatus($link, url) {
      if (url) {
        equal(normalizeUrl($link.attr('href')), url, 'loaded link-to has expected href');
        ok(!$link.hasClass('i-am-loading'), 'loaded linkComponent has no loadingClass');
      } else {
        equal(normalizeUrl($link.attr('href')), '#', "unloaded link-to has href='#'");
        ok($link.hasClass('i-am-loading'), 'loading linkComponent has loadingClass');
      }
    }

    var $contextLink = _emberViews.jQuery('#context-link', '#qunit-fixture');
    var $staticLink = _emberViews.jQuery('#static-link', '#qunit-fixture');
    var controller = appInstance.lookup('controller:index');

    assertLinkStatus($contextLink);
    assertLinkStatus($staticLink);

    _emberMetal.run(function () {
      warnCalled = false;
      $contextLink.click();
      ok(warnCalled, 'Logger.warn was called from clicking loading link');
    });

    // Set the destinationRoute (context is still null).
    _emberMetal.run(controller, 'set', 'destinationRoute', 'thing');
    assertLinkStatus($contextLink);

    // Set the routeContext to an id
    _emberMetal.run(controller, 'set', 'routeContext', '456');
    assertLinkStatus($contextLink, '/thing/456');

    // Test that 0 isn't interpreted as falsy.
    _emberMetal.run(controller, 'set', 'routeContext', 0);
    assertLinkStatus($contextLink, '/thing/0');

    // Set the routeContext to an object
    _emberMetal.run(controller, 'set', 'routeContext', thing);
    assertLinkStatus($contextLink, '/thing/123');

    // Set the destinationRoute back to null.
    _emberMetal.run(controller, 'set', 'destinationRoute', null);
    assertLinkStatus($contextLink);

    _emberMetal.run(function () {
      warnCalled = false;
      $staticLink.click();
      ok(warnCalled, 'Logger.warn was called from clicking loading link');
    });

    _emberMetal.run(controller, 'set', 'secondRoute', 'about');
    assertLinkStatus($staticLink, '/about');

    // Click the now-active link
    _emberMetal.run($staticLink, 'click');

    _emberConsole.default.warn = oldWarn;
  });

  QUnit.test('The {{link-to}} helper refreshes href element when one of params changes', function () {
    Router.map(function () {
      this.route('post', { path: '/posts/:post_id' });
    });

    var post = _emberRuntime.Object.create({ id: '1' });
    var secondPost = _emberRuntime.Object.create({ id: '2' });

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#link-to "post" post id="post"}}post{{/link-to}}'));

    App.IndexController = _emberRuntime.Controller.extend();
    var indexController = appInstance.lookup('controller:index');

    _emberMetal.run(function () {
      return indexController.set('post', post);
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    equal(normalizeUrl(_emberViews.jQuery('#post', '#qunit-fixture').attr('href')), '/posts/1', 'precond - Link has rendered href attr properly');

    _emberMetal.run(function () {
      return indexController.set('post', secondPost);
    });

    equal(_emberViews.jQuery('#post', '#qunit-fixture').attr('href'), '/posts/2', 'href attr was updated after one of the params had been changed');

    _emberMetal.run(function () {
      return indexController.set('post', null);
    });

    equal(_emberViews.jQuery('#post', '#qunit-fixture').attr('href'), '#', 'href attr becomes # when one of the arguments in nullified');
  });

  QUnit.test('The {{link-to}} helper is active when a route is active', function () {
    Router.map(function () {
      this.route('about', function () {
        this.route('item');
      });
    });

    _emberGlimmer.setTemplate('about', _emberTemplateCompiler.compile("<div id='about'>{{#link-to 'about' id='about-link'}}About{{/link-to}} {{#link-to 'about.item' id='item-link'}}Item{{/link-to}} {{outlet}}</div>"));
    _emberGlimmer.setTemplate('about/item', _emberTemplateCompiler.compile(' '));
    _emberGlimmer.setTemplate('about/index', _emberTemplateCompiler.compile(' '));

    bootApplication();

    _emberMetal.run(router, 'handleURL', '/about');

    equal(_emberViews.jQuery('#about-link.active', '#qunit-fixture').length, 1, 'The about route link is active');
    equal(_emberViews.jQuery('#item-link.active', '#qunit-fixture').length, 0, 'The item route link is inactive');

    _emberMetal.run(router, 'handleURL', '/about/item');

    equal(_emberViews.jQuery('#about-link.active', '#qunit-fixture').length, 1, 'The about route link is active');
    equal(_emberViews.jQuery('#item-link.active', '#qunit-fixture').length, 1, 'The item route link is active');
  });

  QUnit.test("The {{link-to}} helper works in an #each'd array of string route names", function () {
    Router.map(function () {
      this.route('foo');
      this.route('bar');
      this.route('rar');
    });

    App.IndexController = _emberRuntime.Controller.extend({
      routeNames: _emberRuntime.A(['foo', 'bar', 'rar']),
      route1: 'bar',
      route2: 'foo'
    });

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#each routeNames as |routeName|}}{{#link-to routeName}}{{routeName}}{{/link-to}}{{/each}}{{#each routeNames as |r|}}{{#link-to r}}{{r}}{{/link-to}}{{/each}}{{#link-to route1}}a{{/link-to}}{{#link-to route2}}b{{/link-to}}'));

    bootApplication();

    function linksEqual($links, expected) {
      equal($links.length, expected.length, 'Has correct number of links');

      var idx = undefined;
      for (idx = 0; idx < $links.length; idx++) {
        var href = _emberViews.jQuery($links[idx]).attr('href');
        // Old IE includes the whole hostname as well
        equal(href.slice(-expected[idx].length), expected[idx], 'Expected link to be \'' + expected[idx] + '\', but was \'' + href + '\'');
      }
    }

    linksEqual(_emberViews.jQuery('a', '#qunit-fixture'), ['/foo', '/bar', '/rar', '/foo', '/bar', '/rar', '/bar', '/foo']);

    var indexController = appInstance.lookup('controller:index');
    _emberMetal.run(indexController, 'set', 'route1', 'rar');

    linksEqual(_emberViews.jQuery('a', '#qunit-fixture'), ['/foo', '/bar', '/rar', '/foo', '/bar', '/rar', '/rar', '/foo']);

    _emberMetal.run(indexController.routeNames, 'shiftObject');

    linksEqual(_emberViews.jQuery('a', '#qunit-fixture'), ['/bar', '/rar', '/bar', '/rar', '/rar', '/foo']);
  });

  QUnit.test('The non-block form {{link-to}} helper moves into the named route', function () {
    expect(3);
    Router.map(function (match) {
      this.route('contact');
    });

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile("<h3>Home</h3>{{link-to 'Contact us' 'contact' id='contact-link'}}{{#link-to 'index' id='self-link'}}Self{{/link-to}}"));
    _emberGlimmer.setTemplate('contact', _emberTemplateCompiler.compile("<h3>Contact</h3>{{link-to 'Home' 'index' id='home-link'}}{{link-to 'Self' 'contact' id='self-link'}}"));

    bootApplication();

    _emberMetal.run(function () {
      return _emberViews.jQuery('#contact-link', '#qunit-fixture').click();
    });

    equal(_emberViews.jQuery('h3:contains(Contact)', '#qunit-fixture').length, 1, 'The contact template was rendered');
    equal(_emberViews.jQuery('#self-link.active', '#qunit-fixture').length, 1, 'The self-link was rendered with active class');
    equal(_emberViews.jQuery('#home-link:not(.active)', '#qunit-fixture').length, 1, 'The other link was rendered without active class');
  });

  QUnit.test('The non-block form {{link-to}} helper updates the link text when it is a binding', function () {
    expect(8);
    Router.map(function (match) {
      this.route('contact');
    });

    App.IndexController = _emberRuntime.Controller.extend({
      contactName: 'Jane'
    });

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile("<h3>Home</h3>{{link-to contactName 'contact' id='contact-link'}}{{#link-to 'index' id='self-link'}}Self{{/link-to}}"));
    _emberGlimmer.setTemplate('contact', _emberTemplateCompiler.compile("<h3>Contact</h3>{{link-to 'Home' 'index' id='home-link'}}{{link-to 'Self' 'contact' id='self-link'}}"));

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    var controller = appInstance.lookup('controller:index');

    equal(_emberViews.jQuery('#contact-link:contains(Jane)', '#qunit-fixture').length, 1, 'The link title is correctly resolved');

    _emberMetal.run(function () {
      return controller.set('contactName', 'Joe');
    });

    equal(_emberViews.jQuery('#contact-link:contains(Joe)', '#qunit-fixture').length, 1, 'The link title is correctly updated when the bound property changes');

    _emberMetal.run(function () {
      return controller.set('contactName', 'Robert');
    });

    equal(_emberViews.jQuery('#contact-link:contains(Robert)', '#qunit-fixture').length, 1, 'The link title is correctly updated when the bound property changes a second time');

    _emberMetal.run(function () {
      return _emberViews.jQuery('#contact-link', '#qunit-fixture').click();
    });

    equal(_emberViews.jQuery('h3:contains(Contact)', '#qunit-fixture').length, 1, 'The contact template was rendered');
    equal(_emberViews.jQuery('#self-link.active', '#qunit-fixture').length, 1, 'The self-link was rendered with active class');
    equal(_emberViews.jQuery('#home-link:not(.active)', '#qunit-fixture').length, 1, 'The other link was rendered without active class');

    _emberMetal.run(function () {
      return _emberViews.jQuery('#home-link', '#qunit-fixture').click();
    });

    equal(_emberViews.jQuery('h3:contains(Home)', '#qunit-fixture').length, 1, 'The index template was rendered');
    equal(_emberViews.jQuery('#contact-link:contains(Robert)', '#qunit-fixture').length, 1, 'The link title is correctly updated when the route changes');
  });

  QUnit.test('The non-block form {{link-to}} helper moves into the named route with context', function () {
    expect(5);

    Router.map(function (match) {
      this.route('item', { path: '/item/:id' });
    });

    App.IndexRoute = _emberRouting.Route.extend({
      model: function () {
        return _emberRuntime.A([{ id: 'yehuda', name: 'Yehuda Katz' }, { id: 'tom', name: 'Tom Dale' }, { id: 'erik', name: 'Erik Brynroflsson' }]);
      }
    });

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile("<h3>Home</h3><ul>{{#each model as |person|}}<li>{{link-to person.name 'item' person}}</li>{{/each}}</ul>"));
    _emberGlimmer.setTemplate('item', _emberTemplateCompiler.compile("<h3>Item</h3><p>{{model.name}}</p>{{#link-to 'index' id='home-link'}}Home{{/link-to}}"));

    bootApplication();

    _emberMetal.run(function () {
      return _emberViews.jQuery('li a:contains(Yehuda)', '#qunit-fixture').click();
    });

    equal(_emberViews.jQuery('h3:contains(Item)', '#qunit-fixture').length, 1, 'The item template was rendered');
    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), 'Yehuda Katz', 'The name is correct');

    _emberMetal.run(function () {
      return _emberViews.jQuery('#home-link').click();
    });

    equal(normalizeUrl(_emberViews.jQuery('li a:contains(Yehuda)').attr('href')), '/item/yehuda');
    equal(normalizeUrl(_emberViews.jQuery('li a:contains(Tom)').attr('href')), '/item/tom');
    equal(normalizeUrl(_emberViews.jQuery('li a:contains(Erik)').attr('href')), '/item/erik');
  });

  QUnit.test('The non-block form {{link-to}} performs property lookup', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile("{{link-to 'string' 'index' id='string-link'}}{{link-to path foo id='path-link'}}"));

    function assertEquality(href) {
      equal(normalizeUrl(_emberViews.jQuery('#string-link', '#qunit-fixture').attr('href')), '/');
      equal(normalizeUrl(_emberViews.jQuery('#path-link', '#qunit-fixture').attr('href')), href);
    }

    App.IndexController = _emberRuntime.Controller.extend({
      foo: 'index'
    });

    App.Router.map(function () {
      this.route('about');
    });

    bootApplication();

    _emberMetal.run(router, 'handleURL', '/');

    assertEquality('/');

    var controller = appInstance.lookup('controller:index');
    _emberMetal.run(function () {
      return controller.set('foo', 'about');
    });

    assertEquality('/about');
  });

  QUnit.test('The non-block form {{link-to}} protects against XSS', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile("{{link-to display 'index' id='link'}}"));

    App.ApplicationController = _emberRuntime.Controller.extend({
      display: 'blahzorz'
    });

    bootApplication();

    _emberMetal.run(router, 'handleURL', '/');

    var controller = appInstance.lookup('controller:application');

    equal(_emberViews.jQuery('#link', '#qunit-fixture').text(), 'blahzorz');
    _emberMetal.run(function () {
      return controller.set('display', '<b>BLAMMO</b>');
    });

    equal(_emberViews.jQuery('#link', '#qunit-fixture').text(), '<b>BLAMMO</b>');
    equal(_emberViews.jQuery('b', '#qunit-fixture').length, 0);
  });

  QUnit.test('the {{link-to}} helper calls preventDefault', function () {
    Router.map(function () {
      this.route('about');
    });

    bootApplication();

    _emberMetal.run(router, 'handleURL', '/');

    var event = _emberViews.jQuery.Event('click');
    _emberViews.jQuery('#about-link', '#qunit-fixture').trigger(event);

    equal(event.isDefaultPrevented(), true, 'should preventDefault');
  });

  QUnit.test('the {{link-to}} helper does not call preventDefault if `preventDefault=false` is passed as an option', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile("{{#link-to 'about' id='about-link' preventDefault=false}}About{{/link-to}}"));

    Router.map(function () {
      this.route('about');
    });

    bootApplication();

    _emberMetal.run(router, 'handleURL', '/');

    var event = _emberViews.jQuery.Event('click');
    _emberViews.jQuery('#about-link', '#qunit-fixture').trigger(event);

    equal(event.isDefaultPrevented(), false, 'should not preventDefault');
  });

  QUnit.test('the {{link-to}} helper does not call preventDefault if `preventDefault=boundFalseyThing` is passed as an option', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile("{{#link-to 'about' id='about-link' preventDefault=boundFalseyThing}}About{{/link-to}}"));

    App.IndexController = _emberRuntime.Controller.extend({
      boundFalseyThing: false
    });

    Router.map(function () {
      this.route('about');
    });

    bootApplication();

    _emberMetal.run(router, 'handleURL', '/');

    var event = _emberViews.jQuery.Event('click');
    _emberViews.jQuery('#about-link', '#qunit-fixture').trigger(event);

    equal(event.isDefaultPrevented(), false, 'should not preventDefault');
  });

  QUnit.test('the {{link-to}} helper throws a useful error if you invoke it wrong', function () {
    expect(1);

    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile("{{#link-to 'post'}}Post{{/link-to}}"));

    Router.map(function () {
      this.route('post', { path: 'post/:post_id' });
    });

    QUnit.throws(function () {
      bootApplication();
    }, /(You attempted to define a `\{\{link-to "post"\}\}` but did not pass the parameters required for generating its dynamic segments.|You must provide param `post_id` to `generate`)/);
  });

  QUnit.test('the {{link-to}} helper does not throw an error if its route has exited', function () {
    expect(0);

    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile("{{#link-to 'index' id='home-link'}}Home{{/link-to}}{{#link-to 'post' defaultPost id='default-post-link'}}Default Post{{/link-to}}{{#if currentPost}}{{#link-to 'post' currentPost id='current-post-link'}}Current Post{{/link-to}}{{/if}}"));

    App.ApplicationController = _emberRuntime.Controller.extend({
      defaultPost: { id: 1 },
      postController: _emberRuntime.inject.controller('post'),
      currentPost: _emberMetal.alias('postController.model')
    });

    App.PostController = _emberRuntime.Controller.extend();

    App.PostRoute = _emberRouting.Route.extend({
      model: function () {
        return { id: 2 };
      },
      serialize: function (model) {
        return { post_id: model.id };
      }
    });

    Router.map(function () {
      this.route('post', { path: 'post/:post_id' });
    });

    bootApplication();

    _emberMetal.run(router, 'handleURL', '/');

    _emberMetal.run(function () {
      return _emberViews.jQuery('#default-post-link', '#qunit-fixture').click();
    });
    _emberMetal.run(function () {
      return _emberViews.jQuery('#home-link', '#qunit-fixture').click();
    });
    _emberMetal.run(function () {
      return _emberViews.jQuery('#current-post-link', '#qunit-fixture').click();
    });
    _emberMetal.run(function () {
      return _emberViews.jQuery('#home-link', '#qunit-fixture').click();
    });
  });

  QUnit.test('{{link-to}} active property respects changing parent route context', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile("{{link-to 'OMG' 'things' 'omg' id='omg-link'}} " + "{{link-to 'LOL' 'things' 'lol' id='lol-link'}} "));

    Router.map(function () {
      this.route('things', { path: '/things/:name' }, function () {
        this.route('other');
      });
    });

    bootApplication();

    _emberMetal.run(router, 'handleURL', '/things/omg');
    shouldBeActive('#omg-link');
    shouldNotBeActive('#lol-link');

    _emberMetal.run(router, 'handleURL', '/things/omg/other');
    shouldBeActive('#omg-link');
    shouldNotBeActive('#lol-link');
  });

  QUnit.test('{{link-to}} populates href with default query param values even without query-params object', function () {
    App.IndexController = _emberRuntime.Controller.extend({
      queryParams: ['foo'],
      foo: '123'
    });

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile("{{#link-to 'index' id='the-link'}}Index{{/link-to}}"));
    bootApplication();
    equal(_emberViews.jQuery('#the-link').attr('href'), '/', 'link has right href');
  });

  QUnit.test('{{link-to}} populates href with default query param values with empty query-params object', function () {
    App.IndexController = _emberRuntime.Controller.extend({
      queryParams: ['foo'],
      foo: '123'
    });

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile("{{#link-to 'index' (query-params) id='the-link'}}Index{{/link-to}}"));
    bootApplication();
    equal(_emberViews.jQuery('#the-link').attr('href'), '/', 'link has right href');
  });

  QUnit.test('{{link-to}} with only query-params and a block updates when route changes', function () {
    Router.map(function () {
      this.route('about');
    });

    App.ApplicationController = _emberRuntime.Controller.extend({
      queryParams: ['foo', 'bar'],
      foo: '123',
      bar: 'yes'
    });

    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{#link-to (query-params foo=\'456\' bar=\'NAW\') id=\'the-link\'}}Index{{/link-to}}'));
    bootApplication();
    equal(_emberViews.jQuery('#the-link').attr('href'), '/?bar=NAW&foo=456', 'link has right href');

    _emberMetal.run(function () {
      return router.handleURL('/about');
    });

    equal(_emberViews.jQuery('#the-link').attr('href'), '/about?bar=NAW&foo=456', 'link has right href');
  });

  QUnit.test('Block-less {{link-to}} with only query-params updates when route changes', function () {
    Router.map(function () {
      this.route('about');
    });

    App.ApplicationController = _emberRuntime.Controller.extend({
      queryParams: ['foo', 'bar'],
      foo: '123',
      bar: 'yes'
    });

    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{link-to "Index" (query-params foo=\'456\' bar=\'NAW\') id=\'the-link\'}}'));
    bootApplication();
    equal(_emberViews.jQuery('#the-link').attr('href'), '/?bar=NAW&foo=456', 'link has right href');

    _emberMetal.run(function () {
      return router.handleURL('/about');
    });

    equal(_emberViews.jQuery('#the-link').attr('href'), '/about?bar=NAW&foo=456', 'link has right href');
  });

  QUnit.test('The {{link-to}} helper can use dynamic params', function () {
    Router.map(function (match) {
      this.route('foo', { path: 'foo/:some/:thing' });
      this.route('bar', { path: 'bar/:some/:thing/:else' });
    });

    var controller = undefined;
    App.IndexController = _emberRuntime.Controller.extend({
      init: function () {
        this._super.apply(this, arguments);

        controller = this;

        this.dynamicLinkParams = ['foo', 'one', 'two'];
      }
    });

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('\n    <h3>Home</h3>\n\n    {{#link-to params=dynamicLinkParams id="dynamic-link"}}Dynamic{{/link-to}}\n  '));

    bootApplication();

    _emberMetal.run(function () {
      return router.handleURL('/');
    });

    var link = _emberViews.jQuery('#dynamic-link', '#qunit-fixture');

    equal(link.attr('href'), '/foo/one/two');

    _emberMetal.run(function () {
      controller.set('dynamicLinkParams', ['bar', 'one', 'two', 'three']);
    });

    equal(link.attr('href'), '/bar/one/two/three');
  });

  QUnit.test('GJ: {{link-to}} to a parent root model hook which performs a `transitionTo` has correct active class #13256', function () {
    expect(1);

    Router.map(function () {
      this.route('parent', function () {
        this.route('child');
      });
    });

    App.ParentRoute = _emberRouting.Route.extend({
      afterModel: function (transition) {
        this.transitionTo('parent.child');
      }
    });

    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('\n    {{link-to \'Parent\' \'parent\' id=\'parent-link\'}}\n  '));

    bootApplication();

    _emberMetal.run(_emberViews.jQuery('#parent-link'), 'click');

    shouldBeActive('#parent-link');
  });
});
enifed('ember/tests/helpers/link_to_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/helpers/link_to_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/helpers/link_to_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/helpers/link_to_test/link_to_transitioning_classes_test', ['exports', 'ember-runtime', 'ember-routing', 'ember-metal', 'ember-template-compiler', 'ember-application', 'ember-views', 'ember-glimmer'], function (exports, _emberRuntime, _emberRouting, _emberMetal, _emberTemplateCompiler, _emberApplication, _emberViews, _emberGlimmer) {
  'use strict';

  var Router = undefined,
      App = undefined,
      registry = undefined,
      container = undefined;

  var aboutDefer = undefined,
      otherDefer = undefined;

  function bootApplication() {
    container.lookup('router:main');
    _emberMetal.run(App, 'advanceReadiness');
  }

  function assertHasClass(className) {
    var i = 1;
    while (i < arguments.length) {
      var $a = arguments[i];
      var shouldHaveClass = arguments[i + 1];
      equal($a.hasClass(className), shouldHaveClass, $a.attr('id') + ' should ' + (shouldHaveClass ? '' : 'not ') + 'have class ' + className);
      i += 2;
    }
  }

  var updateCount = undefined,
      replaceCount = undefined;

  function sharedSetup() {
    App = _emberApplication.Application.create({
      name: 'App',
      rootElement: '#qunit-fixture'
    });

    App.deferReadiness();

    updateCount = replaceCount = 0;
    App.Router.reopen({
      location: _emberRouting.NoneLocation.create({
        setURL: function (path) {
          updateCount++;
          _emberMetal.set(this, 'path', path);
        },

        replaceURL: function (path) {
          replaceCount++;
          _emberMetal.set(this, 'path', path);
        }
      })
    });

    Router = App.Router;
    registry = App.__registry__;
    container = App.__container__;
  }

  function sharedTeardown() {
    _emberMetal.run(function () {
      return App.destroy();
    });
    _emberGlimmer.setTemplates({});
  }

  QUnit.module('The {{link-to}} helper: .transitioning-in .transitioning-out CSS classes', {
    setup: function () {
      _emberMetal.run(function () {
        sharedSetup();

        registry.unregister('router:main');
        registry.register('router:main', Router);

        Router.map(function () {
          this.route('about');
          this.route('other');
        });

        App.AboutRoute = _emberRouting.Route.extend({
          model: function () {
            aboutDefer = _emberRuntime.RSVP.defer();
            return aboutDefer.promise;
          }
        });

        App.OtherRoute = _emberRouting.Route.extend({
          model: function () {
            otherDefer = _emberRuntime.RSVP.defer();
            return otherDefer.promise;
          }
        });

        _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{outlet}}{{link-to \'Index\' \'index\' id=\'index-link\'}}{{link-to \'About\' \'about\' id=\'about-link\'}}{{link-to \'Other\' \'other\' id=\'other-link\'}}'));
      });
    },

    teardown: function () {
      sharedTeardown();
      aboutDefer = null;
    }
  });

  QUnit.test('while a transition is underway', function () {
    expect(18);
    bootApplication();

    var $index = _emberViews.jQuery('#index-link');
    var $about = _emberViews.jQuery('#about-link');
    var $other = _emberViews.jQuery('#other-link');

    _emberMetal.run($about, 'click');

    assertHasClass('active', $index, true, $about, false, $other, false);
    assertHasClass('ember-transitioning-in', $index, false, $about, true, $other, false);
    assertHasClass('ember-transitioning-out', $index, true, $about, false, $other, false);

    _emberMetal.run(aboutDefer, 'resolve');

    assertHasClass('active', $index, false, $about, true, $other, false);
    assertHasClass('ember-transitioning-in', $index, false, $about, false, $other, false);
    assertHasClass('ember-transitioning-out', $index, false, $about, false, $other, false);
  });

  QUnit.test('while a transition is underway with nested link-to\'s', function () {
    expect(54);

    Router.map(function () {
      this.route('parent-route', function () {
        this.route('about');
        this.route('other');
      });
    });

    App.ParentRouteAboutRoute = _emberRouting.Route.extend({
      model: function () {
        aboutDefer = _emberRuntime.RSVP.defer();
        return aboutDefer.promise;
      }
    });

    App.ParentRouteOtherRoute = _emberRouting.Route.extend({
      model: function () {
        otherDefer = _emberRuntime.RSVP.defer();
        return otherDefer.promise;
      }
    });

    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('\n    {{outlet}}\n    {{#link-to \'index\' tagName=\'li\'}}\n      {{link-to \'Index\' \'index\' id=\'index-link\'}}\n    {{/link-to}}\n    {{#link-to \'parent-route.about\' tagName=\'li\'}}\n      {{link-to \'About\' \'parent-route.about\' id=\'about-link\'}}\n    {{/link-to}}\n    {{#link-to \'parent-route.other\' tagName=\'li\'}}\n      {{link-to \'Other\' \'parent-route.other\' id=\'other-link\'}}\n    {{/link-to}}\n  '));

    bootApplication();

    var $index = _emberViews.jQuery('#index-link');
    var $about = _emberViews.jQuery('#about-link');
    var $other = _emberViews.jQuery('#other-link');

    _emberMetal.run($about, 'click');

    assertHasClass('active', $index, true, $about, false, $other, false);
    assertHasClass('ember-transitioning-in', $index, false, $about, true, $other, false);
    assertHasClass('ember-transitioning-out', $index, true, $about, false, $other, false);

    _emberMetal.run(aboutDefer, 'resolve');

    assertHasClass('active', $index, false, $about, true, $other, false);
    assertHasClass('ember-transitioning-in', $index, false, $about, false, $other, false);
    assertHasClass('ember-transitioning-out', $index, false, $about, false, $other, false);

    _emberMetal.run($other, 'click');

    assertHasClass('active', $index, false, $about, true, $other, false);
    assertHasClass('ember-transitioning-in', $index, false, $about, false, $other, true);
    assertHasClass('ember-transitioning-out', $index, false, $about, true, $other, false);

    _emberMetal.run(otherDefer, 'resolve');

    assertHasClass('active', $index, false, $about, false, $other, true);
    assertHasClass('ember-transitioning-in', $index, false, $about, false, $other, false);
    assertHasClass('ember-transitioning-out', $index, false, $about, false, $other, false);

    _emberMetal.run($about, 'click');

    assertHasClass('active', $index, false, $about, false, $other, true);
    assertHasClass('ember-transitioning-in', $index, false, $about, true, $other, false);
    assertHasClass('ember-transitioning-out', $index, false, $about, false, $other, true);

    _emberMetal.run(aboutDefer, 'resolve');

    assertHasClass('active', $index, false, $about, true, $other, false);
    assertHasClass('ember-transitioning-in', $index, false, $about, false, $other, false);
    assertHasClass('ember-transitioning-out', $index, false, $about, false, $other, false);
  });
});
enifed('ember/tests/helpers/link_to_test/link_to_transitioning_classes_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/helpers/link_to_test/link_to_transitioning_classes_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/helpers/link_to_test/link_to_transitioning_classes_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/helpers/link_to_test/link_to_with_query_params_test', ['exports', 'ember-metal', 'ember-runtime', 'ember-routing', 'ember-template-compiler', 'ember-application', 'ember-views', 'ember-glimmer'], function (exports, _emberMetal, _emberRuntime, _emberRouting, _emberTemplateCompiler, _emberApplication, _emberViews, _emberGlimmer) {
  'use strict';

  var Router = undefined,
      App = undefined,
      router = undefined,
      registry = undefined,
      container = undefined;

  function bootApplication() {
    router = container.lookup('router:main');
    _emberMetal.run(App, 'advanceReadiness');
  }

  function shouldNotBeActive(selector) {
    checkActive(selector, false);
  }

  function shouldBeActive(selector) {
    checkActive(selector, true);
  }

  function checkActive(selector, active) {
    var classList = _emberViews.jQuery(selector, '#qunit-fixture')[0].className;
    equal(classList.indexOf('active') > -1, active, selector + ' active should be ' + active.toString());
  }

  var updateCount = undefined,
      replaceCount = undefined;

  function sharedSetup() {
    App = _emberApplication.Application.create({
      name: 'App',
      rootElement: '#qunit-fixture'
    });

    App.deferReadiness();

    updateCount = replaceCount = 0;
    App.Router.reopen({
      location: _emberRouting.NoneLocation.create({
        setURL: function (path) {
          updateCount++;
          _emberMetal.set(this, 'path', path);
        },

        replaceURL: function (path) {
          replaceCount++;
          _emberMetal.set(this, 'path', path);
        }
      })
    });

    Router = App.Router;
    registry = App.__registry__;
    container = App.__container__;
  }

  function sharedTeardown() {
    _emberMetal.run(function () {
      return App.destroy();
    });
    _emberGlimmer.setTemplates({});
  }

  QUnit.module('The {{link-to}} helper: invoking with query params', {
    setup: function () {
      _emberMetal.run(function () {
        sharedSetup();

        App.IndexController = _emberRuntime.Controller.extend({
          queryParams: ['foo', 'bar', 'abool'],
          foo: '123',
          bar: 'abc',
          boundThing: 'OMG',
          abool: true
        });

        App.AboutController = _emberRuntime.Controller.extend({
          queryParams: ['baz', 'bat'],
          baz: 'alex',
          bat: 'borf'
        });

        registry.unregister('router:main');
        registry.register('router:main', Router);
      });
    },

    teardown: sharedTeardown
  });

  QUnit.test('doesn\'t update controller QP properties on current route when invoked', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#link-to \'index\' id=\'the-link\'}}Index{{/link-to}}'));
    bootApplication();

    _emberMetal.run(_emberViews.jQuery('#the-link'), 'click');
    var indexController = container.lookup('controller:index');
    deepEqual(indexController.getProperties('foo', 'bar'), { foo: '123', bar: 'abc' }, 'controller QP properties not');
  });

  QUnit.test('doesn\'t update controller QP properties on current route when invoked (empty query-params obj)', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#link-to \'index\' (query-params) id=\'the-link\'}}Index{{/link-to}}'));
    bootApplication();

    _emberMetal.run(_emberViews.jQuery('#the-link'), 'click');
    var indexController = container.lookup('controller:index');
    deepEqual(indexController.getProperties('foo', 'bar'), { foo: '123', bar: 'abc' }, 'controller QP properties not');
  });

  QUnit.test('link-to with no params throws', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#link-to id=\'the-link\'}}Index{{/link-to}}'));
    expectAssertion(function () {
      return bootApplication();
    }, /one or more/);
  });

  QUnit.test('doesn\'t update controller QP properties on current route when invoked (empty query-params obj, inferred route)', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#link-to (query-params) id=\'the-link\'}}Index{{/link-to}}'));
    bootApplication();

    _emberMetal.run(_emberViews.jQuery('#the-link'), 'click');
    var indexController = container.lookup('controller:index');
    deepEqual(indexController.getProperties('foo', 'bar'), { foo: '123', bar: 'abc' }, 'controller QP properties not');
  });

  QUnit.test('updates controller QP properties on current route when invoked', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#link-to \'index\' (query-params foo=\'456\') id=\'the-link\'}}Index{{/link-to}}'));
    bootApplication();

    _emberMetal.run(_emberViews.jQuery('#the-link'), 'click');
    var indexController = container.lookup('controller:index');
    deepEqual(indexController.getProperties('foo', 'bar'), { foo: '456', bar: 'abc' }, 'controller QP properties updated');
  });

  QUnit.test('updates controller QP properties on current route when invoked (inferred route)', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#link-to (query-params foo=\'456\') id=\'the-link\'}}Index{{/link-to}}'));
    bootApplication();

    _emberMetal.run(_emberViews.jQuery('#the-link'), 'click');
    var indexController = container.lookup('controller:index');
    deepEqual(indexController.getProperties('foo', 'bar'), { foo: '456', bar: 'abc' }, 'controller QP properties updated');
  });

  QUnit.test('updates controller QP properties on other route after transitioning to that route', function () {
    Router.map(function () {
      this.route('about');
    });

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#link-to \'about\' (query-params baz=\'lol\') id=\'the-link\'}}About{{/link-to}}'));
    bootApplication();

    equal(_emberViews.jQuery('#the-link').attr('href'), '/about?baz=lol');
    _emberMetal.run(_emberViews.jQuery('#the-link'), 'click');
    var aboutController = container.lookup('controller:about');
    deepEqual(aboutController.getProperties('baz', 'bat'), { baz: 'lol', bat: 'borf' }, 'about controller QP properties updated');

    equal(container.lookup('controller:application').get('currentPath'), 'about');
  });

  QUnit.test('supplied QP properties can be bound', function () {
    var indexController = container.lookup('controller:index');
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#link-to (query-params foo=boundThing) id=\'the-link\'}}Index{{/link-to}}'));

    bootApplication();

    equal(_emberViews.jQuery('#the-link').attr('href'), '/?foo=OMG');
    _emberMetal.run(indexController, 'set', 'boundThing', 'ASL');
    equal(_emberViews.jQuery('#the-link').attr('href'), '/?foo=ASL');
  });

  QUnit.test('supplied QP properties can be bound (booleans)', function () {
    var indexController = container.lookup('controller:index');
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#link-to (query-params abool=boundThing) id=\'the-link\'}}Index{{/link-to}}'));

    bootApplication();

    equal(_emberViews.jQuery('#the-link').attr('href'), '/?abool=OMG');
    _emberMetal.run(indexController, 'set', 'boundThing', false);
    equal(_emberViews.jQuery('#the-link').attr('href'), '/?abool=false');

    _emberMetal.run(_emberViews.jQuery('#the-link'), 'click');

    deepEqual(indexController.getProperties('foo', 'bar', 'abool'), { foo: '123', bar: 'abc', abool: false });
  });

  QUnit.test('href updates when unsupplied controller QP props change', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#link-to (query-params foo=\'lol\') id=\'the-link\'}}Index{{/link-to}}'));

    bootApplication();
    var indexController = container.lookup('controller:index');

    equal(_emberViews.jQuery('#the-link').attr('href'), '/?foo=lol');
    _emberMetal.run(indexController, 'set', 'bar', 'BORF');
    equal(_emberViews.jQuery('#the-link').attr('href'), '/?bar=BORF&foo=lol');
    _emberMetal.run(indexController, 'set', 'foo', 'YEAH');
    equal(_emberViews.jQuery('#the-link').attr('href'), '/?bar=BORF&foo=lol');
  });

  QUnit.test('The {{link-to}} with only query params always transitions to the current route with the query params applied', function () {
    // Test harness for bug #12033

    _emberGlimmer.setTemplate('cars', _emberTemplateCompiler.compile('\n    {{#link-to \'cars.create\' id=\'create-link\'}}Create new car{{/link-to}}\n    {{#link-to (query-params page=\'2\') id=\'page2-link\'}}Page 2{{/link-to}}\n    {{outlet}}\n  '));

    _emberGlimmer.setTemplate('cars/create', _emberTemplateCompiler.compile('{{#link-to \'cars\' id=\'close-link\'}}Close create form{{/link-to}}'));

    Router.map(function () {
      this.route('cars', function () {
        this.route('create');
      });
    });

    App.CarsController = _emberRuntime.Controller.extend({
      queryParams: ['page'],
      page: 1
    });

    bootApplication();

    var carsController = container.lookup('controller:cars');

    _emberMetal.run(function () {
      return router.handleURL('/cars/create');
    });

    _emberMetal.run(function () {
      equal(router.currentRouteName, 'cars.create');
      _emberViews.jQuery('#close-link').click();
    });

    _emberMetal.run(function () {
      equal(router.currentRouteName, 'cars.index');
      equal(router.get('url'), '/cars');
      equal(carsController.get('page'), 1, 'The page query-param is 1');
      _emberViews.jQuery('#page2-link').click();
    });

    _emberMetal.run(function () {
      equal(router.currentRouteName, 'cars.index', 'The active route is still cars');
      equal(router.get('url'), '/cars?page=2', 'The url has been updated');
      equal(carsController.get('page'), 2, 'The query params have been updated');
    });
  });

  QUnit.test('The {{link-to}} applies activeClass when query params are not changed', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('\n    {{#link-to (query-params foo=\'cat\') id=\'cat-link\'}}Index{{/link-to}}\n    {{#link-to (query-params foo=\'dog\') id=\'dog-link\'}}Index{{/link-to}}\n    {{#link-to \'index\' id=\'change-nothing\'}}Index{{/link-to}}\n  '));

    _emberGlimmer.setTemplate('search', _emberTemplateCompiler.compile('\n    {{#link-to (query-params search=\'same\') id=\'same-search\'}}Index{{/link-to}}\n    {{#link-to (query-params search=\'change\') id=\'change-search\'}}Index{{/link-to}}\n    {{#link-to (query-params search=\'same\' archive=true) id=\'same-search-add-archive\'}}Index{{/link-to}}\n    {{#link-to (query-params archive=true) id=\'only-add-archive\'}}Index{{/link-to}}\n    {{#link-to (query-params search=\'same\' archive=true) id=\'both-same\'}}Index{{/link-to}}\n    {{#link-to (query-params search=\'different\' archive=true) id=\'change-one\'}}Index{{/link-to}}\n    {{#link-to (query-params search=\'different\' archive=false) id=\'remove-one\'}}Index{{/link-to}}\n    {{outlet}}\n  '));

    _emberGlimmer.setTemplate('search/results', _emberTemplateCompiler.compile('\n    {{#link-to (query-params sort=\'title\') id=\'same-sort-child-only\'}}Index{{/link-to}}\n    {{#link-to (query-params search=\'same\') id=\'same-search-parent-only\'}}Index{{/link-to}}\n    {{#link-to (query-params search=\'change\') id=\'change-search-parent-only\'}}Index{{/link-to}}\n    {{#link-to (query-params search=\'same\' sort=\'title\') id=\'same-search-same-sort-child-and-parent\'}}Index{{/link-to}}\n    {{#link-to (query-params search=\'same\' sort=\'author\') id=\'same-search-different-sort-child-and-parent\'}}Index{{/link-to}}\n    {{#link-to (query-params search=\'change\' sort=\'title\') id=\'change-search-same-sort-child-and-parent\'}}Index{{/link-to}}\n    {{#link-to (query-params foo=\'dog\') id=\'dog-link\'}}Index{{/link-to}}\n  '));

    Router.map(function () {
      this.route('search', function () {
        this.route('results');
      });
    });

    App.SearchController = _emberRuntime.Controller.extend({
      queryParams: ['search', 'archive'],
      search: '',
      archive: false
    });

    App.SearchResultsController = _emberRuntime.Controller.extend({
      queryParams: ['sort', 'showDetails'],
      sort: 'title',
      showDetails: true
    });

    bootApplication();

    //Basic tests
    shouldNotBeActive('#cat-link');
    shouldNotBeActive('#dog-link');
    _emberMetal.run(router, 'handleURL', '/?foo=cat');
    shouldBeActive('#cat-link');
    shouldNotBeActive('#dog-link');
    _emberMetal.run(router, 'handleURL', '/?foo=dog');
    shouldBeActive('#dog-link');
    shouldNotBeActive('#cat-link');
    shouldBeActive('#change-nothing');

    //Multiple params
    _emberMetal.run(function () {
      return router.handleURL('/search?search=same');
    });
    shouldBeActive('#same-search');
    shouldNotBeActive('#change-search');
    shouldNotBeActive('#same-search-add-archive');
    shouldNotBeActive('#only-add-archive');
    shouldNotBeActive('#remove-one');

    _emberMetal.run(function () {
      return router.handleURL('/search?search=same&archive=true');
    });

    shouldBeActive('#both-same');
    shouldNotBeActive('#change-one');

    //Nested Controllers
    _emberMetal.run(function () {
      // Note: this is kind of a strange case; sort's default value is 'title',
      // so this URL shouldn't have been generated in the first place, but
      // we should also be able to gracefully handle these cases.
      router.handleURL('/search/results?search=same&sort=title&showDetails=true');
    });
    //shouldBeActive('#same-sort-child-only');
    shouldBeActive('#same-search-parent-only');
    shouldNotBeActive('#change-search-parent-only');
    shouldBeActive('#same-search-same-sort-child-and-parent');
    shouldNotBeActive('#same-search-different-sort-child-and-parent');
    shouldNotBeActive('#change-search-same-sort-child-and-parent');
  });

  QUnit.test('The {{link-to}} applies active class when query-param is number', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('\n    {{#link-to (query-params page=pageNumber) id=\'page-link\'}}Index{{/link-to}}\n  '));

    App.IndexController = _emberRuntime.Controller.extend({
      queryParams: ['page'],
      page: 1,
      pageNumber: 5
    });

    bootApplication();

    shouldNotBeActive('#page-link');
    _emberMetal.run(router, 'handleURL', '/?page=5');
    shouldBeActive('#page-link');
  });

  QUnit.test('The {{link-to}} applies active class when query-param is array', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('\n    {{#link-to (query-params pages=pagesArray) id=\'array-link\'}}Index{{/link-to}}\n    {{#link-to (query-params pages=biggerArray) id=\'bigger-link\'}}Index{{/link-to}}\n    {{#link-to (query-params pages=emptyArray) id=\'empty-link\'}}Index{{/link-to}}\n  '));

    App.IndexController = _emberRuntime.Controller.extend({
      queryParams: ['pages'],
      pages: [],
      pagesArray: [1, 2],
      biggerArray: [1, 2, 3],
      emptyArray: []
    });

    bootApplication();

    shouldNotBeActive('#array-link');
    _emberMetal.run(router, 'handleURL', '/?pages=%5B1%2C2%5D');
    shouldBeActive('#array-link');
    shouldNotBeActive('#bigger-link');
    shouldNotBeActive('#empty-link');
    _emberMetal.run(router, 'handleURL', '/?pages=%5B2%2C1%5D');
    shouldNotBeActive('#array-link');
    shouldNotBeActive('#bigger-link');
    shouldNotBeActive('#empty-link');
    _emberMetal.run(router, 'handleURL', '/?pages=%5B1%2C2%2C3%5D');
    shouldBeActive('#bigger-link');
    shouldNotBeActive('#array-link');
    shouldNotBeActive('#empty-link');
  });

  QUnit.test('The {{link-to}} helper applies active class to parent route', function () {
    App.Router.map(function () {
      this.route('parent', function () {
        this.route('child');
      });
    });

    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('\n    {{#link-to \'parent\' id=\'parent-link\'}}Parent{{/link-to}}\n    {{#link-to \'parent.child\' id=\'parent-child-link\'}}Child{{/link-to}}\n    {{#link-to \'parent\' (query-params foo=cat) id=\'parent-link-qp\'}}Parent{{/link-to}}\n    {{outlet}}\n  '));

    App.ParentChildController = _emberRuntime.Controller.extend({
      queryParams: ['foo'],
      foo: 'bar'
    });

    bootApplication();
    shouldNotBeActive('#parent-link');
    shouldNotBeActive('#parent-child-link');
    shouldNotBeActive('#parent-link-qp');
    _emberMetal.run(router, 'handleURL', '/parent/child?foo=dog');
    shouldBeActive('#parent-link');
    shouldNotBeActive('#parent-link-qp');
  });

  QUnit.test('The {{link-to}} helper disregards query-params in activeness computation when current-when specified', function () {
    App.Router.map(function () {
      this.route('parent');
    });

    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('\n    {{#link-to \'parent\' (query-params page=1) current-when=\'parent\' id=\'app-link\'}}Parent{{/link-to}} {{outlet}}\n  '));
    _emberGlimmer.setTemplate('parent', _emberTemplateCompiler.compile('\n    {{#link-to \'parent\' (query-params page=1) current-when=\'parent\' id=\'parent-link\'}}Parent{{/link-to}} {{outlet}}\n  '));

    App.ParentController = _emberRuntime.Controller.extend({
      queryParams: ['page'],
      page: 1
    });

    bootApplication();
    equal(_emberViews.jQuery('#app-link').attr('href'), '/parent');
    shouldNotBeActive('#app-link');

    _emberMetal.run(router, 'handleURL', '/parent?page=2');
    equal(_emberViews.jQuery('#app-link').attr('href'), '/parent');
    shouldBeActive('#app-link');
    equal(_emberViews.jQuery('#parent-link').attr('href'), '/parent');
    shouldBeActive('#parent-link');

    var parentController = container.lookup('controller:parent');
    equal(parentController.get('page'), 2);
    _emberMetal.run(parentController, 'set', 'page', 3);
    equal(router.get('location.path'), '/parent?page=3');
    shouldBeActive('#app-link');
    shouldBeActive('#parent-link');

    _emberViews.jQuery('#app-link').click();
    equal(router.get('location.path'), '/parent');
  });

  QUnit.test('link-to default query params while in active transition regression test', function () {
    App.Router.map(function () {
      this.route('foos');
      this.route('bars');
    });
    var foos = _emberRuntime.RSVP.defer();
    var bars = _emberRuntime.RSVP.defer();

    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('\n    {{link-to \'Foos\' \'foos\' id=\'foos-link\'}}\n    {{link-to \'Baz Foos\' \'foos\' (query-params baz=true) id=\'baz-foos-link\'}}\n    {{link-to \'Quux Bars\' \'bars\' (query-params quux=true) id=\'bars-link\'}}\n  '));

    App.FoosController = _emberRuntime.Controller.extend({
      queryParams: ['status'],
      baz: false
    });

    App.FoosRoute = _emberRouting.Route.extend({
      model: function () {
        return foos.promise;
      }
    });

    App.BarsController = _emberRuntime.Controller.extend({
      queryParams: ['status'],
      quux: false
    });

    App.BarsRoute = _emberRouting.Route.extend({
      model: function () {
        return bars.promise;
      }
    });

    bootApplication();
    equal(_emberViews.jQuery('#foos-link').attr('href'), '/foos');
    equal(_emberViews.jQuery('#baz-foos-link').attr('href'), '/foos?baz=true');
    equal(_emberViews.jQuery('#bars-link').attr('href'), '/bars?quux=true');

    equal(router.get('location.path'), '');

    shouldNotBeActive('#foos-link');
    shouldNotBeActive('#baz-foos-link');
    shouldNotBeActive('#bars-link');

    _emberMetal.run(_emberViews.jQuery('#bars-link'), 'click');
    shouldNotBeActive('#bars-link');

    _emberMetal.run(_emberViews.jQuery('#foos-link'), 'click');
    shouldNotBeActive('#foos-link');

    _emberMetal.run(foos, 'resolve');

    equal(router.get('location.path'), '/foos');
    shouldBeActive('#foos-link');
  });
});
enifed('ember/tests/helpers/link_to_test/link_to_with_query_params_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/helpers/link_to_test/link_to_with_query_params_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/helpers/link_to_test/link_to_with_query_params_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/homepage_example_test', ['exports', 'ember-routing', 'ember-metal', 'ember-application', 'ember-runtime', 'ember-template-compiler', 'ember-views', 'ember-glimmer'], function (exports, _emberRouting, _emberMetal, _emberApplication, _emberRuntime, _emberTemplateCompiler, _emberViews, _emberGlimmer) {
  'use strict';

  var App = undefined,
      $fixture = undefined;

  function setupExample() {
    // setup templates
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{outlet}}'));
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<h1>People</h1><ul>{{#each model as |person|}}<li>Hello, <b>{{person.fullName}}</b>!</li>{{/each}}</ul>'));

    App.Person = _emberRuntime.Object.extend({
      firstName: null,
      lastName: null,

      fullName: _emberMetal.computed('firstName', 'lastName', function () {
        return this.get('firstName') + ' ' + this.get('lastName');
      })
    });

    App.IndexRoute = _emberRouting.Route.extend({
      model: function () {
        var people = _emberRuntime.A([App.Person.create({
          firstName: 'Tom',
          lastName: 'Dale'
        }), App.Person.create({
          firstName: 'Yehuda',
          lastName: 'Katz'
        })]);
        return people;
      }
    });
  }

  QUnit.module('Homepage Example', {
    setup: function () {
      _emberMetal.run(function () {
        App = _emberApplication.Application.create({
          name: 'App',
          rootElement: '#qunit-fixture'
        });
        App.deferReadiness();

        App.Router.reopen({
          location: 'none'
        });

        App.LoadingRoute = _emberRouting.Route.extend();
      });

      $fixture = _emberViews.jQuery('#qunit-fixture');
      setupExample();
    },

    teardown: function () {
      _emberMetal.run(function () {
        return App.destroy();
      });

      App = null;

      _emberGlimmer.setTemplates({});
    }
  });

  QUnit.test('The example renders correctly', function () {
    _emberMetal.run(App, 'advanceReadiness');

    equal($fixture.find('h1:contains(People)').length, 1);
    equal($fixture.find('li').length, 2);
    equal($fixture.find('li:nth-of-type(1)').text(), 'Hello, Tom Dale!');
    equal($fixture.find('li:nth-of-type(2)').text(), 'Hello, Yehuda Katz!');
  });
});
enifed('ember/tests/homepage_example_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/homepage_example_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/homepage_example_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/integration/multiple-app-test', ['exports', 'ember-metal', 'ember-template-compiler', 'ember-application', 'ember-glimmer', 'ember-views'], function (exports, _emberMetal, _emberTemplateCompiler, _emberApplication, _emberGlimmer, _emberViews) {
  'use strict';

  var App1 = undefined,
      App2 = undefined,
      actions = undefined;

  function startApp(rootElement) {
    var application = undefined;

    _emberMetal.run(function () {
      application = _emberApplication.Application.create({
        rootElement: rootElement
      });
      application.deferReadiness();

      application.Router.reopen({
        location: 'none'
      });

      var registry = application.__registry__;

      registry.register('component:special-button', _emberGlimmer.Component.extend({
        actions: {
          doStuff: function () {
            actions.push(rootElement);
          }
        }
      }));
      registry.register('template:application', _emberTemplateCompiler.compile('{{outlet}}', { moduleName: 'application' }));
      registry.register('template:index', _emberTemplateCompiler.compile('<h1>Node 1</h1>{{special-button}}', { moduleName: 'index' }));
      registry.register('template:components/special-button', _emberTemplateCompiler.compile('<button class=\'do-stuff\' {{action \'doStuff\'}}>Button</button>', { moduleName: 'components/special-button' }));
    });

    return application;
  }

  function handleURL(application, path) {
    var router = application.__container__.lookup('router:main');
    return _emberMetal.run(router, 'handleURL', path);
  }

  QUnit.module('View Integration', {
    setup: function () {
      actions = [];
      _emberViews.jQuery('#qunit-fixture').html('<div id="app-1"></div><div id="app-2"></div>');
      App1 = startApp('#app-1');
      App2 = startApp('#app-2');
    },

    teardown: function () {
      _emberMetal.run(App1, 'destroy');
      _emberMetal.run(App2, 'destroy');
      App1 = App2 = null;
    }
  });

  QUnit.test('booting multiple applications can properly handle events', function (assert) {
    _emberMetal.run(App1, 'advanceReadiness');
    _emberMetal.run(App2, 'advanceReadiness');

    handleURL(App1, '/');
    handleURL(App2, '/');

    _emberViews.jQuery('#app-2 .do-stuff').click();
    _emberViews.jQuery('#app-1 .do-stuff').click();

    assert.deepEqual(actions, ['#app-2', '#app-1']);
  });
});
enifed('ember/tests/integration/multiple-app-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/integration/multiple-app-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/integration/multiple-app-test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/reexports_test', ['exports', 'ember/index', 'internal-test-helpers', 'ember-metal'], function (exports, _emberIndex, _internalTestHelpers, _emberMetal) {
  'use strict';

  QUnit.module('ember reexports');

  [
  // ember-utils
  ['getOwner', 'ember-utils', 'getOwner'], ['setOwner', 'ember-utils', 'setOwner'],
  // ['assign', 'ember-metal'], TODO: fix this test, we use `Object.assign` if present
  ['GUID_KEY', 'ember-utils'], ['uuid', 'ember-utils'], ['generateGuid', 'ember-utils'], ['guidFor', 'ember-utils'], ['inspect', 'ember-utils'], ['makeArray', 'ember-utils'], ['canInvoke', 'ember-utils'], ['tryInvoke', 'ember-utils'], ['wrap', 'ember-utils'], ['applyStr', 'ember-utils'],

  // ember-environment
  // ['ENV', 'ember-environment', 'ENV'], TODO: fix this, its failing because we are hitting the getter

  // container
  ['Registry', 'container', 'Registry'], ['Container', 'container', 'Container'],

  // ember-metal
  ['computed', 'ember-metal'], ['computed.alias', 'ember-metal', 'alias'], ['ComputedProperty', 'ember-metal'], ['cacheFor', 'ember-metal'], ['deprecate', 'ember-metal'], ['deprecateFunc', 'ember-metal'], ['assert', 'ember-metal'], ['warn', 'ember-metal'], ['debug', 'ember-metal'], ['runInDebug', 'ember-metal'], ['merge', 'ember-metal'], ['instrument', 'ember-metal'], ['Instrumentation.instrument', 'ember-metal', 'instrument'], ['Instrumentation.subscribe', 'ember-metal', 'instrumentationSubscribe'], ['Instrumentation.unsubscribe', 'ember-metal', 'instrumentationUnsubscribe'], ['Instrumentation.reset', 'ember-metal', 'instrumentationReset'], ['testing', 'ember-metal', { get: 'isTesting', set: 'setTesting' }], ['onerror', 'ember-metal', { get: 'getOnerror', set: 'setOnerror' }],
  // ['create'], TODO: figure out what to do here
  // ['keys'], TODO: figure out what to do here
  ['FEATURES', 'ember-metal'], ['FEATURES.isEnabled', 'ember-metal', 'isFeatureEnabled'], ['Error', 'ember-metal'], ['META_DESC', 'ember-metal'], ['meta', 'ember-metal'], ['get', 'ember-metal'], ['set', 'ember-metal'], ['_getPath', 'ember-metal'], ['getWithDefault', 'ember-metal'], ['trySet', 'ember-metal'], ['_Cache', 'ember-metal', 'Cache'], ['on', 'ember-metal'], ['addListener', 'ember-metal'], ['removeListener', 'ember-metal'], ['_suspendListener', 'ember-metal', 'suspendListener'], ['_suspendListeners', 'ember-metal', 'suspendListeners'], ['sendEvent', 'ember-metal'], ['hasListeners', 'ember-metal'], ['watchedEvents', 'ember-metal'], ['listenersFor', 'ember-metal'], ['accumulateListeners', 'ember-metal'], ['isNone', 'ember-metal'], ['isEmpty', 'ember-metal'], ['isBlank', 'ember-metal'], ['isPresent', 'ember-metal'], ['_Backburner', 'backburner', 'default'], ['run', 'ember-metal'], ['_ObserverSet', 'ember-metal', 'ObserverSet'], ['propertyWillChange', 'ember-metal'], ['propertyDidChange', 'ember-metal'], ['overrideChains', 'ember-metal'], ['beginPropertyChanges', 'ember-metal'], ['beginPropertyChanges', 'ember-metal'], ['endPropertyChanges', 'ember-metal'], ['changeProperties', 'ember-metal'], ['defineProperty', 'ember-metal'], ['watchKey', 'ember-metal'], ['unwatchKey', 'ember-metal'], ['removeChainWatcher', 'ember-metal'], ['_ChainNode', 'ember-metal', 'ChainNode'], ['finishChains', 'ember-metal'], ['watchPath', 'ember-metal'], ['unwatchPath', 'ember-metal'], ['watch', 'ember-metal'], ['isWatching', 'ember-metal'], ['unwatch', 'ember-metal'], ['destroy', 'ember-metal'], ['libraries', 'ember-metal'], ['OrderedSet', 'ember-metal'], ['Map', 'ember-metal'], ['MapWithDefault', 'ember-metal'], ['getProperties', 'ember-metal'], ['setProperties', 'ember-metal'], ['expandProperties', 'ember-metal'], ['NAME_KEY', 'ember-utils'], ['addObserver', 'ember-metal'], ['observersFor', 'ember-metal'], ['removeObserver', 'ember-metal'], ['_suspendObserver', 'ember-metal'], ['_suspendObservers', 'ember-metal'], ['required', 'ember-metal'], ['aliasMethod', 'ember-metal'], ['observer', 'ember-metal'], ['immediateObserver', 'ember-metal', '_immediateObserver'], ['mixin', 'ember-metal'], ['Mixin', 'ember-metal'], ['bind', 'ember-metal'], ['Binding', 'ember-metal'], ['isGlobalPath', 'ember-metal'],

  // ember-views
  ['$', 'ember-views', 'jQuery'], ['ViewUtils.isSimpleClick', 'ember-views', 'isSimpleClick'], ['ViewUtils.getViewElement', 'ember-views', 'getViewElement'], ['ViewUtils.getViewBounds', 'ember-views', 'getViewBounds'], ['ViewUtils.getViewClientRects', 'ember-views', 'getViewClientRects'], ['ViewUtils.getViewBoundingClientRect', 'ember-views', 'getViewBoundingClientRect'], ['ViewUtils.getRootViews', 'ember-views', 'getRootViews'], ['ViewUtils.getChildViews', 'ember-views', 'getChildViews'], ['TextSupport', 'ember-views'], ['ComponentLookup', 'ember-views'], ['EventDispatcher', 'ember-views'],

  // ember-glimmer
  ['Component', 'ember-glimmer', 'Component'], ['Helper', 'ember-glimmer', 'Helper'], ['Helper.helper', 'ember-glimmer', 'helper'], ['Checkbox', 'ember-glimmer', 'Checkbox'], ['LinkComponent', 'ember-glimmer', 'LinkComponent'], ['TextArea', 'ember-glimmer', 'TextArea'], ['TextField', 'ember-glimmer', 'TextField'], ['TEMPLATES', 'ember-glimmer', { get: 'getTemplates', set: 'setTemplates' }], ['Handlebars.template', 'ember-glimmer', 'template'], ['Handlebars.SafeString', 'ember-glimmer', { get: '_getSafeString' }], ['Handlebars.Utils.escapeExpression', 'ember-glimmer', 'escapeExpression'], ['String.htmlSafe', 'ember-glimmer', 'htmlSafe'], ['HTMLBars.makeBoundHelper', 'ember-glimmer', 'makeBoundHelper'],

  // ember-runtime
  ['_RegistryProxyMixin', 'ember-runtime', 'RegistryProxyMixin'], ['_ContainerProxyMixin', 'ember-runtime', 'ContainerProxyMixin'], ['Object', 'ember-runtime'], ['String', 'ember-runtime'], ['compare', 'ember-runtime'], ['copy', 'ember-runtime'], ['isEqual', 'ember-runtime'], ['inject', 'ember-runtime'], ['Array', 'ember-runtime'], ['Comparable', 'ember-runtime'], ['Namespace', 'ember-runtime'], ['Enumerable', 'ember-runtime'], ['ArrayProxy', 'ember-runtime'], ['ObjectProxy', 'ember-runtime'], ['ActionHandler', 'ember-runtime'], ['CoreObject', 'ember-runtime'], ['NativeArray', 'ember-runtime'], ['Copyable', 'ember-runtime'], ['Freezable', 'ember-runtime'], ['FROZEN_ERROR', 'ember-runtime'], ['MutableEnumerable', 'ember-runtime'], ['MutableArray', 'ember-runtime'], ['TargetActionSupport', 'ember-runtime'], ['Evented', 'ember-runtime'], ['PromiseProxyMixin', 'ember-runtime'], ['Observable', 'ember-runtime'], ['typeOf', 'ember-runtime'], ['isArray', 'ember-runtime'], ['Object', 'ember-runtime'], ['onLoad', 'ember-runtime'], ['runLoadHooks', 'ember-runtime'], ['Controller', 'ember-runtime'], ['ControllerMixin', 'ember-runtime'], ['Service', 'ember-runtime'], ['_ProxyMixin', 'ember-runtime'], ['RSVP', 'ember-runtime'], ['STRINGS', 'ember-runtime', { get: 'getStrings', set: 'setStrings' }], ['BOOTED', 'ember-runtime', { get: 'isNamespaceSearchDisabled', set: 'setNamespaceSearchDisabled' }],

  // ember-routing
  ['Location', 'ember-routing'], ['AutoLocation', 'ember-routing'], ['HashLocation', 'ember-routing'], ['HistoryLocation', 'ember-routing'], ['NoneLocation', 'ember-routing'], ['controllerFor', 'ember-routing'], ['generateControllerFactory', 'ember-routing'], ['generateController', 'ember-routing'], ['RouterDSL', 'ember-routing'], ['Router', 'ember-routing'], ['Route', 'ember-routing'],

  // ember-application
  ['Application', 'ember-application'], ['ApplicationInstance', 'ember-application'], ['Engine', 'ember-application'], ['EngineInstance', 'ember-application'], ['Resolver', 'ember-application'], ['DefaultResolver', 'ember-application', 'Resolver'],

  // ember-extension-support
  ['DataAdapter', 'ember-extension-support'], ['ContainerDebugAdapter', 'ember-extension-support']].forEach(function (reexport) {
    var path = reexport[0];
    var moduleId = reexport[1];
    var exportName = reexport[2];

    // default path === exportName if none present
    if (!exportName) {
      exportName = path;
    }

    QUnit.test('Ember.' + path + ' exports correctly', function (assert) {
      _internalTestHelpers.confirmExport(_emberIndex.default, assert, path, moduleId, exportName);
    });
  });

  QUnit.test('Ember.String.isHTMLSafe exports correctly', function (assert) {
    _internalTestHelpers.confirmExport(_emberIndex.default, assert, 'String.isHTMLSafe', 'ember-glimmer', 'isHTMLSafe');
  });

  if (_emberMetal.isFeatureEnabled('ember-metal-weakmap')) {
    QUnit.test('Ember.WeakMap exports correctly', function (assert) {
      _internalTestHelpers.confirmExport(_emberIndex.default, assert, 'WeakMap', 'ember-metal', 'WeakMap');
    });
  }
});
enifed('ember/tests/reexports_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/reexports_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/reexports_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/routing/basic_test', ['exports', 'ember-utils', 'ember-console', 'ember-runtime', 'ember-routing', 'ember-metal', 'ember-glimmer', 'ember-views', 'ember-template-compiler', 'ember-application', 'router'], function (exports, _emberUtils, _emberConsole, _emberRuntime, _emberRouting, _emberMetal, _emberGlimmer, _emberViews, _emberTemplateCompiler, _emberApplication, _router) {
  'use strict';

  var trim = _emberViews.jQuery.trim;

  var Router = undefined,
      App = undefined,
      router = undefined,
      registry = undefined,
      container = undefined,
      originalLoggerError = undefined;

  function bootApplication() {
    router = container.lookup('router:main');
    _emberMetal.run(App, 'advanceReadiness');
  }

  function handleURL(path) {
    return _emberMetal.run(function () {
      return router.handleURL(path).then(function (value) {
        ok(true, 'url: `' + path + '` was handled');
        return value;
      }, function (reason) {
        ok(false, 'failed to visit:`' + path + '` reason: `' + QUnit.jsDump.parse(reason));
        throw reason;
      });
    });
  }

  function handleURLAborts(path) {
    _emberMetal.run(function () {
      router.handleURL(path).then(function (value) {
        ok(false, 'url: `' + path + '` was NOT to be handled');
      }, function (reason) {
        ok(reason && reason.message === 'TransitionAborted', 'url: `' + path + '` was to be aborted');
      });
    });
  }

  function handleURLRejectsWith(path, expectedReason) {
    _emberMetal.run(function () {
      router.handleURL(path).then(function (value) {
        ok(false, 'expected handleURLing: `' + path + '` to fail');
      }, function (reason) {
        equal(reason, expectedReason);
      });
    });
  }

  QUnit.module('Basic Routing', {
    setup: function () {
      _emberMetal.run(function () {
        App = _emberApplication.Application.create({
          name: 'App',
          rootElement: '#qunit-fixture'
        });

        App.deferReadiness();

        App.Router.reopen({
          location: 'none'
        });

        Router = App.Router;

        App.LoadingRoute = _emberRouting.Route.extend({});

        registry = App.__registry__;
        container = App.__container__;

        _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{outlet}}'));
        _emberGlimmer.setTemplate('home', _emberTemplateCompiler.compile('<h3>Hours</h3>'));
        _emberGlimmer.setTemplate('homepage', _emberTemplateCompiler.compile('<h3>Megatroll</h3><p>{{model.home}}</p>'));
        _emberGlimmer.setTemplate('camelot', _emberTemplateCompiler.compile('<section><h3>Is a silly place</h3></section>'));

        originalLoggerError = _emberConsole.default.error;
      });
    },

    teardown: function () {
      _emberMetal.run(function () {
        App.destroy();
        App = null;

        _emberGlimmer.setTemplates({});
        _emberConsole.default.error = originalLoggerError;
      });
    }
  });

  QUnit.test('warn on URLs not included in the route set', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
    });

    bootApplication();

    expectAssertion(function () {
      return _emberMetal.run(function () {
        return router.handleURL('/what-is-this-i-dont-even');
      });
    }, 'The URL \'/what-is-this-i-dont-even\' did not match any routes in your application');
  });

  QUnit.test('The Homepage', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
    });

    App.HomeRoute = _emberRouting.Route.extend({});

    var currentPath = undefined;

    App.ApplicationController = _emberRuntime.Controller.extend({
      currentPathDidChange: _emberMetal.observer('currentPath', function () {
        currentPath = _emberMetal.get(this, 'currentPath');
      })
    });

    bootApplication();

    equal(currentPath, 'home');
    equal(_emberViews.jQuery('h3:contains(Hours)', '#qunit-fixture').length, 1, 'The home template was rendered');
  });

  QUnit.test('The Home page and the Camelot page with multiple Router.map calls', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
    });

    Router.map(function () {
      this.route('camelot', { path: '/camelot' });
    });

    App.HomeRoute = _emberRouting.Route.extend({});

    App.CamelotRoute = _emberRouting.Route.extend({});

    var currentPath = undefined;

    App.ApplicationController = _emberRuntime.Controller.extend({
      currentPathDidChange: _emberMetal.observer('currentPath', function () {
        currentPath = _emberMetal.get(this, 'currentPath');
      })
    });

    App.CamelotController = _emberRuntime.Controller.extend({
      currentPathDidChange: _emberMetal.observer('currentPath', function () {
        currentPath = _emberMetal.get(this, 'currentPath');
      })
    });

    bootApplication();

    handleURL('/camelot');

    equal(currentPath, 'camelot');
    equal(_emberViews.jQuery('h3:contains(silly)', '#qunit-fixture').length, 1, 'The camelot template was rendered');

    handleURL('/');

    equal(currentPath, 'home');
    equal(_emberViews.jQuery('h3:contains(Hours)', '#qunit-fixture').length, 1, 'The home template was rendered');
  });

  QUnit.test('The Homepage with explicit template name in renderTemplate', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
    });

    App.HomeRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render('homepage');
      }
    });

    bootApplication();

    equal(_emberViews.jQuery('h3:contains(Megatroll)', '#qunit-fixture').length, 1, 'The homepage template was rendered');
  });

  QUnit.test('An alternate template will pull in an alternate controller', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
    });

    App.HomeRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render('homepage');
      }
    });

    App.HomepageController = _emberRuntime.Controller.extend({
      model: {
        home: 'Comes from homepage'
      }
    });

    bootApplication();

    equal(_emberViews.jQuery('h3:contains(Megatroll) + p:contains(Comes from homepage)', '#qunit-fixture').length, 1, 'The homepage template was rendered');
  });

  QUnit.test('An alternate template will pull in an alternate controller instead of controllerName', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
    });

    App.HomeRoute = _emberRouting.Route.extend({
      controllerName: 'foo',
      renderTemplate: function () {
        this.render('homepage');
      }
    });

    App.FooController = _emberRuntime.Controller.extend({
      model: {
        home: 'Comes from Foo'
      }
    });

    App.HomepageController = _emberRuntime.Controller.extend({
      model: {
        home: 'Comes from homepage'
      }
    });

    bootApplication();

    equal(_emberViews.jQuery('h3:contains(Megatroll) + p:contains(Comes from homepage)', '#qunit-fixture').length, 1, 'The homepage template was rendered');
  });

  QUnit.test('The template will pull in an alternate controller via key/value', function () {
    Router.map(function () {
      this.route('homepage', { path: '/' });
    });

    App.HomepageRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render({ controller: 'home' });
      }
    });

    App.HomeController = _emberRuntime.Controller.extend({
      model: {
        home: 'Comes from home.'
      }
    });

    bootApplication();

    equal(_emberViews.jQuery('h3:contains(Megatroll) + p:contains(Comes from home.)', '#qunit-fixture').length, 1, 'The homepage template was rendered from data from the HomeController');
  });

  QUnit.test('The Homepage with explicit template name in renderTemplate and controller', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
    });

    App.HomeController = _emberRuntime.Controller.extend({
      model: {
        home: 'YES I AM HOME'
      }
    });

    App.HomeRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render('homepage');
      }
    });

    bootApplication();

    equal(_emberViews.jQuery('h3:contains(Megatroll) + p:contains(YES I AM HOME)', '#qunit-fixture').length, 1, 'The homepage template was rendered');
  });

  QUnit.test('Model passed via renderTemplate model is set as controller\'s model', function () {
    _emberGlimmer.setTemplate('bio', _emberTemplateCompiler.compile('<p>{{model.name}}</p>'));

    App.BioController = _emberRuntime.Controller.extend();

    Router.map(function () {
      this.route('home', { path: '/' });
    });

    App.HomeRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render('bio', {
          model: { name: 'emberjs' }
        });
      }
    });

    bootApplication();

    equal(_emberViews.jQuery('p:contains(emberjs)', '#qunit-fixture').length, 1, 'Passed model was set as controllers model');
  });

  QUnit.test('render uses templateName from route', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
    });

    _emberGlimmer.setTemplate('the_real_home_template', _emberTemplateCompiler.compile('<p>THIS IS THE REAL HOME</p>'));

    App.HomeController = _emberRuntime.Controller.extend();
    App.HomeRoute = _emberRouting.Route.extend({
      templateName: 'the_real_home_template'
    });

    bootApplication();

    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), 'THIS IS THE REAL HOME', 'The homepage template was rendered');
  });

  QUnit.test('defining templateName allows other templates to be rendered', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
    });

    _emberGlimmer.setTemplate('alert', _emberTemplateCompiler.compile('<div class=\'alert-box\'>Invader!</div>'));
    _emberGlimmer.setTemplate('the_real_home_template', _emberTemplateCompiler.compile('<p>THIS IS THE REAL HOME</p>{{outlet \'alert\'}}'));

    App.HomeController = _emberRuntime.Controller.extend();
    App.HomeRoute = _emberRouting.Route.extend({
      templateName: 'the_real_home_template',
      actions: {
        showAlert: function () {
          this.render('alert', {
            into: 'home',
            outlet: 'alert'
          });
        }
      }
    });

    bootApplication();

    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), 'THIS IS THE REAL HOME', 'The homepage template was rendered');

    _emberMetal.run(function () {
      return router.send('showAlert');
    });

    equal(_emberViews.jQuery('.alert-box', '#qunit-fixture').text(), 'Invader!', 'Template for alert was render into outlet');
  });

  QUnit.test('templateName is still used when calling render with no name and options', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
    });

    _emberGlimmer.setTemplate('alert', _emberTemplateCompiler.compile('<div class=\'alert-box\'>Invader!</div>'));
    _emberGlimmer.setTemplate('home', _emberTemplateCompiler.compile('<p>THIS IS THE REAL HOME</p>{{outlet \'alert\'}}'));

    App.HomeRoute = _emberRouting.Route.extend({
      templateName: 'alert',
      renderTemplate: function () {
        this.render({});
      }
    });

    bootApplication();

    equal(_emberViews.jQuery('.alert-box', '#qunit-fixture').text(), 'Invader!', 'default templateName was rendered into outlet');
  });

  QUnit.test('The Homepage with a `setupController` hook', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
    });

    App.HomeRoute = _emberRouting.Route.extend({
      setupController: function (controller) {
        _emberMetal.set(controller, 'hours', _emberRuntime.A(['Monday through Friday: 9am to 5pm', 'Saturday: Noon to Midnight', 'Sunday: Noon to 6pm']));
      }
    });

    _emberGlimmer.setTemplate('home', _emberTemplateCompiler.compile('<ul>{{#each hours as |entry|}}<li>{{entry}}</li>{{/each}}</ul>'));

    bootApplication();

    equal(_emberViews.jQuery('ul li', '#qunit-fixture').eq(2).text(), 'Sunday: Noon to 6pm', 'The template was rendered with the hours context');
  });

  QUnit.test('The route controller is still set when overriding the setupController hook', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
    });

    App.HomeRoute = _emberRouting.Route.extend({
      setupController: function (controller) {
        // no-op
        // importantly, we are not calling  this._super here
      }
    });

    registry.register('controller:home', _emberRuntime.Controller.extend());

    bootApplication();

    deepEqual(container.lookup('route:home').controller, container.lookup('controller:home'), 'route controller is the home controller');
  });

  QUnit.test('The route controller can be specified via controllerName', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
    });

    _emberGlimmer.setTemplate('home', _emberTemplateCompiler.compile('<p>{{myValue}}</p>'));

    App.HomeRoute = _emberRouting.Route.extend({
      controllerName: 'myController'
    });

    registry.register('controller:myController', _emberRuntime.Controller.extend({
      myValue: 'foo'
    }));

    bootApplication();

    deepEqual(container.lookup('route:home').controller, container.lookup('controller:myController'), 'route controller is set by controllerName');
    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), 'foo', 'The homepage template was rendered with data from the custom controller');
  });

  QUnit.test('The route controller specified via controllerName is used in render', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
    });

    _emberGlimmer.setTemplate('alternative_home', _emberTemplateCompiler.compile('<p>alternative home: {{myValue}}</p>'));

    App.HomeRoute = _emberRouting.Route.extend({
      controllerName: 'myController',
      renderTemplate: function () {
        this.render('alternative_home');
      }
    });

    registry.register('controller:myController', _emberRuntime.Controller.extend({
      myValue: 'foo'
    }));

    bootApplication();

    deepEqual(container.lookup('route:home').controller, container.lookup('controller:myController'), 'route controller is set by controllerName');
    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), 'alternative home: foo', 'The homepage template was rendered with data from the custom controller');
  });

  QUnit.test('The route controller specified via controllerName is used in render even when a controller with the routeName is available', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
    });

    _emberGlimmer.setTemplate('home', _emberTemplateCompiler.compile('<p>home: {{myValue}}</p>'));

    App.HomeRoute = _emberRouting.Route.extend({
      controllerName: 'myController'
    });

    registry.register('controller:home', _emberRuntime.Controller.extend({
      myValue: 'home'
    }));

    registry.register('controller:myController', _emberRuntime.Controller.extend({
      myValue: 'myController'
    }));

    bootApplication();

    deepEqual(container.lookup('route:home').controller, container.lookup('controller:myController'), 'route controller is set by controllerName');
    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), 'home: myController', 'The homepage template was rendered with data from the custom controller');
  });

  QUnit.test('The Homepage with a `setupController` hook modifying other controllers', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
    });

    App.HomeRoute = _emberRouting.Route.extend({
      setupController: function (controller) {
        _emberMetal.set(this.controllerFor('home'), 'hours', _emberRuntime.A(['Monday through Friday: 9am to 5pm', 'Saturday: Noon to Midnight', 'Sunday: Noon to 6pm']));
      }
    });

    _emberGlimmer.setTemplate('home', _emberTemplateCompiler.compile('<ul>{{#each hours as |entry|}}<li>{{entry}}</li>{{/each}}</ul>'));

    bootApplication();

    equal(_emberViews.jQuery('ul li', '#qunit-fixture').eq(2).text(), 'Sunday: Noon to 6pm', 'The template was rendered with the hours context');
  });

  QUnit.test('The Homepage with a computed context that does not get overridden', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
    });

    App.HomeController = _emberRuntime.Controller.extend({
      model: _emberMetal.computed(function () {
        return _emberRuntime.A(['Monday through Friday: 9am to 5pm', 'Saturday: Noon to Midnight', 'Sunday: Noon to 6pm']);
      })
    });

    _emberGlimmer.setTemplate('home', _emberTemplateCompiler.compile('<ul>{{#each model as |passage|}}<li>{{passage}}</li>{{/each}}</ul>'));

    bootApplication();

    equal(_emberViews.jQuery('ul li', '#qunit-fixture').eq(2).text(), 'Sunday: Noon to 6pm', 'The template was rendered with the context intact');
  });

  QUnit.test('The Homepage getting its controller context via model', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
    });

    App.HomeRoute = _emberRouting.Route.extend({
      model: function () {
        return _emberRuntime.A(['Monday through Friday: 9am to 5pm', 'Saturday: Noon to Midnight', 'Sunday: Noon to 6pm']);
      },

      setupController: function (controller, model) {
        equal(this.controllerFor('home'), controller);

        _emberMetal.set(this.controllerFor('home'), 'hours', model);
      }
    });

    _emberGlimmer.setTemplate('home', _emberTemplateCompiler.compile('<ul>{{#each hours as |entry|}}<li>{{entry}}</li>{{/each}}</ul>'));

    bootApplication();

    equal(_emberViews.jQuery('ul li', '#qunit-fixture').eq(2).text(), 'Sunday: Noon to 6pm', 'The template was rendered with the hours context');
  });

  QUnit.test('The Specials Page getting its controller context by deserializing the params hash', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
      this.route('special', { path: '/specials/:menu_item_id' });
    });

    App.SpecialRoute = _emberRouting.Route.extend({
      model: function (params) {
        return _emberRuntime.Object.create({
          menuItemId: params.menu_item_id
        });
      },

      setupController: function (controller, model) {
        _emberMetal.set(controller, 'model', model);
      }
    });

    _emberGlimmer.setTemplate('special', _emberTemplateCompiler.compile('<p>{{model.menuItemId}}</p>'));

    bootApplication();

    registry.register('controller:special', _emberRuntime.Controller.extend());

    handleURL('/specials/1');

    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), '1', 'The model was used to render the template');
  });

  QUnit.test('The Specials Page defaults to looking models up via `find`', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
      this.route('special', { path: '/specials/:menu_item_id' });
    });

    App.MenuItem = _emberRuntime.Object.extend();
    App.MenuItem.reopenClass({
      find: function (id) {
        return App.MenuItem.create({
          id: id
        });
      }
    });

    App.SpecialRoute = _emberRouting.Route.extend({
      setupController: function (controller, model) {
        _emberMetal.set(controller, 'model', model);
      }
    });

    _emberGlimmer.setTemplate('special', _emberTemplateCompiler.compile('<p>{{model.id}}</p>'));

    bootApplication();

    registry.register('controller:special', _emberRuntime.Controller.extend());

    handleURL('/specials/1');

    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), '1', 'The model was used to render the template');
  });

  QUnit.test('The Special Page returning a promise puts the app into a loading state until the promise is resolved', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
      this.route('special', { path: '/specials/:menu_item_id' });
    });

    var menuItem = undefined,
        resolve = undefined;

    App.MenuItem = _emberRuntime.Object.extend();
    App.MenuItem.reopenClass({
      find: function (id) {
        menuItem = App.MenuItem.create({ id: id });

        return new _emberRuntime.RSVP.Promise(function (res) {
          resolve = res;
        });
      }
    });

    App.LoadingRoute = _emberRouting.Route.extend({});

    App.SpecialRoute = _emberRouting.Route.extend({
      setupController: function (controller, model) {
        _emberMetal.set(controller, 'model', model);
      }
    });

    _emberGlimmer.setTemplate('special', _emberTemplateCompiler.compile('<p>{{model.id}}</p>'));

    _emberGlimmer.setTemplate('loading', _emberTemplateCompiler.compile('<p>LOADING!</p>'));

    bootApplication();

    registry.register('controller:special', _emberRuntime.Controller.extend());

    handleURL('/specials/1');

    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), 'LOADING!', 'The app is in the loading state');

    _emberMetal.run(function () {
      return resolve(menuItem);
    });

    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), '1', 'The app is now in the specials state');
  });

  QUnit.test('The loading state doesn\'t get entered for promises that resolve on the same run loop', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
      this.route('special', { path: '/specials/:menu_item_id' });
    });

    App.MenuItem = _emberRuntime.Object.extend();
    App.MenuItem.reopenClass({
      find: function (id) {
        return { id: id };
      }
    });

    App.LoadingRoute = _emberRouting.Route.extend({
      enter: function () {
        ok(false, 'LoadingRoute shouldn\'t have been entered.');
      }
    });

    App.SpecialRoute = _emberRouting.Route.extend({
      setupController: function (controller, model) {
        _emberMetal.set(controller, 'model', model);
      }
    });

    _emberGlimmer.setTemplate('special', _emberTemplateCompiler.compile('<p>{{model.id}}</p>'));

    _emberGlimmer.setTemplate('loading', _emberTemplateCompiler.compile('<p>LOADING!</p>'));

    bootApplication();

    registry.register('controller:special', _emberRuntime.Controller.extend());

    handleURL('/specials/1');

    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), '1', 'The app is now in the specials state');
  });

  /*
  asyncTest("The Special page returning an error fires the error hook on SpecialRoute", function() {
    Router.map(function() {
      this.route("home", { path: "/" });
      this.route("special", { path: "/specials/:menu_item_id" });
    });
  
    let menuItem;
  
    App.MenuItem = Ember.Object.extend();
    App.MenuItem.reopenClass({
      find: function(id) {
        menuItem = App.MenuItem.create({ id: id });
        run.later(function() { menuItem.resolve(menuItem); }, 1);
        return menuItem;
      }
    });
  
    App.SpecialRoute = Route.extend({
      setup: function() {
        throw 'Setup error';
      },
      actions: {
        error: function(reason) {
          equal(reason, 'Setup error');
          QUnit.start();
        }
      }
    });
  
    bootApplication();
  
    handleURLRejectsWith('/specials/1', 'Setup error');
  });
  */

  QUnit.test('The Special page returning an error invokes SpecialRoute\'s error handler', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
      this.route('special', { path: '/specials/:menu_item_id' });
    });

    var menuItem = undefined,
        promise = undefined,
        resolve = undefined;

    App.MenuItem = _emberRuntime.Object.extend();
    App.MenuItem.reopenClass({
      find: function (id) {
        menuItem = App.MenuItem.create({ id: id });
        promise = new _emberRuntime.RSVP.Promise(function (res) {
          resolve = res;
        });

        return promise;
      }
    });

    App.SpecialRoute = _emberRouting.Route.extend({
      setup: function () {
        throw 'Setup error';
      },
      actions: {
        error: function (reason) {
          equal(reason, 'Setup error', 'SpecialRoute#error received the error thrown from setup');
          return true;
        }
      }
    });

    bootApplication();

    handleURLRejectsWith('/specials/1', 'Setup error');

    _emberMetal.run(function () {
      return resolve(menuItem);
    });
  });

  var testOverridableErrorHandler = function (handlersName) {
    expect(2);

    Router.map(function () {
      this.route('home', { path: '/' });
      this.route('special', { path: '/specials/:menu_item_id' });
    });

    var menuItem = undefined,
        resolve = undefined;

    App.MenuItem = _emberRuntime.Object.extend();
    App.MenuItem.reopenClass({
      find: function (id) {
        menuItem = App.MenuItem.create({ id: id });
        return new _emberRuntime.RSVP.Promise(function (res) {
          resolve = res;
        });
      }
    });

    var attrs = {};
    attrs[handlersName] = {
      error: function (reason) {
        equal(reason, 'Setup error', 'error was correctly passed to custom ApplicationRoute handler');
        return true;
      }
    };

    App.ApplicationRoute = _emberRouting.Route.extend(attrs);

    App.SpecialRoute = _emberRouting.Route.extend({
      setup: function () {
        throw 'Setup error';
      }
    });

    bootApplication();

    handleURLRejectsWith('/specials/1', 'Setup error');

    _emberMetal.run(function () {
      return resolve(menuItem);
    });
  };

  QUnit.test('ApplicationRoute\'s default error handler can be overridden', function () {
    testOverridableErrorHandler('actions');
  });

  QUnit.asyncTest('Moving from one page to another triggers the correct callbacks', function () {
    expect(3);

    Router.map(function () {
      this.route('home', { path: '/' });
      this.route('special', { path: '/specials/:menu_item_id' });
    });

    App.MenuItem = _emberRuntime.Object.extend();

    App.SpecialRoute = _emberRouting.Route.extend({
      setupController: function (controller, model) {
        _emberMetal.set(controller, 'model', model);
      }
    });

    _emberGlimmer.setTemplate('home', _emberTemplateCompiler.compile('<h3>Home</h3>'));

    _emberGlimmer.setTemplate('special', _emberTemplateCompiler.compile('<p>{{model.id}}</p>'));

    bootApplication();

    registry.register('controller:special', _emberRuntime.Controller.extend());

    var transition = handleURL('/');

    _emberMetal.run(function () {
      transition.then(function () {
        equal(_emberViews.jQuery('h3', '#qunit-fixture').text(), 'Home', 'The app is now in the initial state');

        var promiseContext = App.MenuItem.create({ id: 1 });
        _emberMetal.run.later(function () {
          return _emberRuntime.RSVP.resolve(promiseContext);
        }, 1);

        return router.transitionTo('special', promiseContext);
      }).then(function (result) {
        deepEqual(router.location.path, '/specials/1');
        QUnit.start();
      });
    });
  });

  QUnit.asyncTest('Nested callbacks are not exited when moving to siblings', function () {
    Router.map(function () {
      this.route('root', { path: '/' }, function () {
        this.route('special', { path: '/specials/:menu_item_id', resetNamespace: true });
      });
    });

    App.RootRoute = _emberRouting.Route.extend({
      model: function () {
        rootModel++;
        return this._super.apply(this, arguments);
      },

      setupController: function () {
        rootSetup++;
      },

      renderTemplate: function () {
        rootRender++;
      },

      serialize: function () {
        rootSerialize++;
        return this._super.apply(this, arguments);
      }
    });

    var currentPath = undefined;

    App.ApplicationController = _emberRuntime.Controller.extend({
      currentPathDidChange: _emberMetal.observer('currentPath', function () {
        currentPath = _emberMetal.get(this, 'currentPath');
      })
    });

    var menuItem = undefined;

    App.MenuItem = _emberRuntime.Object.extend();
    App.MenuItem.reopenClass({
      find: function (id) {
        menuItem = App.MenuItem.create({ id: id });
        return menuItem;
      }
    });

    App.LoadingRoute = _emberRouting.Route.extend({});

    App.HomeRoute = _emberRouting.Route.extend({});

    App.SpecialRoute = _emberRouting.Route.extend({
      setupController: function (controller, model) {
        _emberMetal.set(controller, 'model', model);
      }
    });

    _emberGlimmer.setTemplate('root/index', _emberTemplateCompiler.compile('<h3>Home</h3>'));

    _emberGlimmer.setTemplate('special', _emberTemplateCompiler.compile('<p>{{model.id}}</p>'));

    _emberGlimmer.setTemplate('loading', _emberTemplateCompiler.compile('<p>LOADING!</p>'));

    var rootSetup = 0;
    var rootRender = 0;
    var rootModel = 0;
    var rootSerialize = 0;

    bootApplication();

    registry.register('controller:special', _emberRuntime.Controller.extend());

    equal(_emberViews.jQuery('h3', '#qunit-fixture').text(), 'Home', 'The app is now in the initial state');
    equal(rootSetup, 1, 'The root setup was triggered');
    equal(rootRender, 1, 'The root render was triggered');
    equal(rootSerialize, 0, 'The root serialize was not called');
    equal(rootModel, 1, 'The root model was called');

    router = container.lookup('router:main');

    _emberMetal.run(function () {
      var menuItem = App.MenuItem.create({ id: 1 });
      _emberMetal.run.later(function () {
        return _emberRuntime.RSVP.resolve(menuItem);
      }, 1);

      router.transitionTo('special', menuItem).then(function (result) {
        equal(rootSetup, 1, 'The root setup was not triggered again');
        equal(rootRender, 1, 'The root render was not triggered again');
        equal(rootSerialize, 0, 'The root serialize was not called');

        // TODO: Should this be changed?
        equal(rootModel, 1, 'The root model was called again');

        deepEqual(router.location.path, '/specials/1');
        equal(currentPath, 'root.special');

        QUnit.start();
      });
    });
  });

  QUnit.asyncTest('Events are triggered on the controller if a matching action name is implemented', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
    });

    var model = { name: 'Tom Dale' };
    var stateIsNotCalled = true;

    App.HomeRoute = _emberRouting.Route.extend({
      model: function () {
        return model;
      },

      actions: {
        showStuff: function (obj) {
          stateIsNotCalled = false;
        }
      }
    });

    _emberGlimmer.setTemplate('home', _emberTemplateCompiler.compile('<a {{action \'showStuff\' model}}>{{name}}</a>'));

    var controller = _emberRuntime.Controller.extend({
      actions: {
        showStuff: function (context) {
          ok(stateIsNotCalled, 'an event on the state is not triggered');
          deepEqual(context, { name: 'Tom Dale' }, 'an event with context is passed');
          QUnit.start();
        }
      }
    });

    registry.register('controller:home', controller);

    bootApplication();

    _emberViews.jQuery('#qunit-fixture a').click();
  });

  QUnit.asyncTest('Events are triggered on the current state when defined in `actions` object', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
    });

    var model = { name: 'Tom Dale' };

    App.HomeRoute = _emberRouting.Route.extend({
      model: function () {
        return model;
      },

      actions: {
        showStuff: function (obj) {
          ok(this instanceof App.HomeRoute, 'the handler is an App.HomeRoute');
          // Using Ember.copy removes any private Ember vars which older IE would be confused by
          deepEqual(_emberRuntime.copy(obj, true), { name: 'Tom Dale' }, 'the context is correct');
          QUnit.start();
        }
      }
    });

    _emberGlimmer.setTemplate('home', _emberTemplateCompiler.compile('<a {{action \'showStuff\' model}}>{{model.name}}</a>'));

    bootApplication();

    _emberViews.jQuery('#qunit-fixture a').click();
  });

  QUnit.asyncTest('Events defined in `actions` object are triggered on the current state when routes are nested', function () {
    Router.map(function () {
      this.route('root', { path: '/' }, function () {
        this.route('index', { path: '/' });
      });
    });

    var model = { name: 'Tom Dale' };

    App.RootRoute = _emberRouting.Route.extend({
      actions: {
        showStuff: function (obj) {
          ok(this instanceof App.RootRoute, 'the handler is an App.HomeRoute');
          // Using Ember.copy removes any private Ember vars which older IE would be confused by
          deepEqual(_emberRuntime.copy(obj, true), { name: 'Tom Dale' }, 'the context is correct');
          QUnit.start();
        }
      }
    });

    App.RootIndexRoute = _emberRouting.Route.extend({
      model: function () {
        return model;
      }
    });

    _emberGlimmer.setTemplate('root/index', _emberTemplateCompiler.compile('<a {{action \'showStuff\' model}}>{{model.name}}</a>'));

    bootApplication();

    _emberViews.jQuery('#qunit-fixture a').click();
  });

  QUnit.test('Events can be handled by inherited event handlers', function () {
    expect(4);

    App.SuperRoute = _emberRouting.Route.extend({
      actions: {
        foo: function () {
          ok(true, 'foo');
        },
        bar: function (msg) {
          equal(msg, 'HELLO');
        }
      }
    });

    App.RouteMixin = _emberMetal.Mixin.create({
      actions: {
        bar: function (msg) {
          equal(msg, 'HELLO');
          this._super(msg);
        }
      }
    });

    App.IndexRoute = App.SuperRoute.extend(App.RouteMixin, {
      actions: {
        baz: function () {
          ok(true, 'baz');
        }
      }
    });

    bootApplication();

    router.send('foo');
    router.send('bar', 'HELLO');
    router.send('baz');
  });

  QUnit.asyncTest('Actions are not triggered on the controller if a matching action name is implemented as a method', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
    });

    var model = { name: 'Tom Dale' };
    var stateIsNotCalled = true;

    App.HomeRoute = _emberRouting.Route.extend({
      model: function () {
        return model;
      },

      actions: {
        showStuff: function (context) {
          ok(stateIsNotCalled, 'an event on the state is not triggered');
          deepEqual(context, { name: 'Tom Dale' }, 'an event with context is passed');
          QUnit.start();
        }
      }
    });

    _emberGlimmer.setTemplate('home', _emberTemplateCompiler.compile('<a {{action \'showStuff\' model}}>{{name}}</a>'));

    var controller = _emberRuntime.Controller.extend({
      showStuff: function (context) {
        stateIsNotCalled = false;
        ok(stateIsNotCalled, 'an event on the state is not triggered');
      }
    });

    registry.register('controller:home', controller);

    bootApplication();

    _emberViews.jQuery('#qunit-fixture a').click();
  });

  QUnit.asyncTest('actions can be triggered with multiple arguments', function () {
    Router.map(function () {
      this.route('root', { path: '/' }, function () {
        this.route('index', { path: '/' });
      });
    });

    var model1 = { name: 'Tilde' };
    var model2 = { name: 'Tom Dale' };

    App.RootRoute = _emberRouting.Route.extend({
      actions: {
        showStuff: function (obj1, obj2) {
          ok(this instanceof App.RootRoute, 'the handler is an App.HomeRoute');
          // Using Ember.copy removes any private Ember vars which older IE would be confused by
          deepEqual(_emberRuntime.copy(obj1, true), { name: 'Tilde' }, 'the first context is correct');
          deepEqual(_emberRuntime.copy(obj2, true), { name: 'Tom Dale' }, 'the second context is correct');
          QUnit.start();
        }
      }
    });

    App.RootIndexController = _emberRuntime.Controller.extend({
      model1: model1,
      model2: model2
    });

    _emberGlimmer.setTemplate('root/index', _emberTemplateCompiler.compile('<a {{action \'showStuff\' model1 model2}}>{{model1.name}}</a>'));

    bootApplication();

    _emberViews.jQuery('#qunit-fixture a').click();
  });

  QUnit.test('transitioning multiple times in a single run loop only sets the URL once', function () {
    Router.map(function () {
      this.route('root', { path: '/' });
      this.route('foo');
      this.route('bar');
    });

    bootApplication();

    var urlSetCount = 0;

    router.get('location').setURL = function (path) {
      urlSetCount++;
      _emberMetal.set(this, 'path', path);
    };

    equal(urlSetCount, 0);

    _emberMetal.run(function () {
      router.transitionTo('foo');
      router.transitionTo('bar');
    });

    equal(urlSetCount, 1);
    equal(router.get('location').getURL(), '/bar');
  });

  QUnit.test('navigating away triggers a url property change', function () {
    expect(3);

    Router.map(function () {
      this.route('root', { path: '/' });
      this.route('foo', { path: '/foo' });
      this.route('bar', { path: '/bar' });
    });

    bootApplication();

    _emberMetal.run(function () {
      _emberMetal.addObserver(router, 'url', function () {
        ok(true, 'url change event was fired');
      });
    });

    ['foo', 'bar', '/foo'].forEach(function (destination) {
      return _emberMetal.run(router, 'transitionTo', destination);
    });
  });

  QUnit.test('using replaceWith calls location.replaceURL if available', function () {
    var setCount = 0;
    var replaceCount = 0;

    Router.reopen({
      location: _emberRouting.NoneLocation.create({
        setURL: function (path) {
          setCount++;
          _emberMetal.set(this, 'path', path);
        },

        replaceURL: function (path) {
          replaceCount++;
          _emberMetal.set(this, 'path', path);
        }
      })
    });

    Router.map(function () {
      this.route('root', { path: '/' });
      this.route('foo');
    });

    bootApplication();

    equal(setCount, 0);
    equal(replaceCount, 0);

    _emberMetal.run(function () {
      return router.replaceWith('foo');
    });

    equal(setCount, 0, 'should not call setURL');
    equal(replaceCount, 1, 'should call replaceURL once');
    equal(router.get('location').getURL(), '/foo');
  });

  QUnit.test('using replaceWith calls setURL if location.replaceURL is not defined', function () {
    var setCount = 0;

    Router.reopen({
      location: _emberRouting.NoneLocation.create({
        setURL: function (path) {
          setCount++;
          _emberMetal.set(this, 'path', path);
        }
      })
    });

    Router.map(function () {
      this.route('root', { path: '/' });
      this.route('foo');
    });

    bootApplication();

    equal(setCount, 0);

    _emberMetal.run(function () {
      return router.replaceWith('foo');
    });

    equal(setCount, 1, 'should call setURL once');
    equal(router.get('location').getURL(), '/foo');
  });

  QUnit.test('Route inherits model from parent route', function () {
    expect(9);

    Router.map(function () {
      this.route('the_post', { path: '/posts/:post_id' }, function () {
        this.route('comments');

        this.route('shares', { path: '/shares/:share_id', resetNamespace: true }, function () {
          this.route('share');
        });
      });
    });

    var post1 = {};
    var post2 = {};
    var post3 = {};
    var share1 = {};
    var share2 = {};
    var share3 = {};

    var posts = {
      1: post1,
      2: post2,
      3: post3
    };
    var shares = {
      1: share1,
      2: share2,
      3: share3
    };

    App.ThePostRoute = _emberRouting.Route.extend({
      model: function (params) {
        return posts[params.post_id];
      }
    });

    App.ThePostCommentsRoute = _emberRouting.Route.extend({
      afterModel: function (post, transition) {
        var parent_model = this.modelFor('thePost');

        equal(post, parent_model);
      }
    });

    App.SharesRoute = _emberRouting.Route.extend({
      model: function (params) {
        return shares[params.share_id];
      }
    });

    App.SharesShareRoute = _emberRouting.Route.extend({
      afterModel: function (share, transition) {
        var parent_model = this.modelFor('shares');

        equal(share, parent_model);
      }
    });

    bootApplication();

    handleURL('/posts/1/comments');
    handleURL('/posts/1/shares/1');

    handleURL('/posts/2/comments');
    handleURL('/posts/2/shares/2');

    handleURL('/posts/3/comments');
    handleURL('/posts/3/shares/3');
  });

  QUnit.test('Routes with { resetNamespace: true } inherits model from parent route', function () {
    expect(6);

    Router.map(function () {
      this.route('the_post', { path: '/posts/:post_id' }, function () {
        this.route('comments', { resetNamespace: true }, function () {});
      });
    });

    var post1 = {};
    var post2 = {};
    var post3 = {};

    var posts = {
      1: post1,
      2: post2,
      3: post3
    };

    App.ThePostRoute = _emberRouting.Route.extend({
      model: function (params) {
        return posts[params.post_id];
      }
    });

    App.CommentsRoute = _emberRouting.Route.extend({
      afterModel: function (post, transition) {
        var parent_model = this.modelFor('thePost');

        equal(post, parent_model);
      }
    });

    bootApplication();

    handleURL('/posts/1/comments');
    handleURL('/posts/2/comments');
    handleURL('/posts/3/comments');
  });

  QUnit.test('It is possible to get the model from a parent route', function () {
    expect(9);

    Router.map(function () {
      this.route('the_post', { path: '/posts/:post_id' }, function () {
        this.route('comments', { resetNamespace: true });
      });
    });

    var post1 = {};
    var post2 = {};
    var post3 = {};
    var currentPost = undefined;

    var posts = {
      1: post1,
      2: post2,
      3: post3
    };

    App.ThePostRoute = _emberRouting.Route.extend({
      model: function (params) {
        return posts[params.post_id];
      }
    });

    App.CommentsRoute = _emberRouting.Route.extend({
      model: function () {
        // Allow both underscore / camelCase format.
        equal(this.modelFor('thePost'), currentPost);
        equal(this.modelFor('the_post'), currentPost);
      }
    });

    bootApplication();

    currentPost = post1;
    handleURL('/posts/1/comments');

    currentPost = post2;
    handleURL('/posts/2/comments');

    currentPost = post3;
    handleURL('/posts/3/comments');
  });

  QUnit.test('A redirection hook is provided', function () {
    Router.map(function () {
      this.route('choose', { path: '/' });
      this.route('home');
    });

    var chooseFollowed = 0;
    var destination = undefined;

    App.ChooseRoute = _emberRouting.Route.extend({
      redirect: function () {
        if (destination) {
          this.transitionTo(destination);
        }
      },

      setupController: function () {
        chooseFollowed++;
      }
    });

    destination = 'home';

    bootApplication();

    equal(chooseFollowed, 0, 'The choose route wasn\'t entered since a transition occurred');
    equal(_emberViews.jQuery('h3:contains(Hours)', '#qunit-fixture').length, 1, 'The home template was rendered');
    equal(_emberUtils.getOwner(router).lookup('controller:application').get('currentPath'), 'home');
  });

  QUnit.test('Redirecting from the middle of a route aborts the remainder of the routes', function () {
    expect(3);

    Router.map(function () {
      this.route('home');
      this.route('foo', function () {
        this.route('bar', { resetNamespace: true }, function () {
          this.route('baz');
        });
      });
    });

    App.BarRoute = _emberRouting.Route.extend({
      redirect: function () {
        this.transitionTo('home');
      },
      setupController: function () {
        ok(false, 'Should transition before setupController');
      }
    });

    App.BarBazRoute = _emberRouting.Route.extend({
      enter: function () {
        ok(false, 'Should abort transition getting to next route');
      }
    });

    bootApplication();

    handleURLAborts('/foo/bar/baz');

    equal(_emberUtils.getOwner(router).lookup('controller:application').get('currentPath'), 'home');
    equal(router.get('location').getURL(), '/home');
  });

  QUnit.test('Redirecting to the current target in the middle of a route does not abort initial routing', function () {
    expect(5);

    Router.map(function () {
      this.route('home');
      this.route('foo', function () {
        this.route('bar', { resetNamespace: true }, function () {
          this.route('baz');
        });
      });
    });

    var successCount = 0;
    App.BarRoute = _emberRouting.Route.extend({
      redirect: function () {
        this.transitionTo('bar.baz').then(function () {
          successCount++;
        });
      },

      setupController: function () {
        ok(true, 'Should still invoke bar\'s setupController');
      }
    });

    App.BarBazRoute = _emberRouting.Route.extend({
      setupController: function () {
        ok(true, 'Should still invoke bar.baz\'s setupController');
      }
    });

    bootApplication();

    handleURL('/foo/bar/baz');

    equal(_emberUtils.getOwner(router).lookup('controller:application').get('currentPath'), 'foo.bar.baz');
    equal(successCount, 1, 'transitionTo success handler was called once');
  });

  QUnit.test('Redirecting to the current target with a different context aborts the remainder of the routes', function () {
    expect(4);

    Router.map(function () {
      this.route('home');
      this.route('foo', function () {
        this.route('bar', { path: 'bar/:id', resetNamespace: true }, function () {
          this.route('baz');
        });
      });
    });

    var model = { id: 2 };

    var count = 0;

    App.BarRoute = _emberRouting.Route.extend({
      afterModel: function (context) {
        if (count++ > 10) {
          ok(false, 'infinite loop');
        } else {
          this.transitionTo('bar.baz', model);
        }
      }
    });

    App.BarBazRoute = _emberRouting.Route.extend({
      setupController: function () {
        ok(true, 'Should still invoke setupController');
      }
    });

    bootApplication();

    handleURLAborts('/foo/bar/1/baz');

    equal(_emberUtils.getOwner(router).lookup('controller:application').get('currentPath'), 'foo.bar.baz');
    equal(router.get('location').getURL(), '/foo/bar/2/baz');
  });

  QUnit.test('Transitioning from a parent event does not prevent currentPath from being set', function () {
    Router.map(function () {
      this.route('foo', function () {
        this.route('bar', { resetNamespace: true }, function () {
          this.route('baz');
        });
        this.route('qux');
      });
    });

    App.FooRoute = _emberRouting.Route.extend({
      actions: {
        goToQux: function () {
          this.transitionTo('foo.qux');
        }
      }
    });

    bootApplication();

    var applicationController = _emberUtils.getOwner(router).lookup('controller:application');

    handleURL('/foo/bar/baz');

    equal(applicationController.get('currentPath'), 'foo.bar.baz');

    _emberMetal.run(function () {
      return router.send('goToQux');
    });

    equal(applicationController.get('currentPath'), 'foo.qux');
    equal(router.get('location').getURL(), '/foo/qux');
  });

  QUnit.test('Generated names can be customized when providing routes with dot notation', function () {
    expect(4);

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<div>Index</div>'));
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<h1>Home</h1><div class=\'main\'>{{outlet}}</div>'));
    _emberGlimmer.setTemplate('foo', _emberTemplateCompiler.compile('<div class=\'middle\'>{{outlet}}</div>'));
    _emberGlimmer.setTemplate('bar', _emberTemplateCompiler.compile('<div class=\'bottom\'>{{outlet}}</div>'));
    _emberGlimmer.setTemplate('bar/baz', _emberTemplateCompiler.compile('<p>{{name}}Bottom!</p>'));

    Router.map(function () {
      this.route('foo', { path: '/top' }, function () {
        this.route('bar', { path: '/middle', resetNamespace: true }, function () {
          this.route('baz', { path: '/bottom' });
        });
      });
    });

    App.FooRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        ok(true, 'FooBarRoute was called');
        return this._super.apply(this, arguments);
      }
    });

    App.BarBazRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        ok(true, 'BarBazRoute was called');
        return this._super.apply(this, arguments);
      }
    });

    App.BarController = _emberRuntime.Controller.extend({
      name: 'Bar'
    });

    App.BarBazController = _emberRuntime.Controller.extend({
      name: 'BarBaz'
    });

    bootApplication();

    handleURL('/top/middle/bottom');

    equal(_emberViews.jQuery('.main .middle .bottom p', '#qunit-fixture').text(), 'BarBazBottom!', 'The templates were rendered into their appropriate parents');
  });

  QUnit.test('Child routes render into their parent route\'s template by default', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<div>Index</div>'));
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<h1>Home</h1><div class=\'main\'>{{outlet}}</div>'));
    _emberGlimmer.setTemplate('top', _emberTemplateCompiler.compile('<div class=\'middle\'>{{outlet}}</div>'));
    _emberGlimmer.setTemplate('middle', _emberTemplateCompiler.compile('<div class=\'bottom\'>{{outlet}}</div>'));
    _emberGlimmer.setTemplate('middle/bottom', _emberTemplateCompiler.compile('<p>Bottom!</p>'));

    Router.map(function () {
      this.route('top', function () {
        this.route('middle', { resetNamespace: true }, function () {
          this.route('bottom');
        });
      });
    });

    bootApplication();

    handleURL('/top/middle/bottom');

    equal(_emberViews.jQuery('.main .middle .bottom p', '#qunit-fixture').text(), 'Bottom!', 'The templates were rendered into their appropriate parents');
  });

  QUnit.test('Child routes render into specified template', function () {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<div>Index</div>'));
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<h1>Home</h1><div class=\'main\'>{{outlet}}</div>'));
    _emberGlimmer.setTemplate('top', _emberTemplateCompiler.compile('<div class=\'middle\'>{{outlet}}</div>'));
    _emberGlimmer.setTemplate('middle', _emberTemplateCompiler.compile('<div class=\'bottom\'>{{outlet}}</div>'));
    _emberGlimmer.setTemplate('middle/bottom', _emberTemplateCompiler.compile('<p>Bottom!</p>'));

    Router.map(function () {
      this.route('top', function () {
        this.route('middle', { resetNamespace: true }, function () {
          this.route('bottom');
        });
      });
    });

    App.MiddleBottomRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render('middle/bottom', { into: 'top' });
      }
    });

    bootApplication();

    handleURL('/top/middle/bottom');

    equal(_emberViews.jQuery('.main .middle .bottom p', '#qunit-fixture').length, 0, 'should not render into the middle template');
    equal(_emberViews.jQuery('.main .middle > p', '#qunit-fixture').text(), 'Bottom!', 'The template was rendered into the top template');
  });

  QUnit.test('Rendering into specified template with slash notation', function () {
    _emberGlimmer.setTemplate('person/profile', _emberTemplateCompiler.compile('profile {{outlet}}'));
    _emberGlimmer.setTemplate('person/details', _emberTemplateCompiler.compile('details!'));

    Router.map(function () {
      this.route('home', { path: '/' });
    });

    App.HomeRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render('person/profile');
        this.render('person/details', { into: 'person/profile' });
      }
    });

    bootApplication();

    equal(_emberViews.jQuery('#qunit-fixture:contains(profile details!)').length, 1, 'The templates were rendered');
  });

  QUnit.test('Parent route context change', function () {
    var editCount = 0;
    var editedPostIds = _emberRuntime.A();

    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{outlet}}'));
    _emberGlimmer.setTemplate('posts', _emberTemplateCompiler.compile('{{outlet}}'));
    _emberGlimmer.setTemplate('post', _emberTemplateCompiler.compile('{{outlet}}'));
    _emberGlimmer.setTemplate('post/index', _emberTemplateCompiler.compile('showing'));
    _emberGlimmer.setTemplate('post/edit', _emberTemplateCompiler.compile('editing'));

    Router.map(function () {
      this.route('posts', function () {
        this.route('post', { path: '/:postId', resetNamespace: true }, function () {
          this.route('edit');
        });
      });
    });

    App.PostsRoute = _emberRouting.Route.extend({
      actions: {
        showPost: function (context) {
          this.transitionTo('post', context);
        }
      }
    });

    App.PostRoute = _emberRouting.Route.extend({
      model: function (params) {
        return { id: params.postId };
      },

      serialize: function (model) {
        return { postId: model.id };
      },

      actions: {
        editPost: function (context) {
          this.transitionTo('post.edit');
        }
      }
    });

    App.PostEditRoute = _emberRouting.Route.extend({
      model: function (params) {
        var postId = this.modelFor('post').id;
        editedPostIds.push(postId);
        return null;
      },
      setup: function () {
        this._super.apply(this, arguments);
        editCount++;
      }
    });

    bootApplication();

    handleURL('/posts/1');

    _emberMetal.run(function () {
      return router.send('editPost');
    });
    _emberMetal.run(function () {
      return router.send('showPost', { id: '2' });
    });
    _emberMetal.run(function () {
      return router.send('editPost');
    });

    equal(editCount, 2, 'set up the edit route twice without failure');
    deepEqual(editedPostIds, ['1', '2'], 'modelFor posts.post returns the right context');
  });

  QUnit.test('Router accounts for rootURL on page load when using history location', function () {
    var rootURL = window.location.pathname + '/app';
    var postsTemplateRendered = false;
    var setHistory = undefined,
        HistoryTestLocation = undefined;

    setHistory = function (obj, path) {
      obj.set('history', { state: { path: path } });
    };

    // Create new implementation that extends HistoryLocation
    // and set current location to rootURL + '/posts'
    HistoryTestLocation = _emberRouting.HistoryLocation.extend({
      initState: function () {
        var path = rootURL + '/posts';

        setHistory(this, path);
        this.set('location', {
          pathname: path,
          href: 'http://localhost/' + path
        });
      },

      replaceState: function (path) {
        setHistory(this, path);
      },

      pushState: function (path) {
        setHistory(this, path);
      }
    });

    registry.register('location:historyTest', HistoryTestLocation);

    Router.reopen({
      location: 'historyTest',
      rootURL: rootURL
    });

    Router.map(function () {
      this.route('posts', { path: '/posts' });
    });

    App.PostsRoute = _emberRouting.Route.extend({
      model: function () {},
      renderTemplate: function () {
        postsTemplateRendered = true;
      }
    });

    bootApplication();

    ok(postsTemplateRendered, 'Posts route successfully stripped from rootURL');
  });

  QUnit.test('The rootURL is passed properly to the location implementation', function () {
    expect(1);
    var rootURL = '/blahzorz';
    var HistoryTestLocation = undefined;

    HistoryTestLocation = _emberRouting.HistoryLocation.extend({
      rootURL: 'this is not the URL you are looking for',
      initState: function () {
        equal(this.get('rootURL'), rootURL);
      }
    });

    registry.register('location:history-test', HistoryTestLocation);

    Router.reopen({
      location: 'history-test',
      rootURL: rootURL,
      // if we transition in this test we will receive failures
      // if the tests are run from a static file
      _doURLTransition: function () {}
    });

    bootApplication();
  });

  QUnit.test('Only use route rendered into main outlet for default into property on child', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{outlet \'menu\'}}{{outlet}}'));
    _emberGlimmer.setTemplate('posts', _emberTemplateCompiler.compile('{{outlet}}'));
    _emberGlimmer.setTemplate('posts/index', _emberTemplateCompiler.compile('<p class="posts-index">postsIndex</p>'));
    _emberGlimmer.setTemplate('posts/menu', _emberTemplateCompiler.compile('<div class="posts-menu">postsMenu</div>'));

    Router.map(function () {
      this.route('posts', function () {});
    });

    App.PostsRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render();
        this.render('posts/menu', {
          into: 'application',
          outlet: 'menu'
        });
      }
    });

    bootApplication();

    handleURL('/posts');

    equal(_emberViews.jQuery('div.posts-menu:contains(postsMenu)', '#qunit-fixture').length, 1, 'The posts/menu template was rendered');
    equal(_emberViews.jQuery('p.posts-index:contains(postsIndex)', '#qunit-fixture').length, 1, 'The posts/index template was rendered');
  });

  QUnit.test('Generating a URL should not affect currentModel', function () {
    Router.map(function () {
      this.route('post', { path: '/posts/:post_id' });
    });

    var posts = {
      1: { id: 1 },
      2: { id: 2 }
    };

    App.PostRoute = _emberRouting.Route.extend({
      model: function (params) {
        return posts[params.post_id];
      }
    });

    bootApplication();

    handleURL('/posts/1');

    var route = container.lookup('route:post');
    equal(route.modelFor('post'), posts[1]);

    var url = router.generate('post', posts[2]);
    equal(url, '/posts/2');

    equal(route.modelFor('post'), posts[1]);
  });

  QUnit.test('Generated route should be an instance of App.Route if provided', function () {
    var generatedRoute = undefined;

    Router.map(function () {
      this.route('posts');
    });

    App.Route = _emberRouting.Route.extend();

    bootApplication();

    handleURL('/posts');

    generatedRoute = container.lookup('route:posts');

    ok(generatedRoute instanceof App.Route, 'should extend the correct route');
  });

  QUnit.test('Nested index route is not overriden by parent\'s implicit index route', function () {
    Router.map(function () {
      this.route('posts', function () {
        this.route('index', { path: ':category' });
      });
    });

    bootApplication();

    _emberMetal.run(function () {
      return router.transitionTo('posts', { category: 'emberjs' });
    });

    deepEqual(router.location.path, '/posts/emberjs');
  });

  QUnit.test('Application template does not duplicate when re-rendered', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<h3>I Render Once</h3>{{outlet}}'));

    Router.map(function () {
      this.route('posts');
    });

    App.ApplicationRoute = _emberRouting.Route.extend({
      model: function () {
        return _emberRuntime.A();
      }
    });

    bootApplication();

    // should cause application template to re-render
    handleURL('/posts');

    equal(_emberViews.jQuery('h3:contains(I Render Once)').length, 1);
  });

  QUnit.test('Child routes should render inside the application template if the application template causes a redirect', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<h3>App</h3> {{outlet}}'));
    _emberGlimmer.setTemplate('posts', _emberTemplateCompiler.compile('posts'));

    Router.map(function () {
      this.route('posts');
      this.route('photos');
    });

    App.ApplicationRoute = _emberRouting.Route.extend({
      afterModel: function () {
        this.transitionTo('posts');
      }
    });

    bootApplication();

    equal(_emberViews.jQuery('#qunit-fixture > div').text(), 'App posts');
  });

  QUnit.test('The template is not re-rendered when the route\'s context changes', function () {
    Router.map(function () {
      this.route('page', { path: '/page/:name' });
    });

    App.PageRoute = _emberRouting.Route.extend({
      model: function (params) {
        return _emberRuntime.Object.create({ name: params.name });
      }
    });

    var insertionCount = 0;
    App.FooBarComponent = _emberGlimmer.Component.extend({
      didInsertElement: function () {
        insertionCount += 1;
      }
    });

    _emberGlimmer.setTemplate('page', _emberTemplateCompiler.compile('<p>{{model.name}}{{foo-bar}}</p>'));

    bootApplication();

    handleURL('/page/first');

    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), 'first');
    equal(insertionCount, 1);

    handleURL('/page/second');

    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), 'second');
    equal(insertionCount, 1, 'view should have inserted only once');

    _emberMetal.run(function () {
      return router.transitionTo('page', _emberRuntime.Object.create({ name: 'third' }));
    });

    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), 'third');
    equal(insertionCount, 1, 'view should still have inserted only once');
  });

  QUnit.test('The template is not re-rendered when two routes present the exact same template & controller', function () {
    Router.map(function () {
      this.route('first');
      this.route('second');
      this.route('third');
      this.route('fourth');
    });

    // Note add a component to test insertion

    var insertionCount = 0;
    App.XInputComponent = _emberGlimmer.Component.extend({
      didInsertElement: function () {
        insertionCount += 1;
      }
    });

    App.SharedRoute = _emberRouting.Route.extend({
      setupController: function (controller) {
        this.controllerFor('shared').set('message', 'This is the ' + this.routeName + ' message');
      },

      renderTemplate: function (controller, context) {
        this.render('shared', { controller: 'shared' });
      }
    });

    App.FirstRoute = App.SharedRoute.extend();
    App.SecondRoute = App.SharedRoute.extend();
    App.ThirdRoute = App.SharedRoute.extend();
    App.FourthRoute = App.SharedRoute.extend();

    App.SharedController = _emberRuntime.Controller.extend();

    _emberGlimmer.setTemplate('shared', _emberTemplateCompiler.compile('<p>{{message}}{{x-input}}</p>'));

    bootApplication();

    handleURL('/first');

    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), 'This is the first message');
    equal(insertionCount, 1, 'expected one assertion');

    // Transition by URL
    handleURL('/second');

    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), 'This is the second message');
    equal(insertionCount, 1, 'expected one assertion');

    // Then transition directly by route name
    _emberMetal.run(function () {
      router.transitionTo('third').then(function (value) {
        ok(true, 'expected transition');
      }, function (reason) {
        ok(false, 'unexpected transition failure: ', QUnit.jsDump.parse(reason));
      });
    });

    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), 'This is the third message');
    equal(insertionCount, 1, 'expected one assertion');

    // Lastly transition to a different view, with the same controller and template
    handleURL('/fourth');
    equal(insertionCount, 1, 'expected one assertion');

    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), 'This is the fourth message');
  });

  QUnit.test('ApplicationRoute with model does not proxy the currentPath', function () {
    var model = {};
    var currentPath = undefined;

    App.ApplicationRoute = _emberRouting.Route.extend({
      model: function () {
        return model;
      }
    });

    App.ApplicationController = _emberRuntime.Controller.extend({
      currentPathDidChange: _emberMetal.observer('currentPath', function () {
        currentPath = _emberMetal.get(this, 'currentPath');
      })
    });

    bootApplication();

    equal(currentPath, 'index', 'currentPath is index');
    equal('currentPath' in model, false, 'should have defined currentPath on controller');
  });

  QUnit.test('Promises encountered on app load put app into loading state until resolved', function () {
    expect(2);

    var deferred = _emberRuntime.RSVP.defer();

    App.IndexRoute = _emberRouting.Route.extend({
      model: function () {
        return deferred.promise;
      }
    });

    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<p>INDEX</p>'));
    _emberGlimmer.setTemplate('loading', _emberTemplateCompiler.compile('<p>LOADING</p>'));

    bootApplication();

    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), 'LOADING', 'The loading state is displaying.');
    _emberMetal.run(deferred.resolve);
    equal(_emberViews.jQuery('p', '#qunit-fixture').text(), 'INDEX', 'The index route is display.');
  });

  QUnit.test('Route should tear down multiple outlets', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{outlet \'menu\'}}{{outlet}}{{outlet \'footer\'}}'));
    _emberGlimmer.setTemplate('posts', _emberTemplateCompiler.compile('{{outlet}}'));
    _emberGlimmer.setTemplate('users', _emberTemplateCompiler.compile('users'));
    _emberGlimmer.setTemplate('posts/index', _emberTemplateCompiler.compile('<p class="posts-index">postsIndex</p>'));
    _emberGlimmer.setTemplate('posts/menu', _emberTemplateCompiler.compile('<div class="posts-menu">postsMenu</div>'));
    _emberGlimmer.setTemplate('posts/footer', _emberTemplateCompiler.compile('<div class="posts-footer">postsFooter</div>'));

    Router.map(function () {
      this.route('posts', function () {});
      this.route('users', function () {});
    });

    App.PostsRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render('posts/menu', {
          into: 'application',
          outlet: 'menu'
        });

        this.render();

        this.render('posts/footer', {
          into: 'application',
          outlet: 'footer'
        });
      }
    });

    bootApplication();

    handleURL('/posts');

    equal(_emberViews.jQuery('div.posts-menu:contains(postsMenu)', '#qunit-fixture').length, 1, 'The posts/menu template was rendered');
    equal(_emberViews.jQuery('p.posts-index:contains(postsIndex)', '#qunit-fixture').length, 1, 'The posts/index template was rendered');
    equal(_emberViews.jQuery('div.posts-footer:contains(postsFooter)', '#qunit-fixture').length, 1, 'The posts/footer template was rendered');

    handleURL('/users');

    equal(_emberViews.jQuery('div.posts-menu:contains(postsMenu)', '#qunit-fixture').length, 0, 'The posts/menu template was removed');
    equal(_emberViews.jQuery('p.posts-index:contains(postsIndex)', '#qunit-fixture').length, 0, 'The posts/index template was removed');
    equal(_emberViews.jQuery('div.posts-footer:contains(postsFooter)', '#qunit-fixture').length, 0, 'The posts/footer template was removed');
  });

  QUnit.test('Route will assert if you try to explicitly render {into: ...} a missing template', function () {
    expectDeprecation(/Rendering into a {{render}} helper that resolves to an {{outlet}} is deprecated./);

    Router.map(function () {
      this.route('home', { path: '/' });
    });

    App.HomeRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render({ into: 'nonexistent' });
      }
    });

    expectAssertion(function () {
      return bootApplication();
    }, 'You attempted to render into \'nonexistent\' but it was not found');
  });

  QUnit.test('Route supports clearing outlet explicitly', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{outlet}}{{outlet \'modal\'}}'));
    _emberGlimmer.setTemplate('posts', _emberTemplateCompiler.compile('{{outlet}}'));
    _emberGlimmer.setTemplate('users', _emberTemplateCompiler.compile('users'));
    _emberGlimmer.setTemplate('posts/index', _emberTemplateCompiler.compile('<div class="posts-index">postsIndex {{outlet}}</div>'));
    _emberGlimmer.setTemplate('posts/modal', _emberTemplateCompiler.compile('<div class="posts-modal">postsModal</div>'));
    _emberGlimmer.setTemplate('posts/extra', _emberTemplateCompiler.compile('<div class="posts-extra">postsExtra</div>'));

    Router.map(function () {
      this.route('posts', function () {});
      this.route('users', function () {});
    });

    App.PostsRoute = _emberRouting.Route.extend({
      actions: {
        showModal: function () {
          this.render('posts/modal', {
            into: 'application',
            outlet: 'modal'
          });
        },
        hideModal: function () {
          this.disconnectOutlet({ outlet: 'modal', parentView: 'application' });
        }
      }
    });

    App.PostsIndexRoute = _emberRouting.Route.extend({
      actions: {
        showExtra: function () {
          this.render('posts/extra', {
            into: 'posts/index'
          });
        },
        hideExtra: function () {
          this.disconnectOutlet({ parentView: 'posts/index' });
        }
      }
    });

    bootApplication();

    handleURL('/posts');

    equal(_emberViews.jQuery('div.posts-index:contains(postsIndex)', '#qunit-fixture').length, 1, 'The posts/index template was rendered');

    _emberMetal.run(function () {
      return router.send('showModal');
    });

    equal(_emberViews.jQuery('div.posts-modal:contains(postsModal)', '#qunit-fixture').length, 1, 'The posts/modal template was rendered');

    _emberMetal.run(function () {
      return router.send('showExtra');
    });

    equal(_emberViews.jQuery('div.posts-extra:contains(postsExtra)', '#qunit-fixture').length, 1, 'The posts/extra template was rendered');

    _emberMetal.run(function () {
      return router.send('hideModal');
    });

    equal(_emberViews.jQuery('div.posts-modal:contains(postsModal)', '#qunit-fixture').length, 0, 'The posts/modal template was removed');

    _emberMetal.run(function () {
      return router.send('hideExtra');
    });

    equal(_emberViews.jQuery('div.posts-extra:contains(postsExtra)', '#qunit-fixture').length, 0, 'The posts/extra template was removed');
    _emberMetal.run(function () {
      router.send('showModal');
    });
    equal(_emberViews.jQuery('div.posts-modal:contains(postsModal)', '#qunit-fixture').length, 1, 'The posts/modal template was rendered');
    _emberMetal.run(function () {
      router.send('showExtra');
    });
    equal(_emberViews.jQuery('div.posts-extra:contains(postsExtra)', '#qunit-fixture').length, 1, 'The posts/extra template was rendered');

    handleURL('/users');

    equal(_emberViews.jQuery('div.posts-index:contains(postsIndex)', '#qunit-fixture').length, 0, 'The posts/index template was removed');
    equal(_emberViews.jQuery('div.posts-modal:contains(postsModal)', '#qunit-fixture').length, 0, 'The posts/modal template was removed');
    equal(_emberViews.jQuery('div.posts-extra:contains(postsExtra)', '#qunit-fixture').length, 0, 'The posts/extra template was removed');
  });

  QUnit.test('Route supports clearing outlet using string parameter', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{outlet}}{{outlet \'modal\'}}'));
    _emberGlimmer.setTemplate('posts', _emberTemplateCompiler.compile('{{outlet}}'));
    _emberGlimmer.setTemplate('users', _emberTemplateCompiler.compile('users'));
    _emberGlimmer.setTemplate('posts/index', _emberTemplateCompiler.compile('<div class="posts-index">postsIndex {{outlet}}</div>'));
    _emberGlimmer.setTemplate('posts/modal', _emberTemplateCompiler.compile('<div class="posts-modal">postsModal</div>'));

    Router.map(function () {
      this.route('posts', function () {});
      this.route('users', function () {});
    });

    App.PostsRoute = _emberRouting.Route.extend({
      actions: {
        showModal: function () {
          this.render('posts/modal', {
            into: 'application',
            outlet: 'modal'
          });
        },
        hideModal: function () {
          this.disconnectOutlet('modal');
        }
      }
    });

    bootApplication();

    handleURL('/posts');

    equal(_emberViews.jQuery('div.posts-index:contains(postsIndex)', '#qunit-fixture').length, 1, 'The posts/index template was rendered');

    _emberMetal.run(function () {
      return router.send('showModal');
    });

    equal(_emberViews.jQuery('div.posts-modal:contains(postsModal)', '#qunit-fixture').length, 1, 'The posts/modal template was rendered');

    _emberMetal.run(function () {
      return router.send('hideModal');
    });

    equal(_emberViews.jQuery('div.posts-modal:contains(postsModal)', '#qunit-fixture').length, 0, 'The posts/modal template was removed');

    handleURL('/users');

    equal(_emberViews.jQuery('div.posts-index:contains(postsIndex)', '#qunit-fixture').length, 0, 'The posts/index template was removed');
    equal(_emberViews.jQuery('div.posts-modal:contains(postsModal)', '#qunit-fixture').length, 0, 'The posts/modal template was removed');
  });

  QUnit.test('Route silently fails when cleaning an outlet from an inactive view', function () {
    expect(1); // handleURL

    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{outlet}}'));
    _emberGlimmer.setTemplate('posts', _emberTemplateCompiler.compile('{{outlet \'modal\'}}'));
    _emberGlimmer.setTemplate('modal', _emberTemplateCompiler.compile('A Yo.'));

    Router.map(function () {
      this.route('posts');
    });

    App.PostsRoute = _emberRouting.Route.extend({
      actions: {
        hideSelf: function () {
          this.disconnectOutlet({ outlet: 'main', parentView: 'application' });
        },
        showModal: function () {
          this.render('modal', { into: 'posts', outlet: 'modal' });
        },
        hideModal: function () {
          this.disconnectOutlet({ outlet: 'modal', parentView: 'posts' });
        }
      }
    });

    bootApplication();

    handleURL('/posts');

    _emberMetal.run(function () {
      return router.send('showModal');
    });
    _emberMetal.run(function () {
      return router.send('hideSelf');
    });
    _emberMetal.run(function () {
      return router.send('hideModal');
    });
  });

  QUnit.test('Router `willTransition` hook passes in cancellable transition', function () {
    // Should hit willTransition 3 times, once for the initial route, and then 2 more times
    // for the two handleURL calls below
    expect(3);

    Router.map(function () {
      this.route('nork');
      this.route('about');
    });

    Router.reopen({
      init: function () {
        this._super();
        this.on('willTransition', this.testWillTransitionHook);
      },
      testWillTransitionHook: function (transition, url) {
        ok(true, 'willTransition was called ' + url);
        transition.abort();
      }
    });

    App.LoadingRoute = _emberRouting.Route.extend({
      activate: function () {
        ok(false, 'LoadingRoute was not entered');
      }
    });

    App.NorkRoute = _emberRouting.Route.extend({
      activate: function () {
        ok(false, 'NorkRoute was not entered');
      }
    });

    App.AboutRoute = _emberRouting.Route.extend({
      activate: function () {
        ok(false, 'AboutRoute was not entered');
      }
    });

    bootApplication();

    // Attempted transitions out of index should abort.
    _emberMetal.run(router, 'handleURL', '/nork');
    _emberMetal.run(router, 'handleURL', '/about');
  });

  QUnit.test('Aborting/redirecting the transition in `willTransition` prevents LoadingRoute from being entered', function () {
    expect(8);

    Router.map(function () {
      this.route('nork');
      this.route('about');
    });

    var redirect = false;

    App.IndexRoute = _emberRouting.Route.extend({
      actions: {
        willTransition: function (transition) {
          ok(true, 'willTransition was called');
          if (redirect) {
            // router.js won't refire `willTransition` for this redirect
            this.transitionTo('about');
          } else {
            transition.abort();
          }
        }
      }
    });

    var deferred = null;

    App.LoadingRoute = _emberRouting.Route.extend({
      activate: function () {
        ok(deferred, 'LoadingRoute should be entered at this time');
      },
      deactivate: function () {
        ok(true, 'LoadingRoute was exited');
      }
    });

    App.NorkRoute = _emberRouting.Route.extend({
      activate: function () {
        ok(true, 'NorkRoute was entered');
      }
    });

    App.AboutRoute = _emberRouting.Route.extend({
      activate: function () {
        ok(true, 'AboutRoute was entered');
      },
      model: function () {
        if (deferred) {
          return deferred.promise;
        }
      }
    });

    bootApplication();

    // Attempted transitions out of index should abort.
    _emberMetal.run(router, 'transitionTo', 'nork');
    _emberMetal.run(router, 'handleURL', '/nork');

    // Attempted transitions out of index should redirect to about
    redirect = true;
    _emberMetal.run(router, 'transitionTo', 'nork');
    _emberMetal.run(router, 'transitionTo', 'index');

    // Redirected transitions out of index to a route with a
    // promise model should pause the transition and
    // activate LoadingRoute
    deferred = _emberRuntime.RSVP.defer();
    _emberMetal.run(router, 'transitionTo', 'nork');
    _emberMetal.run(deferred.resolve);
  });

  QUnit.test('`didTransition` event fires on the router', function () {
    expect(3);

    Router.map(function () {
      this.route('nork');
    });

    router = container.lookup('router:main');

    router.one('didTransition', function () {
      ok(true, 'didTransition fired on initial routing');
    });

    bootApplication();

    router.one('didTransition', function () {
      ok(true, 'didTransition fired on the router');
      equal(router.get('url'), '/nork', 'The url property is updated by the time didTransition fires');
    });

    _emberMetal.run(router, 'transitionTo', 'nork');
  });
  QUnit.test('`didTransition` can be reopened', function () {
    expect(1);

    Router.map(function () {
      this.route('nork');
    });

    Router.reopen({
      didTransition: function () {
        this._super.apply(this, arguments);
        ok(true, 'reopened didTransition was called');
      }
    });

    bootApplication();
  });

  QUnit.test('`activate` event fires on the route', function () {
    expect(2);

    var eventFired = 0;

    Router.map(function () {
      this.route('nork');
    });

    App.NorkRoute = _emberRouting.Route.extend({
      init: function () {
        this._super.apply(this, arguments);

        this.on('activate', function () {
          equal(++eventFired, 1, 'activate event is fired once');
        });
      },

      activate: function () {
        ok(true, 'activate hook is called');
      }
    });

    bootApplication();

    _emberMetal.run(router, 'transitionTo', 'nork');
  });

  QUnit.test('`deactivate` event fires on the route', function () {
    expect(2);

    var eventFired = 0;

    Router.map(function () {
      this.route('nork');
      this.route('dork');
    });

    App.NorkRoute = _emberRouting.Route.extend({
      init: function () {
        this._super.apply(this, arguments);

        this.on('deactivate', function () {
          equal(++eventFired, 1, 'deactivate event is fired once');
        });
      },

      deactivate: function () {
        ok(true, 'deactivate hook is called');
      }
    });

    bootApplication();

    _emberMetal.run(router, 'transitionTo', 'nork');
    _emberMetal.run(router, 'transitionTo', 'dork');
  });

  QUnit.test('Actions can be handled by inherited action handlers', function () {
    expect(4);

    App.SuperRoute = _emberRouting.Route.extend({
      actions: {
        foo: function () {
          ok(true, 'foo');
        },
        bar: function (msg) {
          equal(msg, 'HELLO');
        }
      }
    });

    App.RouteMixin = _emberMetal.Mixin.create({
      actions: {
        bar: function (msg) {
          equal(msg, 'HELLO');
          this._super(msg);
        }
      }
    });

    App.IndexRoute = App.SuperRoute.extend(App.RouteMixin, {
      actions: {
        baz: function () {
          ok(true, 'baz');
        }
      }
    });

    bootApplication();

    router.send('foo');
    router.send('bar', 'HELLO');
    router.send('baz');
  });

  QUnit.test('transitionTo returns Transition when passed a route name', function () {
    expect(1);
    Router.map(function () {
      this.route('root', { path: '/' });
      this.route('bar');
    });

    bootApplication();

    var transition = _emberMetal.run(function () {
      return router.transitionTo('bar');
    });

    equal(transition instanceof _router.Transition, true);
  });

  QUnit.test('transitionTo returns Transition when passed a url', function () {
    expect(1);
    Router.map(function () {
      this.route('root', { path: '/' });
      this.route('bar', function () {
        this.route('baz');
      });
    });

    bootApplication();

    var transition = _emberMetal.run(function () {
      return router.transitionTo('/bar/baz');
    });

    equal(transition instanceof _router.Transition, true);
  });

  QUnit.test('currentRouteName is a property installed on ApplicationController that can be used in transitionTo', function () {
    expect(24);

    Router.map(function () {
      this.route('be', function () {
        this.route('excellent', { resetNamespace: true }, function () {
          this.route('to', { resetNamespace: true }, function () {
            this.route('each', { resetNamespace: true }, function () {
              this.route('other');
            });
          });
        });
      });
    });

    bootApplication();

    var appController = _emberUtils.getOwner(router).lookup('controller:application');

    function transitionAndCheck(path, expectedPath, expectedRouteName) {
      if (path) {
        _emberMetal.run(router, 'transitionTo', path);
      }
      equal(appController.get('currentPath'), expectedPath);
      equal(appController.get('currentRouteName'), expectedRouteName);
    }

    transitionAndCheck(null, 'index', 'index');
    transitionAndCheck('/be', 'be.index', 'be.index');
    transitionAndCheck('/be/excellent', 'be.excellent.index', 'excellent.index');
    transitionAndCheck('/be/excellent/to', 'be.excellent.to.index', 'to.index');
    transitionAndCheck('/be/excellent/to/each', 'be.excellent.to.each.index', 'each.index');
    transitionAndCheck('/be/excellent/to/each/other', 'be.excellent.to.each.other', 'each.other');

    transitionAndCheck('index', 'index', 'index');
    transitionAndCheck('be', 'be.index', 'be.index');
    transitionAndCheck('excellent', 'be.excellent.index', 'excellent.index');
    transitionAndCheck('to.index', 'be.excellent.to.index', 'to.index');
    transitionAndCheck('each', 'be.excellent.to.each.index', 'each.index');
    transitionAndCheck('each.other', 'be.excellent.to.each.other', 'each.other');
  });

  QUnit.test('Route model hook finds the same model as a manual find', function () {
    var Post = undefined;
    App.Post = _emberRuntime.Object.extend();
    App.Post.reopenClass({
      find: function () {
        Post = this;
        return {};
      }
    });

    Router.map(function () {
      this.route('post', { path: '/post/:post_id' });
    });

    bootApplication();

    handleURL('/post/1');

    equal(App.Post, Post);
  });

  QUnit.test('Routes can refresh themselves causing their model hooks to be re-run', function () {
    Router.map(function () {
      this.route('parent', { path: '/parent/:parent_id' }, function () {
        this.route('child');
      });
    });

    var appcount = 0;
    App.ApplicationRoute = _emberRouting.Route.extend({
      model: function () {
        ++appcount;
      }
    });

    var parentcount = 0;
    App.ParentRoute = _emberRouting.Route.extend({
      model: function (params) {
        equal(params.parent_id, '123');
        ++parentcount;
      },
      actions: {
        refreshParent: function () {
          this.refresh();
        }
      }
    });

    var childcount = 0;
    App.ParentChildRoute = _emberRouting.Route.extend({
      model: function () {
        ++childcount;
      }
    });

    bootApplication();

    equal(appcount, 1);
    equal(parentcount, 0);
    equal(childcount, 0);

    _emberMetal.run(router, 'transitionTo', 'parent.child', '123');

    equal(appcount, 1);
    equal(parentcount, 1);
    equal(childcount, 1);

    _emberMetal.run(router, 'send', 'refreshParent');

    equal(appcount, 1);
    equal(parentcount, 2);
    equal(childcount, 2);
  });

  QUnit.test('Specifying non-existent controller name in route#render throws', function () {
    expect(1);

    Router.map(function () {
      this.route('home', { path: '/' });
    });

    App.HomeRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        try {
          this.render('homepage', { controller: 'stefanpenneristhemanforme' });
        } catch (e) {
          equal(e.message, 'You passed `controller: \'stefanpenneristhemanforme\'` into the `render` method, but no such controller could be found.');
        }
      }
    });

    bootApplication();
  });

  QUnit.test('Redirecting with null model doesn\'t error out', function () {
    Router.map(function () {
      this.route('home', { path: '/' });
      this.route('about', { path: '/about/:hurhurhur' });
    });

    App.AboutRoute = _emberRouting.Route.extend({
      serialize: function (model) {
        if (model === null) {
          return { hurhurhur: 'TreeklesMcGeekles' };
        }
      }
    });

    App.HomeRoute = _emberRouting.Route.extend({
      beforeModel: function () {
        this.transitionTo('about', null);
      }
    });

    bootApplication();

    equal(router.get('location.path'), '/about/TreeklesMcGeekles');
  });

  QUnit.test('rejecting the model hooks promise with a non-error prints the `message` property', function () {
    expect(5);

    var rejectedMessage = 'OMG!! SOOOOOO BAD!!!!';
    var rejectedStack = 'Yeah, buddy: stack gets printed too.';

    Router.map(function () {
      this.route('yippie', { path: '/' });
    });

    _emberConsole.default.error = function (initialMessage, errorMessage, errorStack) {
      equal(initialMessage, 'Error while processing route: yippie', 'a message with the current route name is printed');
      equal(errorMessage, rejectedMessage, 'the rejected reason\'s message property is logged');
      equal(errorStack, rejectedStack, 'the rejected reason\'s stack property is logged');
    };

    App.YippieRoute = _emberRouting.Route.extend({
      model: function () {
        return _emberRuntime.RSVP.reject({ message: rejectedMessage, stack: rejectedStack });
      }
    });

    throws(function () {
      bootApplication();
    }, function (err) {
      equal(err.message, rejectedMessage);
      return true;
    }, 'expected an exception');
  });

  QUnit.test('rejecting the model hooks promise with an error with `errorThrown` property prints `errorThrown.message` property', function () {
    expect(5);
    var rejectedMessage = 'OMG!! SOOOOOO BAD!!!!';
    var rejectedStack = 'Yeah, buddy: stack gets printed too.';

    Router.map(function () {
      this.route('yippie', { path: '/' });
    });

    _emberConsole.default.error = function (initialMessage, errorMessage, errorStack) {
      equal(initialMessage, 'Error while processing route: yippie', 'a message with the current route name is printed');
      equal(errorMessage, rejectedMessage, 'the rejected reason\'s message property is logged');
      equal(errorStack, rejectedStack, 'the rejected reason\'s stack property is logged');
    };

    App.YippieRoute = _emberRouting.Route.extend({
      model: function () {
        return _emberRuntime.RSVP.reject({
          errorThrown: { message: rejectedMessage, stack: rejectedStack }
        });
      }
    });

    throws(function () {
      return bootApplication();
    }, function (err) {
      equal(err.message, rejectedMessage);
      return true;
    }, 'expected an exception');
  });

  QUnit.test('rejecting the model hooks promise with no reason still logs error', function () {
    Router.map(function () {
      this.route('wowzers', { path: '/' });
    });

    _emberConsole.default.error = function (initialMessage) {
      equal(initialMessage, 'Error while processing route: wowzers', 'a message with the current route name is printed');
    };

    App.WowzersRoute = _emberRouting.Route.extend({
      model: function () {
        return _emberRuntime.RSVP.reject();
      }
    });

    bootApplication();
  });

  QUnit.test('rejecting the model hooks promise with a string shows a good error', function () {
    expect(3);
    var originalLoggerError = _emberConsole.default.error;
    var rejectedMessage = 'Supercalifragilisticexpialidocious';

    Router.map(function () {
      this.route('yondo', { path: '/' });
    });

    _emberConsole.default.error = function (initialMessage, errorMessage) {
      equal(initialMessage, 'Error while processing route: yondo', 'a message with the current route name is printed');
      equal(errorMessage, rejectedMessage, 'the rejected reason\'s message property is logged');
    };

    App.YondoRoute = _emberRouting.Route.extend({
      model: function () {
        return _emberRuntime.RSVP.reject(rejectedMessage);
      }
    });

    throws(function () {
      return bootApplication();
    }, rejectedMessage, 'expected an exception');

    _emberConsole.default.error = originalLoggerError;
  });

  QUnit.test('willLeave, willChangeContext, willChangeModel actions don\'t fire unless feature flag enabled', function () {
    expect(1);

    App.Router.map(function () {
      this.route('about');
    });

    function shouldNotFire() {
      ok(false, 'this action shouldn\'t have been received');
    }

    App.IndexRoute = _emberRouting.Route.extend({
      actions: {
        willChangeModel: shouldNotFire,
        willChangeContext: shouldNotFire,
        willLeave: shouldNotFire
      }
    });

    App.AboutRoute = _emberRouting.Route.extend({
      setupController: function () {
        ok(true, 'about route was entered');
      }
    });

    bootApplication();
    _emberMetal.run(router, 'transitionTo', 'about');
  });

  QUnit.test('Errors in transitionTo within redirect hook are logged', function () {
    expect(4);
    var actual = [];

    Router.map(function () {
      this.route('yondo', { path: '/' });
      this.route('stink-bomb');
    });

    App.YondoRoute = _emberRouting.Route.extend({
      redirect: function () {
        this.transitionTo('stink-bomb', { something: 'goes boom' });
      }
    });

    _emberConsole.default.error = function () {
      // push the arguments onto an array so we can detect if the error gets logged twice
      actual.push(arguments);
    };

    throws(function () {
      return bootApplication();
    }, /More context objects were passed/);

    equal(actual.length, 1, 'the error is only logged once');
    equal(actual[0][0], 'Error while processing route: yondo', 'source route is printed');
    ok(actual[0][1].match(/More context objects were passed than there are dynamic segments for the route: stink-bomb/), 'the error is printed');
  });

  QUnit.test('Errors in transition show error template if available', function () {
    _emberGlimmer.setTemplate('error', _emberTemplateCompiler.compile('<div id=\'error\'>Error!</div>'));

    Router.map(function () {
      this.route('yondo', { path: '/' });
      this.route('stink-bomb');
    });

    App.YondoRoute = _emberRouting.Route.extend({
      redirect: function () {
        this.transitionTo('stink-bomb', { something: 'goes boom' });
      }
    });

    throws(function () {
      return bootApplication();
    }, /More context objects were passed/);

    equal(_emberViews.jQuery('#error').length, 1, 'Error template was rendered.');
  });

  QUnit.test('Route#resetController gets fired when changing models and exiting routes', function () {
    expect(4);

    Router.map(function () {
      this.route('a', function () {
        this.route('b', { path: '/b/:id', resetNamespace: true }, function () {});
        this.route('c', { path: '/c/:id', resetNamespace: true }, function () {});
      });
      this.route('out');
    });

    var calls = [];

    var SpyRoute = _emberRouting.Route.extend({
      setupController: function (controller, model, transition) {
        calls.push(['setup', this.routeName]);
      },

      resetController: function (controller) {
        calls.push(['reset', this.routeName]);
      }
    });

    App.ARoute = SpyRoute.extend();
    App.BRoute = SpyRoute.extend();
    App.CRoute = SpyRoute.extend();
    App.OutRoute = SpyRoute.extend();

    bootApplication();
    deepEqual(calls, []);

    _emberMetal.run(router, 'transitionTo', 'b', 'b-1');
    deepEqual(calls, [['setup', 'a'], ['setup', 'b']]);
    calls.length = 0;

    _emberMetal.run(router, 'transitionTo', 'c', 'c-1');
    deepEqual(calls, [['reset', 'b'], ['setup', 'c']]);
    calls.length = 0;

    _emberMetal.run(router, 'transitionTo', 'out');
    deepEqual(calls, [['reset', 'c'], ['reset', 'a'], ['setup', 'out']]);
  });

  QUnit.test('Exception during initialization of non-initial route is not swallowed', function () {
    Router.map(function () {
      this.route('boom');
    });
    App.BoomRoute = _emberRouting.Route.extend({
      init: function () {
        throw new Error('boom!');
      }
    });
    bootApplication();
    throws(function () {
      return _emberMetal.run(router, 'transitionTo', 'boom');
    }, /\bboom\b/);
  });

  QUnit.test('Exception during load of non-initial route is not swallowed', function () {
    Router.map(function () {
      this.route('boom');
    });
    var lookup = container.lookup;
    container.lookup = function () {
      if (arguments[0] === 'route:boom') {
        throw new Error('boom!');
      }
      return lookup.apply(this, arguments);
    };
    App.BoomRoute = _emberRouting.Route.extend({
      init: function () {
        throw new Error('boom!');
      }
    });
    bootApplication();
    throws(function () {
      return _emberMetal.run(router, 'transitionTo', 'boom');
    });
  });

  QUnit.test('Exception during initialization of initial route is not swallowed', function () {
    Router.map(function () {
      this.route('boom', { path: '/' });
    });
    App.BoomRoute = _emberRouting.Route.extend({
      init: function () {
        throw new Error('boom!');
      }
    });
    throws(function () {
      return bootApplication();
    }, /\bboom\b/);
  });

  QUnit.test('Exception during load of initial route is not swallowed', function () {
    Router.map(function () {
      this.route('boom', { path: '/' });
    });
    var lookup = container.lookup;
    container.lookup = function () {
      if (arguments[0] === 'route:boom') {
        throw new Error('boom!');
      }
      return lookup.apply(this, arguments);
    };
    App.BoomRoute = _emberRouting.Route.extend({
      init: function () {
        throw new Error('boom!');
      }
    });
    throws(function () {
      return bootApplication();
    }, /\bboom\b/);
  });

  QUnit.test('{{outlet}} works when created after initial render', function () {
    _emberGlimmer.setTemplate('sample', _emberTemplateCompiler.compile('Hi{{#if showTheThing}}{{outlet}}{{/if}}Bye'));
    _emberGlimmer.setTemplate('sample/inner', _emberTemplateCompiler.compile('Yay'));
    _emberGlimmer.setTemplate('sample/inner2', _emberTemplateCompiler.compile('Boo'));
    Router.map(function () {
      this.route('sample', { path: '/' }, function () {
        this.route('inner', { path: '/' });
        this.route('inner2', { path: '/2' });
      });
    });

    bootApplication();

    equal(_emberViews.jQuery('#qunit-fixture').text(), 'HiBye', 'initial render');

    _emberMetal.run(function () {
      return container.lookup('controller:sample').set('showTheThing', true);
    });

    equal(_emberViews.jQuery('#qunit-fixture').text(), 'HiYayBye', 'second render');

    handleURL('/2');

    equal(_emberViews.jQuery('#qunit-fixture').text(), 'HiBooBye', 'third render');
  });

  QUnit.test('Can render into a named outlet at the top level', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('A-{{outlet}}-B-{{outlet "other"}}-C'));
    _emberGlimmer.setTemplate('modal', _emberTemplateCompiler.compile('Hello world'));
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('The index'));

    registry.register('route:application', _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render();
        this.render('modal', {
          into: 'application',
          outlet: 'other'
        });
      }
    }));

    bootApplication();

    equal(_emberViews.jQuery('#qunit-fixture').text(), 'A-The index-B-Hello world-C', 'initial render');
  });

  QUnit.test('Can disconnect a named outlet at the top level', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('A-{{outlet}}-B-{{outlet "other"}}-C'));
    _emberGlimmer.setTemplate('modal', _emberTemplateCompiler.compile('Hello world'));
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('The index'));

    registry.register('route:application', _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render();
        this.render('modal', {
          into: 'application',
          outlet: 'other'
        });
      },
      actions: {
        banish: function () {
          this.disconnectOutlet({
            parentView: 'application',
            outlet: 'other'
          });
        }
      }
    }));

    bootApplication();

    equal(_emberViews.jQuery('#qunit-fixture').text(), 'A-The index-B-Hello world-C', 'initial render');

    _emberMetal.run(router, 'send', 'banish');

    equal(_emberViews.jQuery('#qunit-fixture').text(), 'A-The index-B--C', 'second render');
  });

  QUnit.test('Can render into a named outlet at the top level, with empty main outlet', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('A-{{outlet}}-B-{{outlet "other"}}-C'));
    _emberGlimmer.setTemplate('modal', _emberTemplateCompiler.compile('Hello world'));

    Router.map(function () {
      this.route('hasNoTemplate', { path: '/' });
    });

    registry.register('route:application', _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render();
        this.render('modal', {
          into: 'application',
          outlet: 'other'
        });
      }
    }));

    bootApplication();

    equal(_emberViews.jQuery('#qunit-fixture').text(), 'A--B-Hello world-C', 'initial render');
  });

  QUnit.test('Can render into a named outlet at the top level, later', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('A-{{outlet}}-B-{{outlet "other"}}-C'));
    _emberGlimmer.setTemplate('modal', _emberTemplateCompiler.compile('Hello world'));
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('The index'));

    registry.register('route:application', _emberRouting.Route.extend({
      actions: {
        launch: function () {
          this.render('modal', {
            into: 'application',
            outlet: 'other'
          });
        }
      }
    }));

    bootApplication();

    equal(_emberViews.jQuery('#qunit-fixture').text(), 'A-The index-B--C', 'initial render');

    _emberMetal.run(router, 'send', 'launch');

    equal(_emberViews.jQuery('#qunit-fixture').text(), 'A-The index-B-Hello world-C', 'second render');
  });

  QUnit.test('Can render routes with no \'main\' outlet and their children', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div id="application">{{outlet "app"}}</div>'));
    _emberGlimmer.setTemplate('app', _emberTemplateCompiler.compile('<div id="app-common">{{outlet "common"}}</div><div id="app-sub">{{outlet "sub"}}</div>'));
    _emberGlimmer.setTemplate('common', _emberTemplateCompiler.compile('<div id="common"></div>'));
    _emberGlimmer.setTemplate('sub', _emberTemplateCompiler.compile('<div id="sub"></div>'));

    Router.map(function () {
      this.route('app', { path: '/app' }, function () {
        this.route('sub', { path: '/sub', resetNamespace: true });
      });
    });

    App.AppRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render('app', {
          outlet: 'app',
          into: 'application'
        });
        this.render('common', {
          outlet: 'common',
          into: 'app'
        });
      }
    });

    App.SubRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render('sub', {
          outlet: 'sub',
          into: 'app'
        });
      }
    });

    bootApplication();
    handleURL('/app');
    equal(_emberViews.jQuery('#app-common #common').length, 1, 'Finds common while viewing /app');
    handleURL('/app/sub');
    equal(_emberViews.jQuery('#app-common #common').length, 1, 'Finds common while viewing /app/sub');
    equal(_emberViews.jQuery('#app-sub #sub').length, 1, 'Finds sub while viewing /app/sub');
  });

  QUnit.test('Tolerates stacked renders', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{outlet}}{{outlet "modal"}}'));
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('hi'));
    _emberGlimmer.setTemplate('layer', _emberTemplateCompiler.compile('layer'));
    App.ApplicationRoute = _emberRouting.Route.extend({
      actions: {
        openLayer: function () {
          this.render('layer', {
            into: 'application',
            outlet: 'modal'
          });
        },
        close: function () {
          this.disconnectOutlet({
            outlet: 'modal',
            parentView: 'application'
          });
        }
      }
    });
    bootApplication();
    equal(trim(_emberViews.jQuery('#qunit-fixture').text()), 'hi');
    _emberMetal.run(router, 'send', 'openLayer');
    equal(trim(_emberViews.jQuery('#qunit-fixture').text()), 'hilayer');
    _emberMetal.run(router, 'send', 'openLayer');
    equal(trim(_emberViews.jQuery('#qunit-fixture').text()), 'hilayer');
    _emberMetal.run(router, 'send', 'close');
    equal(trim(_emberViews.jQuery('#qunit-fixture').text()), 'hi');
  });

  QUnit.test('Renders child into parent with non-default template name', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('<div class="a">{{outlet}}</div>'));
    _emberGlimmer.setTemplate('exports/root', _emberTemplateCompiler.compile('<div class="b">{{outlet}}</div>'));
    _emberGlimmer.setTemplate('exports/index', _emberTemplateCompiler.compile('<div class="c"></div>'));

    Router.map(function () {
      this.route('root', function () {});
    });

    App.RootRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render('exports/root');
      }
    });

    App.RootIndexRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render('exports/index');
      }
    });

    bootApplication();
    handleURL('/root');
    equal(_emberViews.jQuery('#qunit-fixture .a .b .c').length, 1);
  });

  QUnit.test('Allows any route to disconnectOutlet another route\'s templates', function () {
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{outlet}}{{outlet "modal"}}'));
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('hi'));
    _emberGlimmer.setTemplate('layer', _emberTemplateCompiler.compile('layer'));
    App.ApplicationRoute = _emberRouting.Route.extend({
      actions: {
        openLayer: function () {
          this.render('layer', {
            into: 'application',
            outlet: 'modal'
          });
        }
      }
    });
    App.IndexRoute = _emberRouting.Route.extend({
      actions: {
        close: function () {
          this.disconnectOutlet({
            parentView: 'application',
            outlet: 'modal'
          });
        }
      }
    });
    bootApplication();
    equal(trim(_emberViews.jQuery('#qunit-fixture').text()), 'hi');
    _emberMetal.run(router, 'send', 'openLayer');
    equal(trim(_emberViews.jQuery('#qunit-fixture').text()), 'hilayer');
    _emberMetal.run(router, 'send', 'close');
    equal(trim(_emberViews.jQuery('#qunit-fixture').text()), 'hi');
  });

  QUnit.test('Can this.render({into:...}) the render helper', function () {
    expectDeprecation(/Rendering into a {{render}} helper that resolves to an {{outlet}} is deprecated./);

    expectDeprecation(function () {
      _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{render "sidebar"}}'));
    }, /Please refactor [\w\{\}"` ]+ to a component/);

    _emberGlimmer.setTemplate('sidebar', _emberTemplateCompiler.compile('<div class="sidebar">{{outlet}}</div>'));
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('other'));
    _emberGlimmer.setTemplate('bar', _emberTemplateCompiler.compile('bar'));

    App.IndexRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render({ into: 'sidebar' });
      },
      actions: {
        changeToBar: function () {
          this.disconnectOutlet({
            parentView: 'sidebar',
            outlet: 'main'
          });
          this.render('bar', { into: 'sidebar' });
        }
      }
    });

    bootApplication();
    equal(_emberViews.jQuery('#qunit-fixture .sidebar').text(), 'other');
    _emberMetal.run(router, 'send', 'changeToBar');
    equal(_emberViews.jQuery('#qunit-fixture .sidebar').text(), 'bar');
  });

  QUnit.test('Can disconnect from the render helper', function () {
    expectDeprecation(/Rendering into a {{render}} helper that resolves to an {{outlet}} is deprecated./);

    expectDeprecation(function () {
      _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{render "sidebar"}}'));
    }, /Please refactor [\w\{\}"` ]+ to a component/);

    _emberGlimmer.setTemplate('sidebar', _emberTemplateCompiler.compile('<div class="sidebar">{{outlet}}</div>'));
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('other'));

    App.IndexRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render({ into: 'sidebar' });
      },
      actions: {
        disconnect: function () {
          this.disconnectOutlet({
            parentView: 'sidebar',
            outlet: 'main'
          });
        }
      }
    });

    bootApplication();
    equal(_emberViews.jQuery('#qunit-fixture .sidebar').text(), 'other');
    _emberMetal.run(router, 'send', 'disconnect');
    equal(_emberViews.jQuery('#qunit-fixture .sidebar').text(), '');
  });

  QUnit.test('Can this.render({into:...}) the render helper\'s children', function () {
    expectDeprecation(/Rendering into a {{render}} helper that resolves to an {{outlet}} is deprecated./);

    expectDeprecation(function () {
      _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{render "sidebar"}}'));
    }, /Please refactor [\w\{\}"` ]+ to a component/);

    _emberGlimmer.setTemplate('sidebar', _emberTemplateCompiler.compile('<div class="sidebar">{{outlet}}</div>'));
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<div class="index">{{outlet}}</div>'));
    _emberGlimmer.setTemplate('other', _emberTemplateCompiler.compile('other'));
    _emberGlimmer.setTemplate('bar', _emberTemplateCompiler.compile('bar'));

    App.IndexRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render({ into: 'sidebar' });
        this.render('other', { into: 'index' });
      },
      actions: {
        changeToBar: function () {
          this.disconnectOutlet({
            parentView: 'index',
            outlet: 'main'
          });
          this.render('bar', { into: 'index' });
        }
      }
    });

    bootApplication();
    equal(_emberViews.jQuery('#qunit-fixture .sidebar .index').text(), 'other');
    _emberMetal.run(router, 'send', 'changeToBar');
    equal(_emberViews.jQuery('#qunit-fixture .sidebar .index').text(), 'bar');
  });

  QUnit.test('Can disconnect from the render helper\'s children', function () {
    expectDeprecation(/Rendering into a {{render}} helper that resolves to an {{outlet}} is deprecated./);

    expectDeprecation(function () {
      _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{render "sidebar"}}'));
    }, /Please refactor [\w\{\}"` ]+ to a component/);

    _emberGlimmer.setTemplate('sidebar', _emberTemplateCompiler.compile('<div class="sidebar">{{outlet}}</div>'));
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<div class="index">{{outlet}}</div>'));
    _emberGlimmer.setTemplate('other', _emberTemplateCompiler.compile('other'));

    App.IndexRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render({ into: 'sidebar' });
        this.render('other', { into: 'index' });
      },
      actions: {
        disconnect: function () {
          this.disconnectOutlet({
            parentView: 'index',
            outlet: 'main'
          });
        }
      }
    });

    bootApplication();
    equal(_emberViews.jQuery('#qunit-fixture .sidebar .index').text(), 'other');
    _emberMetal.run(router, 'send', 'disconnect');
    equal(_emberViews.jQuery('#qunit-fixture .sidebar .index').text(), '');
  });

  QUnit.test('Can this.render({into:...}) nested render helpers', function () {
    expectDeprecation(/Rendering into a {{render}} helper that resolves to an {{outlet}} is deprecated./);

    expectDeprecation(function () {
      _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{render "sidebar"}}'));
    }, /Please refactor [\w\{\}"` ]+ to a component/);

    expectDeprecation(function () {
      _emberGlimmer.setTemplate('sidebar', _emberTemplateCompiler.compile('<div class="sidebar">{{render "cart"}}</div>'));
    }, /Please refactor [\w\{\}"` ]+ to a component/);

    _emberGlimmer.setTemplate('cart', _emberTemplateCompiler.compile('<div class="cart">{{outlet}}</div>'));
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('other'));
    _emberGlimmer.setTemplate('baz', _emberTemplateCompiler.compile('baz'));

    App.IndexRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render({ into: 'cart' });
      },
      actions: {
        changeToBaz: function () {
          this.disconnectOutlet({
            parentView: 'cart',
            outlet: 'main'
          });
          this.render('baz', { into: 'cart' });
        }
      }
    });

    bootApplication();
    equal(_emberViews.jQuery('#qunit-fixture .cart').text(), 'other');
    _emberMetal.run(router, 'send', 'changeToBaz');
    equal(_emberViews.jQuery('#qunit-fixture .cart').text(), 'baz');
  });

  QUnit.test('Can disconnect from nested render helpers', function () {
    expectDeprecation(/Rendering into a {{render}} helper that resolves to an {{outlet}} is deprecated./);

    expectDeprecation(function () {
      _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{render "sidebar"}}'));
    }, /Please refactor [\w\{\}"` ]+ to a component/);

    expectDeprecation(function () {
      _emberGlimmer.setTemplate('sidebar', _emberTemplateCompiler.compile('<div class="sidebar">{{render "cart"}}</div>'));
    }, /Please refactor [\w\{\}"` ]+ to a component/);

    _emberGlimmer.setTemplate('cart', _emberTemplateCompiler.compile('<div class="cart">{{outlet}}</div>'));
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('other'));

    App.IndexRoute = _emberRouting.Route.extend({
      renderTemplate: function () {
        this.render({ into: 'cart' });
      },
      actions: {
        disconnect: function () {
          this.disconnectOutlet({
            parentView: 'cart',
            outlet: 'main'
          });
        }
      }
    });

    bootApplication();
    equal(_emberViews.jQuery('#qunit-fixture .cart').text(), 'other');
    _emberMetal.run(router, 'send', 'disconnect');
    equal(_emberViews.jQuery('#qunit-fixture .cart').text(), '');
  });

  QUnit.test('Components inside an outlet have their didInsertElement hook invoked when the route is displayed', function (assert) {
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('{{#if showFirst}}{{my-component}}{{else}}{{other-component}}{{/if}}'));

    var myComponentCounter = 0;
    var otherComponentCounter = 0;
    var indexController = undefined;

    App.IndexController = _emberRuntime.Controller.extend({
      showFirst: true
    });

    App.IndexRoute = _emberRouting.Route.extend({
      setupController: function (controller) {
        indexController = controller;
      }
    });

    App.MyComponentComponent = _emberGlimmer.Component.extend({
      didInsertElement: function () {
        myComponentCounter++;
      }
    });

    App.OtherComponentComponent = _emberGlimmer.Component.extend({
      didInsertElement: function () {
        otherComponentCounter++;
      }
    });

    bootApplication();

    assert.strictEqual(myComponentCounter, 1, 'didInsertElement invoked on displayed component');
    assert.strictEqual(otherComponentCounter, 0, 'didInsertElement not invoked on displayed component');

    _emberMetal.run(function () {
      return indexController.set('showFirst', false);
    });

    assert.strictEqual(myComponentCounter, 1, 'didInsertElement not invoked on displayed component');
    assert.strictEqual(otherComponentCounter, 1, 'didInsertElement invoked on displayed component');
  });

  QUnit.test('Doesnt swallow exception thrown from willTransition', function () {
    expect(1);
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{outlet}}'));
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('index'));
    _emberGlimmer.setTemplate('other', _emberTemplateCompiler.compile('other'));

    Router.map(function () {
      this.route('other', function () {});
    });

    App.IndexRoute = _emberRouting.Route.extend({
      actions: {
        willTransition: function () {
          throw new Error('boom');
        }
      }
    });

    bootApplication();

    throws(function () {
      _emberMetal.run(function () {
        return router.handleURL('/other');
      });
    }, /boom/, 'expected an exception that didnt happen');
  });

  QUnit.test('Exception if outlet name is undefined in render and disconnectOutlet', function (assert) {
    App.ApplicationRoute = _emberRouting.Route.extend({
      actions: {
        showModal: function () {
          this.render({
            outlet: undefined,
            parentView: 'application'
          });
        },
        hideModal: function () {
          this.disconnectOutlet({
            outlet: undefined,
            parentView: 'application'
          });
        }
      }
    });

    bootApplication();

    throws(function () {
      _emberMetal.run(function () {
        return router.send('showModal');
      });
    }, /You passed undefined as the outlet name/);

    throws(function () {
      _emberMetal.run(function () {
        return router.send('hideModal');
      });
    }, /You passed undefined as the outlet name/);
  });

  QUnit.test('Route serializers work for Engines', function () {
    expect(2);

    // Register engine
    var BlogEngine = _emberApplication.Engine.extend();
    registry.register('engine:blog', BlogEngine);

    // Register engine route map
    var postSerialize = function (params) {
      ok(true, 'serialize hook runs');
      return {
        post_id: params.id
      };
    };
    var BlogMap = function () {
      this.route('post', { path: '/post/:post_id', serialize: postSerialize });
    };
    registry.register('route-map:blog', BlogMap);

    Router.map(function () {
      this.mount('blog');
    });

    bootApplication();

    equal(router.router.generate('blog.post', { id: '13' }), '/blog/post/13', 'url is generated properly');
  });

  QUnit.test('Defining a Route#serialize method in an Engine throws an error', function () {
    expect(1);

    // Register engine
    var BlogEngine = _emberApplication.Engine.extend();
    registry.register('engine:blog', BlogEngine);

    // Register engine route map
    var BlogMap = function () {
      this.route('post');
    };
    registry.register('route-map:blog', BlogMap);

    Router.map(function () {
      this.mount('blog');
    });

    bootApplication();

    var PostRoute = _emberRouting.Route.extend({ serialize: function () {} });
    container.lookup('engine:blog').register('route:post', PostRoute);

    throws(function () {
      return router.transitionTo('blog.post');
    }, /Defining a custom serialize method on an Engine route is not supported/);
  });

  QUnit.test('App.destroy does not leave undestroyed views after clearing engines', function () {
    expect(4);

    var engineInstance = undefined;
    // Register engine
    var BlogEngine = _emberApplication.Engine.extend();
    registry.register('engine:blog', BlogEngine);
    var EngineIndexRoute = _emberRouting.Route.extend({
      init: function () {
        this._super.apply(this, arguments);
        engineInstance = _emberUtils.getOwner(this);
      }
    });

    // Register engine route map
    var BlogMap = function () {
      this.route('post');
    };
    registry.register('route-map:blog', BlogMap);

    Router.map(function () {
      this.mount('blog');
    });

    bootApplication();

    var engine = container.lookup('engine:blog');
    engine.register('route:index', EngineIndexRoute);
    engine.register('template:index', _emberTemplateCompiler.compile('Engine Post!'));

    handleURL('/blog');

    var route = engineInstance.lookup('route:index');

    _emberMetal.run(router, 'destroy');
    equal(router._toplevelView, null, 'the toplevelView was cleared');

    _emberMetal.run(route, 'destroy');
    equal(router._toplevelView, null, 'the toplevelView was not reinitialized');

    _emberMetal.run(App, 'destroy');
    equal(router._toplevelView, null, 'the toplevelView was not reinitialized');
  });
});
enifed('ember/tests/routing/basic_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/routing/basic_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/routing/basic_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/routing/query_params_test', ['exports', 'ember-runtime', 'ember-metal', 'ember-routing', 'ember-views', 'internal-test-helpers'], function (exports, _emberRuntime, _emberMetal, _emberRouting, _emberViews, _internalTestHelpers) {
  'use strict';

  _internalTestHelpers.moduleFor('Query Params - main', (function (_QueryParamTestCase) {
    babelHelpers.inherits(_class, _QueryParamTestCase);

    function _class() {
      _QueryParamTestCase.apply(this, arguments);
    }

    _class.prototype.refreshModelWhileLoadingTest = function refreshModelWhileLoadingTest(loadingReturn) {
      var _actions,
          _this = this;

      var assert = this.assert;

      assert.expect(9);

      var appModelCount = 0;
      var promiseResolve = undefined;

      this.registerRoute('application', _emberRouting.Route.extend({
        queryParams: {
          appomg: {
            defaultValue: 'applol'
          }
        },
        model: function (params) {
          appModelCount++;
        }
      }));

      this.setSingleQPController('index', 'omg', undefined, {
        omg: undefined
      });

      var actionName = typeof loadingReturn !== 'undefined' ? 'loading' : 'ignore';
      var indexModelCount = 0;
      this.registerRoute('index', _emberRouting.Route.extend({
        queryParams: {
          omg: {
            refreshModel: true
          }
        },
        actions: (_actions = {}, _actions[actionName] = function () {
          return loadingReturn;
        }, _actions),
        model: function (params) {
          indexModelCount++;
          if (indexModelCount === 2) {
            assert.deepEqual(params, { omg: 'lex' });
            return new _emberRuntime.RSVP.Promise(function (resolve) {
              promiseResolve = resolve;
              return;
            });
          } else if (indexModelCount === 3) {
            assert.deepEqual(params, { omg: 'hello' }, 'Model hook reruns even if the previous one didnt finish');
          }
        }
      }));

      return this.visit('/').then(function () {
        assert.equal(appModelCount, 1, 'appModelCount is 1');
        assert.equal(indexModelCount, 1);

        var indexController = _this.getController('index');
        _this.setAndFlush(indexController, 'omg', 'lex');

        assert.equal(appModelCount, 1, 'appModelCount is 1');
        assert.equal(indexModelCount, 2);

        _this.setAndFlush(indexController, 'omg', 'hello');
        assert.equal(appModelCount, 1, 'appModelCount is 1');
        assert.equal(indexModelCount, 3);

        _emberMetal.run(function () {
          promiseResolve();
        });

        assert.equal(_emberMetal.get(indexController, 'omg'), 'hello', 'At the end last value prevails');
      });
    };

    _class.prototype['@test No replaceURL occurs on startup because default values don\'t show up in URL'] = function testNoReplaceURLOccursOnStartupBecauseDefaultValuesDonTShowUpInURL(assert) {
      assert.expect(1);

      this.setSingleQPController('index');

      return this.visitAndAssert('/');
    };

    _class.prototype['@test Calling transitionTo does not lose query params already on the activeTransition'] = function testCallingTransitionToDoesNotLoseQueryParamsAlreadyOnTheActiveTransition(assert) {
      var _this2 = this;

      assert.expect(2);

      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
          this.route('sibling');
        });
      });

      this.registerRoute('parent.child', _emberRouting.Route.extend({
        afterModel: function () {
          this.transitionTo('parent.sibling');
        }
      }));

      this.setSingleQPController('parent');

      return this.visit('/parent/child?foo=lol').then(function () {
        _this2.assertCurrentPath('/parent/sibling?foo=lol', 'redirected to the sibling route, instead of child route');
        assert.equal(_this2.getController('parent').get('foo'), 'lol', 'controller has value from the active transition');
      });
    };

    _class.prototype['@test Single query params can be set on the controller and reflected in the url'] = function testSingleQueryParamsCanBeSetOnTheControllerAndReflectedInTheUrl(assert) {
      var _this3 = this;

      assert.expect(3);

      this.router.map(function () {
        this.route('home', { path: '/' });
      });

      this.setSingleQPController('home');

      return this.visitAndAssert('/').then(function () {
        var controller = _this3.getController('home');

        _this3.setAndFlush(controller, 'foo', '456');
        _this3.assertCurrentPath('/?foo=456');

        _this3.setAndFlush(controller, 'foo', '987');
        _this3.assertCurrentPath('/?foo=987');
      });
    };

    _class.prototype['@test Query params can map to different url keys configured on the controller'] = function testQueryParamsCanMapToDifferentUrlKeysConfiguredOnTheController(assert) {
      var _this4 = this;

      assert.expect(6);

      this.registerController('index', _emberRuntime.Controller.extend({
        queryParams: [{ foo: 'other_foo', bar: { as: 'other_bar' } }],
        foo: 'FOO',
        bar: 'BAR'
      }));

      return this.visitAndAssert('/').then(function () {
        var controller = _this4.getController('index');

        _this4.setAndFlush(controller, 'foo', 'LEX');
        _this4.assertCurrentPath('/?other_foo=LEX', 'QP mapped correctly without \'as\'');

        _this4.setAndFlush(controller, 'foo', 'WOO');
        _this4.assertCurrentPath('/?other_foo=WOO', 'QP updated correctly without \'as\'');

        _this4.transitionTo('/?other_foo=NAW');
        assert.equal(controller.get('foo'), 'NAW', 'QP managed correctly on URL transition');

        _this4.setAndFlush(controller, 'bar', 'NERK');
        _this4.assertCurrentPath('/?other_bar=NERK&other_foo=NAW', 'QP mapped correctly with \'as\'');

        _this4.setAndFlush(controller, 'bar', 'NUKE');
        _this4.assertCurrentPath('/?other_bar=NUKE&other_foo=NAW', 'QP updated correctly with \'as\'');
      });
    };

    _class.prototype['@test Routes have a private overridable serializeQueryParamKey hook'] = function testRoutesHaveAPrivateOverridableSerializeQueryParamKeyHook(assert) {
      var _this5 = this;

      assert.expect(2);

      this.registerRoute('index', _emberRouting.Route.extend({
        serializeQueryParamKey: _emberRuntime.String.dasherize
      }));

      this.setSingleQPController('index', 'funTimes', '');

      return this.visitAndAssert('/').then(function () {
        var controller = _this5.getController('index');

        _this5.setAndFlush(controller, 'funTimes', 'woot');
        _this5.assertCurrentPath('/?fun-times=woot');
      });
    };

    _class.prototype['@test Can override inherited QP behavior by specifying queryParams as a computed property'] = function testCanOverrideInheritedQPBehaviorBySpecifyingQueryParamsAsAComputedProperty(assert) {
      var _this6 = this;

      assert.expect(3);

      this.setSingleQPController('index', 'a', 0, {
        queryParams: _emberMetal.computed(function () {
          return ['c'];
        }),
        c: true
      });

      return this.visitAndAssert('/').then(function () {
        var indexController = _this6.getController('index');

        _this6.setAndFlush(indexController, 'a', 1);
        _this6.assertCurrentPath('/', 'QP did not update due to being overriden');

        _this6.setAndFlush(indexController, 'c', false);
        _this6.assertCurrentPath('/?c=false', 'QP updated with overriden param');
      });
    };

    _class.prototype['@test Can concatenate inherited QP behavior by specifying queryParams as an array'] = function testCanConcatenateInheritedQPBehaviorBySpecifyingQueryParamsAsAnArray(assert) {
      var _this7 = this;

      assert.expect(3);

      this.setSingleQPController('index', 'a', 0, {
        queryParams: ['c'],
        c: true
      });

      return this.visitAndAssert('/').then(function () {
        var indexController = _this7.getController('index');

        _this7.setAndFlush(indexController, 'a', 1);
        _this7.assertCurrentPath('/?a=1', 'Inherited QP did update');

        _this7.setAndFlush(indexController, 'c', false);
        _this7.assertCurrentPath('/?a=1&c=false', 'New QP did update');
      });
    };

    _class.prototype['@test model hooks receives query params'] = function testModelHooksReceivesQueryParams(assert) {
      assert.expect(2);

      this.setSingleQPController('index');

      this.registerRoute('index', _emberRouting.Route.extend({
        model: function (params) {
          assert.deepEqual(params, { foo: 'bar' });
        }
      }));

      return this.visitAndAssert('/');
    };

    _class.prototype['@test model hooks receives query params with dynamic segment params'] = function testModelHooksReceivesQueryParamsWithDynamicSegmentParams(assert) {
      assert.expect(2);

      this.router.map(function () {
        this.route('index', { path: '/:id' });
      });

      this.setSingleQPController('index');

      this.registerRoute('index', _emberRouting.Route.extend({
        model: function (params) {
          assert.deepEqual(params, { foo: 'bar', id: 'baz' });
        }
      }));

      return this.visitAndAssert('/baz');
    };

    _class.prototype['@test model hooks receives query params (overridden by incoming url value)'] = function testModelHooksReceivesQueryParamsOverriddenByIncomingUrlValue(assert) {
      assert.expect(2);

      this.router.map(function () {
        this.route('index', { path: '/:id' });
      });

      this.setSingleQPController('index');

      this.registerRoute('index', _emberRouting.Route.extend({
        model: function (params) {
          assert.deepEqual(params, { foo: 'baz', id: 'boo' });
        }
      }));

      return this.visitAndAssert('/boo?foo=baz');
    };

    _class.prototype['@test error is thrown if dynamic segment and query param have same name'] = function testErrorIsThrownIfDynamicSegmentAndQueryParamHaveSameName(assert) {
      var _this8 = this;

      assert.expect(1);

      this.router.map(function () {
        this.route('index', { path: '/:foo' });
      });

      this.setSingleQPController('index');

      expectAssertion(function () {
        _this8.visitAndAssert('/boo?foo=baz');
      }, 'The route \'index\' has both a dynamic segment and query param with name \'foo\'. Please rename one to avoid collisions.');
    };

    _class.prototype['@test controllers won\'t be eagerly instantiated by internal query params logic'] = function testControllersWonTBeEagerlyInstantiatedByInternalQueryParamsLogic(assert) {
      var _this9 = this;

      assert.expect(10);

      this.router.map(function () {
        this.route('cats', function () {
          this.route('index', { path: '/' });
        });
        this.route('home', { path: '/' });
        this.route('about');
      });

      this.registerTemplate('home', '<h3>{{link-to \'About\' \'about\' (query-params lol=\'wat\') id=\'link-to-about\'}}</h3>');
      this.registerTemplate('about', '<h3>{{link-to \'Home\' \'home\'  (query-params foo=\'naw\')}}</h3>');
      this.registerTemplate('cats.index', '<h3>{{link-to \'Cats\' \'cats\'  (query-params name=\'domino\') id=\'cats-link\'}}</h3>');

      var homeShouldBeCreated = false;
      var aboutShouldBeCreated = false;
      var catsIndexShouldBeCreated = false;

      this.registerRoute('home', _emberRouting.Route.extend({
        setup: function () {
          homeShouldBeCreated = true;
          this._super.apply(this, arguments);
        }
      }));

      this.setSingleQPController('home', 'foo', '123', {
        init: function () {
          this._super.apply(this, arguments);
          assert.ok(homeShouldBeCreated, 'HomeController should be created at this time');
        }
      });

      this.registerRoute('about', _emberRouting.Route.extend({
        setup: function () {
          aboutShouldBeCreated = true;
          this._super.apply(this, arguments);
        }
      }));

      this.setSingleQPController('about', 'lol', 'haha', {
        init: function () {
          this._super.apply(this, arguments);
          assert.ok(aboutShouldBeCreated, 'AboutController should be created at this time');
        }
      });

      this.registerRoute('cats.index', _emberRouting.Route.extend({
        model: function () {
          return [];
        },
        setup: function () {
          catsIndexShouldBeCreated = true;
          this._super.apply(this, arguments);
        },
        setupController: function (controller, context) {
          controller.set('model', context);
        }
      }));

      this.registerController('cats.index', _emberRuntime.Controller.extend({
        queryParams: ['breed', 'name'],
        breed: 'Golden',
        name: null,
        init: function () {
          this._super.apply(this, arguments);
          assert.ok(catsIndexShouldBeCreated, 'CatsIndexController should be created at this time');
        }
      }));

      return this.visitAndAssert('/').then(function () {
        var controller = _this9.getController('home');

        _this9.setAndFlush(controller, 'foo', '456');
        _this9.assertCurrentPath('/?foo=456');
        assert.equal(_emberViews.jQuery('#link-to-about').attr('href'), '/about?lol=wat', 'link to about is correct');

        _this9.transitionTo('about');
        _this9.assertCurrentPath('/about');

        _this9.transitionTo('cats');
        _this9.assertCurrentPath('/cats');
        assert.equal(_emberViews.jQuery('#cats-link').attr('href'), '/cats?name=domino', 'link to cats is correct');

        _emberMetal.run(_emberViews.jQuery('#cats-link'), 'click');
        _this9.assertCurrentPath('/cats?name=domino');
      });
    };

    _class.prototype['@test query params have been set by the time setupController is called'] = function testQueryParamsHaveBeenSetByTheTimeSetupControllerIsCalled(assert) {
      assert.expect(2);

      this.setSingleQPController('application');

      this.registerRoute('application', _emberRouting.Route.extend({
        setupController: function (controller) {
          assert.equal(controller.get('foo'), 'YEAH', 'controller\'s foo QP property set before setupController called');
        }
      }));

      return this.visitAndAssert('/?foo=YEAH');
    };

    _class.prototype['@test mapped query params have been set by the time setupController is called'] = function testMappedQueryParamsHaveBeenSetByTheTimeSetupControllerIsCalled(assert) {
      assert.expect(2);

      this.setSingleQPController('application', { faz: 'foo' });

      this.registerRoute('application', _emberRouting.Route.extend({
        setupController: function (controller) {
          assert.equal(controller.get('faz'), 'YEAH', 'controller\'s foo QP property set before setupController called');
        }
      }));

      return this.visitAndAssert('/?foo=YEAH');
    };

    _class.prototype['@test Route#paramsFor fetches query params with default value'] = function testRouteParamsForFetchesQueryParamsWithDefaultValue(assert) {
      assert.expect(2);

      this.router.map(function () {
        this.route('index', { path: '/:something' });
      });

      this.setSingleQPController('index');

      this.registerRoute('index', _emberRouting.Route.extend({
        model: function (params, transition) {
          assert.deepEqual(this.paramsFor('index'), { something: 'baz', foo: 'bar' }, 'could retrieve params for index');
        }
      }));

      return this.visitAndAssert('/baz');
    };

    _class.prototype['@test Route#paramsFor fetches query params with non-default value'] = function testRouteParamsForFetchesQueryParamsWithNonDefaultValue(assert) {
      assert.expect(2);

      this.router.map(function () {
        this.route('index', { path: '/:something' });
      });

      this.setSingleQPController('index');

      this.registerRoute('index', _emberRouting.Route.extend({
        model: function (params, transition) {
          assert.deepEqual(this.paramsFor('index'), { something: 'baz', foo: 'boo' }, 'could retrieve params for index');
        }
      }));

      return this.visitAndAssert('/baz?foo=boo');
    };

    _class.prototype['@test Route#paramsFor fetches default falsy query params'] = function testRouteParamsForFetchesDefaultFalsyQueryParams(assert) {
      assert.expect(2);

      this.router.map(function () {
        this.route('index', { path: '/:something' });
      });

      this.setSingleQPController('index', 'foo', false);

      this.registerRoute('index', _emberRouting.Route.extend({
        model: function (params, transition) {
          assert.deepEqual(this.paramsFor('index'), { something: 'baz', foo: false }, 'could retrieve params for index');
        }
      }));

      return this.visitAndAssert('/baz');
    };

    _class.prototype['@test Route#paramsFor fetches non-default falsy query params'] = function testRouteParamsForFetchesNonDefaultFalsyQueryParams(assert) {
      assert.expect(2);

      this.router.map(function () {
        this.route('index', { path: '/:something' });
      });

      this.setSingleQPController('index', 'foo', true);

      this.registerRoute('index', _emberRouting.Route.extend({
        model: function (params, transition) {
          assert.deepEqual(this.paramsFor('index'), { something: 'baz', foo: false }, 'could retrieve params for index');
        }
      }));

      return this.visitAndAssert('/baz?foo=false');
    };

    _class.prototype['@test model hook can query prefix-less application params'] = function testModelHookCanQueryPrefixLessApplicationParams(assert) {
      assert.expect(4);

      this.setSingleQPController('application', 'appomg', 'applol');
      this.setSingleQPController('index', 'omg', 'lol');

      this.registerRoute('application', _emberRouting.Route.extend({
        model: function (params) {
          assert.deepEqual(params, { appomg: 'applol' });
        }
      }));

      this.registerRoute('index', _emberRouting.Route.extend({
        model: function (params) {
          assert.deepEqual(params, { omg: 'lol' });
          assert.deepEqual(this.paramsFor('application'), { appomg: 'applol' });
        }
      }));

      return this.visitAndAssert('/');
    };

    _class.prototype['@test model hook can query prefix-less application params (overridden by incoming url value)'] = function testModelHookCanQueryPrefixLessApplicationParamsOverriddenByIncomingUrlValue(assert) {
      assert.expect(4);

      this.setSingleQPController('application', 'appomg', 'applol');
      this.setSingleQPController('index', 'omg', 'lol');

      this.registerRoute('application', _emberRouting.Route.extend({
        model: function (params) {
          assert.deepEqual(params, { appomg: 'appyes' });
        }
      }));

      this.registerRoute('index', _emberRouting.Route.extend({
        model: function (params) {
          assert.deepEqual(params, { omg: 'yes' });
          assert.deepEqual(this.paramsFor('application'), { appomg: 'appyes' });
        }
      }));

      return this.visitAndAssert('/?appomg=appyes&omg=yes');
    };

    _class.prototype['@test can opt into full transition by setting refreshModel in route queryParams'] = function testCanOptIntoFullTransitionBySettingRefreshModelInRouteQueryParams(assert) {
      var _this10 = this;

      assert.expect(7);

      this.setSingleQPController('application', 'appomg', 'applol');
      this.setSingleQPController('index', 'omg', 'lol');

      var appModelCount = 0;
      this.registerRoute('application', _emberRouting.Route.extend({
        model: function (params) {
          appModelCount++;
        }
      }));

      var indexModelCount = 0;
      this.registerRoute('index', _emberRouting.Route.extend({
        queryParams: {
          omg: {
            refreshModel: true
          }
        },
        model: function (params) {
          indexModelCount++;

          if (indexModelCount === 1) {
            assert.deepEqual(params, { omg: 'lol' }, 'params are correct on first pass');
          } else if (indexModelCount === 2) {
            assert.deepEqual(params, { omg: 'lex' }, 'params are correct on second pass');
          }
        }
      }));

      return this.visitAndAssert('/').then(function () {
        assert.equal(appModelCount, 1, 'app model hook ran');
        assert.equal(indexModelCount, 1, 'index model hook ran');

        var indexController = _this10.getController('index');
        _this10.setAndFlush(indexController, 'omg', 'lex');

        assert.equal(appModelCount, 1, 'app model hook did not run again');
        assert.equal(indexModelCount, 2, 'index model hook ran again due to refreshModel');
      });
    };

    _class.prototype['@test multiple QP value changes only cause a single model refresh'] = function testMultipleQPValueChangesOnlyCauseASingleModelRefresh(assert) {
      var _this11 = this;

      assert.expect(2);

      this.setSingleQPController('index', 'alex', 'lol');
      this.setSingleQPController('index', 'steely', 'lel');

      var refreshCount = 0;
      this.registerRoute('index', _emberRouting.Route.extend({
        queryParams: {
          alex: {
            refreshModel: true
          },
          steely: {
            refreshModel: true
          }
        },
        refresh: function () {
          refreshCount++;
        }
      }));

      return this.visitAndAssert('/').then(function () {
        var indexController = _this11.getController('index');
        _emberMetal.run(indexController, 'setProperties', { alex: 'fran', steely: 'david' });
        assert.equal(refreshCount, 1, 'index refresh hook only run once');
      });
    };

    _class.prototype['@test refreshModel does not cause a second transition during app boot '] = function testRefreshModelDoesNotCauseASecondTransitionDuringAppBoot(assert) {
      assert.expect(1);

      this.setSingleQPController('application', 'appomg', 'applol');
      this.setSingleQPController('index', 'omg', 'lol');

      this.registerRoute('index', _emberRouting.Route.extend({
        queryParams: {
          omg: {
            refreshModel: true
          }
        },
        refresh: function () {
          assert.ok(false);
        }
      }));

      return this.visitAndAssert('/?appomg=hello&omg=world');
    };

    _class.prototype['@test queryParams are updated when a controller property is set and the route is refreshed. Issue #13263  '] = function testQueryParamsAreUpdatedWhenAControllerPropertyIsSetAndTheRouteIsRefreshedIssue13263(assert) {
      var _this12 = this;

      this.registerTemplate('application', '<button id="test-button" {{action \'increment\'}}>Increment</button><span id="test-value">{{foo}}</span>{{outlet}}');

      this.setSingleQPController('application', 'foo', 1, {
        actions: {
          increment: function () {
            this.incrementProperty('foo');
            this.send('refreshRoute');
          }
        }
      });

      this.registerRoute('application', _emberRouting.Route.extend({
        actions: {
          refreshRoute: function () {
            this.refresh();
          }
        }
      }));

      return this.visitAndAssert('/').then(function () {
        assert.equal(_emberViews.jQuery('#test-value').text().trim(), '1');

        _emberMetal.run(_emberViews.jQuery('#test-button'), 'click');
        assert.equal(_emberViews.jQuery('#test-value').text().trim(), '2');
        _this12.assertCurrentPath('/?foo=2');

        _emberMetal.run(_emberViews.jQuery('#test-button'), 'click');
        assert.equal(_emberViews.jQuery('#test-value').text().trim(), '3');
        _this12.assertCurrentPath('/?foo=3');
      });
    };

    _class.prototype['@test Use Ember.get to retrieve query params \'refreshModel\' configuration'] = function testUseEmberGetToRetrieveQueryParamsRefreshModelConfiguration(assert) {
      var _this13 = this;

      assert.expect(7);

      this.setSingleQPController('application', 'appomg', 'applol');
      this.setSingleQPController('index', 'omg', 'lol');

      var appModelCount = 0;
      this.registerRoute('application', _emberRouting.Route.extend({
        model: function (params) {
          appModelCount++;
        }
      }));

      var indexModelCount = 0;
      this.registerRoute('index', _emberRouting.Route.extend({
        queryParams: _emberRuntime.Object.create({
          unknownProperty: function (keyName) {
            return { refreshModel: true };
          }
        }),
        model: function (params) {
          indexModelCount++;

          if (indexModelCount === 1) {
            assert.deepEqual(params, { omg: 'lol' });
          } else if (indexModelCount === 2) {
            assert.deepEqual(params, { omg: 'lex' });
          }
        }
      }));

      return this.visitAndAssert('/').then(function () {
        assert.equal(appModelCount, 1);
        assert.equal(indexModelCount, 1);

        var indexController = _this13.getController('index');
        _this13.setAndFlush(indexController, 'omg', 'lex');

        assert.equal(appModelCount, 1);
        assert.equal(indexModelCount, 2);
      });
    };

    _class.prototype['@test can use refreshModel even with URL changes that remove QPs from address bar'] = function testCanUseRefreshModelEvenWithURLChangesThatRemoveQPsFromAddressBar(assert) {
      var _this14 = this;

      assert.expect(4);

      this.setSingleQPController('index', 'omg', 'lol');

      var indexModelCount = 0;
      this.registerRoute('index', _emberRouting.Route.extend({
        queryParams: {
          omg: {
            refreshModel: true
          }
        },
        model: function (params) {
          indexModelCount++;

          var data = undefined;
          if (indexModelCount === 1) {
            data = 'foo';
          } else if (indexModelCount === 2) {
            data = 'lol';
          }

          assert.deepEqual(params, { omg: data }, 'index#model receives right data');
        }
      }));

      return this.visitAndAssert('/?omg=foo').then(function () {
        _this14.transitionTo('/');

        var indexController = _this14.getController('index');
        assert.equal(indexController.get('omg'), 'lol');
      });
    };

    _class.prototype['@test can opt into a replace query by specifying replace:true in the Route config hash'] = function testCanOptIntoAReplaceQueryBySpecifyingReplaceTrueInTheRouteConfigHash(assert) {
      var _this15 = this;

      assert.expect(2);

      this.setSingleQPController('application', 'alex', 'matchneer');

      this.registerRoute('application', _emberRouting.Route.extend({
        queryParams: {
          alex: {
            replace: true
          }
        }
      }));

      return this.visitAndAssert('/').then(function () {
        var appController = _this15.getController('application');
        _this15.expectedReplaceURL = '/?alex=wallace';
        _this15.setAndFlush(appController, 'alex', 'wallace');
      });
    };

    _class.prototype['@test Route query params config can be configured using property name instead of URL key'] = function testRouteQueryParamsConfigCanBeConfiguredUsingPropertyNameInsteadOfURLKey(assert) {
      var _this16 = this;

      assert.expect(2);

      this.registerController('application', _emberRuntime.Controller.extend({
        queryParams: [{ commitBy: 'commit_by' }]
      }));

      this.registerRoute('application', _emberRouting.Route.extend({
        queryParams: {
          commitBy: {
            replace: true
          }
        }
      }));

      return this.visitAndAssert('/').then(function () {
        var appController = _this16.getController('application');
        _this16.expectedReplaceURL = '/?commit_by=igor_seb';
        _this16.setAndFlush(appController, 'commitBy', 'igor_seb');
      });
    };

    _class.prototype['@test An explicit replace:false on a changed QP always wins and causes a pushState'] = function testAnExplicitReplaceFalseOnAChangedQPAlwaysWinsAndCausesAPushState(assert) {
      var _this17 = this;

      assert.expect(3);

      this.registerController('application', _emberRuntime.Controller.extend({
        queryParams: ['alex', 'steely'],
        alex: 'matchneer',
        steely: 'dan'
      }));

      this.registerRoute('application', _emberRouting.Route.extend({
        queryParams: {
          alex: {
            replace: true
          },
          steely: {
            replace: false
          }
        }
      }));

      return this.visit('/').then(function () {
        var appController = _this17.getController('application');
        _this17.expectedPushURL = '/?alex=wallace&steely=jan';
        _emberMetal.run(appController, 'setProperties', { alex: 'wallace', steely: 'jan' });

        _this17.expectedPushURL = '/?alex=wallace&steely=fran';
        _emberMetal.run(appController, 'setProperties', { steely: 'fran' });

        _this17.expectedReplaceURL = '/?alex=sriracha&steely=fran';
        _emberMetal.run(appController, 'setProperties', { alex: 'sriracha' });
      });
    };

    _class.prototype['@test can opt into full transition by setting refreshModel in route queryParams when transitioning from child to parent'] = function testCanOptIntoFullTransitionBySettingRefreshModelInRouteQueryParamsWhenTransitioningFromChildToParent(assert) {
      this.registerTemplate('parent', '{{outlet}}');
      this.registerTemplate('parent.child', '{{link-to \'Parent\' \'parent\' (query-params foo=\'change\') id=\'parent-link\'}}');

      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
        });
      });

      var parentModelCount = 0;
      this.registerRoute('parent', _emberRouting.Route.extend({
        model: function () {
          parentModelCount++;
        },
        queryParams: {
          foo: {
            refreshModel: true
          }
        }
      }));

      this.setSingleQPController('parent', 'foo', 'abc');

      return this.visit('/parent/child?foo=lol').then(function () {
        assert.equal(parentModelCount, 1);

        _emberMetal.run(_emberViews.jQuery('#parent-link'), 'click');
        assert.equal(parentModelCount, 2);
      });
    };

    _class.prototype['@test Use Ember.get to retrieve query params \'replace\' configuration'] = function testUseEmberGetToRetrieveQueryParamsReplaceConfiguration(assert) {
      var _this18 = this;

      assert.expect(2);

      this.setSingleQPController('application', 'alex', 'matchneer');

      this.registerRoute('application', _emberRouting.Route.extend({
        queryParams: _emberRuntime.Object.create({
          unknownProperty: function (keyName) {
            // We are simulating all qps requiring refresh
            return { replace: true };
          }
        })
      }));

      return this.visitAndAssert('/').then(function () {
        var appController = _this18.getController('application');
        _this18.expectedReplaceURL = '/?alex=wallace';
        _this18.setAndFlush(appController, 'alex', 'wallace');
      });
    };

    _class.prototype['@test can override incoming QP values in setupController'] = function testCanOverrideIncomingQPValuesInSetupController(assert) {
      var _this19 = this;

      assert.expect(3);

      this.router.map(function () {
        this.route('about');
      });

      this.setSingleQPController('index', 'omg', 'lol');

      this.registerRoute('index', _emberRouting.Route.extend({
        setupController: function (controller) {
          assert.ok(true, 'setupController called');
          controller.set('omg', 'OVERRIDE');
        },
        actions: {
          queryParamsDidChange: function () {
            assert.ok(false, 'queryParamsDidChange shouldn\'t fire');
          }
        }
      }));

      return this.visitAndAssert('/about').then(function () {
        _this19.transitionTo('index');
        _this19.assertCurrentPath('/?omg=OVERRIDE');
      });
    };

    _class.prototype['@test can override incoming QP array values in setupController'] = function testCanOverrideIncomingQPArrayValuesInSetupController(assert) {
      var _this20 = this;

      assert.expect(3);

      this.router.map(function () {
        this.route('about');
      });

      this.setSingleQPController('index', 'omg', ['lol']);

      this.registerRoute('index', _emberRouting.Route.extend({
        setupController: function (controller) {
          assert.ok(true, 'setupController called');
          controller.set('omg', ['OVERRIDE']);
        },
        actions: {
          queryParamsDidChange: function () {
            assert.ok(false, 'queryParamsDidChange shouldn\'t fire');
          }
        }
      }));

      return this.visitAndAssert('/about').then(function () {
        _this20.transitionTo('index');
        _this20.assertCurrentPath('/?omg=' + encodeURIComponent(JSON.stringify(['OVERRIDE'])));
      });
    };

    _class.prototype['@test URL transitions that remove QPs still register as QP changes'] = function testURLTransitionsThatRemoveQPsStillRegisterAsQPChanges(assert) {
      var _this21 = this;

      assert.expect(2);

      this.setSingleQPController('index', 'omg', 'lol');

      return this.visit('/?omg=borf').then(function () {
        var indexController = _this21.getController('index');
        assert.equal(indexController.get('omg'), 'borf');

        _this21.transitionTo('/');
        assert.equal(indexController.get('omg'), 'lol');
      });
    };

    _class.prototype['@test Subresource naming style is supported'] = function testSubresourceNamingStyleIsSupported(assert) {
      var _this22 = this;

      assert.expect(5);

      this.router.map(function () {
        this.route('abc.def', { path: '/abcdef' }, function () {
          this.route('zoo');
        });
      });

      this.registerTemplate('application', '{{link-to \'A\' \'abc.def\' (query-params foo=\'123\') id=\'one\'}}{{link-to \'B\' \'abc.def.zoo\' (query-params foo=\'123\' bar=\'456\') id=\'two\'}}{{outlet}}');

      this.setSingleQPController('abc.def', 'foo', 'lol');
      this.setSingleQPController('abc.def.zoo', 'bar', 'haha');

      return this.visitAndAssert('/').then(function () {
        assert.equal(_emberViews.jQuery('#one').attr('href'), '/abcdef?foo=123');
        assert.equal(_emberViews.jQuery('#two').attr('href'), '/abcdef/zoo?bar=456&foo=123');

        _emberMetal.run(_emberViews.jQuery('#one'), 'click');
        _this22.assertCurrentPath('/abcdef?foo=123');

        _emberMetal.run(_emberViews.jQuery('#two'), 'click');
        _this22.assertCurrentPath('/abcdef/zoo?bar=456&foo=123');
      });
    };

    _class.prototype['@test transitionTo supports query params'] = function testTransitionToSupportsQueryParams(assert) {
      var _this23 = this;

      this.setSingleQPController('index', 'foo', 'lol');

      return this.visitAndAssert('/').then(function () {
        _this23.transitionTo({ queryParams: { foo: 'borf' } });
        _this23.assertCurrentPath('/?foo=borf', 'shorthand supported');

        _this23.transitionTo({ queryParams: { 'index:foo': 'blaf' } });
        _this23.assertCurrentPath('/?foo=blaf', 'longform supported');

        _this23.transitionTo({ queryParams: { 'index:foo': false } });
        _this23.assertCurrentPath('/?foo=false', 'longform supported (bool)');

        _this23.transitionTo({ queryParams: { foo: false } });
        _this23.assertCurrentPath('/?foo=false', 'shorhand supported (bool)');
      });
    };

    _class.prototype['@test transitionTo supports query params (multiple)'] = function testTransitionToSupportsQueryParamsMultiple(assert) {
      var _this24 = this;

      this.registerController('index', _emberRuntime.Controller.extend({
        queryParams: ['foo', 'bar'],
        foo: 'lol',
        bar: 'wat'
      }));

      return this.visitAndAssert('/').then(function () {
        _this24.transitionTo({ queryParams: { foo: 'borf' } });
        _this24.assertCurrentPath('/?foo=borf', 'shorthand supported');

        _this24.transitionTo({ queryParams: { 'index:foo': 'blaf' } });
        _this24.assertCurrentPath('/?foo=blaf', 'longform supported');

        _this24.transitionTo({ queryParams: { 'index:foo': false } });
        _this24.assertCurrentPath('/?foo=false', 'longform supported (bool)');

        _this24.transitionTo({ queryParams: { foo: false } });
        _this24.assertCurrentPath('/?foo=false', 'shorhand supported (bool)');
      });
    };

    _class.prototype['@test setting controller QP to empty string doesn\'t generate null in URL'] = function testSettingControllerQPToEmptyStringDoesnTGenerateNullInURL(assert) {
      var _this25 = this;

      assert.expect(1);

      this.setSingleQPController('index', 'foo', '123');

      return this.visit('/').then(function () {
        var controller = _this25.getController('index');

        _this25.expectedPushURL = '/?foo=';
        _this25.setAndFlush(controller, 'foo', '');
      });
    };

    _class.prototype['@test setting QP to empty string doesn\'t generate null in URL'] = function testSettingQPToEmptyStringDoesnTGenerateNullInURL(assert) {
      var _this26 = this;

      assert.expect(1);

      this.registerRoute('index', _emberRouting.Route.extend({
        queryParams: {
          foo: {
            defaultValue: '123'
          }
        }
      }));

      return this.visit('/').then(function () {
        var controller = _this26.getController('index');

        _this26.expectedPushURL = '/?foo=';
        _this26.setAndFlush(controller, 'foo', '');
      });
    };

    _class.prototype['@test A default boolean value deserializes QPs as booleans rather than strings'] = function testADefaultBooleanValueDeserializesQPsAsBooleansRatherThanStrings(assert) {
      var _this27 = this;

      assert.expect(3);

      this.setSingleQPController('index', 'foo', false);

      this.registerRoute('index', _emberRouting.Route.extend({
        model: function (params) {
          assert.equal(params.foo, true, 'model hook received foo as boolean true');
        }
      }));

      return this.visit('/?foo=true').then(function () {
        var controller = _this27.getController('index');
        assert.equal(controller.get('foo'), true);

        _this27.transitionTo('/?foo=false');
        assert.equal(controller.get('foo'), false);
      });
    };

    _class.prototype['@test Query param without value are empty string'] = function testQueryParamWithoutValueAreEmptyString(assert) {
      var _this28 = this;

      assert.expect(1);

      this.registerController('index', _emberRuntime.Controller.extend({
        queryParams: ['foo'],
        foo: ''
      }));

      return this.visit('/?foo=').then(function () {
        var controller = _this28.getController('index');
        assert.equal(controller.get('foo'), '');
      });
    };

    _class.prototype['@test Array query params can be set'] = function testArrayQueryParamsCanBeSet(assert) {
      var _this29 = this;

      assert.expect(2);

      this.router.map(function () {
        this.route('home', { path: '/' });
      });

      this.setSingleQPController('home', 'foo', []);

      return this.visit('/').then(function () {
        var controller = _this29.getController('home');

        _this29.setAndFlush(controller, 'foo', [1, 2]);
        _this29.assertCurrentPath('/?foo=%5B1%2C2%5D');

        _this29.setAndFlush(controller, 'foo', [3, 4]);
        _this29.assertCurrentPath('/?foo=%5B3%2C4%5D');
      });
    };

    _class.prototype['@test (de)serialization: arrays'] = function testDeSerializationArrays(assert) {
      var _this30 = this;

      assert.expect(4);

      this.setSingleQPController('index', 'foo', [1]);

      return this.visitAndAssert('/').then(function () {
        _this30.transitionTo({ queryParams: { foo: [2, 3] } });
        _this30.assertCurrentPath('/?foo=%5B2%2C3%5D', 'shorthand supported');
        _this30.transitionTo({ queryParams: { 'index:foo': [4, 5] } });
        _this30.assertCurrentPath('/?foo=%5B4%2C5%5D', 'longform supported');
        _this30.transitionTo({ queryParams: { foo: [] } });
        _this30.assertCurrentPath('/?foo=%5B%5D', 'longform supported');
      });
    };

    _class.prototype['@test Url with array query param sets controller property to array'] = function testUrlWithArrayQueryParamSetsControllerPropertyToArray(assert) {
      var _this31 = this;

      assert.expect(1);

      this.setSingleQPController('index', 'foo', '');

      return this.visit('/?foo[]=1&foo[]=2&foo[]=3').then(function () {
        var controller = _this31.getController('index');
        assert.deepEqual(controller.get('foo'), ['1', '2', '3']);
      });
    };

    _class.prototype['@test Array query params can be pushed/popped'] = function testArrayQueryParamsCanBePushedPopped(assert) {
      var _this32 = this;

      assert.expect(17);

      this.router.map(function () {
        this.route('home', { path: '/' });
      });

      this.setSingleQPController('home', 'foo', _emberRuntime.A());

      return this.visitAndAssert('/').then(function () {
        var controller = _this32.getController('home');

        _emberMetal.run(controller.foo, 'pushObject', 1);
        _this32.assertCurrentPath('/?foo=%5B1%5D');
        assert.deepEqual(controller.foo, [1]);

        _emberMetal.run(controller.foo, 'popObject');
        _this32.assertCurrentPath('/');
        assert.deepEqual(controller.foo, []);

        _emberMetal.run(controller.foo, 'pushObject', 1);
        _this32.assertCurrentPath('/?foo=%5B1%5D');
        assert.deepEqual(controller.foo, [1]);

        _emberMetal.run(controller.foo, 'popObject');
        _this32.assertCurrentPath('/');
        assert.deepEqual(controller.foo, []);

        _emberMetal.run(controller.foo, 'pushObject', 1);
        _this32.assertCurrentPath('/?foo=%5B1%5D');
        assert.deepEqual(controller.foo, [1]);

        _emberMetal.run(controller.foo, 'pushObject', 2);
        _this32.assertCurrentPath('/?foo=%5B1%2C2%5D');
        assert.deepEqual(controller.foo, [1, 2]);

        _emberMetal.run(controller.foo, 'popObject');
        _this32.assertCurrentPath('/?foo=%5B1%5D');
        assert.deepEqual(controller.foo, [1]);

        _emberMetal.run(controller.foo, 'unshiftObject', 'lol');
        _this32.assertCurrentPath('/?foo=%5B%22lol%22%2C1%5D');
        assert.deepEqual(controller.foo, ['lol', 1]);
      });
    };

    _class.prototype['@test Overwriting with array with same content shouldn\'t refire update'] = function testOverwritingWithArrayWithSameContentShouldnTRefireUpdate(assert) {
      var _this33 = this;

      assert.expect(4);

      this.router.map(function () {
        this.route('home', { path: '/' });
      });

      var modelCount = 0;
      this.registerRoute('home', _emberRouting.Route.extend({
        model: function () {
          modelCount++;
        }
      }));

      this.setSingleQPController('home', 'foo', _emberRuntime.A([1]));

      return this.visitAndAssert('/').then(function () {
        assert.equal(modelCount, 1);

        var controller = _this33.getController('home');
        _this33.setAndFlush(controller, 'model', _emberRuntime.A([1]));

        assert.equal(modelCount, 1);
        _this33.assertCurrentPath('/');
      });
    };

    _class.prototype['@test Defaulting to params hash as the model should not result in that params object being watched'] = function testDefaultingToParamsHashAsTheModelShouldNotResultInThatParamsObjectBeingWatched(assert) {
      var _this34 = this;

      assert.expect(1);

      this.router.map(function () {
        this.route('other');
      });

      // This causes the params hash, which is returned as a route's
      // model if no other model could be resolved given the provided
      // params (and no custom model hook was defined), to be watched,
      // unless we return a copy of the params hash.
      this.setSingleQPController('application', 'woot', 'wat');

      this.registerRoute('other', _emberRouting.Route.extend({
        model: function (p, trans) {
          var m = _emberMetal.meta(trans.params.application);
          assert.ok(!m.peekWatching('woot'), 'A meta object isn\'t constructed for this params POJO');
        }
      }));

      return this.visit('/').then(function () {
        _this34.transitionTo('other');
      });
    };

    _class.prototype['@test A child of a resource route still defaults to parent route\'s model even if the child route has a query param'] = function testAChildOfAResourceRouteStillDefaultsToParentRouteSModelEvenIfTheChildRouteHasAQueryParam(assert) {
      assert.expect(2);

      this.setSingleQPController('index', 'woot', undefined, {
        woot: undefined
      });

      this.registerRoute('application', _emberRouting.Route.extend({
        model: function (p, trans) {
          return { woot: true };
        }
      }));

      this.registerRoute('index', _emberRouting.Route.extend({
        setupController: function (controller, model) {
          assert.deepEqual(model, { woot: true }, 'index route inherited model route from parent route');
        }
      }));

      return this.visitAndAssert('/');
    };

    _class.prototype['@test opting into replace does not affect transitions between routes'] = function testOptingIntoReplaceDoesNotAffectTransitionsBetweenRoutes(assert) {
      var _this35 = this;

      assert.expect(5);

      this.registerTemplate('application', '{{link-to \'Foo\' \'foo\' id=\'foo-link\'}}{{link-to \'Bar\' \'bar\' id=\'bar-no-qp-link\'}}{{link-to \'Bar\' \'bar\' (query-params raytiley=\'isthebest\') id=\'bar-link\'}}{{outlet}}');

      this.router.map(function () {
        this.route('foo');
        this.route('bar');
      });

      this.setSingleQPController('bar', 'raytiley', 'israd');

      this.registerRoute('bar', _emberRouting.Route.extend({
        queryParams: {
          raytiley: {
            replace: true
          }
        }
      }));

      return this.visit('/').then(function () {
        var controller = _this35.getController('bar');

        _this35.expectedPushURL = '/foo';
        _emberMetal.run(_emberViews.jQuery('#foo-link'), 'click');

        _this35.expectedPushURL = '/bar';
        _emberMetal.run(_emberViews.jQuery('#bar-no-qp-link'), 'click');

        _this35.expectedReplaceURL = '/bar?raytiley=woot';
        _this35.setAndFlush(controller, 'raytiley', 'woot');

        _this35.expectedPushURL = '/foo';
        _emberMetal.run(_emberViews.jQuery('#foo-link'), 'click');

        _this35.expectedPushURL = '/bar?raytiley=isthebest';
        _emberMetal.run(_emberViews.jQuery('#bar-link'), 'click');
      });
    };

    _class.prototype['@test undefined isn\'t serialized or deserialized into a string'] = function testUndefinedIsnTSerializedOrDeserializedIntoAString(assert) {
      var _this36 = this;

      assert.expect(4);

      this.router.map(function () {
        this.route('example');
      });

      this.registerTemplate('application', '{{link-to \'Example\' \'example\' (query-params foo=undefined) id=\'the-link\'}}');

      this.setSingleQPController('example', 'foo', undefined, {
        foo: undefined
      });

      this.registerRoute('example', _emberRouting.Route.extend({
        model: function (params) {
          assert.deepEqual(params, { foo: undefined });
        }
      }));

      return this.visitAndAssert('/').then(function () {
        assert.equal(_this36.$('#the-link').attr('href'), '/example', 'renders without undefined qp serialized');

        return _this36.transitionTo('example', { queryParams: { foo: undefined } }).then(function () {
          _this36.assertCurrentPath('/example');
        });
      });
    };

    _class.prototype['@test when refreshModel is true and loading hook is undefined, model hook will rerun when QPs change even if previous did not finish'] = function testWhenRefreshModelIsTrueAndLoadingHookIsUndefinedModelHookWillRerunWhenQPsChangeEvenIfPreviousDidNotFinish(assert) {
      return this.refreshModelWhileLoadingTest();
    };

    _class.prototype['@test when refreshModel is true and loading hook returns false, model hook will rerun when QPs change even if previous did not finish'] = function testWhenRefreshModelIsTrueAndLoadingHookReturnsFalseModelHookWillRerunWhenQPsChangeEvenIfPreviousDidNotFinish(assert) {
      return this.refreshModelWhileLoadingTest(false);
    };

    _class.prototype['@test when refreshModel is true and loading hook returns true, model hook will rerun when QPs change even if previous did not finish'] = function testWhenRefreshModelIsTrueAndLoadingHookReturnsTrueModelHookWillRerunWhenQPsChangeEvenIfPreviousDidNotFinish(assert) {
      return this.refreshModelWhileLoadingTest(true);
    };

    _class.prototype['@test warn user that Route\'s queryParams configuration must be an Object, not an Array'] = function testWarnUserThatRouteSQueryParamsConfigurationMustBeAnObjectNotAnArray(assert) {
      var _this37 = this;

      assert.expect(1);

      this.registerRoute('application', _emberRouting.Route.extend({
        queryParams: [{ commitBy: { replace: true } }]
      }));

      expectAssertion(function () {
        _this37.visit('/');
      }, 'You passed in `[{"commitBy":{"replace":true}}]` as the value for `queryParams` but `queryParams` cannot be an Array');
    };

    _class.prototype['@test handle route names that clash with Object.prototype properties'] = function testHandleRouteNamesThatClashWithObjectPrototypeProperties(assert) {
      var _this38 = this;

      assert.expect(1);

      this.router.map(function () {
        this.route('constructor');
      });

      this.registerRoute('constructor', _emberRouting.Route.extend({
        queryParams: {
          foo: {
            defaultValue: '123'
          }
        }
      }));

      return this.visit('/').then(function () {
        _this38.transitionTo('constructor', { queryParams: { foo: '999' } });
        var controller = _this38.getController('constructor');
        assert.equal(_emberMetal.get(controller, 'foo'), '999');
      });
    };

    return _class;
  })(_internalTestHelpers.QueryParamTestCase));
});
enifed('ember/tests/routing/query_params_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/routing/query_params_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/routing/query_params_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/routing/query_params_test/model_dependent_state_with_query_params_test', ['exports', 'ember-runtime', 'ember-routing', 'ember-metal', 'ember-views', 'internal-test-helpers'], function (exports, _emberRuntime, _emberRouting, _emberMetal, _emberViews, _internalTestHelpers) {
  'use strict';

  var ModelDependentQPTestCase = (function (_QueryParamTestCase) {
    babelHelpers.inherits(ModelDependentQPTestCase, _QueryParamTestCase);

    function ModelDependentQPTestCase() {
      _QueryParamTestCase.apply(this, arguments);
    }

    ModelDependentQPTestCase.prototype.boot = function boot() {
      this.setupApplication();
      return this.visitApplication();
    };

    ModelDependentQPTestCase.prototype.teardown = function teardown() {
      var _QueryParamTestCase$prototype$teardown;

      (_QueryParamTestCase$prototype$teardown = _QueryParamTestCase.prototype.teardown).call.apply(_QueryParamTestCase$prototype$teardown, [this].concat(babelHelpers.slice.call(arguments)));
      this.assert.ok(!this.expectedModelHookParams, 'there should be no pending expectation of expected model hook params');
    };

    ModelDependentQPTestCase.prototype.reopenController = function reopenController(name, options) {
      this.application.resolveRegistration('controller:' + name).reopen(options);
    };

    ModelDependentQPTestCase.prototype.reopenRoute = function reopenRoute(name, options) {
      this.application.resolveRegistration('route:' + name).reopen(options);
    };

    ModelDependentQPTestCase.prototype.queryParamsStickyTest1 = function queryParamsStickyTest1(urlPrefix) {
      var _this = this;

      var assert = this.assert;

      assert.expect(14);

      return this.boot().then(function () {
        _emberMetal.run(_this.$link1, 'click');
        _this.assertCurrentPath(urlPrefix + '/a-1');

        _this.setAndFlush(_this.controller, 'q', 'lol');

        assert.equal(_this.$link1.attr('href'), urlPrefix + '/a-1?q=lol');
        assert.equal(_this.$link2.attr('href'), urlPrefix + '/a-2');
        assert.equal(_this.$link3.attr('href'), urlPrefix + '/a-3');

        _emberMetal.run(_this.$link2, 'click');

        assert.equal(_this.controller.get('q'), 'wat');
        assert.equal(_this.controller.get('z'), 0);
        assert.deepEqual(_this.controller.get('model'), { id: 'a-2' });
        assert.equal(_this.$link1.attr('href'), urlPrefix + '/a-1?q=lol');
        assert.equal(_this.$link2.attr('href'), urlPrefix + '/a-2');
        assert.equal(_this.$link3.attr('href'), urlPrefix + '/a-3');
      });
    };

    ModelDependentQPTestCase.prototype.queryParamsStickyTest2 = function queryParamsStickyTest2(urlPrefix) {
      var _this2 = this;

      var assert = this.assert;

      assert.expect(24);

      return this.boot().then(function () {
        _this2.expectedModelHookParams = { id: 'a-1', q: 'lol', z: 0 };
        _this2.transitionTo(urlPrefix + '/a-1?q=lol');

        assert.deepEqual(_this2.controller.get('model'), { id: 'a-1' });
        assert.equal(_this2.controller.get('q'), 'lol');
        assert.equal(_this2.controller.get('z'), 0);
        assert.equal(_this2.$link1.attr('href'), urlPrefix + '/a-1?q=lol');
        assert.equal(_this2.$link2.attr('href'), urlPrefix + '/a-2');
        assert.equal(_this2.$link3.attr('href'), urlPrefix + '/a-3');

        _this2.expectedModelHookParams = { id: 'a-2', q: 'lol', z: 0 };
        _this2.transitionTo(urlPrefix + '/a-2?q=lol');

        assert.deepEqual(_this2.controller.get('model'), { id: 'a-2' }, 'controller\'s model changed to a-2');
        assert.equal(_this2.controller.get('q'), 'lol');
        assert.equal(_this2.controller.get('z'), 0);
        assert.equal(_this2.$link1.attr('href'), urlPrefix + '/a-1?q=lol');
        assert.equal(_this2.$link2.attr('href'), urlPrefix + '/a-2?q=lol'); // fail
        assert.equal(_this2.$link3.attr('href'), urlPrefix + '/a-3');

        _this2.expectedModelHookParams = { id: 'a-3', q: 'lol', z: 123 };
        _this2.transitionTo(urlPrefix + '/a-3?q=lol&z=123');

        assert.equal(_this2.controller.get('q'), 'lol');
        assert.equal(_this2.controller.get('z'), 123);
        assert.equal(_this2.$link1.attr('href'), urlPrefix + '/a-1?q=lol');
        assert.equal(_this2.$link2.attr('href'), urlPrefix + '/a-2?q=lol');
        assert.equal(_this2.$link3.attr('href'), urlPrefix + '/a-3?q=lol&z=123');
      });
    };

    ModelDependentQPTestCase.prototype.queryParamsStickyTest3 = function queryParamsStickyTest3(urlPrefix, articleLookup) {
      var _this3 = this;

      var assert = this.assert;

      assert.expect(32);

      this.registerTemplate('application', '{{#each articles as |a|}} {{link-to \'Article\' \'' + articleLookup + '\' a.id id=a.id}} {{/each}}');

      return this.boot().then(function () {
        _this3.expectedModelHookParams = { id: 'a-1', q: 'wat', z: 0 };
        _this3.transitionTo(articleLookup, 'a-1');

        assert.deepEqual(_this3.controller.get('model'), { id: 'a-1' });
        assert.equal(_this3.controller.get('q'), 'wat');
        assert.equal(_this3.controller.get('z'), 0);
        assert.equal(_this3.$link1.attr('href'), urlPrefix + '/a-1');
        assert.equal(_this3.$link2.attr('href'), urlPrefix + '/a-2');
        assert.equal(_this3.$link3.attr('href'), urlPrefix + '/a-3');

        _this3.expectedModelHookParams = { id: 'a-2', q: 'lol', z: 0 };
        _this3.transitionTo(articleLookup, 'a-2', { queryParams: { q: 'lol' } });

        assert.deepEqual(_this3.controller.get('model'), { id: 'a-2' });
        assert.equal(_this3.controller.get('q'), 'lol');
        assert.equal(_this3.controller.get('z'), 0);
        assert.equal(_this3.$link1.attr('href'), urlPrefix + '/a-1');
        assert.equal(_this3.$link2.attr('href'), urlPrefix + '/a-2?q=lol');
        assert.equal(_this3.$link3.attr('href'), urlPrefix + '/a-3');

        _this3.expectedModelHookParams = { id: 'a-3', q: 'hay', z: 0 };
        _this3.transitionTo(articleLookup, 'a-3', { queryParams: { q: 'hay' } });

        assert.deepEqual(_this3.controller.get('model'), { id: 'a-3' });
        assert.equal(_this3.controller.get('q'), 'hay');
        assert.equal(_this3.controller.get('z'), 0);
        assert.equal(_this3.$link1.attr('href'), urlPrefix + '/a-1');
        assert.equal(_this3.$link2.attr('href'), urlPrefix + '/a-2?q=lol');
        assert.equal(_this3.$link3.attr('href'), urlPrefix + '/a-3?q=hay');

        _this3.expectedModelHookParams = { id: 'a-2', q: 'lol', z: 1 };
        _this3.transitionTo(articleLookup, 'a-2', { queryParams: { z: 1 } });

        assert.deepEqual(_this3.controller.get('model'), { id: 'a-2' });
        assert.equal(_this3.controller.get('q'), 'lol');
        assert.equal(_this3.controller.get('z'), 1);
        assert.equal(_this3.$link1.attr('href'), urlPrefix + '/a-1');
        assert.equal(_this3.$link2.attr('href'), urlPrefix + '/a-2?q=lol&z=1');
        assert.equal(_this3.$link3.attr('href'), urlPrefix + '/a-3?q=hay');
      });
    };

    ModelDependentQPTestCase.prototype.queryParamsStickyTest4 = function queryParamsStickyTest4(urlPrefix, articleLookup) {
      var _this4 = this;

      var assert = this.assert;

      assert.expect(24);

      this.setupApplication();

      this.reopenController(articleLookup, {
        queryParams: { q: { scope: 'controller' } }
      });

      return this.visitApplication().then(function () {
        _emberMetal.run(_this4.$link1, 'click');
        _this4.assertCurrentPath(urlPrefix + '/a-1');

        _this4.setAndFlush(_this4.controller, 'q', 'lol');

        assert.equal(_this4.$link1.attr('href'), urlPrefix + '/a-1?q=lol');
        assert.equal(_this4.$link2.attr('href'), urlPrefix + '/a-2?q=lol');
        assert.equal(_this4.$link3.attr('href'), urlPrefix + '/a-3?q=lol');

        _emberMetal.run(_this4.$link2, 'click');

        assert.equal(_this4.controller.get('q'), 'lol');
        assert.equal(_this4.controller.get('z'), 0);
        assert.deepEqual(_this4.controller.get('model'), { id: 'a-2' });

        assert.equal(_this4.$link1.attr('href'), urlPrefix + '/a-1?q=lol');
        assert.equal(_this4.$link2.attr('href'), urlPrefix + '/a-2?q=lol');
        assert.equal(_this4.$link3.attr('href'), urlPrefix + '/a-3?q=lol');

        _this4.expectedModelHookParams = { id: 'a-3', q: 'haha', z: 123 };
        _this4.transitionTo(urlPrefix + '/a-3?q=haha&z=123');

        assert.deepEqual(_this4.controller.get('model'), { id: 'a-3' });
        assert.equal(_this4.controller.get('q'), 'haha');
        assert.equal(_this4.controller.get('z'), 123);

        assert.equal(_this4.$link1.attr('href'), urlPrefix + '/a-1?q=haha');
        assert.equal(_this4.$link2.attr('href'), urlPrefix + '/a-2?q=haha');
        assert.equal(_this4.$link3.attr('href'), urlPrefix + '/a-3?q=haha&z=123');

        _this4.setAndFlush(_this4.controller, 'q', 'woot');

        assert.equal(_this4.$link1.attr('href'), urlPrefix + '/a-1?q=woot');
        assert.equal(_this4.$link2.attr('href'), urlPrefix + '/a-2?q=woot');
        assert.equal(_this4.$link3.attr('href'), urlPrefix + '/a-3?q=woot&z=123');
      });
    };

    ModelDependentQPTestCase.prototype.queryParamsStickyTest5 = function queryParamsStickyTest5(urlPrefix, commentsLookupKey) {
      var _this5 = this;

      var assert = this.assert;

      assert.expect(12);

      return this.boot().then(function () {
        _this5.transitionTo(commentsLookupKey, 'a-1');

        var commentsCtrl = _this5.getController(commentsLookupKey);
        assert.equal(commentsCtrl.get('page'), 1);
        _this5.assertCurrentPath(urlPrefix + '/a-1/comments');

        _this5.setAndFlush(commentsCtrl, 'page', 2);
        _this5.assertCurrentPath(urlPrefix + '/a-1/comments?page=2');

        _this5.setAndFlush(commentsCtrl, 'page', 3);
        _this5.assertCurrentPath(urlPrefix + '/a-1/comments?page=3');

        _this5.transitionTo(commentsLookupKey, 'a-2');
        assert.equal(commentsCtrl.get('page'), 1);
        _this5.assertCurrentPath(urlPrefix + '/a-2/comments');

        _this5.transitionTo(commentsLookupKey, 'a-1');
        assert.equal(commentsCtrl.get('page'), 3);
        _this5.assertCurrentPath(urlPrefix + '/a-1/comments?page=3');
      });
    };

    ModelDependentQPTestCase.prototype.queryParamsStickyTest6 = function queryParamsStickyTest6(urlPrefix, articleLookup, commentsLookup) {
      var _this6 = this;

      var assert = this.assert;

      assert.expect(13);

      this.setupApplication();

      this.reopenRoute(articleLookup, {
        resetController: function (controller, isExiting) {
          this.controllerFor(commentsLookup).set('page', 1);
          if (isExiting) {
            controller.set('q', 'imdone');
          }
        }
      });

      this.registerTemplate('about', '{{link-to \'A\' \'' + commentsLookup + '\' \'a-1\' id=\'one\'}} {{link-to \'B\' \'' + commentsLookup + '\' \'a-2\' id=\'two\'}}');

      return this.visitApplication().then(function () {
        _this6.transitionTo(commentsLookup, 'a-1');

        var commentsCtrl = _this6.getController(commentsLookup);
        assert.equal(commentsCtrl.get('page'), 1);
        _this6.assertCurrentPath(urlPrefix + '/a-1/comments');

        _this6.setAndFlush(commentsCtrl, 'page', 2);
        _this6.assertCurrentPath(urlPrefix + '/a-1/comments?page=2');

        _this6.transitionTo(commentsLookup, 'a-2');
        assert.equal(commentsCtrl.get('page'), 1);
        assert.equal(_this6.controller.get('q'), 'wat');

        _this6.transitionTo(commentsLookup, 'a-1');

        _this6.assertCurrentPath(urlPrefix + '/a-1/comments');
        assert.equal(commentsCtrl.get('page'), 1);

        _this6.transitionTo('about');
        assert.equal(_emberViews.jQuery('#one').attr('href'), urlPrefix + '/a-1/comments?q=imdone');
        assert.equal(_emberViews.jQuery('#two').attr('href'), urlPrefix + '/a-2/comments');
      });
    };

    return ModelDependentQPTestCase;
  })(_internalTestHelpers.QueryParamTestCase);

  _internalTestHelpers.moduleFor('Query Params - model-dependent state', (function (_ModelDependentQPTestCase) {
    babelHelpers.inherits(_class, _ModelDependentQPTestCase);

    function _class() {
      _ModelDependentQPTestCase.apply(this, arguments);
    }

    _class.prototype.setupApplication = function setupApplication() {
      this.router.map(function () {
        this.route('article', { path: '/a/:id' }, function () {
          this.route('comments', { resetNamespace: true });
        });
        this.route('about');
      });

      var articles = _emberRuntime.A([{ id: 'a-1' }, { id: 'a-2' }, { id: 'a-3' }]);

      this.registerController('application', _emberRuntime.Controller.extend({
        articles: articles
      }));

      var self = this;
      var assert = this.assert;
      this.registerRoute('article', _emberRouting.Route.extend({
        model: function (params) {
          if (self.expectedModelHookParams) {
            assert.deepEqual(params, self.expectedModelHookParams, 'the ArticleRoute model hook received the expected merged dynamic segment + query params hash');
            self.expectedModelHookParams = null;
          }
          return articles.findBy('id', params.id);
        }
      }));

      this.registerController('article', _emberRuntime.Controller.extend({
        queryParams: ['q', 'z'],
        q: 'wat',
        z: 0
      }));

      this.registerController('comments', _emberRuntime.Controller.extend({
        queryParams: 'page',
        page: 1
      }));

      this.registerTemplate('application', '{{#each articles as |a|}} 1{{link-to \'Article\' \'article\' a id=a.id}} {{/each}} {{outlet}}');
    };

    _class.prototype.visitApplication = function visitApplication() {
      var _this7 = this;

      return this.visit('/').then(function () {
        var assert = _this7.assert;

        _this7.$link1 = _emberViews.jQuery('#a-1');
        _this7.$link2 = _emberViews.jQuery('#a-2');
        _this7.$link3 = _emberViews.jQuery('#a-3');

        assert.equal(_this7.$link1.attr('href'), '/a/a-1');
        assert.equal(_this7.$link2.attr('href'), '/a/a-2');
        assert.equal(_this7.$link3.attr('href'), '/a/a-3');

        _this7.controller = _this7.getController('article');
      });
    };

    _class.prototype['@test query params have \'model\' stickiness by default'] = function testQueryParamsHaveModelStickinessByDefault() {
      return this.queryParamsStickyTest1('/a');
    };

    _class.prototype['@test query params have \'model\' stickiness by default (url changes)'] = function testQueryParamsHaveModelStickinessByDefaultUrlChanges() {
      return this.queryParamsStickyTest2('/a');
    };

    _class.prototype['@test query params have \'model\' stickiness by default (params-based transitions)'] = function testQueryParamsHaveModelStickinessByDefaultParamsBasedTransitions() {
      return this.queryParamsStickyTest3('/a', 'article');
    };

    _class.prototype['@test \'controller\' stickiness shares QP state between models'] = function testControllerStickinessSharesQPStateBetweenModels() {
      return this.queryParamsStickyTest4('/a', 'article');
    };

    _class.prototype['@test \'model\' stickiness is scoped to current or first dynamic parent route'] = function testModelStickinessIsScopedToCurrentOrFirstDynamicParentRoute() {
      return this.queryParamsStickyTest5('/a', 'comments');
    };

    _class.prototype['@test can reset query params using the resetController hook'] = function testCanResetQueryParamsUsingTheResetControllerHook() {
      return this.queryParamsStickyTest6('/a', 'article', 'comments');
    };

    return _class;
  })(ModelDependentQPTestCase));

  _internalTestHelpers.moduleFor('Query Params - model-dependent state (nested)', (function (_ModelDependentQPTestCase2) {
    babelHelpers.inherits(_class2, _ModelDependentQPTestCase2);

    function _class2() {
      _ModelDependentQPTestCase2.apply(this, arguments);
    }

    _class2.prototype.setupApplication = function setupApplication() {
      this.router.map(function () {
        this.route('site', function () {
          this.route('article', { path: '/a/:id' }, function () {
            this.route('comments');
          });
        });
        this.route('about');
      });

      var site_articles = _emberRuntime.A([{ id: 'a-1' }, { id: 'a-2' }, { id: 'a-3' }]);

      this.registerController('application', _emberRuntime.Controller.extend({
        articles: site_articles
      }));

      var self = this;
      var assert = this.assert;
      this.registerRoute('site.article', _emberRouting.Route.extend({
        model: function (params) {
          if (self.expectedModelHookParams) {
            assert.deepEqual(params, self.expectedModelHookParams, 'the ArticleRoute model hook received the expected merged dynamic segment + query params hash');
            self.expectedModelHookParams = null;
          }
          return site_articles.findBy('id', params.id);
        }
      }));

      this.registerController('site.article', _emberRuntime.Controller.extend({
        queryParams: ['q', 'z'],
        q: 'wat',
        z: 0
      }));

      this.registerController('site.article.comments', _emberRuntime.Controller.extend({
        queryParams: 'page',
        page: 1
      }));

      this.registerTemplate('application', '{{#each articles as |a|}} {{link-to \'Article\' \'site.article\' a id=a.id}} {{/each}} {{outlet}}');
    };

    _class2.prototype.visitApplication = function visitApplication() {
      var _this8 = this;

      return this.visit('/').then(function () {
        var assert = _this8.assert;

        _this8.$link1 = _emberViews.jQuery('#a-1');
        _this8.$link2 = _emberViews.jQuery('#a-2');
        _this8.$link3 = _emberViews.jQuery('#a-3');

        assert.equal(_this8.$link1.attr('href'), '/site/a/a-1');
        assert.equal(_this8.$link2.attr('href'), '/site/a/a-2');
        assert.equal(_this8.$link3.attr('href'), '/site/a/a-3');

        _this8.controller = _this8.getController('site.article');
      });
    };

    _class2.prototype['@test query params have \'model\' stickiness by default'] = function testQueryParamsHaveModelStickinessByDefault() {
      return this.queryParamsStickyTest1('/site/a');
    };

    _class2.prototype['@test query params have \'model\' stickiness by default (url changes)'] = function testQueryParamsHaveModelStickinessByDefaultUrlChanges() {
      return this.queryParamsStickyTest2('/site/a');
    };

    _class2.prototype['@test query params have \'model\' stickiness by default (params-based transitions)'] = function testQueryParamsHaveModelStickinessByDefaultParamsBasedTransitions() {
      return this.queryParamsStickyTest3('/site/a', 'site.article');
    };

    _class2.prototype['@test \'controller\' stickiness shares QP state between models'] = function testControllerStickinessSharesQPStateBetweenModels() {
      return this.queryParamsStickyTest4('/site/a', 'site.article');
    };

    _class2.prototype['@test \'model\' stickiness is scoped to current or first dynamic parent route'] = function testModelStickinessIsScopedToCurrentOrFirstDynamicParentRoute() {
      return this.queryParamsStickyTest5('/site/a', 'site.article.comments');
    };

    _class2.prototype['@test can reset query params using the resetController hook'] = function testCanResetQueryParamsUsingTheResetControllerHook() {
      return this.queryParamsStickyTest6('/site/a', 'site.article', 'site.article.comments');
    };

    return _class2;
  })(ModelDependentQPTestCase));

  _internalTestHelpers.moduleFor('Query Params - model-dependent state (nested & more than 1 dynamic segment)', (function (_ModelDependentQPTestCase3) {
    babelHelpers.inherits(_class3, _ModelDependentQPTestCase3);

    function _class3() {
      _ModelDependentQPTestCase3.apply(this, arguments);
    }

    _class3.prototype.setupApplication = function setupApplication() {
      this.router.map(function () {
        this.route('site', { path: '/site/:site_id' }, function () {
          this.route('article', { path: '/a/:article_id' }, function () {
            this.route('comments');
          });
        });
      });

      var sites = _emberRuntime.A([{ id: 's-1' }, { id: 's-2' }, { id: 's-3' }]);
      var site_articles = _emberRuntime.A([{ id: 'a-1' }, { id: 'a-2' }, { id: 'a-3' }]);

      this.registerController('application', _emberRuntime.Controller.extend({
        siteArticles: site_articles,
        sites: sites,
        allSitesAllArticles: _emberMetal.computed({
          get: function () {
            var ret = [];
            var siteArticles = this.siteArticles;
            var sites = this.sites;
            sites.forEach(function (site) {
              ret = ret.concat(siteArticles.map(function (article) {
                return { id: site.id + '-' + article.id, site_id: site.id, article_id: article.id };
              }));
            });
            return ret;
          }
        })
      }));

      var self = this;
      var assert = this.assert;
      this.registerRoute('site', _emberRouting.Route.extend({
        model: function (params) {
          if (self.expectedSiteModelHookParams) {
            assert.deepEqual(params, self.expectedSiteModelHookParams, 'the SiteRoute model hook received the expected merged dynamic segment + query params hash');
            self.expectedSiteModelHookParams = null;
          }
          return sites.findBy('id', params.site_id);
        }
      }));

      this.registerRoute('site.article', _emberRouting.Route.extend({
        model: function (params) {
          if (self.expectedArticleModelHookParams) {
            assert.deepEqual(params, self.expectedArticleModelHookParams, 'the SiteArticleRoute model hook received the expected merged dynamic segment + query params hash');
            self.expectedArticleModelHookParams = null;
          }
          return site_articles.findBy('id', params.article_id);
        }
      }));

      this.registerController('site', _emberRuntime.Controller.extend({
        queryParams: ['country'],
        country: 'au'
      }));

      this.registerController('site.article', _emberRuntime.Controller.extend({
        queryParams: ['q', 'z'],
        q: 'wat',
        z: 0
      }));

      this.registerController('site.article.comments', _emberRuntime.Controller.extend({
        queryParams: ['page'],
        page: 1
      }));

      this.registerTemplate('application', '{{#each allSitesAllArticles as |a|}} {{#link-to \'site.article\' a.site_id a.article_id id=a.id}}Article [{{a.site_id}}] [{{a.article_id}}]{{/link-to}} {{/each}} {{outlet}}');
    };

    _class3.prototype.visitApplication = function visitApplication() {
      var _this9 = this;

      return this.visit('/').then(function () {
        var assert = _this9.assert;

        _this9.links = {};
        _this9.links['s-1-a-1'] = _emberViews.jQuery('#s-1-a-1');
        _this9.links['s-1-a-2'] = _emberViews.jQuery('#s-1-a-2');
        _this9.links['s-1-a-3'] = _emberViews.jQuery('#s-1-a-3');
        _this9.links['s-2-a-1'] = _emberViews.jQuery('#s-2-a-1');
        _this9.links['s-2-a-2'] = _emberViews.jQuery('#s-2-a-2');
        _this9.links['s-2-a-3'] = _emberViews.jQuery('#s-2-a-3');
        _this9.links['s-3-a-1'] = _emberViews.jQuery('#s-3-a-1');
        _this9.links['s-3-a-2'] = _emberViews.jQuery('#s-3-a-2');
        _this9.links['s-3-a-3'] = _emberViews.jQuery('#s-3-a-3');

        assert.equal(_this9.links['s-1-a-1'].attr('href'), '/site/s-1/a/a-1');
        assert.equal(_this9.links['s-1-a-2'].attr('href'), '/site/s-1/a/a-2');
        assert.equal(_this9.links['s-1-a-3'].attr('href'), '/site/s-1/a/a-3');
        assert.equal(_this9.links['s-2-a-1'].attr('href'), '/site/s-2/a/a-1');
        assert.equal(_this9.links['s-2-a-2'].attr('href'), '/site/s-2/a/a-2');
        assert.equal(_this9.links['s-2-a-3'].attr('href'), '/site/s-2/a/a-3');
        assert.equal(_this9.links['s-3-a-1'].attr('href'), '/site/s-3/a/a-1');
        assert.equal(_this9.links['s-3-a-2'].attr('href'), '/site/s-3/a/a-2');
        assert.equal(_this9.links['s-3-a-3'].attr('href'), '/site/s-3/a/a-3');

        _this9.site_controller = _this9.getController('site');
        _this9.article_controller = _this9.getController('site.article');
      });
    };

    _class3.prototype['@test query params have \'model\' stickiness by default'] = function testQueryParamsHaveModelStickinessByDefault(assert) {
      var _this10 = this;

      assert.expect(59); // Insane.

      return this.boot().then(function () {
        _emberMetal.run(_this10.links['s-1-a-1'], 'click');
        assert.deepEqual(_this10.site_controller.get('model'), { id: 's-1' });
        assert.deepEqual(_this10.article_controller.get('model'), { id: 'a-1' });
        _this10.assertCurrentPath('/site/s-1/a/a-1');

        _this10.setAndFlush(_this10.article_controller, 'q', 'lol');

        assert.equal(_this10.links['s-1-a-1'].attr('href'), '/site/s-1/a/a-1?q=lol');
        assert.equal(_this10.links['s-1-a-2'].attr('href'), '/site/s-1/a/a-2');
        assert.equal(_this10.links['s-1-a-3'].attr('href'), '/site/s-1/a/a-3');
        assert.equal(_this10.links['s-2-a-1'].attr('href'), '/site/s-2/a/a-1?q=lol');
        assert.equal(_this10.links['s-2-a-2'].attr('href'), '/site/s-2/a/a-2');
        assert.equal(_this10.links['s-2-a-3'].attr('href'), '/site/s-2/a/a-3');
        assert.equal(_this10.links['s-3-a-1'].attr('href'), '/site/s-3/a/a-1?q=lol');
        assert.equal(_this10.links['s-3-a-2'].attr('href'), '/site/s-3/a/a-2');
        assert.equal(_this10.links['s-3-a-3'].attr('href'), '/site/s-3/a/a-3');

        _this10.setAndFlush(_this10.site_controller, 'country', 'us');

        assert.equal(_this10.links['s-1-a-1'].attr('href'), '/site/s-1/a/a-1?country=us&q=lol');
        assert.equal(_this10.links['s-1-a-2'].attr('href'), '/site/s-1/a/a-2?country=us');
        assert.equal(_this10.links['s-1-a-3'].attr('href'), '/site/s-1/a/a-3?country=us');
        assert.equal(_this10.links['s-2-a-1'].attr('href'), '/site/s-2/a/a-1?q=lol');
        assert.equal(_this10.links['s-2-a-2'].attr('href'), '/site/s-2/a/a-2');
        assert.equal(_this10.links['s-2-a-3'].attr('href'), '/site/s-2/a/a-3');
        assert.equal(_this10.links['s-3-a-1'].attr('href'), '/site/s-3/a/a-1?q=lol');
        assert.equal(_this10.links['s-3-a-2'].attr('href'), '/site/s-3/a/a-2');
        assert.equal(_this10.links['s-3-a-3'].attr('href'), '/site/s-3/a/a-3');

        _emberMetal.run(_this10.links['s-1-a-2'], 'click');

        assert.equal(_this10.site_controller.get('country'), 'us');
        assert.equal(_this10.article_controller.get('q'), 'wat');
        assert.equal(_this10.article_controller.get('z'), 0);
        assert.deepEqual(_this10.site_controller.get('model'), { id: 's-1' });
        assert.deepEqual(_this10.article_controller.get('model'), { id: 'a-2' });
        assert.equal(_this10.links['s-1-a-1'].attr('href'), '/site/s-1/a/a-1?country=us&q=lol');
        assert.equal(_this10.links['s-1-a-2'].attr('href'), '/site/s-1/a/a-2?country=us');
        assert.equal(_this10.links['s-1-a-3'].attr('href'), '/site/s-1/a/a-3?country=us');
        assert.equal(_this10.links['s-2-a-1'].attr('href'), '/site/s-2/a/a-1?q=lol');
        assert.equal(_this10.links['s-2-a-2'].attr('href'), '/site/s-2/a/a-2');
        assert.equal(_this10.links['s-2-a-3'].attr('href'), '/site/s-2/a/a-3');
        assert.equal(_this10.links['s-3-a-1'].attr('href'), '/site/s-3/a/a-1?q=lol');
        assert.equal(_this10.links['s-3-a-2'].attr('href'), '/site/s-3/a/a-2');
        assert.equal(_this10.links['s-3-a-3'].attr('href'), '/site/s-3/a/a-3');

        _emberMetal.run(_this10.links['s-2-a-2'], 'click');

        assert.equal(_this10.site_controller.get('country'), 'au');
        assert.equal(_this10.article_controller.get('q'), 'wat');
        assert.equal(_this10.article_controller.get('z'), 0);
        assert.deepEqual(_this10.site_controller.get('model'), { id: 's-2' });
        assert.deepEqual(_this10.article_controller.get('model'), { id: 'a-2' });
        assert.equal(_this10.links['s-1-a-1'].attr('href'), '/site/s-1/a/a-1?country=us&q=lol');
        assert.equal(_this10.links['s-1-a-2'].attr('href'), '/site/s-1/a/a-2?country=us');
        assert.equal(_this10.links['s-1-a-3'].attr('href'), '/site/s-1/a/a-3?country=us');
        assert.equal(_this10.links['s-2-a-1'].attr('href'), '/site/s-2/a/a-1?q=lol');
        assert.equal(_this10.links['s-2-a-2'].attr('href'), '/site/s-2/a/a-2');
        assert.equal(_this10.links['s-2-a-3'].attr('href'), '/site/s-2/a/a-3');
        assert.equal(_this10.links['s-3-a-1'].attr('href'), '/site/s-3/a/a-1?q=lol');
        assert.equal(_this10.links['s-3-a-2'].attr('href'), '/site/s-3/a/a-2');
        assert.equal(_this10.links['s-3-a-3'].attr('href'), '/site/s-3/a/a-3');
      });
    };

    _class3.prototype['@test query params have \'model\' stickiness by default (url changes)'] = function testQueryParamsHaveModelStickinessByDefaultUrlChanges(assert) {
      var _this11 = this;

      assert.expect(88); // INSANE.

      return this.boot().then(function () {
        _this11.expectedSiteModelHookParams = { site_id: 's-1', country: 'au' };
        _this11.expectedArticleModelHookParams = { article_id: 'a-1', q: 'lol', z: 0 };
        _this11.transitionTo('/site/s-1/a/a-1?q=lol');

        assert.deepEqual(_this11.site_controller.get('model'), { id: 's-1' }, 'site controller\'s model is s-1');
        assert.deepEqual(_this11.article_controller.get('model'), { id: 'a-1' }, 'article controller\'s model is a-1');
        assert.equal(_this11.site_controller.get('country'), 'au');
        assert.equal(_this11.article_controller.get('q'), 'lol');
        assert.equal(_this11.article_controller.get('z'), 0);
        assert.equal(_this11.links['s-1-a-1'].attr('href'), '/site/s-1/a/a-1?q=lol');
        assert.equal(_this11.links['s-1-a-2'].attr('href'), '/site/s-1/a/a-2');
        assert.equal(_this11.links['s-1-a-3'].attr('href'), '/site/s-1/a/a-3');
        assert.equal(_this11.links['s-2-a-1'].attr('href'), '/site/s-2/a/a-1?q=lol');
        assert.equal(_this11.links['s-2-a-2'].attr('href'), '/site/s-2/a/a-2');
        assert.equal(_this11.links['s-2-a-3'].attr('href'), '/site/s-2/a/a-3');
        assert.equal(_this11.links['s-3-a-1'].attr('href'), '/site/s-3/a/a-1?q=lol');
        assert.equal(_this11.links['s-3-a-2'].attr('href'), '/site/s-3/a/a-2');
        assert.equal(_this11.links['s-3-a-3'].attr('href'), '/site/s-3/a/a-3');

        _this11.expectedSiteModelHookParams = { site_id: 's-2', country: 'us' };
        _this11.expectedArticleModelHookParams = { article_id: 'a-1', q: 'lol', z: 0 };
        _this11.transitionTo('/site/s-2/a/a-1?country=us&q=lol');

        assert.deepEqual(_this11.site_controller.get('model'), { id: 's-2' }, 'site controller\'s model is s-2');
        assert.deepEqual(_this11.article_controller.get('model'), { id: 'a-1' }, 'article controller\'s model is a-1');
        assert.equal(_this11.site_controller.get('country'), 'us');
        assert.equal(_this11.article_controller.get('q'), 'lol');
        assert.equal(_this11.article_controller.get('z'), 0);
        assert.equal(_this11.links['s-1-a-1'].attr('href'), '/site/s-1/a/a-1?q=lol');
        assert.equal(_this11.links['s-1-a-2'].attr('href'), '/site/s-1/a/a-2');
        assert.equal(_this11.links['s-1-a-3'].attr('href'), '/site/s-1/a/a-3');
        assert.equal(_this11.links['s-2-a-1'].attr('href'), '/site/s-2/a/a-1?country=us&q=lol');
        assert.equal(_this11.links['s-2-a-2'].attr('href'), '/site/s-2/a/a-2?country=us');
        assert.equal(_this11.links['s-2-a-3'].attr('href'), '/site/s-2/a/a-3?country=us');
        assert.equal(_this11.links['s-3-a-1'].attr('href'), '/site/s-3/a/a-1?q=lol');
        assert.equal(_this11.links['s-3-a-2'].attr('href'), '/site/s-3/a/a-2');
        assert.equal(_this11.links['s-3-a-3'].attr('href'), '/site/s-3/a/a-3');

        _this11.expectedSiteModelHookParams = { site_id: 's-2', country: 'us' };
        _this11.expectedArticleModelHookParams = { article_id: 'a-2', q: 'lol', z: 0 };
        _this11.transitionTo('/site/s-2/a/a-2?country=us&q=lol');

        assert.deepEqual(_this11.site_controller.get('model'), { id: 's-2' }, 'site controller\'s model is s-2');
        assert.deepEqual(_this11.article_controller.get('model'), { id: 'a-2' }, 'article controller\'s model is a-2');
        assert.equal(_this11.site_controller.get('country'), 'us');
        assert.equal(_this11.article_controller.get('q'), 'lol');
        assert.equal(_this11.article_controller.get('z'), 0);
        assert.equal(_this11.links['s-1-a-1'].attr('href'), '/site/s-1/a/a-1?q=lol');
        assert.equal(_this11.links['s-1-a-2'].attr('href'), '/site/s-1/a/a-2?q=lol');
        assert.equal(_this11.links['s-1-a-3'].attr('href'), '/site/s-1/a/a-3');
        assert.equal(_this11.links['s-2-a-1'].attr('href'), '/site/s-2/a/a-1?country=us&q=lol');
        assert.equal(_this11.links['s-2-a-2'].attr('href'), '/site/s-2/a/a-2?country=us&q=lol');
        assert.equal(_this11.links['s-2-a-3'].attr('href'), '/site/s-2/a/a-3?country=us');
        assert.equal(_this11.links['s-3-a-1'].attr('href'), '/site/s-3/a/a-1?q=lol');
        assert.equal(_this11.links['s-3-a-2'].attr('href'), '/site/s-3/a/a-2?q=lol');
        assert.equal(_this11.links['s-3-a-3'].attr('href'), '/site/s-3/a/a-3');

        _this11.expectedSiteModelHookParams = { site_id: 's-2', country: 'us' };
        _this11.expectedArticleModelHookParams = { article_id: 'a-3', q: 'lol', z: 123 };
        _this11.transitionTo('/site/s-2/a/a-3?country=us&q=lol&z=123');

        assert.deepEqual(_this11.site_controller.get('model'), { id: 's-2' }, 'site controller\'s model is s-2');
        assert.deepEqual(_this11.article_controller.get('model'), { id: 'a-3' }, 'article controller\'s model is a-3');
        assert.equal(_this11.site_controller.get('country'), 'us');
        assert.equal(_this11.article_controller.get('q'), 'lol');
        assert.equal(_this11.article_controller.get('z'), 123);
        assert.equal(_this11.links['s-1-a-1'].attr('href'), '/site/s-1/a/a-1?q=lol');
        assert.equal(_this11.links['s-1-a-2'].attr('href'), '/site/s-1/a/a-2?q=lol');
        assert.equal(_this11.links['s-1-a-3'].attr('href'), '/site/s-1/a/a-3?q=lol&z=123');
        assert.equal(_this11.links['s-2-a-1'].attr('href'), '/site/s-2/a/a-1?country=us&q=lol');
        assert.equal(_this11.links['s-2-a-2'].attr('href'), '/site/s-2/a/a-2?country=us&q=lol');
        assert.equal(_this11.links['s-2-a-3'].attr('href'), '/site/s-2/a/a-3?country=us&q=lol&z=123');
        assert.equal(_this11.links['s-3-a-1'].attr('href'), '/site/s-3/a/a-1?q=lol');
        assert.equal(_this11.links['s-3-a-2'].attr('href'), '/site/s-3/a/a-2?q=lol');
        assert.equal(_this11.links['s-3-a-3'].attr('href'), '/site/s-3/a/a-3?q=lol&z=123');

        _this11.expectedSiteModelHookParams = { site_id: 's-3', country: 'nz' };
        _this11.expectedArticleModelHookParams = { article_id: 'a-3', q: 'lol', z: 123 };
        _this11.transitionTo('/site/s-3/a/a-3?country=nz&q=lol&z=123');

        assert.deepEqual(_this11.site_controller.get('model'), { id: 's-3' }, 'site controller\'s model is s-3');
        assert.deepEqual(_this11.article_controller.get('model'), { id: 'a-3' }, 'article controller\'s model is a-3');
        assert.equal(_this11.site_controller.get('country'), 'nz');
        assert.equal(_this11.article_controller.get('q'), 'lol');
        assert.equal(_this11.article_controller.get('z'), 123);
        assert.equal(_this11.links['s-1-a-1'].attr('href'), '/site/s-1/a/a-1?q=lol');
        assert.equal(_this11.links['s-1-a-2'].attr('href'), '/site/s-1/a/a-2?q=lol');
        assert.equal(_this11.links['s-1-a-3'].attr('href'), '/site/s-1/a/a-3?q=lol&z=123');
        assert.equal(_this11.links['s-2-a-1'].attr('href'), '/site/s-2/a/a-1?country=us&q=lol');
        assert.equal(_this11.links['s-2-a-2'].attr('href'), '/site/s-2/a/a-2?country=us&q=lol');
        assert.equal(_this11.links['s-2-a-3'].attr('href'), '/site/s-2/a/a-3?country=us&q=lol&z=123');
        assert.equal(_this11.links['s-3-a-1'].attr('href'), '/site/s-3/a/a-1?country=nz&q=lol');
        assert.equal(_this11.links['s-3-a-2'].attr('href'), '/site/s-3/a/a-2?country=nz&q=lol');
        assert.equal(_this11.links['s-3-a-3'].attr('href'), '/site/s-3/a/a-3?country=nz&q=lol&z=123');
      });
    };

    _class3.prototype['@test query params have \'model\' stickiness by default (params-based transitions)'] = function testQueryParamsHaveModelStickinessByDefaultParamsBasedTransitions(assert) {
      var _this12 = this;

      assert.expect(118); // <-- INSANE! Like why is this even a thing?

      return this.boot().then(function () {
        _this12.expectedSiteModelHookParams = { site_id: 's-1', country: 'au' };
        _this12.expectedArticleModelHookParams = { article_id: 'a-1', q: 'wat', z: 0 };
        _this12.transitionTo('site.article', 's-1', 'a-1');

        assert.deepEqual(_this12.site_controller.get('model'), { id: 's-1' });
        assert.deepEqual(_this12.article_controller.get('model'), { id: 'a-1' });
        assert.equal(_this12.site_controller.get('country'), 'au');
        assert.equal(_this12.article_controller.get('q'), 'wat');
        assert.equal(_this12.article_controller.get('z'), 0);
        assert.equal(_this12.links['s-1-a-1'].attr('href'), '/site/s-1/a/a-1');
        assert.equal(_this12.links['s-1-a-2'].attr('href'), '/site/s-1/a/a-2');
        assert.equal(_this12.links['s-1-a-3'].attr('href'), '/site/s-1/a/a-3');
        assert.equal(_this12.links['s-2-a-1'].attr('href'), '/site/s-2/a/a-1');
        assert.equal(_this12.links['s-2-a-2'].attr('href'), '/site/s-2/a/a-2');
        assert.equal(_this12.links['s-2-a-3'].attr('href'), '/site/s-2/a/a-3');
        assert.equal(_this12.links['s-3-a-1'].attr('href'), '/site/s-3/a/a-1');
        assert.equal(_this12.links['s-3-a-2'].attr('href'), '/site/s-3/a/a-2');
        assert.equal(_this12.links['s-3-a-3'].attr('href'), '/site/s-3/a/a-3');

        _this12.expectedSiteModelHookParams = { site_id: 's-1', country: 'au' };
        _this12.expectedArticleModelHookParams = { article_id: 'a-2', q: 'lol', z: 0 };
        _this12.transitionTo('site.article', 's-1', 'a-2', { queryParams: { q: 'lol' } });

        assert.deepEqual(_this12.site_controller.get('model'), { id: 's-1' });
        assert.deepEqual(_this12.article_controller.get('model'), { id: 'a-2' });
        assert.equal(_this12.site_controller.get('country'), 'au');
        assert.equal(_this12.article_controller.get('q'), 'lol');
        assert.equal(_this12.article_controller.get('z'), 0);
        assert.equal(_this12.links['s-1-a-1'].attr('href'), '/site/s-1/a/a-1');
        assert.equal(_this12.links['s-1-a-2'].attr('href'), '/site/s-1/a/a-2?q=lol');
        assert.equal(_this12.links['s-1-a-3'].attr('href'), '/site/s-1/a/a-3');
        assert.equal(_this12.links['s-2-a-1'].attr('href'), '/site/s-2/a/a-1');
        assert.equal(_this12.links['s-2-a-2'].attr('href'), '/site/s-2/a/a-2?q=lol');
        assert.equal(_this12.links['s-2-a-3'].attr('href'), '/site/s-2/a/a-3');
        assert.equal(_this12.links['s-3-a-1'].attr('href'), '/site/s-3/a/a-1');
        assert.equal(_this12.links['s-3-a-2'].attr('href'), '/site/s-3/a/a-2?q=lol');
        assert.equal(_this12.links['s-3-a-3'].attr('href'), '/site/s-3/a/a-3');

        _this12.expectedSiteModelHookParams = { site_id: 's-1', country: 'au' };
        _this12.expectedArticleModelHookParams = { article_id: 'a-3', q: 'hay', z: 0 };
        _this12.transitionTo('site.article', 's-1', 'a-3', { queryParams: { q: 'hay' } });

        assert.deepEqual(_this12.site_controller.get('model'), { id: 's-1' });
        assert.deepEqual(_this12.article_controller.get('model'), { id: 'a-3' });
        assert.equal(_this12.site_controller.get('country'), 'au');
        assert.equal(_this12.article_controller.get('q'), 'hay');
        assert.equal(_this12.article_controller.get('z'), 0);
        assert.equal(_this12.links['s-1-a-1'].attr('href'), '/site/s-1/a/a-1');
        assert.equal(_this12.links['s-1-a-2'].attr('href'), '/site/s-1/a/a-2?q=lol');
        assert.equal(_this12.links['s-1-a-3'].attr('href'), '/site/s-1/a/a-3?q=hay');
        assert.equal(_this12.links['s-2-a-1'].attr('href'), '/site/s-2/a/a-1');
        assert.equal(_this12.links['s-2-a-2'].attr('href'), '/site/s-2/a/a-2?q=lol');
        assert.equal(_this12.links['s-2-a-3'].attr('href'), '/site/s-2/a/a-3?q=hay');
        assert.equal(_this12.links['s-3-a-1'].attr('href'), '/site/s-3/a/a-1');
        assert.equal(_this12.links['s-3-a-2'].attr('href'), '/site/s-3/a/a-2?q=lol');
        assert.equal(_this12.links['s-3-a-3'].attr('href'), '/site/s-3/a/a-3?q=hay');

        _this12.expectedSiteModelHookParams = { site_id: 's-1', country: 'au' };
        _this12.expectedArticleModelHookParams = { article_id: 'a-2', q: 'lol', z: 1 };
        _this12.transitionTo('site.article', 's-1', 'a-2', { queryParams: { z: 1 } });

        assert.deepEqual(_this12.site_controller.get('model'), { id: 's-1' });
        assert.deepEqual(_this12.article_controller.get('model'), { id: 'a-2' });
        assert.equal(_this12.site_controller.get('country'), 'au');
        assert.equal(_this12.article_controller.get('q'), 'lol');
        assert.equal(_this12.article_controller.get('z'), 1);
        assert.equal(_this12.links['s-1-a-1'].attr('href'), '/site/s-1/a/a-1');
        assert.equal(_this12.links['s-1-a-2'].attr('href'), '/site/s-1/a/a-2?q=lol&z=1');
        assert.equal(_this12.links['s-1-a-3'].attr('href'), '/site/s-1/a/a-3?q=hay');
        assert.equal(_this12.links['s-2-a-1'].attr('href'), '/site/s-2/a/a-1');
        assert.equal(_this12.links['s-2-a-2'].attr('href'), '/site/s-2/a/a-2?q=lol&z=1');
        assert.equal(_this12.links['s-2-a-3'].attr('href'), '/site/s-2/a/a-3?q=hay');
        assert.equal(_this12.links['s-3-a-1'].attr('href'), '/site/s-3/a/a-1');
        assert.equal(_this12.links['s-3-a-2'].attr('href'), '/site/s-3/a/a-2?q=lol&z=1');
        assert.equal(_this12.links['s-3-a-3'].attr('href'), '/site/s-3/a/a-3?q=hay');

        _this12.expectedSiteModelHookParams = { site_id: 's-2', country: 'us' };
        _this12.expectedArticleModelHookParams = { article_id: 'a-2', q: 'lol', z: 1 };
        _this12.transitionTo('site.article', 's-2', 'a-2', { queryParams: { country: 'us' } });

        assert.deepEqual(_this12.site_controller.get('model'), { id: 's-2' });
        assert.deepEqual(_this12.article_controller.get('model'), { id: 'a-2' });
        assert.equal(_this12.site_controller.get('country'), 'us');
        assert.equal(_this12.article_controller.get('q'), 'lol');
        assert.equal(_this12.article_controller.get('z'), 1);
        assert.equal(_this12.links['s-1-a-1'].attr('href'), '/site/s-1/a/a-1');
        assert.equal(_this12.links['s-1-a-2'].attr('href'), '/site/s-1/a/a-2?q=lol&z=1');
        assert.equal(_this12.links['s-1-a-3'].attr('href'), '/site/s-1/a/a-3?q=hay');
        assert.equal(_this12.links['s-2-a-1'].attr('href'), '/site/s-2/a/a-1?country=us');
        assert.equal(_this12.links['s-2-a-2'].attr('href'), '/site/s-2/a/a-2?country=us&q=lol&z=1');
        assert.equal(_this12.links['s-2-a-3'].attr('href'), '/site/s-2/a/a-3?country=us&q=hay');
        assert.equal(_this12.links['s-3-a-1'].attr('href'), '/site/s-3/a/a-1');
        assert.equal(_this12.links['s-3-a-2'].attr('href'), '/site/s-3/a/a-2?q=lol&z=1');
        assert.equal(_this12.links['s-3-a-3'].attr('href'), '/site/s-3/a/a-3?q=hay');

        _this12.expectedSiteModelHookParams = { site_id: 's-2', country: 'us' };
        _this12.expectedArticleModelHookParams = { article_id: 'a-1', q: 'yeah', z: 0 };
        _this12.transitionTo('site.article', 's-2', 'a-1', { queryParams: { q: 'yeah' } });

        assert.deepEqual(_this12.site_controller.get('model'), { id: 's-2' });
        assert.deepEqual(_this12.article_controller.get('model'), { id: 'a-1' });
        assert.equal(_this12.site_controller.get('country'), 'us');
        assert.equal(_this12.article_controller.get('q'), 'yeah');
        assert.equal(_this12.article_controller.get('z'), 0);
        assert.equal(_this12.links['s-1-a-1'].attr('href'), '/site/s-1/a/a-1?q=yeah');
        assert.equal(_this12.links['s-1-a-2'].attr('href'), '/site/s-1/a/a-2?q=lol&z=1');
        assert.equal(_this12.links['s-1-a-3'].attr('href'), '/site/s-1/a/a-3?q=hay');
        assert.equal(_this12.links['s-2-a-1'].attr('href'), '/site/s-2/a/a-1?country=us&q=yeah');
        assert.equal(_this12.links['s-2-a-2'].attr('href'), '/site/s-2/a/a-2?country=us&q=lol&z=1');
        assert.equal(_this12.links['s-2-a-3'].attr('href'), '/site/s-2/a/a-3?country=us&q=hay');
        assert.equal(_this12.links['s-3-a-1'].attr('href'), '/site/s-3/a/a-1?q=yeah');
        assert.equal(_this12.links['s-3-a-2'].attr('href'), '/site/s-3/a/a-2?q=lol&z=1');
        assert.equal(_this12.links['s-3-a-3'].attr('href'), '/site/s-3/a/a-3?q=hay');

        _this12.expectedSiteModelHookParams = { site_id: 's-3', country: 'nz' };
        _this12.expectedArticleModelHookParams = { article_id: 'a-3', q: 'hay', z: 3 };
        _this12.transitionTo('site.article', 's-3', 'a-3', { queryParams: { country: 'nz', z: 3 } });

        assert.deepEqual(_this12.site_controller.get('model'), { id: 's-3' });
        assert.deepEqual(_this12.article_controller.get('model'), { id: 'a-3' });
        assert.equal(_this12.site_controller.get('country'), 'nz');
        assert.equal(_this12.article_controller.get('q'), 'hay');
        assert.equal(_this12.article_controller.get('z'), 3);
        assert.equal(_this12.links['s-1-a-1'].attr('href'), '/site/s-1/a/a-1?q=yeah');
        assert.equal(_this12.links['s-1-a-2'].attr('href'), '/site/s-1/a/a-2?q=lol&z=1');
        assert.equal(_this12.links['s-1-a-3'].attr('href'), '/site/s-1/a/a-3?q=hay&z=3');
        assert.equal(_this12.links['s-2-a-1'].attr('href'), '/site/s-2/a/a-1?country=us&q=yeah');
        assert.equal(_this12.links['s-2-a-2'].attr('href'), '/site/s-2/a/a-2?country=us&q=lol&z=1');
        assert.equal(_this12.links['s-2-a-3'].attr('href'), '/site/s-2/a/a-3?country=us&q=hay&z=3');
        assert.equal(_this12.links['s-3-a-1'].attr('href'), '/site/s-3/a/a-1?country=nz&q=yeah');
        assert.equal(_this12.links['s-3-a-2'].attr('href'), '/site/s-3/a/a-2?country=nz&q=lol&z=1');
        assert.equal(_this12.links['s-3-a-3'].attr('href'), '/site/s-3/a/a-3?country=nz&q=hay&z=3');
      });
    };

    return _class3;
  })(ModelDependentQPTestCase));
});
enifed('ember/tests/routing/query_params_test/model_dependent_state_with_query_params_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/routing/query_params_test/model_dependent_state_with_query_params_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/routing/query_params_test/model_dependent_state_with_query_params_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/routing/query_params_test/overlapping_query_params_test', ['exports', 'ember-runtime', 'ember-routing', 'ember-metal', 'internal-test-helpers'], function (exports, _emberRuntime, _emberRouting, _emberMetal, _internalTestHelpers) {
  'use strict';

  _internalTestHelpers.moduleFor('Query Params - overlapping query param property names', (function (_QueryParamTestCase) {
    babelHelpers.inherits(_class, _QueryParamTestCase);

    function _class() {
      _QueryParamTestCase.apply(this, arguments);
    }

    _class.prototype.setupBase = function setupBase() {
      this.router.map(function () {
        this.route('parent', function () {
          this.route('child');
        });
      });

      return this.visit('/parent/child');
    };

    _class.prototype['@test can remap same-named qp props'] = function testCanRemapSameNamedQpProps(assert) {
      var _this = this;

      assert.expect(7);

      this.setMappedQPController('parent');
      this.setMappedQPController('parent.child', 'page', 'childPage');

      return this.setupBase().then(function () {
        _this.assertCurrentPath('/parent/child');

        var parentController = _this.getController('parent');
        var parentChildController = _this.getController('parent.child');

        _this.setAndFlush(parentController, 'page', 2);
        _this.assertCurrentPath('/parent/child?parentPage=2');
        _this.setAndFlush(parentController, 'page', 1);
        _this.assertCurrentPath('/parent/child');

        _this.setAndFlush(parentChildController, 'page', 2);
        _this.assertCurrentPath('/parent/child?childPage=2');
        _this.setAndFlush(parentChildController, 'page', 1);
        _this.assertCurrentPath('/parent/child');

        _emberMetal.run(function () {
          parentController.set('page', 2);
          parentChildController.set('page', 2);
        });

        _this.assertCurrentPath('/parent/child?childPage=2&parentPage=2');

        _emberMetal.run(function () {
          parentController.set('page', 1);
          parentChildController.set('page', 1);
        });

        _this.assertCurrentPath('/parent/child');
      });
    };

    _class.prototype['@test query params can be either controller property or url key'] = function testQueryParamsCanBeEitherControllerPropertyOrUrlKey(assert) {
      var _this2 = this;

      assert.expect(3);

      this.setMappedQPController('parent');

      return this.setupBase().then(function () {
        _this2.assertCurrentPath('/parent/child');

        _this2.transitionTo('parent.child', { queryParams: { page: 2 } });
        _this2.assertCurrentPath('/parent/child?parentPage=2');

        _this2.transitionTo('parent.child', { queryParams: { parentPage: 3 } });
        _this2.assertCurrentPath('/parent/child?parentPage=3');
      });
    };

    _class.prototype['@test query param matching a url key and controller property'] = function testQueryParamMatchingAUrlKeyAndControllerProperty(assert) {
      var _this3 = this;

      assert.expect(3);

      this.setMappedQPController('parent', 'page', 'parentPage');
      this.setMappedQPController('parent.child', 'index', 'page');

      return this.setupBase().then(function () {
        _this3.transitionTo('parent.child', { queryParams: { page: 2 } });
        _this3.assertCurrentPath('/parent/child?parentPage=2');

        _this3.transitionTo('parent.child', { queryParams: { parentPage: 3 } });
        _this3.assertCurrentPath('/parent/child?parentPage=3');

        _this3.transitionTo('parent.child', { queryParams: { index: 2, page: 2 } });
        _this3.assertCurrentPath('/parent/child?page=2&parentPage=2');
      });
    };

    _class.prototype['@test query param matching same property on two controllers use the urlKey higher in the chain'] = function testQueryParamMatchingSamePropertyOnTwoControllersUseTheUrlKeyHigherInTheChain(assert) {
      var _this4 = this;

      assert.expect(4);

      this.setMappedQPController('parent', 'page', 'parentPage');
      this.setMappedQPController('parent.child', 'page', 'childPage');

      return this.setupBase().then(function () {
        _this4.transitionTo('parent.child', { queryParams: { page: 2 } });
        _this4.assertCurrentPath('/parent/child?parentPage=2');

        _this4.transitionTo('parent.child', { queryParams: { parentPage: 3 } });
        _this4.assertCurrentPath('/parent/child?parentPage=3');

        _this4.transitionTo('parent.child', { queryParams: { childPage: 2, page: 2 } });
        _this4.assertCurrentPath('/parent/child?childPage=2&parentPage=2');

        _this4.transitionTo('parent.child', { queryParams: { childPage: 3, parentPage: 4 } });
        _this4.assertCurrentPath('/parent/child?childPage=3&parentPage=4');
      });
    };

    _class.prototype['@test query params does not error when a query parameter exists for route instances that share a controller'] = function testQueryParamsDoesNotErrorWhenAQueryParameterExistsForRouteInstancesThatShareAController(assert) {
      var _this5 = this;

      assert.expect(1);

      var parentController = _emberRuntime.Controller.extend({
        queryParams: { page: 'page' }
      });
      this.registerController('parent', parentController);
      this.registerRoute('parent.child', _emberRouting.Route.extend({ controllerName: 'parent' }));

      return this.setupBase('/parent').then(function () {
        _this5.transitionTo('parent.child', { queryParams: { page: 2 } });
        _this5.assertCurrentPath('/parent/child?page=2');
      });
    };

    _class.prototype['@test query params in the same route hierarchy with the same url key get auto-scoped'] = function testQueryParamsInTheSameRouteHierarchyWithTheSameUrlKeyGetAutoScoped(assert) {
      var _this6 = this;

      assert.expect(1);

      this.setMappedQPController('parent');
      this.setMappedQPController('parent.child');

      expectAssertion(function () {
        _this6.setupBase();
      }, 'You\'re not allowed to have more than one controller property map to the same query param key, but both `parent:page` and `parent.child:page` map to `parentPage`. You can fix this by mapping one of the controller properties to a different query param key via the `as` config option, e.g. `page: { as: \'other-page\' }`');
    };

    _class.prototype['@test Support shared but overridable mixin pattern'] = function testSupportSharedButOverridableMixinPattern(assert) {
      var _this7 = this;

      assert.expect(7);

      var HasPage = _emberMetal.Mixin.create({
        queryParams: 'page',
        page: 1
      });

      this.registerController('parent', _emberRuntime.Controller.extend(HasPage, {
        queryParams: { page: 'yespage' }
      }));

      this.registerController('parent.child', _emberRuntime.Controller.extend(HasPage));

      return this.setupBase().then(function () {
        _this7.assertCurrentPath('/parent/child');

        var parentController = _this7.getController('parent');
        var parentChildController = _this7.getController('parent.child');

        _this7.setAndFlush(parentChildController, 'page', 2);
        _this7.assertCurrentPath('/parent/child?page=2');
        assert.equal(parentController.get('page'), 1);
        assert.equal(parentChildController.get('page'), 2);

        _this7.setAndFlush(parentController, 'page', 2);
        _this7.assertCurrentPath('/parent/child?page=2&yespage=2');
        assert.equal(parentController.get('page'), 2);
        assert.equal(parentChildController.get('page'), 2);
      });
    };

    return _class;
  })(_internalTestHelpers.QueryParamTestCase));
});
enifed('ember/tests/routing/query_params_test/overlapping_query_params_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/routing/query_params_test/overlapping_query_params_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/routing/query_params_test/overlapping_query_params_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/routing/query_params_test/query_param_async_get_handler_test', ['exports', 'ember-runtime', 'ember-routing', 'internal-test-helpers'], function (exports, _emberRuntime, _emberRouting, _internalTestHelpers) {
  'use strict';

  // These tests mimic what happens with lazily loaded Engines.
  _internalTestHelpers.moduleFor('Query Params - async get handler', (function (_QueryParamTestCase) {
    babelHelpers.inherits(_class, _QueryParamTestCase);

    function _class() {
      _QueryParamTestCase.apply(this, arguments);
    }

    _class.prototype['@test can render a link to an asynchronously loaded route without fetching the route'] = function testCanRenderALinkToAnAsynchronouslyLoadedRouteWithoutFetchingTheRoute(assert) {
      var _this = this;

      assert.expect(4);

      this.router.map(function () {
        this.route('post', { path: '/post/:id' });
      });

      this.setSingleQPController('post');

      var setupAppTemplate = function () {
        _this.registerTemplate('application', '\n        {{link-to \'Post\' \'post\' 1337 (query-params foo=\'bar\') class=\'post-link\'}}\n        {{link-to \'Post\' \'post\' 7331 (query-params foo=\'boo\') class=\'post-link\'}}\n        {{outlet}}\n      ');
      };

      setupAppTemplate();

      return this.visitAndAssert('/').then(function () {
        assert.equal(_this.$('.post-link').eq(0).attr('href'), '/post/1337?foo=bar', 'renders correctly with default QP value');
        assert.equal(_this.$('.post-link').eq(1).attr('href'), '/post/7331?foo=boo', 'renders correctly with non-default QP value');
        assert.deepEqual(_this.fetchedHandlers, ['application', 'index'], 'only fetched the handlers for the route we\'re on');
      });
    };

    _class.prototype['@test can transitionTo to an asynchronously loaded route with simple query params'] = function testCanTransitionToToAnAsynchronouslyLoadedRouteWithSimpleQueryParams(assert) {
      var _this2 = this;

      assert.expect(6);

      this.router.map(function () {
        this.route('post', { path: '/post/:id' });
        this.route('posts');
      });

      this.setSingleQPController('post');

      var postController = undefined;
      return this.visitAndAssert('/').then(function () {
        postController = _this2.getController('post');

        return _this2.transitionTo('posts').then(function () {
          _this2.assertCurrentPath('/posts');
        });
      }).then(function () {
        return _this2.transitionTo('post', 1337, { queryParams: { foo: 'boo' } }).then(function () {
          assert.equal(postController.get('foo'), 'boo', 'simple QP is correctly set on controller');
          _this2.assertCurrentPath('/post/1337?foo=boo');
        });
      }).then(function () {
        return _this2.transitionTo('post', 1337, { queryParams: { foo: 'bar' } }).then(function () {
          assert.equal(postController.get('foo'), 'bar', 'simple QP is correctly set with default value');
          _this2.assertCurrentPath('/post/1337');
        });
      });
    };

    _class.prototype['@test can transitionTo to an asynchronously loaded route with array query params'] = function testCanTransitionToToAnAsynchronouslyLoadedRouteWithArrayQueryParams(assert) {
      var _this3 = this;

      assert.expect(5);

      this.router.map(function () {
        this.route('post', { path: '/post/:id' });
      });

      this.setSingleQPController('post', 'comments', []);

      var postController = undefined;
      return this.visitAndAssert('/').then(function () {
        postController = _this3.getController('post');
        return _this3.transitionTo('post', 1337, { queryParams: { comments: [1, 2] } }).then(function () {
          assert.deepEqual(postController.get('comments'), [1, 2], 'array QP is correctly set with default value');
          _this3.assertCurrentPath('/post/1337?comments=%5B1%2C2%5D');
        });
      }).then(function () {
        return _this3.transitionTo('post', 1338).then(function () {
          assert.deepEqual(postController.get('comments'), [], 'array QP is correctly set on controller');
          _this3.assertCurrentPath('/post/1338');
        });
      });
    };

    _class.prototype['@test can transitionTo to an asynchronously loaded route with mapped query params'] = function testCanTransitionToToAnAsynchronouslyLoadedRouteWithMappedQueryParams(assert) {
      var _this4 = this;

      assert.expect(7);

      this.router.map(function () {
        this.route('post', { path: '/post/:id' }, function () {
          this.route('index', { path: '/' });
        });
      });

      this.setSingleQPController('post');
      this.setMappedQPController('post.index', 'comment', 'note');

      var postController = undefined;
      var postIndexController = undefined;

      return this.visitAndAssert('/').then(function () {
        postController = _this4.getController('post');
        postIndexController = _this4.getController('post.index');

        return _this4.transitionTo('post.index', 1337, { queryParams: { note: 6, foo: 'boo' } }).then(function () {
          assert.equal(postController.get('foo'), 'boo', 'simple QP is correctly set on controller');
          assert.equal(postIndexController.get('comment'), 6, 'mapped QP is correctly set on controller');
          _this4.assertCurrentPath('/post/1337?foo=boo&note=6');
        });
      }).then(function () {
        return _this4.transitionTo('post', 1337, { queryParams: { foo: 'bar' } }).then(function () {
          assert.equal(postController.get('foo'), 'bar', 'simple QP is correctly set with default value');
          assert.equal(postIndexController.get('comment'), 6, 'mapped QP retains value scoped to model');
          _this4.assertCurrentPath('/post/1337?note=6');
        });
      });
    };

    _class.prototype['@test can transitionTo with a URL'] = function testCanTransitionToWithAURL(assert) {
      var _this5 = this;

      assert.expect(7);

      this.router.map(function () {
        this.route('post', { path: '/post/:id' }, function () {
          this.route('index', { path: '/' });
        });
      });

      this.setSingleQPController('post');
      this.setMappedQPController('post.index', 'comment', 'note');

      var postController = undefined;
      var postIndexController = undefined;

      return this.visitAndAssert('/').then(function () {
        postController = _this5.getController('post');
        postIndexController = _this5.getController('post.index');

        return _this5.transitionTo('/post/1337?foo=boo&note=6').then(function () {
          assert.equal(postController.get('foo'), 'boo', 'simple QP is correctly deserialized on controller');
          assert.equal(postIndexController.get('comment'), 6, 'mapped QP is correctly deserialized on controller');
          _this5.assertCurrentPath('/post/1337?foo=boo&note=6');
        });
      }).then(function () {
        return _this5.transitionTo('/post/1337?note=6').then(function () {
          assert.equal(postController.get('foo'), 'bar', 'simple QP is correctly deserialized with default value');
          assert.equal(postIndexController.get('comment'), 6, 'mapped QP retains value scoped to model');
          _this5.assertCurrentPath('/post/1337?note=6');
        });
      });
    };

    _class.prototype['@test undefined isn\'t serialized or deserialized into a string'] = function testUndefinedIsnTSerializedOrDeserializedIntoAString(assert) {
      var _this6 = this;

      assert.expect(4);

      this.router.map(function () {
        this.route('example');
      });

      this.registerTemplate('application', '{{link-to \'Example\' \'example\' (query-params foo=undefined) id=\'the-link\'}}');

      this.setSingleQPController('example', 'foo', undefined, {
        foo: undefined
      });

      this.registerRoute('example', _emberRouting.Route.extend({
        model: function (params) {
          assert.deepEqual(params, { foo: undefined });
        }
      }));

      return this.visitAndAssert('/').then(function () {
        assert.equal(_this6.$('#the-link').attr('href'), '/example', 'renders without undefined qp serialized');

        return _this6.transitionTo('example', { queryParams: { foo: undefined } }).then(function () {
          _this6.assertCurrentPath('/example');
        });
      });
    };

    babelHelpers.createClass(_class, [{
      key: 'routerOptions',
      get: function () {
        var fetchedHandlers = this.fetchedHandlers = [];

        return {
          location: 'test',

          _getQPMeta: function (handlerInfo) {
            return this._bucketCache.lookup('route-meta', handlerInfo.name);
          },

          _getHandlerFunction: function () {
            var getHandler = this._super.apply(this, arguments);
            var cache = {};

            return function (routeName) {
              fetchedHandlers.push(routeName);

              // Cache the returns so we don't have more than one Promise for a
              // given handler.
              return cache[routeName] || (cache[routeName] = new _emberRuntime.RSVP.Promise(function (resolve) {
                setTimeout(function () {
                  return resolve(getHandler(routeName));
                }, 10);
              }));
            };
          }
        };
      }
    }]);
    return _class;
  })(_internalTestHelpers.QueryParamTestCase));
});
enifed('ember/tests/routing/query_params_test/query_param_async_get_handler_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/routing/query_params_test/query_param_async_get_handler_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/routing/query_params_test/query_param_async_get_handler_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/routing/query_params_test/query_params_paramless_link_to_test', ['exports', 'ember-runtime', 'ember-views', 'internal-test-helpers'], function (exports, _emberRuntime, _emberViews, _internalTestHelpers) {
  'use strict';

  _internalTestHelpers.moduleFor('Query Params - paramless link-to', (function (_QueryParamTestCase) {
    babelHelpers.inherits(_class, _QueryParamTestCase);

    function _class() {
      _QueryParamTestCase.apply(this, arguments);
    }

    _class.prototype.testParamlessLinks = function testParamlessLinks(assert, routeName) {
      assert.expect(1);

      this.registerTemplate(routeName, '{{link-to \'index\' \'index\' id=\'index-link\'}}');

      this.registerController(routeName, _emberRuntime.Controller.extend({
        queryParams: ['foo'],
        foo: 'wat'
      }));

      return this.visit('/?foo=YEAH').then(function () {
        assert.equal(_emberViews.jQuery('#index-link').attr('href'), '/?foo=YEAH');
      });
    };

    _class.prototype['@test param-less links in an app booted with query params in the URL don\'t reset the query params: application'] = function testParamLessLinksInAnAppBootedWithQueryParamsInTheURLDonTResetTheQueryParamsApplication(assert) {
      return this.testParamlessLinks(assert, 'application');
    };

    _class.prototype['@test param-less links in an app booted with query params in the URL don\'t reset the query params: index'] = function testParamLessLinksInAnAppBootedWithQueryParamsInTheURLDonTResetTheQueryParamsIndex(assert) {
      return this.testParamlessLinks(assert, 'index');
    };

    return _class;
  })(_internalTestHelpers.QueryParamTestCase));
});
enifed('ember/tests/routing/query_params_test/query_params_paramless_link_to_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/routing/query_params_test/query_params_paramless_link_to_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/routing/query_params_test/query_params_paramless_link_to_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/routing/query_params_test/shared_state_test', ['exports', 'ember-runtime', 'ember', 'ember-metal', 'ember-views', 'internal-test-helpers'], function (exports, _emberRuntime, _ember, _emberMetal, _emberViews, _internalTestHelpers) {
  'use strict';

  _internalTestHelpers.moduleFor('Query Params - shared service state', (function (_QueryParamTestCase) {
    babelHelpers.inherits(_class, _QueryParamTestCase);

    function _class() {
      _QueryParamTestCase.apply(this, arguments);
    }

    _class.prototype.boot = function boot() {
      this.setupApplication();
      return this.visitApplication();
    };

    _class.prototype.setupApplication = function setupApplication() {
      this.router.map(function () {
        this.route('home', { path: '/' });
        this.route('dashboard');
      });

      this.application.register('service:filters', _emberRuntime.Service.extend({
        shared: true
      }));

      this.registerController('home', _emberRuntime.Controller.extend({
        filters: _ember.default.inject.service()
      }));

      this.registerController('dashboard', _emberRuntime.Controller.extend({
        filters: _ember.default.inject.service(),
        queryParams: [{ 'filters.shared': 'shared' }]
      }));

      this.registerTemplate('application', '{{link-to \'Home\' \'home\' }} <div> {{outlet}} </div>');
      this.registerTemplate('home', '{{link-to \'Dashboard\' \'dashboard\' }}{{input type="checkbox" id=\'filters-checkbox\' checked=(mut filters.shared) }}');
      this.registerTemplate('dashboard', '{{link-to \'Home\' \'home\' }}');
    };

    _class.prototype.visitApplication = function visitApplication() {
      return this.visit('/');
    };

    _class.prototype['@test can modify shared state before transition'] = function testCanModifySharedStateBeforeTransition(assert) {
      var _this = this;

      assert.expect(1);

      return this.boot().then(function () {
        _this.$input = _emberViews.jQuery('#filters-checkbox');

        // click the checkbox once to set filters.shared to false
        _emberMetal.run(_this.$input, 'click');

        return _this.visit('/dashboard').then(function () {
          assert.ok(true, 'expecting navigating to dashboard to succeed');
        });
      });
    };

    _class.prototype['@test can modify shared state back to the default value before transition'] = function testCanModifySharedStateBackToTheDefaultValueBeforeTransition(assert) {
      var _this2 = this;

      assert.expect(1);

      return this.boot().then(function () {
        _this2.$input = _emberViews.jQuery('#filters-checkbox');

        // click the checkbox twice to set filters.shared to false and back to true
        _emberMetal.run(_this2.$input, 'click');
        _emberMetal.run(_this2.$input, 'click');

        return _this2.visit('/dashboard').then(function () {
          assert.ok(true, 'expecting navigating to dashboard to succeed');
        });
      });
    };

    return _class;
  })(_internalTestHelpers.QueryParamTestCase));
});
enifed('ember/tests/routing/query_params_test/shared_state_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/routing/query_params_test/shared_state_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/routing/query_params_test/shared_state_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/routing/router_map_test', ['exports', 'ember-metal', 'ember-template-compiler', 'ember-application', 'ember-routing', 'ember-views', 'ember-glimmer'], function (exports, _emberMetal, _emberTemplateCompiler, _emberApplication, _emberRouting, _emberViews, _emberGlimmer) {
  'use strict';

  var router = undefined,
      App = undefined,
      container = undefined;

  function bootApplication() {
    router = container.lookup('router:main');
    _emberMetal.run(App, 'advanceReadiness');
  }

  function handleURL(path) {
    return _emberMetal.run(function () {
      return router.handleURL(path).then(function (value) {
        ok(true, 'url: `' + path + '` was handled');
        return value;
      }, function (reason) {
        ok(false, 'failed to visit:`' + path + '` reason: `' + QUnit.jsDump.parse(reason));
        throw reason;
      });
    });
  }

  QUnit.module('Router.map', {
    setup: function () {
      _emberMetal.run(function () {
        App = _emberApplication.Application.create({
          name: 'App',
          rootElement: '#qunit-fixture'
        });

        App.deferReadiness();

        App.Router.reopen({
          location: 'none'
        });

        container = App.__container__;
      });
    },

    teardown: function () {
      _emberMetal.run(function () {
        App.destroy();
        App = null;

        _emberGlimmer.setTemplates({});
      });
    }
  });

  QUnit.test('Router.map returns an Ember Router class', function () {
    expect(1);

    var ret = App.Router.map(function () {
      this.route('hello');
    });

    ok(_emberRouting.Router.detect(ret));
  });

  QUnit.test('Router.map can be called multiple times', function () {
    expect(4);

    _emberGlimmer.setTemplate('hello', _emberTemplateCompiler.compile('Hello!'));
    _emberGlimmer.setTemplate('goodbye', _emberTemplateCompiler.compile('Goodbye!'));

    App.Router.map(function () {
      this.route('hello');
    });

    App.Router.map(function () {
      this.route('goodbye');
    });

    bootApplication();

    handleURL('/hello');

    equal(_emberViews.jQuery('#qunit-fixture').text(), 'Hello!', 'The hello template was rendered');

    handleURL('/goodbye');

    equal(_emberViews.jQuery('#qunit-fixture').text(), 'Goodbye!', 'The goodbye template was rendered');
  });
});
enifed('ember/tests/routing/router_map_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/routing/router_map_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/routing/router_map_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/routing/router_service_test/basic_test', ['exports', 'ember-runtime', 'ember-glimmer', 'ember-routing', 'ember-metal', 'internal-test-helpers'], function (exports, _emberRuntime, _emberGlimmer, _emberRouting, _emberMetal, _internalTestHelpers) {
  'use strict';

  if (_emberMetal.isFeatureEnabled('ember-routing-router-service')) {
    _internalTestHelpers.moduleFor('Router Service - main', (function (_RouterTestCase) {
      babelHelpers.inherits(_class, _RouterTestCase);

      function _class() {
        _RouterTestCase.apply(this, arguments);
      }

      _class.prototype['@test RouterService#currentRouteName is correctly set for top level route'] = function testRouterServiceCurrentRouteNameIsCorrectlySetForTopLevelRoute(assert) {
        var _this = this;

        assert.expect(1);

        return this.visit('/').then(function () {
          assert.equal(_this.routerService.get('currentRouteName'), 'parent.index');
        });
      };

      _class.prototype['@test RouterService#currentRouteName is correctly set for child route'] = function testRouterServiceCurrentRouteNameIsCorrectlySetForChildRoute(assert) {
        var _this2 = this;

        assert.expect(1);

        return this.visit('/child').then(function () {
          assert.equal(_this2.routerService.get('currentRouteName'), 'parent.child');
        });
      };

      _class.prototype['@test RouterService#currentRouteName is correctly set after transition'] = function testRouterServiceCurrentRouteNameIsCorrectlySetAfterTransition(assert) {
        var _this3 = this;

        assert.expect(1);

        return this.visit('/child').then(function () {
          return _this3.routerService.transitionTo('parent.sister');
        }).then(function () {
          assert.equal(_this3.routerService.get('currentRouteName'), 'parent.sister');
        });
      };

      _class.prototype['@test RouterService#currentRouteName is correctly set on each transition'] = function testRouterServiceCurrentRouteNameIsCorrectlySetOnEachTransition(assert) {
        var _this4 = this;

        assert.expect(3);

        return this.visit('/child').then(function () {
          assert.equal(_this4.routerService.get('currentRouteName'), 'parent.child');

          return _this4.visit('/sister');
        }).then(function () {
          assert.equal(_this4.routerService.get('currentRouteName'), 'parent.sister');

          return _this4.visit('/brother');
        }).then(function () {
          assert.equal(_this4.routerService.get('currentRouteName'), 'parent.brother');
        });
      };

      _class.prototype['@test RouterService#rootURL is correctly set to the default value'] = function testRouterServiceRootURLIsCorrectlySetToTheDefaultValue(assert) {
        var _this5 = this;

        assert.expect(1);

        return this.visit('/').then(function () {
          assert.equal(_this5.routerService.get('rootURL'), '/');
        });
      };

      _class.prototype['@test RouterService#rootURL is correctly set to a custom value'] = function testRouterServiceRootURLIsCorrectlySetToACustomValue(assert) {
        var _this6 = this;

        assert.expect(1);

        this.registerRoute('parent.index', _emberRouting.Route.extend({
          init: function () {
            this._super();
            _emberMetal.set(this.router, 'rootURL', '/homepage');
          }
        }));

        return this.visit('/').then(function () {
          assert.equal(_this6.routerService.get('rootURL'), '/homepage');
        });
      };

      _class.prototype['@test RouterService#location is correctly delegated from router:main'] = function testRouterServiceLocationIsCorrectlyDelegatedFromRouterMain(assert) {
        var _this7 = this;

        assert.expect(2);

        return this.visit('/').then(function () {
          var location = _this7.routerService.get('location');
          assert.ok(location);
          assert.ok(location instanceof _emberRouting.NoneLocation);
        });
      };

      return _class;
    })(_internalTestHelpers.RouterTestCase));
  }
});
enifed('ember/tests/routing/router_service_test/basic_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/routing/router_service_test/basic_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/routing/router_service_test/basic_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/routing/router_service_test/currenturl_lifecycle_test', ['exports', 'ember-runtime', 'ember-glimmer', 'ember-routing', 'ember-metal', 'internal-test-helpers'], function (exports, _emberRuntime, _emberGlimmer, _emberRouting, _emberMetal, _internalTestHelpers) {
  'use strict';

  if (_emberMetal.isFeatureEnabled('ember-routing-router-service')) {
    (function () {
      var results = [];
      var ROUTE_NAMES = ['index', 'child', 'sister', 'brother'];

      var InstrumentedRoute = _emberRouting.Route.extend({
        routerService: _emberRuntime.inject.service('router'),

        beforeModel: function () {
          var service = _emberMetal.get(this, 'routerService');
          results.push([service.get('currentRouteName'), 'beforeModel', service.get('currentURL')]);
        },

        model: function () {
          var service = _emberMetal.get(this, 'routerService');
          results.push([service.get('currentRouteName'), 'model', service.get('currentURL')]);
        },

        afterModel: function () {
          var service = _emberMetal.get(this, 'routerService');
          results.push([service.get('currentRouteName'), 'afterModel', service.get('currentURL')]);
        }
      });

      _internalTestHelpers.moduleFor('Router Service - currentURL', (function (_RouterTestCase) {
        babelHelpers.inherits(_class, _RouterTestCase);

        function _class() {
          var _this = this;

          _RouterTestCase.call(this);

          results = [];

          ROUTE_NAMES.forEach(function (name) {
            var routeName = 'parent.' + name;
            _this.registerRoute(routeName, InstrumentedRoute.extend());
            _this.registerTemplate(routeName, '{{current-url}}');
          });

          this.registerComponent('current-url', {
            ComponentClass: _emberGlimmer.Component.extend({
              routerService: _emberRuntime.inject.service('router'),
              currentURL: _emberRuntime.readOnly('routerService.currentURL')
            }),
            template: '{{currentURL}}'
          });
        }

        _class.prototype['@test RouterService#currentURL is correctly set for top level route'] = function testRouterServiceCurrentURLIsCorrectlySetForTopLevelRoute(assert) {
          var _this2 = this;

          assert.expect(1);

          return this.visit('/').then(function () {
            assert.equal(_this2.routerService.get('currentURL'), '/');
          });
        };

        _class.prototype['@test RouterService#currentURL is correctly set for child route'] = function testRouterServiceCurrentURLIsCorrectlySetForChildRoute(assert) {
          var _this3 = this;

          assert.expect(1);

          return this.visit('/child').then(function () {
            assert.equal(_this3.routerService.get('currentURL'), '/child');
          });
        };

        _class.prototype['@test RouterService#currentURL is correctly set after transition'] = function testRouterServiceCurrentURLIsCorrectlySetAfterTransition(assert) {
          var _this4 = this;

          assert.expect(1);

          return this.visit('/child').then(function () {
            return _this4.routerService.transitionTo('parent.sister');
          }).then(function () {
            assert.equal(_this4.routerService.get('currentURL'), '/sister');
          });
        };

        _class.prototype['@test RouterService#currentURL is correctly set on each transition'] = function testRouterServiceCurrentURLIsCorrectlySetOnEachTransition(assert) {
          var _this5 = this;

          assert.expect(3);

          return this.visit('/child').then(function () {
            assert.equal(_this5.routerService.get('currentURL'), '/child');

            return _this5.visit('/sister');
          }).then(function () {
            assert.equal(_this5.routerService.get('currentURL'), '/sister');

            return _this5.visit('/brother');
          }).then(function () {
            assert.equal(_this5.routerService.get('currentURL'), '/brother');
          });
        };

        _class.prototype['@test RouterService#currentURL is not set during lifecycle hooks'] = function testRouterServiceCurrentURLIsNotSetDuringLifecycleHooks(assert) {
          var _this6 = this;

          assert.expect(2);

          return this.visit('/').then(function () {
            assert.deepEqual(results, [[null, 'beforeModel', null], [null, 'model', null], [null, 'afterModel', null]]);

            results = [];

            return _this6.visit('/child');
          }).then(function () {
            assert.deepEqual(results, [['parent.index', 'beforeModel', '/'], ['parent.index', 'model', '/'], ['parent.index', 'afterModel', '/']]);
          });
        };

        _class.prototype['@test RouterService#currentURL is correctly set with component after consecutive visits'] = function testRouterServiceCurrentURLIsCorrectlySetWithComponentAfterConsecutiveVisits(assert) {
          var _this7 = this;

          assert.expect(3);

          return this.visit('/').then(function () {
            _this7.assertText('/');

            return _this7.visit('/child');
          }).then(function () {
            _this7.assertText('/child');

            return _this7.visit('/');
          }).then(function () {
            _this7.assertText('/');
          });
        };

        return _class;
      })(_internalTestHelpers.RouterTestCase));
    })();
  }
});
enifed('ember/tests/routing/router_service_test/currenturl_lifecycle_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/routing/router_service_test/currenturl_lifecycle_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/routing/router_service_test/currenturl_lifecycle_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/routing/router_service_test/replaceWith_test', ['exports', 'ember-routing', 'internal-test-helpers', 'router', 'ember-metal'], function (exports, _emberRouting, _internalTestHelpers, _router, _emberMetal) {
  'use strict';

  if (_emberMetal.isFeatureEnabled('ember-routing-router-service')) {
    _internalTestHelpers.moduleFor('Router Service - replaceWith', (function (_RouterTestCase) {
      babelHelpers.inherits(_class, _RouterTestCase);

      function _class() {
        _RouterTestCase.call(this);

        var testCase = this;
        testCase.state = [];

        this.application.register('location:test', _emberRouting.NoneLocation.extend({
          setURL: function (path) {
            testCase.state.push(path);
            this.set('path', path);
          },

          replaceURL: function (path) {
            testCase.state.splice(testCase.state.length - 1, 1, path);
            this.set('path', path);
          }
        }));
      }

      _class.prototype['@test RouterService#replaceWith returns a Transition'] = function testRouterServiceReplaceWithReturnsATransition(assert) {
        var _this = this;

        assert.expect(1);

        var transition = undefined;

        return this.visit('/').then(function () {
          transition = _this.routerService.replaceWith('parent.child');

          assert.ok(transition instanceof _router.Transition);

          return transition;
        });
      };

      _class.prototype['@test RouterService#replaceWith with basic route replaces location'] = function testRouterServiceReplaceWithWithBasicRouteReplacesLocation(assert) {
        var _this2 = this;

        assert.expect(1);

        return this.visit('/').then(function () {
          return _this2.routerService.transitionTo('parent.child');
        }).then(function () {
          return _this2.routerService.transitionTo('parent.sister');
        }).then(function () {
          return _this2.routerService.replaceWith('parent.brother');
        }).then(function () {
          assert.deepEqual(_this2.state, ['/', '/child', '/brother']);
        });
      };

      _class.prototype['@test RouterService#replaceWith transitioning back to previously visited route replaces location'] = function testRouterServiceReplaceWithTransitioningBackToPreviouslyVisitedRouteReplacesLocation(assert) {
        var _this3 = this;

        assert.expect(1);

        return this.visit('/').then(function () {
          return _this3.routerService.transitionTo('parent.child');
        }).then(function () {
          return _this3.routerService.transitionTo('parent.sister');
        }).then(function () {
          return _this3.routerService.transitionTo('parent.brother');
        }).then(function () {
          return _this3.routerService.replaceWith('parent.sister');
        }).then(function () {
          assert.deepEqual(_this3.state, ['/', '/child', '/sister', '/sister']);
        });
      };

      babelHelpers.createClass(_class, [{
        key: 'routerOptions',
        get: function () {
          return {
            location: 'test'
          };
        }
      }]);
      return _class;
    })(_internalTestHelpers.RouterTestCase));
  }
});
enifed('ember/tests/routing/router_service_test/replaceWith_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/routing/router_service_test/replaceWith_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/routing/router_service_test/replaceWith_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/routing/router_service_test/transitionTo_test', ['exports', 'ember-runtime', 'ember-glimmer', 'ember-routing', 'ember-metal', 'internal-test-helpers', 'router'], function (exports, _emberRuntime, _emberGlimmer, _emberRouting, _emberMetal, _internalTestHelpers, _router) {
  'use strict';

  if (_emberMetal.isFeatureEnabled('ember-routing-router-service')) {
    _internalTestHelpers.moduleFor('Router Service - transitionTo', (function (_RouterTestCase) {
      babelHelpers.inherits(_class, _RouterTestCase);

      function _class() {
        _RouterTestCase.call(this);

        var testCase = this;
        testCase.state = [];

        this.application.register('location:test', _emberRouting.NoneLocation.extend({
          setURL: function (path) {
            testCase.state.push(path);
            this.set('path', path);
          },

          replaceURL: function (path) {
            testCase.state.splice(testCase.state.length - 1, 1, path);
            this.set('path', path);
          }
        }));
      }

      _class.prototype['@test RouterService#transitionTo returns a Transition'] = function testRouterServiceTransitionToReturnsATransition(assert) {
        var _this = this;

        assert.expect(1);

        var transition = undefined;

        return this.visit('/').then(function () {
          transition = _this.routerService.transitionTo('parent.child');

          assert.ok(transition instanceof _router.Transition);

          return transition;
        });
      };

      _class.prototype['@test RouterService#transitionTo with basic route updates location'] = function testRouterServiceTransitionToWithBasicRouteUpdatesLocation(assert) {
        var _this2 = this;

        assert.expect(1);

        return this.visit('/').then(function () {
          return _this2.routerService.transitionTo('parent.child');
        }).then(function () {
          return _this2.routerService.transitionTo('parent.sister');
        }).then(function () {
          return _this2.routerService.transitionTo('parent.brother');
        }).then(function () {
          assert.deepEqual(_this2.state, ['/', '/child', '/sister', '/brother']);
        });
      };

      _class.prototype['@test RouterService#transitionTo transitioning back to previously visited route updates location'] = function testRouterServiceTransitionToTransitioningBackToPreviouslyVisitedRouteUpdatesLocation(assert) {
        var _this3 = this;

        assert.expect(1);

        return this.visit('/').then(function () {
          return _this3.routerService.transitionTo('parent.child');
        }).then(function () {
          return _this3.routerService.transitionTo('parent.sister');
        }).then(function () {
          return _this3.routerService.transitionTo('parent.brother');
        }).then(function () {
          return _this3.routerService.transitionTo('parent.sister');
        }).then(function () {
          assert.deepEqual(_this3.state, ['/', '/child', '/sister', '/brother', '/sister']);
        });
      };

      _class.prototype['@test RouterService#transitionTo with basic route'] = function testRouterServiceTransitionToWithBasicRoute(assert) {
        var _this4 = this;

        assert.expect(1);

        var componentInstance = undefined;

        this.registerTemplate('parent.index', '{{foo-bar}}');

        this.registerComponent('foo-bar', {
          ComponentClass: _emberGlimmer.Component.extend({
            routerService: _emberRuntime.inject.service('router'),
            init: function () {
              this._super();
              componentInstance = this;
            },
            actions: {
              transitionToSister: function () {
                _emberMetal.get(this, 'routerService').transitionTo('parent.sister');
              }
            }
          }),
          template: 'foo-bar'
        });

        return this.visit('/').then(function () {
          _emberMetal.run(function () {
            componentInstance.send('transitionToSister');
          });

          assert.equal(_this4.routerService.get('currentRouteName'), 'parent.sister');
        });
      };

      _class.prototype['@test RouterService#transitionTo with dynamic segment'] = function testRouterServiceTransitionToWithDynamicSegment(assert) {
        var _this5 = this;

        assert.expect(3);

        var componentInstance = undefined;
        var dynamicModel = { id: 1, contents: 'much dynamicism' };

        this.registerTemplate('parent.index', '{{foo-bar}}');
        this.registerTemplate('dynamic', '{{model.contents}}');

        this.registerComponent('foo-bar', {
          ComponentClass: _emberGlimmer.Component.extend({
            routerService: _emberRuntime.inject.service('router'),
            init: function () {
              this._super();
              componentInstance = this;
            },
            actions: {
              transitionToDynamic: function () {
                _emberMetal.get(this, 'routerService').transitionTo('dynamic', dynamicModel);
              }
            }
          }),
          template: 'foo-bar'
        });

        return this.visit('/').then(function () {
          _emberMetal.run(function () {
            componentInstance.send('transitionToDynamic');
          });

          assert.equal(_this5.routerService.get('currentRouteName'), 'dynamic');
          assert.equal(_this5.routerService.get('currentURL'), '/dynamic/1');
          _this5.assertText('much dynamicism');
        });
      };

      _class.prototype['@test RouterService#transitionTo with dynamic segment and model hook'] = function testRouterServiceTransitionToWithDynamicSegmentAndModelHook(assert) {
        var _this6 = this;

        assert.expect(3);

        var componentInstance = undefined;
        var dynamicModel = { id: 1, contents: 'much dynamicism' };

        this.registerRoute('dynamic', _emberRouting.Route.extend({
          model: function () {
            return dynamicModel;
          }
        }));

        this.registerTemplate('parent.index', '{{foo-bar}}');
        this.registerTemplate('dynamic', '{{model.contents}}');

        this.registerComponent('foo-bar', {
          ComponentClass: _emberGlimmer.Component.extend({
            routerService: _emberRuntime.inject.service('router'),
            init: function () {
              this._super();
              componentInstance = this;
            },
            actions: {
              transitionToDynamic: function () {
                _emberMetal.get(this, 'routerService').transitionTo('dynamic', 1);
              }
            }
          }),
          template: 'foo-bar'
        });

        return this.visit('/').then(function () {
          _emberMetal.run(function () {
            componentInstance.send('transitionToDynamic');
          });

          assert.equal(_this6.routerService.get('currentRouteName'), 'dynamic');
          assert.equal(_this6.routerService.get('currentURL'), '/dynamic/1');
          _this6.assertText('much dynamicism');
        });
      };

      babelHelpers.createClass(_class, [{
        key: 'routerOptions',
        get: function () {
          return {
            location: 'test'
          };
        }
      }]);
      return _class;
    })(_internalTestHelpers.RouterTestCase));
  }
});
enifed('ember/tests/routing/router_service_test/transitionTo_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/routing/router_service_test/transitionTo_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/routing/router_service_test/transitionTo_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/routing/substates_test', ['exports', 'ember-runtime', 'ember-routing', 'ember-metal', 'ember-template-compiler', 'ember-application', 'ember-views', 'ember-glimmer'], function (exports, _emberRuntime, _emberRouting, _emberMetal, _emberTemplateCompiler, _emberApplication, _emberViews, _emberGlimmer) {
  'use strict';

  var Router = undefined,
      App = undefined,
      templates = undefined,
      router = undefined,
      container = undefined,
      counter = undefined;

  function step(expectedValue, description) {
    equal(counter, expectedValue, 'Step ' + expectedValue + ': ' + description);
    counter++;
  }

  function bootApplication(startingURL) {
    for (var _name in templates) {
      _emberGlimmer.setTemplate(_name, _emberTemplateCompiler.compile(templates[_name]));
    }

    if (startingURL) {
      _emberRouting.NoneLocation.reopen({
        path: startingURL
      });
    }

    startingURL = startingURL || '';
    router = container.lookup('router:main');
    _emberMetal.run(App, 'advanceReadiness');
  }

  QUnit.module('Loading/Error Substates', {
    setup: function () {
      counter = 1;

      _emberMetal.run(function () {
        App = _emberApplication.Application.create({
          name: 'App',
          rootElement: '#qunit-fixture',
          // fake a modules resolver
          Resolver: _emberApplication.Resolver.extend({ moduleBasedResolver: true })
        });

        App.deferReadiness();

        App.Router.reopen({
          location: 'none'
        });

        Router = App.Router;

        container = App.__container__;

        templates = {
          application: '<div id="app">{{outlet}}</div>',
          index: 'INDEX',
          loading: 'LOADING',
          bro: 'BRO',
          sis: 'SIS'
        };
      });
    },

    teardown: function () {
      _emberMetal.run(function () {
        App.destroy();
        App = null;

        _emberGlimmer.setTemplates({});
      });

      _emberRouting.NoneLocation.reopen({
        path: ''
      });
    }
  });

  QUnit.test('Slow promise from a child route of application enters nested loading state', function () {
    var broModel = {};
    var broDeferred = _emberRuntime.RSVP.defer();

    Router.map(function () {
      this.route('bro');
    });

    App.ApplicationRoute = _emberRouting.Route.extend({
      setupController: function () {
        step(2, 'ApplicationRoute#setup');
      }
    });

    App.BroRoute = _emberRouting.Route.extend({
      model: function () {
        step(1, 'BroRoute#model');
        return broDeferred.promise;
      }
    });

    bootApplication('/bro');

    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'LOADING', 'The Loading template is nested in application template\'s outlet');

    _emberMetal.run(broDeferred, 'resolve', broModel);

    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'BRO', 'bro template has loaded and replaced loading template');
  });

  QUnit.test('Slow promises waterfall on startup', function () {
    expect(7);

    var grandmaDeferred = _emberRuntime.RSVP.defer();
    var sallyDeferred = _emberRuntime.RSVP.defer();

    Router.map(function () {
      this.route('grandma', function () {
        this.route('mom', { resetNamespace: true }, function () {
          this.route('sally');
        });
      });
    });

    templates.grandma = 'GRANDMA {{outlet}}';
    templates.mom = 'MOM {{outlet}}';
    templates['mom/loading'] = 'MOMLOADING';
    templates['mom/sally'] = 'SALLY';

    App.GrandmaRoute = _emberRouting.Route.extend({
      model: function () {
        step(1, 'GrandmaRoute#model');
        return grandmaDeferred.promise;
      }
    });

    App.MomRoute = _emberRouting.Route.extend({
      model: function () {
        step(2, 'Mom#model');
        return {};
      }
    });

    App.MomSallyRoute = _emberRouting.Route.extend({
      model: function () {
        step(3, 'SallyRoute#model');
        return sallyDeferred.promise;
      },
      setupController: function () {
        step(4, 'SallyRoute#setupController');
      }
    });

    bootApplication('/grandma/mom/sally');

    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'LOADING', 'The Loading template is nested in application template\'s outlet');

    _emberMetal.run(grandmaDeferred, 'resolve', {});
    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'GRANDMA MOM MOMLOADING', 'Mom\'s child loading route is displayed due to sally\'s slow promise');

    _emberMetal.run(sallyDeferred, 'resolve', {});
    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'GRANDMA MOM SALLY', 'Sally template displayed');
  });

  QUnit.test('ApplicationRoute#currentPath reflects loading state path', function () {
    expect(4);

    var momDeferred = _emberRuntime.RSVP.defer();

    Router.map(function () {
      this.route('grandma', function () {
        this.route('mom');
      });
    });

    templates.grandma = 'GRANDMA {{outlet}}';
    templates['grandma/loading'] = 'GRANDMALOADING';
    templates['grandma/mom'] = 'MOM';

    App.GrandmaMomRoute = _emberRouting.Route.extend({
      model: function () {
        return momDeferred.promise;
      }
    });

    bootApplication('/grandma/mom');

    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'GRANDMA GRANDMALOADING');

    var appController = container.lookup('controller:application');
    equal(appController.get('currentPath'), 'grandma.loading', 'currentPath reflects loading state');

    _emberMetal.run(momDeferred, 'resolve', {});
    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'GRANDMA MOM');
    equal(appController.get('currentPath'), 'grandma.mom', 'currentPath reflects final state');
  });

  QUnit.test('Slow promises returned from ApplicationRoute#model don\'t enter LoadingRoute', function () {
    expect(2);

    var appDeferred = _emberRuntime.RSVP.defer();

    App.ApplicationRoute = _emberRouting.Route.extend({
      model: function () {
        return appDeferred.promise;
      }
    });

    App.LoadingRoute = _emberRouting.Route.extend({
      setupController: function () {
        ok(false, 'shouldn\'t get here');
      }
    });

    bootApplication();

    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), '', 'nothing has been rendered yet');

    _emberMetal.run(appDeferred, 'resolve', {});
    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'INDEX');
  });

  QUnit.test('Don\'t enter loading route unless either route or template defined', function () {
    delete templates.loading;

    expect(2);

    var indexDeferred = _emberRuntime.RSVP.defer();

    App.ApplicationController = _emberRuntime.Controller.extend();

    App.IndexRoute = _emberRouting.Route.extend({
      model: function () {
        return indexDeferred.promise;
      }
    });

    bootApplication();

    var appController = container.lookup('controller:application');
    ok(appController.get('currentPath') !== 'loading', 'loading state not entered');

    _emberMetal.run(indexDeferred, 'resolve', {});
    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'INDEX');
  });

  QUnit.test('Enter loading route if only LoadingRoute defined', function () {
    delete templates.loading;

    expect(4);

    var indexDeferred = _emberRuntime.RSVP.defer();

    App.IndexRoute = _emberRouting.Route.extend({
      model: function () {
        step(1, 'IndexRoute#model');
        return indexDeferred.promise;
      }
    });

    App.LoadingRoute = _emberRouting.Route.extend({
      setupController: function () {
        step(2, 'LoadingRoute#setupController');
      }
    });

    bootApplication();

    var appController = container.lookup('controller:application');
    equal(appController.get('currentPath'), 'loading', 'loading state entered');

    _emberMetal.run(indexDeferred, 'resolve', {});
    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'INDEX');
  });

  QUnit.test('Enter child loading state of pivot route', function () {
    expect(4);

    var deferred = _emberRuntime.RSVP.defer();

    Router.map(function () {
      this.route('grandma', function () {
        this.route('mom', { resetNamespace: true }, function () {
          this.route('sally');
        });
        this.route('smells');
      });
    });

    templates['grandma/loading'] = 'GMONEYLOADING';

    App.ApplicationController = _emberRuntime.Controller.extend();

    App.MomSallyRoute = _emberRouting.Route.extend({
      setupController: function () {
        step(1, 'SallyRoute#setupController');
      }
    });

    App.GrandmaSmellsRoute = _emberRouting.Route.extend({
      model: function () {
        return deferred.promise;
      }
    });

    bootApplication('/grandma/mom/sally');

    var appController = container.lookup('controller:application');
    equal(appController.get('currentPath'), 'grandma.mom.sally', 'Initial route fully loaded');

    _emberMetal.run(router, 'transitionTo', 'grandma.smells');
    equal(appController.get('currentPath'), 'grandma.loading', 'in pivot route\'s child loading state');

    _emberMetal.run(deferred, 'resolve', {});

    equal(appController.get('currentPath'), 'grandma.smells', 'Finished transition');
  });

  QUnit.test('Loading actions bubble to root, but don\'t enter substates above pivot', function () {
    expect(6);

    delete templates.loading;

    var sallyDeferred = _emberRuntime.RSVP.defer();
    var smellsDeferred = _emberRuntime.RSVP.defer();

    Router.map(function () {
      this.route('grandma', function () {
        this.route('mom', { resetNamespace: true }, function () {
          this.route('sally');
        });
        this.route('smells');
      });
    });

    App.ApplicationController = _emberRuntime.Controller.extend();

    App.ApplicationRoute = _emberRouting.Route.extend({
      actions: {
        loading: function (transition, route) {
          ok(true, 'loading action received on ApplicationRoute');
        }
      }
    });

    App.MomSallyRoute = _emberRouting.Route.extend({
      model: function () {
        return sallyDeferred.promise;
      }
    });

    App.GrandmaSmellsRoute = _emberRouting.Route.extend({
      model: function () {
        return smellsDeferred.promise;
      }
    });

    bootApplication('/grandma/mom/sally');

    var appController = container.lookup('controller:application');
    ok(!appController.get('currentPath'), 'Initial route fully loaded');
    _emberMetal.run(sallyDeferred, 'resolve', {});

    equal(appController.get('currentPath'), 'grandma.mom.sally', 'transition completed');

    _emberMetal.run(router, 'transitionTo', 'grandma.smells');
    equal(appController.get('currentPath'), 'grandma.mom.sally', 'still in initial state because the only loading state is above the pivot route');

    _emberMetal.run(smellsDeferred, 'resolve', {});

    equal(appController.get('currentPath'), 'grandma.smells', 'Finished transition');
  });

  QUnit.test('Default error event moves into nested route', function () {
    expect(6);

    templates['grandma'] = 'GRANDMA {{outlet}}';
    templates['grandma/error'] = 'ERROR: {{model.msg}}';

    Router.map(function () {
      this.route('grandma', function () {
        this.route('mom', { resetNamespace: true }, function () {
          this.route('sally');
        });
      });
    });

    App.ApplicationController = _emberRuntime.Controller.extend();

    App.MomSallyRoute = _emberRouting.Route.extend({
      model: function () {
        step(1, 'MomSallyRoute#model');

        return _emberRuntime.RSVP.reject({
          msg: 'did it broke?'
        });
      },
      actions: {
        error: function () {
          step(2, 'MomSallyRoute#actions.error');
          return true;
        }
      }
    });

    throws(function () {
      bootApplication('/grandma/mom/sally');
    }, function (err) {
      return err.msg === 'did it broke?';
    });

    step(3, 'App finished booting');

    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'GRANDMA ERROR: did it broke?', 'error bubbles');

    var appController = container.lookup('controller:application');
    equal(appController.get('currentPath'), 'grandma.error', 'Initial route fully loaded');
  });

  QUnit.test('Error events that aren\'t bubbled don\t throw application assertions', function () {
    expect(2);

    templates['grandma'] = 'GRANDMA {{outlet}}';

    Router.map(function () {
      this.route('grandma', function () {
        this.route('mom', { resetNamespace: true }, function () {
          this.route('sally');
        });
      });
    });

    App.ApplicationController = _emberRuntime.Controller.extend();

    App.MomSallyRoute = _emberRouting.Route.extend({
      model: function () {
        step(1, 'MomSallyRoute#model');

        return _emberRuntime.RSVP.reject({
          msg: 'did it broke?'
        });
      },
      actions: {
        error: function (err) {
          equal(err.msg, 'did it broke?');
          return false;
        }
      }
    });

    bootApplication('/grandma/mom/sally');
  });

  QUnit.test('Non-bubbled errors that re-throw aren\'t swallowed', function () {
    expect(2);

    templates['grandma'] = 'GRANDMA {{outlet}}';

    Router.map(function () {
      this.route('grandma', function () {
        this.route('mom', { resetNamespace: true }, function () {
          this.route('sally');
        });
      });
    });

    App.ApplicationController = _emberRuntime.Controller.extend();

    App.MomSallyRoute = _emberRouting.Route.extend({
      model: function () {
        step(1, 'MomSallyRoute#model');

        return _emberRuntime.RSVP.reject({
          msg: 'did it broke?'
        });
      },
      actions: {
        error: function (err) {
          // returns undefined which is falsey
          throw err;
        }
      }
    });

    throws(function () {
      bootApplication('/grandma/mom/sally');
    }, function (err) {
      return err.msg === 'did it broke?';
    });
  });

  QUnit.test('Handled errors that re-throw aren\'t swallowed', function () {
    expect(4);

    var handledError = undefined;

    templates['grandma'] = 'GRANDMA {{outlet}}';

    Router.map(function () {
      this.route('grandma', function () {
        this.route('mom', { resetNamespace: true }, function () {
          this.route('sally');
          this.route('this-route-throws');
        });
      });
    });

    App.ApplicationController = _emberRuntime.Controller.extend();

    App.MomSallyRoute = _emberRouting.Route.extend({
      model: function () {
        step(1, 'MomSallyRoute#model');

        return _emberRuntime.RSVP.reject({
          msg: 'did it broke?'
        });
      },
      actions: {
        error: function (err) {
          step(2, 'MomSallyRoute#error');

          handledError = err;

          this.transitionTo('mom.this-route-throws');

          // Marks error as handled
          return false;
        }
      }
    });

    App.MomThisRouteThrowsRoute = _emberRouting.Route.extend({
      model: function () {
        step(3, 'MomThisRouteThrows#model');

        throw handledError;
      }
    });

    throws(function () {
      bootApplication('/grandma/mom/sally');
    }, function (err) {
      return err.msg === 'did it broke?';
    });
  });

  QUnit.test('Handled errors that bubble can be handled at a higher level', function () {
    expect(4);

    var handledError = undefined;

    templates['grandma'] = 'GRANDMA {{outlet}}';

    Router.map(function () {
      this.route('grandma', function () {
        this.route('mom', { resetNamespace: true }, function () {
          this.route('sally');
        });
      });
    });

    App.ApplicationController = _emberRuntime.Controller.extend();

    App.MomRoute = _emberRouting.Route.extend({
      actions: {
        error: function (err) {
          step(3, 'MomRoute#error');

          equal(err, handledError, 'error handled and rebubbled is handleable at heigher route');
        }
      }
    });

    App.MomSallyRoute = _emberRouting.Route.extend({
      model: function () {
        step(1, 'MomSallyRoute#model');

        return _emberRuntime.RSVP.reject({
          msg: 'did it broke?'
        });
      },

      actions: {
        error: function (err) {
          step(2, 'MomSallyRoute#error');

          handledError = err;

          return true;
        }
      }
    });

    bootApplication('/grandma/mom/sally');
  });

  QUnit.test('errors that are bubbled are thrown at a higher level if not handled', function () {
    expect(3);

    templates['grandma'] = 'GRANDMA {{outlet}}';

    Router.map(function () {
      this.route('grandma', function () {
        this.route('mom', { resetNamespace: true }, function () {
          this.route('sally');
        });
      });
    });

    App.ApplicationController = _emberRuntime.Controller.extend();

    App.MomSallyRoute = _emberRouting.Route.extend({
      model: function () {
        step(1, 'MomSallyRoute#model');

        return _emberRuntime.RSVP.reject({
          msg: 'did it broke?'
        });
      },

      actions: {
        error: function (err) {
          step(2, 'MomSallyRoute#error');
          return true;
        }
      }
    });

    throws(function () {
      bootApplication('/grandma/mom/sally');
    }, function (err) {
      return err.msg === 'did it broke?';
    }, 'Correct error was thrown');
  });

  QUnit.test('Handled errors that are thrown through rejection aren\'t swallowed', function () {
    expect(4);

    var handledError = undefined;

    templates['grandma'] = 'GRANDMA {{outlet}}';

    Router.map(function () {
      this.route('grandma', function () {
        this.route('mom', { resetNamespace: true }, function () {
          this.route('sally');
          this.route('this-route-throws');
        });
      });
    });

    App.ApplicationController = _emberRuntime.Controller.extend();

    App.MomSallyRoute = _emberRouting.Route.extend({
      model: function () {
        step(1, 'MomSallyRoute#model');

        return _emberRuntime.RSVP.reject({
          msg: 'did it broke?'
        });
      },
      actions: {
        error: function (err) {
          step(2, 'MomSallyRoute#error');

          handledError = err;

          this.transitionTo('mom.this-route-throws');

          // Marks error as handled
          return false;
        }
      }
    });

    App.MomThisRouteThrowsRoute = _emberRouting.Route.extend({
      model: function () {
        step(3, 'MomThisRouteThrows#model');

        return _emberRuntime.RSVP.reject(handledError);
      }
    });

    throws(function () {
      bootApplication('/grandma/mom/sally');
    }, function (err) {
      return err.msg === 'did it broke?';
    });
  });

  QUnit.test('Setting a query param during a slow transition should work', function () {
    var deferred = _emberRuntime.RSVP.defer();

    Router.map(function () {
      this.route('grandma', { path: '/grandma/:seg' }, function () {});
    });

    templates['grandma/loading'] = 'GMONEYLOADING';

    App.ApplicationController = _emberRuntime.Controller.extend();

    App.IndexRoute = _emberRouting.Route.extend({
      beforeModel: function () {
        this.transitionTo('grandma', 1);
      }
    });

    App.GrandmaRoute = _emberRouting.Route.extend({
      queryParams: {
        test: { defaultValue: 1 }
      }
    });

    App.GrandmaIndexRoute = _emberRouting.Route.extend({
      model: function () {
        return deferred.promise;
      }
    });

    bootApplication('/');

    var appController = container.lookup('controller:application');
    var grandmaController = container.lookup('controller:grandma');

    equal(appController.get('currentPath'), 'grandma.loading', 'Initial route should be loading');

    _emberMetal.run(function () {
      grandmaController.set('test', 3);
    });

    equal(appController.get('currentPath'), 'grandma.loading', 'Route should still be loading');
    equal(grandmaController.get('test'), 3, 'Controller query param value should have changed');

    _emberMetal.run(deferred, 'resolve', {});

    equal(appController.get('currentPath'), 'grandma.index', 'Transition should be complete');
  });

  QUnit.test('Slow promises returned from ApplicationRoute#model enter ApplicationLoadingRoute if present', function () {
    expect(2);

    var appDeferred = _emberRuntime.RSVP.defer();

    App.ApplicationRoute = _emberRouting.Route.extend({
      model: function () {
        return appDeferred.promise;
      }
    });

    var loadingRouteEntered = false;
    App.ApplicationLoadingRoute = _emberRouting.Route.extend({
      setupController: function () {
        loadingRouteEntered = true;
      }
    });

    bootApplication();

    ok(loadingRouteEntered, 'ApplicationLoadingRoute was entered');

    _emberMetal.run(appDeferred, 'resolve', {});
    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'INDEX');
  });

  QUnit.test('Slow promises returned from ApplicationRoute#model enter application_loading if template present', function () {
    expect(3);

    templates['application_loading'] = '<div id="toplevel-loading">TOPLEVEL LOADING</div>';

    var appDeferred = _emberRuntime.RSVP.defer();
    App.ApplicationRoute = _emberRouting.Route.extend({
      model: function () {
        return appDeferred.promise;
      }
    });

    bootApplication();

    equal(_emberViews.jQuery('#qunit-fixture #toplevel-loading').text(), 'TOPLEVEL LOADING');

    _emberMetal.run(appDeferred, 'resolve', {});

    equal(_emberViews.jQuery('#toplevel-loading', '#qunit-fixture').length, 0, 'top-level loading View has been entirely removed from DOM');
    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'INDEX');
  });

  QUnit.test('Default error event moves into nested route, prioritizing more specifically named error route', function () {
    expect(6);

    templates['grandma'] = 'GRANDMA {{outlet}}';
    templates['grandma/error'] = 'ERROR: {{model.msg}}';
    templates['mom_error'] = 'MOM ERROR: {{model.msg}}';

    Router.map(function () {
      this.route('grandma', function () {
        this.route('mom', { resetNamespace: true }, function () {
          this.route('sally');
        });
      });
    });

    App.ApplicationController = _emberRuntime.Controller.extend();

    App.MomSallyRoute = _emberRouting.Route.extend({
      model: function () {
        step(1, 'MomSallyRoute#model');

        return _emberRuntime.RSVP.reject({
          msg: 'did it broke?'
        });
      },
      actions: {
        error: function () {
          step(2, 'MomSallyRoute#actions.error');
          return true;
        }
      }
    });

    throws(function () {
      bootApplication('/grandma/mom/sally');
    }, function (err) {
      return err.msg === 'did it broke?';
    });

    step(3, 'App finished booting');

    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'GRANDMA MOM ERROR: did it broke?', 'the more specifically-named mom error substate was entered over the other error route');

    var appController = container.lookup('controller:application');
    equal(appController.get('currentPath'), 'grandma.mom_error', 'Initial route fully loaded');
  });

  QUnit.test('Prioritized substate entry works with preserved-namespace nested routes', function () {
    expect(2);

    templates['foo/bar_loading'] = 'FOOBAR LOADING';
    templates['foo/bar/index'] = 'YAY';

    Router.map(function () {
      this.route('foo', function () {
        this.route('bar', { path: '/bar' }, function () {});
      });
    });

    App.ApplicationController = _emberRuntime.Controller.extend();

    var deferred = _emberRuntime.RSVP.defer();
    App.FooBarRoute = _emberRouting.Route.extend({
      model: function () {
        return deferred.promise;
      }
    });

    bootApplication('/foo/bar');

    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'FOOBAR LOADING', 'foo.bar_loading was entered (as opposed to something like foo/foo/bar_loading)');

    _emberMetal.run(deferred, 'resolve');

    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'YAY');
  });

  QUnit.test('Prioritized substate entry works with reset-namespace nested routes', function () {
    expect(2);

    templates['bar_loading'] = 'BAR LOADING';
    templates['bar/index'] = 'YAY';

    Router.map(function () {
      this.route('foo', function () {
        this.route('bar', { path: '/bar', resetNamespace: true }, function () {});
      });
    });

    App.ApplicationController = _emberRuntime.Controller.extend();

    var deferred = _emberRuntime.RSVP.defer();
    App.BarRoute = _emberRouting.Route.extend({
      model: function () {
        return deferred.promise;
      }
    });

    bootApplication('/foo/bar');

    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'BAR LOADING', 'foo.bar_loading was entered (as opposed to something like foo/foo/bar_loading)');

    _emberMetal.run(deferred, 'resolve');

    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'YAY');
  });

  QUnit.test('Prioritized loading substate entry works with preserved-namespace nested routes', function () {
    expect(2);

    templates['foo/bar_loading'] = 'FOOBAR LOADING';
    templates['foo/bar'] = 'YAY';

    Router.map(function () {
      this.route('foo', function () {
        this.route('bar');
      });
    });

    App.ApplicationController = _emberRuntime.Controller.extend();

    var deferred = _emberRuntime.RSVP.defer();
    App.FooBarRoute = _emberRouting.Route.extend({
      model: function () {
        return deferred.promise;
      }
    });

    bootApplication('/foo/bar');

    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'FOOBAR LOADING', 'foo.bar_loading was entered (as opposed to something like foo/foo/bar_loading)');

    _emberMetal.run(deferred, 'resolve');

    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'YAY');
  });

  QUnit.test('Prioritized error substate entry works with preserved-namespace nested routes', function () {
    expect(2);

    templates['foo/bar_error'] = 'FOOBAR ERROR: {{model.msg}}';
    templates['foo/bar'] = 'YAY';

    Router.map(function () {
      this.route('foo', function () {
        this.route('bar');
      });
    });

    App.ApplicationController = _emberRuntime.Controller.extend();

    App.FooBarRoute = _emberRouting.Route.extend({
      model: function () {
        return _emberRuntime.RSVP.reject({
          msg: 'did it broke?'
        });
      }
    });

    throws(function () {
      bootApplication('/foo/bar');
    }, function (err) {
      return err.msg === 'did it broke?';
    });

    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'FOOBAR ERROR: did it broke?', 'foo.bar_error was entered (as opposed to something like foo/foo/bar_error)');
  });

  QUnit.test('Prioritized loading substate entry works with auto-generated index routes', function () {
    expect(2);

    templates['foo/index_loading'] = 'FOO LOADING';
    templates['foo/index'] = 'YAY';
    templates['foo'] = '{{outlet}}';

    Router.map(function () {
      this.route('foo', function () {
        this.route('bar');
      });
    });

    App.ApplicationController = _emberRuntime.Controller.extend();

    var deferred = _emberRuntime.RSVP.defer();
    App.FooIndexRoute = _emberRouting.Route.extend({
      model: function () {
        return deferred.promise;
      }
    });
    App.FooRoute = _emberRouting.Route.extend({
      model: function () {
        return true;
      }
    });

    bootApplication('/foo');

    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'FOO LOADING', 'foo.index_loading was entered');

    _emberMetal.run(deferred, 'resolve');

    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'YAY');
  });

  QUnit.test('Prioritized error substate entry works with auto-generated index routes', function () {
    expect(2);

    templates['foo/index_error'] = 'FOO ERROR: {{model.msg}}';
    templates['foo/index'] = 'YAY';
    templates['foo'] = '{{outlet}}';

    Router.map(function () {
      this.route('foo', function () {
        this.route('bar');
      });
    });

    App.ApplicationController = _emberRuntime.Controller.extend();

    App.FooIndexRoute = _emberRouting.Route.extend({
      model: function () {
        return _emberRuntime.RSVP.reject({
          msg: 'did it broke?'
        });
      }
    });
    App.FooRoute = _emberRouting.Route.extend({
      model: function () {
        return true;
      }
    });

    throws(function () {
      return bootApplication('/foo');
    }, function (err) {
      return err.msg === 'did it broke?';
    });

    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'FOO ERROR: did it broke?', 'foo.index_error was entered');
  });

  QUnit.test('Rejected promises returned from ApplicationRoute transition into top-level application_error', function () {
    expect(3);

    templates['application_error'] = '<p id="toplevel-error">TOPLEVEL ERROR: {{model.msg}}</p>';

    var reject = true;
    App.ApplicationRoute = _emberRouting.Route.extend({
      model: function () {
        if (reject) {
          return _emberRuntime.RSVP.reject({ msg: 'BAD NEWS BEARS' });
        } else {
          return {};
        }
      }
    });

    throws(function () {
      return bootApplication();
    }, function (err) {
      return err.msg === 'BAD NEWS BEARS';
    });

    equal(_emberViews.jQuery('#toplevel-error', '#qunit-fixture').text(), 'TOPLEVEL ERROR: BAD NEWS BEARS');

    reject = false;
    _emberMetal.run(router, 'transitionTo', 'index');

    equal(_emberViews.jQuery('#app', '#qunit-fixture').text(), 'INDEX');
  });
});
enifed('ember/tests/routing/substates_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/routing/substates_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/routing/substates_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/routing/toplevel_dom_test', ['exports', 'ember-metal', 'ember-template-compiler', 'ember-application', 'ember-views', 'ember-routing', 'ember-glimmer'], function (exports, _emberMetal, _emberTemplateCompiler, _emberApplication, _emberViews, _emberRouting, _emberGlimmer) {
  'use strict';

  var App = undefined,
      templates = undefined,
      container = undefined;

  function bootApplication() {
    for (var _name in templates) {
      _emberGlimmer.setTemplate(_name, _emberTemplateCompiler.compile(templates[_name]));
    }
    container.lookup('router:main');
    _emberMetal.run(App, 'advanceReadiness');
  }

  QUnit.module('Top Level DOM Structure', {
    setup: function () {
      _emberMetal.run(function () {
        App = _emberApplication.Application.create({
          name: 'App',
          rootElement: '#qunit-fixture'
        });

        App.deferReadiness();

        App.Router.reopen({
          location: 'none'
        });

        container = App.__container__;

        templates = {
          application: 'hello world'
        };
      });
    },

    teardown: function () {
      _emberMetal.run(function () {
        App.destroy();
        App = null;
        _emberGlimmer.setTemplates({});
      });

      _emberRouting.NoneLocation.reopen({
        path: ''
      });
    }
  });

  QUnit.test('Topmost template always get an element', function () {
    bootApplication();
    equal(_emberViews.jQuery('#qunit-fixture > .ember-view').text(), 'hello world');
  });
});
enifed('ember/tests/routing/toplevel_dom_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/routing/toplevel_dom_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/routing/toplevel_dom_test.js should pass ESLint\n\n');
  });
});
enifed('ember/tests/view_instrumentation_test', ['exports', 'ember-metal', 'ember-views', 'ember-application', 'ember-template-compiler', 'ember-glimmer'], function (exports, _emberMetal, _emberViews, _emberApplication, _emberTemplateCompiler, _emberGlimmer) {
  'use strict';

  var App = undefined,
      $fixture = undefined;

  function setupExample() {
    // setup templates
    _emberGlimmer.setTemplate('application', _emberTemplateCompiler.compile('{{outlet}}'));
    _emberGlimmer.setTemplate('index', _emberTemplateCompiler.compile('<h1>Index</h1>'));
    _emberGlimmer.setTemplate('posts', _emberTemplateCompiler.compile('<h1>Posts</h1>'));

    App.Router.map(function () {
      this.route('posts');
    });
  }

  function handleURL(path) {
    var router = App.__container__.lookup('router:main');
    return _emberMetal.run(router, 'handleURL', path);
  }

  QUnit.module('View Instrumentation', {
    setup: function () {
      _emberMetal.run(function () {
        App = _emberApplication.Application.create({
          rootElement: '#qunit-fixture'
        });
        App.deferReadiness();

        App.Router.reopen({
          location: 'none'
        });
      });

      $fixture = _emberViews.jQuery('#qunit-fixture');
      setupExample();
    },

    teardown: function () {
      _emberMetal.instrumentationReset();
      _emberMetal.run(App, 'destroy');
      App = null;
      _emberGlimmer.setTemplates({});
    }
  });

  QUnit.test('Nodes without view instances are instrumented', function (assert) {
    var called = false;
    _emberMetal.instrumentationSubscribe('render', {
      before: function () {
        called = true;
      },
      after: function () {}
    });
    _emberMetal.run(App, 'advanceReadiness');
    assert.equal($fixture.text(), 'Index', 'It rendered the right template');
    assert.ok(called, 'Instrumentation called on first render');
    called = false;
    handleURL('/posts');
    assert.equal($fixture.text(), 'Posts', 'It rendered the right template');
    assert.ok(called, 'instrumentation called on transition to non-view backed route');
  });
});
enifed('ember/tests/view_instrumentation_test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | ember/tests/view_instrumentation_test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'ember/tests/view_instrumentation_test.js should pass ESLint\n\n');
  });
});
enifed('internal-test-helpers/apply-mixins.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | internal-test-helpers/apply-mixins.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'internal-test-helpers/apply-mixins.js should pass ESLint\n\n');
  });
});
enifed('internal-test-helpers/build-owner.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | internal-test-helpers/build-owner.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'internal-test-helpers/build-owner.js should pass ESLint\n\n');
  });
});
enifed('internal-test-helpers/confirm-export.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | internal-test-helpers/confirm-export.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'internal-test-helpers/confirm-export.js should pass ESLint\n\n');
  });
});
enifed('internal-test-helpers/equal-inner-html.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | internal-test-helpers/equal-inner-html.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'internal-test-helpers/equal-inner-html.js should pass ESLint\n\n');
  });
});
enifed('internal-test-helpers/equal-tokens.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | internal-test-helpers/equal-tokens.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'internal-test-helpers/equal-tokens.js should pass ESLint\n\n');
  });
});
enifed('internal-test-helpers/factory.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | internal-test-helpers/factory.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'internal-test-helpers/factory.js should pass ESLint\n\n');
  });
});
enifed('internal-test-helpers/index.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | internal-test-helpers/index.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'internal-test-helpers/index.js should pass ESLint\n\n');
  });
});
enifed('internal-test-helpers/matchers.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | internal-test-helpers/matchers.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'internal-test-helpers/matchers.js should pass ESLint\n\n');
  });
});
enifed('internal-test-helpers/module-for.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | internal-test-helpers/module-for.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'internal-test-helpers/module-for.js should pass ESLint\n\n');
  });
});
enifed('internal-test-helpers/run.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | internal-test-helpers/run.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'internal-test-helpers/run.js should pass ESLint\n\n');
  });
});
enifed('internal-test-helpers/strip.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | internal-test-helpers/strip.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'internal-test-helpers/strip.js should pass ESLint\n\n');
  });
});
enifed('internal-test-helpers/test-cases/abstract-application.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | internal-test-helpers/test-cases/abstract-application.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'internal-test-helpers/test-cases/abstract-application.js should pass ESLint\n\n');
  });
});
enifed('internal-test-helpers/test-cases/abstract-rendering.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | internal-test-helpers/test-cases/abstract-rendering.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'internal-test-helpers/test-cases/abstract-rendering.js should pass ESLint\n\n');
  });
});
enifed('internal-test-helpers/test-cases/abstract.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | internal-test-helpers/test-cases/abstract.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'internal-test-helpers/test-cases/abstract.js should pass ESLint\n\n');
  });
});
enifed('internal-test-helpers/test-cases/application.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | internal-test-helpers/test-cases/application.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'internal-test-helpers/test-cases/application.js should pass ESLint\n\n');
  });
});
enifed('internal-test-helpers/test-cases/query-param.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | internal-test-helpers/test-cases/query-param.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'internal-test-helpers/test-cases/query-param.js should pass ESLint\n\n');
  });
});
enifed('internal-test-helpers/test-cases/rendering.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | internal-test-helpers/test-cases/rendering.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'internal-test-helpers/test-cases/rendering.js should pass ESLint\n\n');
  });
});
enifed('internal-test-helpers/test-cases/router.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | internal-test-helpers/test-cases/router.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'internal-test-helpers/test-cases/router.js should pass ESLint\n\n');
  });
});
enifed('internal-test-helpers/test-groups.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | internal-test-helpers/test-groups.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'internal-test-helpers/test-groups.js should pass ESLint\n\n');
  });
});
enifed('internal-test-helpers/tests/index-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('internal-test-helpers');

  QUnit.test('module present', function (assert) {
    assert.ok(true, 'each package needs at least one test to be able to run through `npm test`');
  });
});
enifed('internal-test-helpers/tests/index-test.lint-test', ['exports'], function (exports) {
  'use strict';

  QUnit.module('ESLint | internal-test-helpers/tests/index-test.js');
  QUnit.test('should pass ESLint', function (assert) {
    assert.expect(1);
    assert.ok(true, 'internal-test-helpers/tests/index-test.js should pass ESLint\n\n');
  });
});
}());
